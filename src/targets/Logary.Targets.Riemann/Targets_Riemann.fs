module Logary.Targets.Riemann

// https://github.com/aphyr/riemann-ruby-client/blob/master/lib/riemann/event.rb
// https://github.com/aphyr/riemann-java-client/tree/master/src/main/java/com

open ProtoBuf
open Hopac
open Hopac.Infixes
open NodaTime
open System
open System.Collections.Generic
open System.IO
open System.Net
open System.Net.Sockets
open System.Net.Security
open System.Security.Cryptography.X509Certificates
open Logary
open Logary.Riemann.Client
open Logary.Riemann.Messages
open Logary.Target
open Logary.Internals

module RiemannHelpers =
  let createClient (ep : IPEndPoint) =
    let c = new TcpClient(ep.Address.ToString(), ep.Port)
    c.NoDelay <- true
    c

  // Note: is it possible to do 'per millisecond'?
  // https://github.com/chillitom/Riemann.Net/blob/master/Riemann.Net/Event.cs#L25
  let asSecondsEpoch (i : EpochNanoSeconds) =
    i * (int64 (2. ** 9.))

  /// Convert the LogLevel to a Riemann (service) state
  let createState = function
    | Verbose | Debug | Info ->
      "ok"

    | Warn ->
      "warning"

    | Error | Fatal ->
      "critical"

  /// Create an Event from a LogLine, supplying a function that optionally changes
  /// the event before yielding it.
  let transform hostname ttl confTags (message : Message) =
    let (PointName msgName) = message.name

    let path =
      PointName [|
        yield! msgName
        match message.value with
        | Event template ->
          yield template
        | _ -> ()
      |]
      |> PointName.format


    let attrsOf (fields : Map<PointName, Field>) (context : Map<string, Value>) =
      [ for KeyValue (key, value) in context do
          yield Attribute(key, Value.toString value)

        for (KeyValue (key, Field (value, units))) in fields do
          yield Attribute(PointName.format key, Value.toString value)
      ]

    let double =
      match message.value with
      | Event _ ->
        1.

      | Gauge (value, units) ->
        Value.toDouble value

      | Derived (value, units) ->
        Value.toDouble value

    Event.createDouble(double,
                       asSecondsEpoch message.timestamp,
                       createState message.level,
                       path, // path = metric name = riemann's 'service'
                       hostname,
                       "",
                       confTags,
                       ttl,
                       attrsOf message.fields message.context)


/// The Riemann target will always use TCP in this version.
type RiemannConf =
  { /// location of the riemann server
    endpoint     : IPEndPoint

    /// A factory function for the WriteClient - useful for testing the target
    /// and for replacing the client with a high-performance client if the async
    /// actor + async + TcpClient isn't enough, but you want to try the async
    /// socket pattern.
    clientFac    : IPEndPoint -> TcpClient

    /// validation function; setting this means you need to be able to validate
    /// the certificate you get back when connecting to Riemann -- if you set
    /// this value the target will try and create a TLS connection.
    ///
    /// Parameters:
    ///  - X509Certificate certificate
    ///  - X509Chain chain
    ///  - SslPolicyErrors sslPolicyErrors
    ///
    /// Returns: bool indicating whether to accept the cert or not
    caValidation : (X509Certificate -> X509Chain -> SslPolicyErrors -> bool) option

    /// An optional mapping function that can change the Event that is generated by
    /// default.
    ofMessage    : Message -> Event

    /// The hostname to send to riemann
    hostname     : string

    /// An optional list of tags to apply to everything sent to riemann
    tags         : string list }

  /// Creates a new Riemann target configuration
  static member create(?endpoint : IPEndPoint, ?clientFac, ?caValidation,
                       ?ofMessage, ?fMeasure, ?hostname, ?ttl, ?tags) =
    let ttl        = defaultArg ttl 10.f
    let hostname   = defaultArg hostname (Dns.GetHostName())
    let tags       = defaultArg tags []
    { endpoint     = defaultArg endpoint (IPEndPoint(IPAddress.Loopback, 5555))
      clientFac    = defaultArg clientFac RiemannHelpers.createClient
      caValidation = defaultArg caValidation None
      ofMessage    = defaultArg ofMessage (RiemannHelpers.transform hostname ttl tags)
      hostname     = hostname
      tags         = tags }

let empty = RiemannConf.create ()

module internal Impl =
  /// Make a stream from a TcpClient and an optional certificate validation
  /// function
  let createStream (client : TcpClient) = function
    | Some f ->
      let cb = new RemoteCertificateValidationCallback(fun _ -> f)
      new SslStream(client.GetStream(),
                    leaveInnerStreamOpen = false,
                    userCertificateValidationCallback = cb)
      :> Stream
    | None ->
      client.GetStream() :> Stream

  type RiemannTargetState =
    { client : TcpClient
      stream : Stream }

    interface IDisposable with
      member x.Dispose () =
        (x.stream :> IDisposable).Dispose()
        (x.client :> IDisposable).Dispose()

  // To Consider: could be useful to spawn multiple of this one: each is async and implement
  // an easy way to send/recv -- multiple will allow interleaving of said requests

  // To Consider: sending multiple events to this

  // So currently we're in push mode; did a Guage, Histogram or other thing send
  // us this metric? Or are Logary 'more dump' and simply shovel the more simple
  // counters and measurements (e.g. function execution timing) to Riemann
  // so that riemann can make up its own data?
  //
  // See https://github.com/aphyr/riemann-java-client/blob/master/src/main/java/com/codahale/metrics/riemann/RiemannReporter.java#L282
  // https://github.com/aphyr/riemann-ruby-client/blob/master/lib/riemann/client/tcp.rb

  let loop (conf : RiemannConf) (ri : RuntimeInfo)
           (requests : RingBuffer<_>)
           (shutdown : Ch<_>) =

    let rec init () : Job<unit> =
      let client = conf.clientFac conf.endpoint
      let stream = createStream client conf.caValidation
      running { client = client
                stream = stream }

    and running state =
      Alt.choose [

        shutdown ^=> fun ack ->
          job {
            do! Job.Scheduler.isolate <| fun _ ->
              Try.safe "Riemann target disposing tcp stream, then client"
                       ri.logger
                       (state :> IDisposable).Dispose
                       ()
            do! ack *<= ()
          }

        RingBuffer.take requests ^=> function
          | Log (message, ack) ->
            // The server will accept a repeated list of Events, and respond
            // with a confirmation message with either an acknowledgement or an error.
            // Check the `ok` boolean in the message; if false, message.error will
            // be a descriptive string.
            let evt = conf.ofMessage message
            [ evt ]
            |> sendEvents state.stream
            |> Job.bind (function
            | Choice1Of2 () ->
              ack *<= () |> Job.bind (fun _ -> running state)
  
            | Choice2Of2 err ->
              Job.raises <| Exception(sprintf "Riemann server error: %s" err))
  
          | Flush (ackCh, nack) ->
            job {
              do! Ch.give ackCh () <|> nack
              return! running state
            }

      ] :> Job<_>

    init ()

/// Create a new Riemann target
let create conf = TargetUtils.stdNamedTarget (Impl.loop conf)

/// Use with LogaryFactory.New( s => s.Target<Riemann.Builder>() )
type Builder(conf, callParent : FactoryApi.ParentCallback<Builder>) =

  member x.Endpoint(ep : IPEndPoint) =
    Builder({ conf with endpoint = ep }, callParent)

  member x.ClientFactory(fac : Func<IPEndPoint, TcpClient>) =
    Builder({ conf with clientFac = fun ep -> fac.Invoke ep }, callParent)

  member x.Done() =
    ! ( callParent x )

  new(callParent : FactoryApi.ParentCallback<_>) =
    Builder(empty, callParent)

  interface Logary.Target.FactoryApi.SpecificTargetConf with
    member x.Build name = create conf name