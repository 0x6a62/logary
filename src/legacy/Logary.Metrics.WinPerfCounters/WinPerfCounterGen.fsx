#I "bin/Release"
#r "Logary.dll"
#r "NodaTime.dll"
#r "Hopac.Core.dll"
#r "Hopac.dll"
#load "WinPerfCounter.fs"

open System
open System.IO
open System.Text.RegularExpressions
open Logary.Metrics
open Logary.Metrics.WinPerfCounter

let munge name =
  Regex.Replace(name, "[\./,]", "_")

let gen () =

  let genComment (pcc : Category) (perfCounter : WinPerfCounterInstance) =
    sprintf
        "/// %s: %s
///
/// %s"
      pcc.CategoryName
      pcc.CategoryHelp
      (if Array.isEmpty perfCounter.instances then
        "This performance counter does not have instance based counters"
       else
        "This performance counter does not have non-instance based counters")

  let genModuleHeader (perfCounter : WinPerfCounterInstance) =
    let preHeader () =
      sprintf """module ``%s`` =

  [<Literal>]
  let CategoryName = "%s"

  let PerfCat = Category.create CategoryName"""
        (munge perfCounter.category.CategoryName)
        perfCounter.category.CategoryName
      
    if Array.isEmpty perfCounter.instances then
      preHeader ()
    else
      sprintf """%s

  /// Returns an array of the instances available on this node/machine.
  let instances () =
    PerfCat
    |> Option.fold (fun s pcc -> Category.instances pcc) Array.empty
    |> Array.filter (fun inst -> not (Array.contains inst KnownInstances.All))
"""
        (preHeader ())

  let genCounter (pc : WinPerfCounterInstance) =
    let cn = pc.counter.CounterName
    let help = pc.counter.CounterHelp.Trim()
    match pc with
    | _ when pc.isNotInstanceBased ->
      sprintf """  /// %s: %s
  let ``%s`` =
    %s"""
        cn help cn
        (sprintf """WinPerfCounter.create(CategoryName, "%s", [])""" cn)
    | _ ->
      sprintf """  /// %s: %s
  let ``%s`` instances =
    %s"""
        cn help cn
        (sprintf """WinPerfCounter.create(CategoryName, "%s", instances)""" cn)

  let genCounters (counters : WinPerfCounterInstance seq) =
    counters
    |> Seq.map genCounter
    |> Seq.filter (not << String.IsNullOrWhiteSpace)
    |> fun ctrs -> String.Join("\n", ctrs)

  let genListing (counters : WinPerfCounterInstance seq) =
    let counters = List.ofSeq counters
    match counters with
    | [] -> """  let allCounters = [||]"""
    | hc :: rest ->
      let fsharpName hc =
        "``" + hc.counter.CounterName + "``" + (if hc.isMultiInstance then " instances" else "")
      sprintf """
  let allCounters%s =
    [| %s
%s
    |]"""
        (if hc.isMultiInstance then " instances" else "")
        (fsharpName hc)
        (rest
          |> List.map fsharpName
          |> List.map (fun s -> "       " + s)
          |> String.concat "\n")

  let genFileHeader () =
    """/// Copyright Henrik Feldt 2016. Part of the Logary source code.
/// An autogenerated file with all performance counters found on a Windows 10 system
module Logary.Metrics.AllWinPerfCounters

open System
open System.Diagnostics
open Logary.Metrics
open Logary.Metrics.WinPerfCounter"""

  Category.list ()
  |> Array.map (fun pcc -> pcc, Category.instances pcc)
  |> Array.sortBy (fun (pcc, _) -> pcc.CategoryName)
  |> Array.map (function
    | pcc, instances -> pcc, WinPerfCounter.list pcc instances)
  |> Array.map (fun (pcc, counters) ->
    pcc, counters |> Array.sortBy (fun x -> x.counter.CounterName))
  |> Array.map (function
    | pcc, [||]     -> ""
    | pcc, counters ->
      let c = Array.head counters
      genComment pcc c + "\n"
      + (genModuleHeader c) + "\n"
      + (genCounters counters) + "\n"
      + (genListing counters) + "\n")
  |> fun modules ->
    genFileHeader () + "\n"
    + String.Join("\n", modules)

let write () =
  let contents = gen ()
  let path = Path.Combine(__SOURCE_DIRECTORY__, "WinPerfCounters.fs")
  printfn "writing to path '%s'" path
  File.WriteAllText(path, contents, System.Text.Encoding.UTF8)

/// SynchronizationNuma: A nice help text
///
/// This performance counter does not have non-instance based counters
module ``SynchronizationNuma Example`` =

  [<Literal>]
  let CategoryName = "SynchronizationNuma"

  let PerfCat = Category.create CategoryName

  let instances () =
    PerfCat
    |> Option.fold (fun s pcc -> Category.instances pcc) Array.empty
    |> Array.filter (fun inst -> not (Array.contains inst KnownInstances.All))

  let ``Exec. Resource no-Waits AcqShrdWaitForExcl/sec`` instance =
    toWindowsCounter3 CategoryName "Exec. Resource no-Waits AcqShrdWaitForExcl/sec" instance

  let ``Exec. Resource Boost Excl. Owner/sec`` instance =
    toWindowsCounter3 CategoryName "Exec. Resource Boost Excl. Owner/sec" instance

  // etc

  let allCounters =
    [ ``Exec. Resource no-Waits AcqShrdWaitForExcl/sec``
      ``Exec. Resource Boost Excl. Owner/sec``
      // etc
    ]

  let countersFor instance =
    allCounters
    |> List.map (fun f -> f instance)
    |> List.filter Option.isSome
    |> List.map Option.get

/// System: a nice help text here too
///
/// This performance counter does not have instance based counters
module ``System Example`` =

  [<Literal>]
  let CategoryName = "System"

  let PerfCat = Category.create CategoryName

  let ``File Read Operations/sec`` =
    WinPerfCounter.create(CategoryName, "File Read Operations/sec", [])

  // etc

  let allCounters =
    [| ``File Read Operations/sec`` |]

//#load "WinPerfCounters.fs"
//Logary.WinPerfCounters.``WorkflowServiceHost 4_0_0_0``.``Workflows Created`` NotApplicable
