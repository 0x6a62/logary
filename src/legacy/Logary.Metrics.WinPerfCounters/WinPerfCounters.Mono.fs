/// Copyright Henrik Feldt 2016. Part of the Logary source code.
/// An autogenerated file with all performance counters found on a Windows 8.1 system
module Logary.Metrics.AllWinPerfCounters

open System
open System.Diagnostics
open Logary.Metrics.WinPerfCounter

/// .NET CLR Exceptions: 
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR Exceptions`` =

  [<Literal>]
  let Category = ".NET CLR Exceptions"

  let PCC = getPCC Category
  /// # of Exceps Thrown: 
  let ``# of Exceps Thrown`` instance =
    { category = ".NET CLR Exceptions"; counter = "# of Exceps Thrown"; instance = instance }
  /// # of Exceps Thrown/Sec: 
  let ``# of Exceps Thrown/Sec`` instance =
    { category = ".NET CLR Exceptions"; counter = "# of Exceps Thrown/Sec"; instance = instance }
  /// # of Filters/Sec: 
  let ``# of Filters/Sec`` instance =
    { category = ".NET CLR Exceptions"; counter = "# of Filters/Sec"; instance = instance }
  /// # of Finallys/Sec: 
  let ``# of Finallys/Sec`` instance =
    { category = ".NET CLR Exceptions"; counter = "# of Finallys/Sec"; instance = instance }
  /// Throw to Catch Depth/Sec: 
  let ``Throw to Catch Depth/Sec`` instance =
    { category = ".NET CLR Exceptions"; counter = "Throw to Catch Depth/Sec"; instance = instance }

  let allCounters =
    [ ``# of Exceps Thrown``
      ``# of Exceps Thrown/Sec``
      ``# of Filters/Sec``
      ``# of Finallys/Sec``
      ``Throw to Catch Depth/Sec``
    ]

/// .NET CLR Interop: 
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR Interop`` =

  [<Literal>]
  let Category = ".NET CLR Interop"

  let PCC = getPCC Category
  /// # of CCWs: 
  let ``# of CCWs`` instance =
    { category = ".NET CLR Interop"; counter = "# of CCWs"; instance = instance }
  /// # of Stubs: 
  let ``# of Stubs`` instance =
    { category = ".NET CLR Interop"; counter = "# of Stubs"; instance = instance }
  /// # of marshalling: 
  let ``# of marshalling`` instance =
    { category = ".NET CLR Interop"; counter = "# of marshalling"; instance = instance }

  let allCounters =
    [ ``# of CCWs``
      ``# of Stubs``
      ``# of marshalling``
    ]

/// .NET CLR JIT: 
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR JIT`` =

  [<Literal>]
  let Category = ".NET CLR JIT"

  let PCC = getPCC Category
  /// # of IL Bytes JITted: 
  let ``# of IL Bytes JITted`` instance =
    { category = ".NET CLR JIT"; counter = "# of IL Bytes JITted"; instance = instance }
  /// # of IL Methods JITted: 
  let ``# of IL Methods JITted`` instance =
    { category = ".NET CLR JIT"; counter = "# of IL Methods JITted"; instance = instance }
  /// % Time in JIT: 
  let ``% Time in JIT`` instance =
    { category = ".NET CLR JIT"; counter = "% Time in JIT"; instance = instance }
  /// IL Bytes Jitted/Sec: 
  let ``IL Bytes Jitted/Sec`` instance =
    { category = ".NET CLR JIT"; counter = "IL Bytes Jitted/Sec"; instance = instance }
  /// Standard Jit Failures: 
  let ``Standard Jit Failures`` instance =
    { category = ".NET CLR JIT"; counter = "Standard Jit Failures"; instance = instance }

  let allCounters =
    [ ``# of IL Bytes JITted``
      ``# of IL Methods JITted``
      ``% Time in JIT``
      ``IL Bytes Jitted/Sec``
      ``Standard Jit Failures``
    ]

/// .NET CLR Loading: 
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR Loading`` =

  [<Literal>]
  let Category = ".NET CLR Loading"

  let PCC = getPCC Category
  /// Bytes in Loader Heap: 
  let ``Bytes in Loader Heap`` instance =
    { category = ".NET CLR Loading"; counter = "Bytes in Loader Heap"; instance = instance }
  /// Current Assemblies: 
  let ``Current Assemblies`` instance =
    { category = ".NET CLR Loading"; counter = "Current Assemblies"; instance = instance }
  /// Current Classes Loaded: 
  let ``Current Classes Loaded`` instance =
    { category = ".NET CLR Loading"; counter = "Current Classes Loaded"; instance = instance }
  /// Current appdomains: 
  let ``Current appdomains`` instance =
    { category = ".NET CLR Loading"; counter = "Current appdomains"; instance = instance }
  /// Rate of Assemblies: 
  let ``Rate of Assemblies`` instance =
    { category = ".NET CLR Loading"; counter = "Rate of Assemblies"; instance = instance }
  /// Rate of Classes Loaded: 
  let ``Rate of Classes Loaded`` instance =
    { category = ".NET CLR Loading"; counter = "Rate of Classes Loaded"; instance = instance }
  /// Rate of Load Failures: 
  let ``Rate of Load Failures`` instance =
    { category = ".NET CLR Loading"; counter = "Rate of Load Failures"; instance = instance }
  /// Rate of appdomains: 
  let ``Rate of appdomains`` instance =
    { category = ".NET CLR Loading"; counter = "Rate of appdomains"; instance = instance }
  /// Rate of appdomains unloaded: 
  let ``Rate of appdomains unloaded`` instance =
    { category = ".NET CLR Loading"; counter = "Rate of appdomains unloaded"; instance = instance }
  /// Total # of Load Failures: 
  let ``Total # of Load Failures`` instance =
    { category = ".NET CLR Loading"; counter = "Total # of Load Failures"; instance = instance }
  /// Total Appdomains: 
  let ``Total Appdomains`` instance =
    { category = ".NET CLR Loading"; counter = "Total Appdomains"; instance = instance }
  /// Total Assemblies: 
  let ``Total Assemblies`` instance =
    { category = ".NET CLR Loading"; counter = "Total Assemblies"; instance = instance }
  /// Total Classes Loaded: 
  let ``Total Classes Loaded`` instance =
    { category = ".NET CLR Loading"; counter = "Total Classes Loaded"; instance = instance }
  /// Total appdomains unloaded: 
  let ``Total appdomains unloaded`` instance =
    { category = ".NET CLR Loading"; counter = "Total appdomains unloaded"; instance = instance }

  let allCounters =
    [ ``Bytes in Loader Heap``
      ``Current Assemblies``
      ``Current Classes Loaded``
      ``Current appdomains``
      ``Rate of Assemblies``
      ``Rate of Classes Loaded``
      ``Rate of Load Failures``
      ``Rate of appdomains``
      ``Rate of appdomains unloaded``
      ``Total # of Load Failures``
      ``Total Appdomains``
      ``Total Assemblies``
      ``Total Classes Loaded``
      ``Total appdomains unloaded``
    ]

/// .NET CLR LocksAndThreads: 
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR LocksAndThreads`` =

  [<Literal>]
  let Category = ".NET CLR LocksAndThreads"

  let PCC = getPCC Category
  /// # of current logical Threads: 
  let ``# of current logical Threads`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "# of current logical Threads"; instance = instance }
  /// # of current physical Threads: 
  let ``# of current physical Threads`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "# of current physical Threads"; instance = instance }
  /// # of current recognized threads: 
  let ``# of current recognized threads`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "# of current recognized threads"; instance = instance }
  /// # of total recognized threads: 
  let ``# of total recognized threads`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "# of total recognized threads"; instance = instance }
  /// Contention Rate / sec: 
  let ``Contention Rate / sec`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "Contention Rate / sec"; instance = instance }
  /// Current Queue Length: 
  let ``Current Queue Length`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "Current Queue Length"; instance = instance }
  /// Queue Length / sec: 
  let ``Queue Length / sec`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "Queue Length / sec"; instance = instance }
  /// Queue Length Peak: 
  let ``Queue Length Peak`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "Queue Length Peak"; instance = instance }
  /// Total # of Contentions: 
  let ``Total # of Contentions`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "Total # of Contentions"; instance = instance }
  /// rate of recognized threads / sec: 
  let ``rate of recognized threads / sec`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "rate of recognized threads / sec"; instance = instance }

  let allCounters =
    [ ``# of current logical Threads``
      ``# of current physical Threads``
      ``# of current recognized threads``
      ``# of total recognized threads``
      ``Contention Rate / sec``
      ``Current Queue Length``
      ``Queue Length / sec``
      ``Queue Length Peak``
      ``Total # of Contentions``
      ``rate of recognized threads / sec``
    ]

/// .NET CLR Memory: 
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR Memory`` =

  [<Literal>]
  let Category = ".NET CLR Memory"

  let PCC = getPCC Category
  /// # Bytes in all Heaps: 
  let ``# Bytes in all Heaps`` instance =
    { category = ".NET CLR Memory"; counter = "# Bytes in all Heaps"; instance = instance }
  /// # GC Handles: 
  let ``# GC Handles`` instance =
    { category = ".NET CLR Memory"; counter = "# GC Handles"; instance = instance }
  /// # Gen 0 Collections: 
  let ``# Gen 0 Collections`` instance =
    { category = ".NET CLR Memory"; counter = "# Gen 0 Collections"; instance = instance }
  /// # Gen 1 Collections: 
  let ``# Gen 1 Collections`` instance =
    { category = ".NET CLR Memory"; counter = "# Gen 1 Collections"; instance = instance }
  /// # Gen 2 Collections: 
  let ``# Gen 2 Collections`` instance =
    { category = ".NET CLR Memory"; counter = "# Gen 2 Collections"; instance = instance }
  /// # Induced GC: 
  let ``# Induced GC`` instance =
    { category = ".NET CLR Memory"; counter = "# Induced GC"; instance = instance }
  /// # Total committed Bytes: 
  let ``# Total committed Bytes`` instance =
    { category = ".NET CLR Memory"; counter = "# Total committed Bytes"; instance = instance }
  /// # Total reserved Bytes: 
  let ``# Total reserved Bytes`` instance =
    { category = ".NET CLR Memory"; counter = "# Total reserved Bytes"; instance = instance }
  /// # of Pinned Objects: 
  let ``# of Pinned Objects`` instance =
    { category = ".NET CLR Memory"; counter = "# of Pinned Objects"; instance = instance }
  /// # of Sink Blocks in use: 
  let ``# of Sink Blocks in use`` instance =
    { category = ".NET CLR Memory"; counter = "# of Sink Blocks in use"; instance = instance }
  /// % Time in GC: 
  let ``% Time in GC`` instance =
    { category = ".NET CLR Memory"; counter = "% Time in GC"; instance = instance }
  /// Allocated Bytes/sec: 
  let ``Allocated Bytes/sec`` instance =
    { category = ".NET CLR Memory"; counter = "Allocated Bytes/sec"; instance = instance }
  /// Finalization Survivors: 
  let ``Finalization Survivors`` instance =
    { category = ".NET CLR Memory"; counter = "Finalization Survivors"; instance = instance }
  /// Gen 0 Promoted Bytes/Sec: 
  let ``Gen 0 Promoted Bytes/Sec`` instance =
    { category = ".NET CLR Memory"; counter = "Gen 0 Promoted Bytes/Sec"; instance = instance }
  /// Gen 0 heap size: 
  let ``Gen 0 heap size`` instance =
    { category = ".NET CLR Memory"; counter = "Gen 0 heap size"; instance = instance }
  /// Gen 1 Promoted Bytes/Sec: 
  let ``Gen 1 Promoted Bytes/Sec`` instance =
    { category = ".NET CLR Memory"; counter = "Gen 1 Promoted Bytes/Sec"; instance = instance }
  /// Gen 1 heap size: 
  let ``Gen 1 heap size`` instance =
    { category = ".NET CLR Memory"; counter = "Gen 1 heap size"; instance = instance }
  /// Gen 2 heap size: 
  let ``Gen 2 heap size`` instance =
    { category = ".NET CLR Memory"; counter = "Gen 2 heap size"; instance = instance }
  /// Large Object Heap size: 
  let ``Large Object Heap size`` instance =
    { category = ".NET CLR Memory"; counter = "Large Object Heap size"; instance = instance }
  /// Promoted Finalization-Memory from Gen 0: 
  let ``Promoted Finalization-Memory from Gen 0`` instance =
    { category = ".NET CLR Memory"; counter = "Promoted Finalization-Memory from Gen 0"; instance = instance }
  /// Promoted Memory from Gen 0: 
  let ``Promoted Memory from Gen 0`` instance =
    { category = ".NET CLR Memory"; counter = "Promoted Memory from Gen 0"; instance = instance }
  /// Promoted Memory from Gen 1: 
  let ``Promoted Memory from Gen 1`` instance =
    { category = ".NET CLR Memory"; counter = "Promoted Memory from Gen 1"; instance = instance }

  let allCounters =
    [ ``# Bytes in all Heaps``
      ``# GC Handles``
      ``# Gen 0 Collections``
      ``# Gen 1 Collections``
      ``# Gen 2 Collections``
      ``# Induced GC``
      ``# Total committed Bytes``
      ``# Total reserved Bytes``
      ``# of Pinned Objects``
      ``# of Sink Blocks in use``
      ``% Time in GC``
      ``Allocated Bytes/sec``
      ``Finalization Survivors``
      ``Gen 0 Promoted Bytes/Sec``
      ``Gen 0 heap size``
      ``Gen 1 Promoted Bytes/Sec``
      ``Gen 1 heap size``
      ``Gen 2 heap size``
      ``Large Object Heap size``
      ``Promoted Finalization-Memory from Gen 0``
      ``Promoted Memory from Gen 0``
      ``Promoted Memory from Gen 1``
    ]

/// .NET CLR Remoting: 
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR Remoting`` =

  [<Literal>]
  let Category = ".NET CLR Remoting"

  let PCC = getPCC Category
  /// Channels: 
  let ``Channels`` instance =
    { category = ".NET CLR Remoting"; counter = "Channels"; instance = instance }
  /// Context Proxies: 
  let ``Context Proxies`` instance =
    { category = ".NET CLR Remoting"; counter = "Context Proxies"; instance = instance }
  /// Context-Bound Classes Loaded: 
  let ``Context-Bound Classes Loaded`` instance =
    { category = ".NET CLR Remoting"; counter = "Context-Bound Classes Loaded"; instance = instance }
  /// Context-Bound Objects Alloc / sec: 
  let ``Context-Bound Objects Alloc / sec`` instance =
    { category = ".NET CLR Remoting"; counter = "Context-Bound Objects Alloc / sec"; instance = instance }
  /// Contexts: 
  let ``Contexts`` instance =
    { category = ".NET CLR Remoting"; counter = "Contexts"; instance = instance }
  /// Remote Calls/sec: 
  let ``Remote Calls/sec`` instance =
    { category = ".NET CLR Remoting"; counter = "Remote Calls/sec"; instance = instance }
  /// Total Remote Calls: 
  let ``Total Remote Calls`` instance =
    { category = ".NET CLR Remoting"; counter = "Total Remote Calls"; instance = instance }

  let allCounters =
    [ ``Channels``
      ``Context Proxies``
      ``Context-Bound Classes Loaded``
      ``Context-Bound Objects Alloc / sec``
      ``Contexts``
      ``Remote Calls/sec``
      ``Total Remote Calls``
    ]

/// .NET CLR Security: 
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR Security`` =

  [<Literal>]
  let Category = ".NET CLR Security"

  let PCC = getPCC Category
  /// # Link Time Checks: 
  let ``# Link Time Checks`` instance =
    { category = ".NET CLR Security"; counter = "# Link Time Checks"; instance = instance }
  /// % Time in RT checks: 
  let ``% Time in RT checks`` instance =
    { category = ".NET CLR Security"; counter = "% Time in RT checks"; instance = instance }
  /// Stack Walk Depth: 
  let ``Stack Walk Depth`` instance =
    { category = ".NET CLR Security"; counter = "Stack Walk Depth"; instance = instance }
  /// Total Runtime Checks: 
  let ``Total Runtime Checks`` instance =
    { category = ".NET CLR Security"; counter = "Total Runtime Checks"; instance = instance }

  let allCounters =
    [ ``# Link Time Checks``
      ``% Time in RT checks``
      ``Stack Walk Depth``
      ``Total Runtime Checks``
    ]

/// ASP.NET: 
///
/// This performance counter does not have non-instance based counters
module ``ASP_NET`` =

  [<Literal>]
  let Category = "ASP.NET"

  let PCC = getPCC Category
  /// Requests Queued: 
  let ``Requests Queued`` instance =
    { category = "ASP.NET"; counter = "Requests Queued"; instance = instance }
  /// Requests Total: 
  let ``Requests Total`` instance =
    { category = "ASP.NET"; counter = "Requests Total"; instance = instance }
  /// Requests/Sec: 
  let ``Requests/Sec`` instance =
    { category = "ASP.NET"; counter = "Requests/Sec"; instance = instance }

  let allCounters =
    [ ``Requests Queued``
      ``Requests Total``
      ``Requests/Sec``
    ]

/// Mono Memory: 
///
/// This performance counter does not have non-instance based counters
module ``Mono Memory`` =

  [<Literal>]
  let Category = "Mono Memory"

  let PCC = getPCC Category
  /// Allocated Objects: 
  let ``Allocated Objects`` instance =
    { category = "Mono Memory"; counter = "Allocated Objects"; instance = instance }
  /// Available Physical Memory: 
  let ``Available Physical Memory`` instance =
    { category = "Mono Memory"; counter = "Available Physical Memory"; instance = instance }
  /// Total Physical Memory: 
  let ``Total Physical Memory`` instance =
    { category = "Mono Memory"; counter = "Total Physical Memory"; instance = instance }

  let allCounters =
    [ ``Allocated Objects``
      ``Available Physical Memory``
      ``Total Physical Memory``
    ]

/// Mono Threadpool: 
///
/// This performance counter does not have non-instance based counters
module ``Mono Threadpool`` =

  [<Literal>]
  let Category = "Mono Threadpool"

  let PCC = getPCC Category
  /// # of IO Threads: 
  let ``# of IO Threads`` instance =
    { category = "Mono Threadpool"; counter = "# of IO Threads"; instance = instance }
  /// # of Threads: 
  let ``# of Threads`` instance =
    { category = "Mono Threadpool"; counter = "# of Threads"; instance = instance }
  /// IO Work Items Added: 
  let ``IO Work Items Added`` instance =
    { category = "Mono Threadpool"; counter = "IO Work Items Added"; instance = instance }
  /// IO Work Items Added/Sec: 
  let ``IO Work Items Added/Sec`` instance =
    { category = "Mono Threadpool"; counter = "IO Work Items Added/Sec"; instance = instance }
  /// Work Items Added: 
  let ``Work Items Added`` instance =
    { category = "Mono Threadpool"; counter = "Work Items Added"; instance = instance }
  /// Work Items Added/Sec: 
  let ``Work Items Added/Sec`` instance =
    { category = "Mono Threadpool"; counter = "Work Items Added/Sec"; instance = instance }

  let allCounters =
    [ ``# of IO Threads``
      ``# of Threads``
      ``IO Work Items Added``
      ``IO Work Items Added/Sec``
      ``Work Items Added``
      ``Work Items Added/Sec``
    ]

/// Network Interface: 
///
/// This performance counter does not have instance based counters
module ``Network Interface`` =

  [<Literal>]
  let Category = "Network Interface"

  let PCC = getPCC Category
  /// Bytes Received/sec: 
  let ``Bytes Received/sec`` =
    { category = "Network Interface"; counter = "Bytes Received/sec"; instance = NotApplicable }
  /// Bytes Sent/sec: 
  let ``Bytes Sent/sec`` =
    { category = "Network Interface"; counter = "Bytes Sent/sec"; instance = NotApplicable }
  /// Bytes Total/sec: 
  let ``Bytes Total/sec`` =
    { category = "Network Interface"; counter = "Bytes Total/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Bytes Received/sec``
      ``Bytes Sent/sec``
      ``Bytes Total/sec``
    ]

/// Process: 
///
/// This performance counter does not have non-instance based counters
module ``Process`` =

  [<Literal>]
  let Category = "Process"

  let PCC = getPCC Category
  /// % Privileged Time: 
  let ``% Privileged Time`` instance =
    { category = "Process"; counter = "% Privileged Time"; instance = instance }
  /// % Processor Time: 
  let ``% Processor Time`` instance =
    { category = "Process"; counter = "% Processor Time"; instance = instance }
  /// % User Time: 
  let ``% User Time`` instance =
    { category = "Process"; counter = "% User Time"; instance = instance }
  /// Private Bytes: 
  let ``Private Bytes`` instance =
    { category = "Process"; counter = "Private Bytes"; instance = instance }
  /// Thread Count: 
  let ``Thread Count`` instance =
    { category = "Process"; counter = "Thread Count"; instance = instance }
  /// Virtual Bytes: 
  let ``Virtual Bytes`` instance =
    { category = "Process"; counter = "Virtual Bytes"; instance = instance }
  /// Working Set: 
  let ``Working Set`` instance =
    { category = "Process"; counter = "Working Set"; instance = instance }

  let allCounters =
    [ ``% Privileged Time``
      ``% Processor Time``
      ``% User Time``
      ``Private Bytes``
      ``Thread Count``
      ``Virtual Bytes``
      ``Working Set``
    ]

/// Processor: 
///
/// This performance counter does not have non-instance based counters
module ``Processor`` =

  [<Literal>]
  let Category = "Processor"

  let PCC = getPCC Category
  /// % DCP Time: 
  let ``% DCP Time`` instance =
    { category = "Processor"; counter = "% DCP Time"; instance = instance }
  /// % Interrupt Time: 
  let ``% Interrupt Time`` instance =
    { category = "Processor"; counter = "% Interrupt Time"; instance = instance }
  /// % Privileged Time: 
  let ``% Privileged Time`` instance =
    { category = "Processor"; counter = "% Privileged Time"; instance = instance }
  /// % Processor Time: 
  let ``% Processor Time`` instance =
    { category = "Processor"; counter = "% Processor Time"; instance = instance }
  /// % User Time: 
  let ``% User Time`` instance =
    { category = "Processor"; counter = "% User Time"; instance = instance }

  let allCounters =
    [ ``% DCP Time``
      ``% Interrupt Time``
      ``% Privileged Time``
      ``% Processor Time``
      ``% User Time``
    ]
