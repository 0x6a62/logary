#if INTERACTIVE
#r "bin/Release/protobuf-net.dll"
#else
module Logary.Target.Riemann
#endif

// https://github.com/aphyr/riemann-ruby-client/blob/master/lib/riemann/event.rb
// https://github.com/aphyr/riemann-java-client/tree/master/src/main/java/com

open ProtoBuf

open FSharp.Actor

open NodaTime

open System
open System.Collections.Generic
open System.IO
open System.Net
open System.Net.Sockets
open System.Net.Security
open System.Security.Cryptography.X509Certificates

open Logary
open Logary.Riemann.Messages
open Logary.Targets
open Logary.Internals.Tcp
open Logary.Internals.InternalLogger

let private mkStream (client : TcpClient) = function
  | Some f ->
    let cb = new RemoteCertificateValidationCallback(fun _ -> f)
    new SslStream(client.GetStream(),
                  leaveInnerStreamOpen = false,
                  userCertificateValidationCallback = cb)
    :> Stream
  | None ->
    client.GetStream() :> Stream

let private mkClient (ep : IPEndPoint) =
  new TcpClient(ep)

// Note: doing ticks per ms. docs say 'per second' so it might be wrong, but
// I want the granularity and:
// https://github.com/chillitom/Riemann.Net/blob/master/Riemann.Net/Event.cs#L25
let private asEpoch (i : Instant) = i.Ticks / NodaConstants.TicksPerMillisecond

/// Convert the LogLevel to a Riemann (service) state
let mkState = function
  | Verbose | Debug | Info -> "info"
  | Warn | Error           -> "warn"
  | Fatal                  -> "critical"

/// The default way of sending attributes; just do ToString() on them
let mkAttrsFromData (m : Map<string, obj>) =
  m |> Seq.map (fun kvp -> Attribute(kvp.Key, kvp.Value.ToString())) |> List.ofSeq

/// Create an Event from a LogLine, supplying a function that optionally changes
/// the event before yielding it.
let mkEventL
  hostname ttl mkAttrsFromData
  ({ message      = message
  ; data          = data
  ; level         = level
  ; tags          = tags
  ; timestamp     = timestamp
  ; path          = path
  ; ``exception`` = ex } as ll) =
  Event.CreateDouble(1.,
                     asEpoch timestamp,
                     mkState level,
                     path, // path = metric name = riemann's 'service'
                     hostname,
                     message,
                     tags,
                     ttl,
                     mkAttrsFromData data) // TODO: make attributes from map

/// Create an Event from a Measure
let mkEventM
  hostname ttl
  { value     = value
    path      = path
    timestamp = timestamp
    level     = level
    mtype     = mtype } =
  match mtype with
  | Gauge   -> failwith "not impl" // TODO: example "RegisterGauge"
  | Timer t -> failwith "not impl"
  | Counter -> failwith "not impl"

/// The Riemann target will always use TCP in this version.
type RiemannConf =
  { /// location of the riemann server
    endpoint     : IPEndPoint

    /// A factory function for the WriteClient - useful for testing the target
    /// and for replacing the client with a high-performance client if the async
    /// actor + async + TcpClient isn't enough, but you want to try the async
    /// socket pattern.
    clientFac    : IPEndPoint -> TcpClient

    /// validation function; setting this means you need to be able to validate
    /// the certificate you get back when connecting to Riemann -- if you set
    /// this value the target will try and create a TLS connection.
    ///
    /// Parameters:
    ///  - X509Certificate certificate
    ///  - X509Chain chain
    ///  - SslPolicyErrors sslPolicyErrors
    ///
    /// Returns: bool indicating whether to accept the cert or not
    caValidation : (X509Certificate -> X509Chain -> SslPolicyErrors -> bool) option

    /// An optional mapping function that can change the Event that is generated by
    /// default.
    fLogLine     : LogLine -> Event

    /// An optional mapping function that can change the Event that is generated by
    /// default.
    fMeasure     : Measure -> Event

    /// The hostname to send to riemann
    hostname     : string }
  /// Creates a new Riemann target configuration
  static member Create(?endpoint : IPEndPoint, ?clientFac, ?caValidation,
                       ?fLogLine, ?fMeasure, ?hostname, ?ttl) =
    let ttl        = defaultArg ttl 0.f
    let hostname   = defaultArg hostname (Dns.GetHostName())
    { endpoint     = defaultArg endpoint (IPEndPoint(IPAddress.Loopback, 5555))
      clientFac    = defaultArg clientFac mkClient
      caValidation = defaultArg caValidation None
      fLogLine     = defaultArg fLogLine (mkEventL hostname ttl mkAttrsFromData)
      fMeasure     = defaultArg fMeasure (mkEventM hostname ttl)
      hostname     = hostname }

type private RiemannTargetState =
  { client : TcpClient
    stream : Stream }

module Client =

  /// Converts int to networkByteOrder
  let toBytes (len : int) =
    BitConverter.GetBytes(IPAddress.HostToNetworkOrder len)

  /// Converts byte[] from networkByteOrder
  let fromBytes (buf : byte []) =
    let i = BitConverter.ToInt32(buf, 0)
    IPAddress.NetworkToHostOrder i

  /// Reads a Riemann-length from a stream at its current position
  let readLen (stream : Stream) = async {
    let lenBuf = Array.zeroCreate 4 // TODO: use extracted buf
    let! wasRead = stream.AsyncRead(lenBuf, 0, 4) // TODO: faster with no async?
    if wasRead = 4 then
      return fromBytes lenBuf
    else
      return raise <| EndOfStreamException("unexpected EOF while reading len") }

  let send (stream : Stream) (msg : byte array) = async {
    do! stream.AsyncWrite(toBytes msg.Length)
    do! stream.AsyncWrite(msg, 0, msg.Length)
    do stream.Flush() // TODO: blocking?
    }

  let private transfer len (source : Stream) (target : Stream) =
    let bufSize = 0x2000
    let buf = Array.zeroCreate bufSize // TODO: extract
    let rec read' amountRead = async {
      if amountRead >= len then return ()
      else
        let toRead = Math.Min(bufSize, len - amountRead)
        let! wasRead = source.AsyncRead(buf, 0, toRead)
        if wasRead <> toRead then raise <| EndOfStreamException("unexpected EOF")
        else
          do! target.AsyncWrite(buf, 0, wasRead)
          return! read' (wasRead + amountRead) }
    read' 0

  let sendEvents (stream : Stream) (es : Event seq) = async {
    let msg = Msg(false, "", [], Query(), es)
    use ms = new MemoryStream() // TODO: re-use MS?
    Serializer.Serialize(ms, msg)
    do! transfer (int ms.Position) ms stream }

  let readResponse (stream : Stream) = async {
    let! toRead = readLen stream
    use ms = new MemoryStream() // TODO: re-use MS?
    do! transfer toRead stream ms
    ms.Seek(0L, SeekOrigin.Begin) |> ignore
    return Serializer.Deserialize<Msg> ms }

// To Consider: could be useful to spawn multiple of this one: each is async and implement
// an easy way to send/recv -- multiple will allow interleaving of said requests

// To Consider: sending multiple events to this

// So currently we're in push mode; did a Guage, Histogram or other thing send
// us this metric? Or are Logary 'more dump' and simply shovel the more simple
// counters and measurements (e.g. function execution timing) to Riemann
// so that riemann can make up its own data?
//
// See https://github.com/aphyr/riemann-java-client/blob/master/src/main/java/com/codahale/metrics/riemann/RiemannReporter.java#L282
// https://github.com/aphyr/riemann-ruby-client/blob/master/lib/riemann/client/tcp.rb

let riemannLoop (conf : RiemannConf) metadata =
  (fun (inbox : IActor<_>) ->
    let rec init () =
      async {
        let client = conf.clientFac conf.endpoint
        let stream = client.GetStream()
        return! running { client = client
                          stream = stream } }

    and running state =
      async {
        let! msg, mopt = inbox.Receive()
        // The server will accept a repeated list of Events, and respond
        // with a confirmation message with either an acknowledgement or an error.
        // Check the `ok` boolean in the message; if false, message.error will
        // be a descriptive string.
        match msg with
        | Log l ->
          do!  [ conf.fLogLine l ] |> Client.sendEvents state.stream
          let! (response : Msg) = Client.readResponse state.stream
          if not response.ok then raise <| Exception(sprintf "server error: %s" response.error)
          else return! running state
        | Metric msr ->
          do!  [ conf.fMeasure msr ] |> Client.sendEvents state.stream
          let! (response : Msg) = Client.readResponse state.stream
          if not response.ok then raise <| Exception(sprintf "server error: %s" response.error)
          else return! running state
        | Flush chan ->
          chan.Reply Ack
          return! running state
        | ShutdownTarget ackChan ->
          return! shutdown state ackChan }

    and shutdown state ackChan =
      async {
        safeTry "riemann target disposing tcp stream, then client" <| fun () ->
          (state.stream :> IDisposable).Dispose()
          (state.client :> IDisposable).Dispose()
        ackChan.Reply Ack
        return () }
    init ())

/// Create a new Riemann target
let create conf = TargetUtils.stdNamedTarget (riemannLoop conf)

[<CompiledName("Create")>]
let CreateC(conf, name) = create conf name

//  /// Use with LogaryFactory.New( s => s.Target<Riemann.Builder>() )
//  type Builder(conf, callParent : FactoryApi.ParentCallback<Builder>) =
//
//    member x.Hostname(hostname : string) =
//      Builder({ conf with LogstashConf.hostname = hostname }, callParent)
//
//    member x.Port(port : uint16) =
//      Builder({ conf with port = port }, callParent)
//
//    member x.ClientFactory(fac : Func<string, uint16, WriteClient>) =
//      Builder({ conf with clientFac = fun host port -> fac.Invoke(host, port) }, callParent)
//
//    /// Sets the JsonSerializerSettings to use, or uses
//    /// <see cref="Logary.Formatting.JsonFormatter.Settings" /> otherwise.
//    member x.JsonSerializerSettings(settings : JsonSerializerSettings) =
//      Builder({ conf with jsonSettings = settings }, callParent)
//
//    member x.EventVersion(ver : EventVersion) =
//      Builder({ conf with evtVer = ver }, callParent)
//
//    member x.Done() =
//      ! ( callParent x )
//
//    new(callParent : FactoryApi.ParentCallback<_>) =
//      Builder(LogstashConf.Create("127.0.0.1"), callParent)
//
//    interface Logary.Targets.FactoryApi.SpecificTargetConf with
//      member x.Build name = create conf name
