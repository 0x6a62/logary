#I "bin/Release"
#r "Logary.dll"
#r "NodaTime.dll"
#r "Hopac.Core.dll"
#r "Hopac.dll"
#load "WinPerfCounter.fs"

open System
open System.IO
open System.Text.RegularExpressions
open Logary.Metrics
open Logary.Metrics.WinPerfCounter

let munge name =
  Regex.Replace(name, "[\./,]", "_")

let gen () =

  let genComment (pcc : Category) (perfCounter : WinPerfCounter) =
    sprintf
        "/// %s: %s
///
/// %s"
      pcc.CategoryName
      pcc.CategoryHelp
      (match perfCounter.instance with
      | None -> "This performance counter does not have instance based counters"
      | _    -> "This performance counter does not have non-instance based counters")

  let genModuleHeader (perfCounter : WinPerfCounter) =
    let preHeader () =
      sprintf """module ``%s`` =

  [<Literal>]
  let CategoryName = "%s"

  let PerfCat = Category.create CategoryName"""
        (munge perfCounter.category)
        perfCounter.category
      

    match perfCounter.instance with
    | None ->
      preHeader ()
    | Some _ ->
      sprintf """%s

  /// Returns an array of the instances available on this node/machine.
  let instances () =
    PerfCat
    |> Option.fold (fun s pcc -> Category.instances pcc) Array.empty
    |> Array.filter (function
      | Some inst -> not (Array.contains inst KnownInstances.All)
      | None -> false)
"""
        (preHeader ())

  let genCounter (pc : WinPerfCounter) =
    match WinPerfCounter.toWindowsCounter pc with
    | Some osPC when pc.instance = None ->
      sprintf """  /// %s: %s
  let ``%s`` =
    %s"""
        pc.counter (osPC.CounterHelp.Trim()) pc.counter
        (sprintf """WinPerfCounter.create(CategoryName, "%s", None)""" pc.counter)
    | mOsPc ->
      let help =
        match mOsPc with
        | None -> "-"
        | Some osPC -> osPC.CounterHelp.Trim()

      sprintf """  /// %s: %s
  let ``%s`` instance =
    %s"""
        pc.counter help pc.counter
        (sprintf """WinPerfCounter.create(CategoryName, "%s", instance)""" pc.counter)

  let genCounters (counters : WinPerfCounter list) =
    counters
    |> List.map genCounter
    |> List.filter (not << String.IsNullOrWhiteSpace)
    |> fun ctrs -> String.Join("\n", ctrs)

  let genListing (counters : WinPerfCounter list) =
    match counters with
    | [] -> """  let allCounters = [||]"""
    | hc :: rest ->
      sprintf """
  let allCounters =
    [| ``%s``
%s
    |]"""
        hc.counter
        (rest
          |> List.map (fun { counter = c } -> "``" + c + "``")
          |> List.map (fun s -> "       " + s)
          |> fun ss -> String.Join("\n", ss))

  let genFileHeader () =
    """/// Copyright Henrik Feldt 2016. Part of the Logary source code.
/// An autogenerated file with all performance counters found on a Windows 10 system
module Logary.Metrics.AllWinPerfCounters

open System
open System.Diagnostics
open Logary.Metrics
open Logary.Metrics.WinPerfCounter"""

  Category.list ()
  |> Array.map (fun pcc -> pcc, Category.instances pcc)
  |> Array.sortBy (fun (pcc, _) -> pcc.CategoryName)
  |> Array.map (function
    | pcc, [||]      -> pcc, WinPerfCounter.list pcc None
    | pcc, instances -> pcc, WinPerfCounter.list pcc (Array.head instances))
  |> Array.map (fun (pcc, counters) ->
    pcc, counters |> Array.sortBy (fun x -> x.counter))
  |> Array.map (function
    | pcc, [||]     -> ""
    | pcc, counters ->
      let c = Array.head counters
      let counters = counters |> Seq.distinct |> List.ofSeq
      genComment pcc c + "\n"
      + (genModuleHeader c) + "\n"
      + (genCounters counters) + "\n"
      + (genListing counters) + "\n")
  |> fun modules ->
    genFileHeader () + "\n"
    + String.Join("\n", modules)

let write () =
  let contents = gen ()
  let path = Path.Combine(__SOURCE_DIRECTORY__, "WinPerfCounters.fs")
  printfn "writing to path '%s'" path
  File.WriteAllText(path, contents, System.Text.Encoding.UTF8)

/// SynchronizationNuma: A nice help text
///
/// This performance counter does not have non-instance based counters
module ``SynchronizationNuma Example`` =

  [<Literal>]
  let CategoryName = "SynchronizationNuma"

  let PerfCat = Category.create CategoryName

  let instances () =
    PerfCat
    |> Option.fold (fun s pcc -> Category.instances pcc) Array.empty
    |> Array.filter (function
      | Some inst -> not (Array.contains inst KnownInstances.All)
      | None -> false)

  let ``Exec. Resource no-Waits AcqShrdWaitForExcl/sec`` instance =
    toWindowsCounter3 CategoryName "Exec. Resource no-Waits AcqShrdWaitForExcl/sec" instance

  let ``Exec. Resource Boost Excl. Owner/sec`` instance =
    toWindowsCounter3 CategoryName "Exec. Resource Boost Excl. Owner/sec" instance

  // etc

  let allCounters =
    [ ``Exec. Resource no-Waits AcqShrdWaitForExcl/sec``
      ``Exec. Resource Boost Excl. Owner/sec``
      // etc
    ]

  let countersFor instance =
    allCounters
    |> List.map (fun f -> f instance)
    |> List.filter Option.isSome
    |> List.map Option.get

/// System: a nice help text here too
///
/// This performance counter does not have instance based counters
module ``System Example`` =

  [<Literal>]
  let CategoryName = "System"

  let PerfCat = Category.create CategoryName

  let ``File Read Operations/sec`` =
    WinPerfCounter.create(CategoryName, "File Read Operations/sec", None)

  // etc

  let allCounters =
    [| ``File Read Operations/sec`` |]

//#load "WinPerfCounters.fs"
//Logary.WinPerfCounters.``WorkflowServiceHost 4_0_0_0``.``Workflows Created`` NotApplicable
