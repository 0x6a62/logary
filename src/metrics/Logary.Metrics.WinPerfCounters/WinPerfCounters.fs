/// Copyright Henrik Feldt 2016. Part of the Logary source code.
/// An autogenerated file with all performance counters found on a Windows 10 system
module Logary.Metrics.AllWinPerfCounters

open System
open System.Diagnostics
open Logary.Metrics
open Logary.Metrics.WinPerfCounter
/// .NET CLR Data: .Net CLR Data
///
/// This performance counter does not have instance based counters
module ``_NET CLR Data`` =

  [<Literal>]
  let CategoryName = ".NET CLR Data"

  let PCC = Category.create CategoryName
  /// SqlClient: Current # connection pools: -
  let ``SqlClient: Current # connection pools`` instance =
    { category = CategoryName; counter = "SqlClient: Current # connection pools"; instance = instance }
  /// SqlClient: Current # pooled and nonpooled connections: -
  let ``SqlClient: Current # pooled and nonpooled connections`` instance =
    { category = CategoryName; counter = "SqlClient: Current # pooled and nonpooled connections"; instance = instance }
  /// SqlClient: Current # pooled connections: -
  let ``SqlClient: Current # pooled connections`` instance =
    { category = CategoryName; counter = "SqlClient: Current # pooled connections"; instance = instance }
  /// SqlClient: Peak # pooled connections: -
  let ``SqlClient: Peak # pooled connections`` instance =
    { category = CategoryName; counter = "SqlClient: Peak # pooled connections"; instance = instance }
  /// SqlClient: Total # failed commands: -
  let ``SqlClient: Total # failed commands`` instance =
    { category = CategoryName; counter = "SqlClient: Total # failed commands"; instance = instance }
  /// SqlClient: Total # failed connects: -
  let ``SqlClient: Total # failed connects`` instance =
    { category = CategoryName; counter = "SqlClient: Total # failed connects"; instance = instance }

  let allCounters =
    [| ``SqlClient: Current # connection pools``
       ``SqlClient: Current # pooled and nonpooled connections``
       ``SqlClient: Current # pooled connections``
       ``SqlClient: Peak # pooled connections``
       ``SqlClient: Total # failed commands``
       ``SqlClient: Total # failed connects``
    |]

/// .NET CLR Networking: Help not available.
///
/// This performance counter does not have instance based counters
module ``_NET CLR Networking`` =

  [<Literal>]
  let CategoryName = ".NET CLR Networking"

  let PCC = Category.create CategoryName
  /// Bytes Received: -
  let ``Bytes Received`` instance =
    { category = CategoryName; counter = "Bytes Received"; instance = instance }
  /// Bytes Sent: -
  let ``Bytes Sent`` instance =
    { category = CategoryName; counter = "Bytes Sent"; instance = instance }
  /// Connections Established: -
  let ``Connections Established`` instance =
    { category = CategoryName; counter = "Connections Established"; instance = instance }
  /// Datagrams Received: -
  let ``Datagrams Received`` instance =
    { category = CategoryName; counter = "Datagrams Received"; instance = instance }
  /// Datagrams Sent: -
  let ``Datagrams Sent`` instance =
    { category = CategoryName; counter = "Datagrams Sent"; instance = instance }

  let allCounters =
    [| ``Bytes Received``
       ``Bytes Sent``
       ``Connections Established``
       ``Datagrams Received``
       ``Datagrams Sent``
    |]

/// .NET CLR Networking 4.0.0.0: Counters for classes in the System.Net namespace.
///
/// This performance counter does not have instance based counters
module ``_NET CLR Networking 4_0_0_0`` =

  [<Literal>]
  let CategoryName = ".NET CLR Networking 4.0.0.0"

  let PCC = Category.create CategoryName
  /// Bytes Received: -
  let ``Bytes Received`` instance =
    { category = CategoryName; counter = "Bytes Received"; instance = instance }
  /// Bytes Sent: -
  let ``Bytes Sent`` instance =
    { category = CategoryName; counter = "Bytes Sent"; instance = instance }
  /// Connections Established: -
  let ``Connections Established`` instance =
    { category = CategoryName; counter = "Connections Established"; instance = instance }
  /// Datagrams Received: -
  let ``Datagrams Received`` instance =
    { category = CategoryName; counter = "Datagrams Received"; instance = instance }
  /// Datagrams Sent: -
  let ``Datagrams Sent`` instance =
    { category = CategoryName; counter = "Datagrams Sent"; instance = instance }
  /// HttpWebRequests Aborted/Sec: -
  let ``HttpWebRequests Aborted/Sec`` instance =
    { category = CategoryName; counter = "HttpWebRequests Aborted/Sec"; instance = instance }
  /// HttpWebRequests Average Lifetime: -
  let ``HttpWebRequests Average Lifetime`` instance =
    { category = CategoryName; counter = "HttpWebRequests Average Lifetime"; instance = instance }
  /// HttpWebRequests Average Lifetime Base: -
  let ``HttpWebRequests Average Lifetime Base`` instance =
    { category = CategoryName; counter = "HttpWebRequests Average Lifetime Base"; instance = instance }
  /// HttpWebRequests Average Queue Time: -
  let ``HttpWebRequests Average Queue Time`` instance =
    { category = CategoryName; counter = "HttpWebRequests Average Queue Time"; instance = instance }
  /// HttpWebRequests Average Queue Time Base: -
  let ``HttpWebRequests Average Queue Time Base`` instance =
    { category = CategoryName; counter = "HttpWebRequests Average Queue Time Base"; instance = instance }
  /// HttpWebRequests Created/Sec: -
  let ``HttpWebRequests Created/Sec`` instance =
    { category = CategoryName; counter = "HttpWebRequests Created/Sec"; instance = instance }
  /// HttpWebRequests Failed/Sec: -
  let ``HttpWebRequests Failed/Sec`` instance =
    { category = CategoryName; counter = "HttpWebRequests Failed/Sec"; instance = instance }
  /// HttpWebRequests Queued/Sec: -
  let ``HttpWebRequests Queued/Sec`` instance =
    { category = CategoryName; counter = "HttpWebRequests Queued/Sec"; instance = instance }

  let allCounters =
    [| ``Bytes Received``
       ``Bytes Sent``
       ``Connections Established``
       ``Datagrams Received``
       ``Datagrams Sent``
       ``HttpWebRequests Aborted/Sec``
       ``HttpWebRequests Average Lifetime``
       ``HttpWebRequests Average Lifetime Base``
       ``HttpWebRequests Average Queue Time``
       ``HttpWebRequests Average Queue Time Base``
       ``HttpWebRequests Created/Sec``
       ``HttpWebRequests Failed/Sec``
       ``HttpWebRequests Queued/Sec``
    |]

/// .NET Data Provider for Oracle: Counters for System.Data.OracleClient
///
/// This performance counter does not have instance based counters
module ``_NET Data Provider for Oracle`` =

  [<Literal>]
  let CategoryName = ".NET Data Provider for Oracle"

  let PCC = Category.create CategoryName
  /// HardConnectsPerSecond: -
  let ``HardConnectsPerSecond`` instance =
    { category = CategoryName; counter = "HardConnectsPerSecond"; instance = instance }
  /// HardDisconnectsPerSecond: -
  let ``HardDisconnectsPerSecond`` instance =
    { category = CategoryName; counter = "HardDisconnectsPerSecond"; instance = instance }
  /// NumberOfActiveConnectionPoolGroups: -
  let ``NumberOfActiveConnectionPoolGroups`` instance =
    { category = CategoryName; counter = "NumberOfActiveConnectionPoolGroups"; instance = instance }
  /// NumberOfActiveConnectionPools: -
  let ``NumberOfActiveConnectionPools`` instance =
    { category = CategoryName; counter = "NumberOfActiveConnectionPools"; instance = instance }
  /// NumberOfActiveConnections: -
  let ``NumberOfActiveConnections`` instance =
    { category = CategoryName; counter = "NumberOfActiveConnections"; instance = instance }
  /// NumberOfFreeConnections: -
  let ``NumberOfFreeConnections`` instance =
    { category = CategoryName; counter = "NumberOfFreeConnections"; instance = instance }
  /// NumberOfInactiveConnectionPoolGroups: -
  let ``NumberOfInactiveConnectionPoolGroups`` instance =
    { category = CategoryName; counter = "NumberOfInactiveConnectionPoolGroups"; instance = instance }
  /// NumberOfInactiveConnectionPools: -
  let ``NumberOfInactiveConnectionPools`` instance =
    { category = CategoryName; counter = "NumberOfInactiveConnectionPools"; instance = instance }
  /// NumberOfNonPooledConnections: -
  let ``NumberOfNonPooledConnections`` instance =
    { category = CategoryName; counter = "NumberOfNonPooledConnections"; instance = instance }
  /// NumberOfPooledConnections: -
  let ``NumberOfPooledConnections`` instance =
    { category = CategoryName; counter = "NumberOfPooledConnections"; instance = instance }
  /// NumberOfReclaimedConnections: -
  let ``NumberOfReclaimedConnections`` instance =
    { category = CategoryName; counter = "NumberOfReclaimedConnections"; instance = instance }
  /// NumberOfStasisConnections: -
  let ``NumberOfStasisConnections`` instance =
    { category = CategoryName; counter = "NumberOfStasisConnections"; instance = instance }
  /// SoftConnectsPerSecond: -
  let ``SoftConnectsPerSecond`` instance =
    { category = CategoryName; counter = "SoftConnectsPerSecond"; instance = instance }
  /// SoftDisconnectsPerSecond: -
  let ``SoftDisconnectsPerSecond`` instance =
    { category = CategoryName; counter = "SoftDisconnectsPerSecond"; instance = instance }

  let allCounters =
    [| ``HardConnectsPerSecond``
       ``HardDisconnectsPerSecond``
       ``NumberOfActiveConnectionPoolGroups``
       ``NumberOfActiveConnectionPools``
       ``NumberOfActiveConnections``
       ``NumberOfFreeConnections``
       ``NumberOfInactiveConnectionPoolGroups``
       ``NumberOfInactiveConnectionPools``
       ``NumberOfNonPooledConnections``
       ``NumberOfPooledConnections``
       ``NumberOfReclaimedConnections``
       ``NumberOfStasisConnections``
       ``SoftConnectsPerSecond``
       ``SoftDisconnectsPerSecond``
    |]

/// .NET Data Provider for SqlServer: Counters for System.Data.SqlClient
///
/// This performance counter does not have non-instance based counters
module ``_NET Data Provider for SqlServer`` =

  [<Literal>]
  let CategoryName = ".NET Data Provider for SqlServer"

  let PCC = Category.create CategoryName
  /// HardConnectsPerSecond: The number of actual connections per second that are being made to servers
  let ``HardConnectsPerSecond`` instance =
    { category = CategoryName; counter = "HardConnectsPerSecond"; instance = instance }
  /// HardDisconnectsPerSecond: The number of actual disconnects per second that are being made to servers
  let ``HardDisconnectsPerSecond`` instance =
    { category = CategoryName; counter = "HardDisconnectsPerSecond"; instance = instance }
  /// NumberOfActiveConnectionPoolGroups: The number of unique connection strings
  let ``NumberOfActiveConnectionPoolGroups`` instance =
    { category = CategoryName; counter = "NumberOfActiveConnectionPoolGroups"; instance = instance }
  /// NumberOfActiveConnectionPools: The number of active connection pools
  let ``NumberOfActiveConnectionPools`` instance =
    { category = CategoryName; counter = "NumberOfActiveConnectionPools"; instance = instance }
  /// NumberOfActiveConnections: The number of connections currently in-use
  let ``NumberOfActiveConnections`` instance =
    { category = CategoryName; counter = "NumberOfActiveConnections"; instance = instance }
  /// NumberOfFreeConnections: The number of connections currently available for use
  let ``NumberOfFreeConnections`` instance =
    { category = CategoryName; counter = "NumberOfFreeConnections"; instance = instance }
  /// NumberOfInactiveConnectionPoolGroups: The number of unique connection strings waiting for pruning
  let ``NumberOfInactiveConnectionPoolGroups`` instance =
    { category = CategoryName; counter = "NumberOfInactiveConnectionPoolGroups"; instance = instance }
  /// NumberOfInactiveConnectionPools: The number of inactive connection pools
  let ``NumberOfInactiveConnectionPools`` instance =
    { category = CategoryName; counter = "NumberOfInactiveConnectionPools"; instance = instance }
  /// NumberOfNonPooledConnections: The number of connections that are not using connection pooling
  let ``NumberOfNonPooledConnections`` instance =
    { category = CategoryName; counter = "NumberOfNonPooledConnections"; instance = instance }
  /// NumberOfPooledConnections: The number of connections that are managed by the connection pooler
  let ``NumberOfPooledConnections`` instance =
    { category = CategoryName; counter = "NumberOfPooledConnections"; instance = instance }
  /// NumberOfReclaimedConnections: The number of connections we reclaim from GCed external connections
  let ``NumberOfReclaimedConnections`` instance =
    { category = CategoryName; counter = "NumberOfReclaimedConnections"; instance = instance }
  /// NumberOfStasisConnections: The number of connections currently waiting to be made ready for use
  let ``NumberOfStasisConnections`` instance =
    { category = CategoryName; counter = "NumberOfStasisConnections"; instance = instance }
  /// SoftConnectsPerSecond: The number of connections we get from the pool per second
  let ``SoftConnectsPerSecond`` instance =
    { category = CategoryName; counter = "SoftConnectsPerSecond"; instance = instance }
  /// SoftDisconnectsPerSecond: The number of connections we return to the pool per second
  let ``SoftDisconnectsPerSecond`` instance =
    { category = CategoryName; counter = "SoftDisconnectsPerSecond"; instance = instance }

  let allCounters =
    [| ``HardConnectsPerSecond``
       ``HardDisconnectsPerSecond``
       ``NumberOfActiveConnectionPoolGroups``
       ``NumberOfActiveConnectionPools``
       ``NumberOfActiveConnections``
       ``NumberOfFreeConnections``
       ``NumberOfInactiveConnectionPoolGroups``
       ``NumberOfInactiveConnectionPools``
       ``NumberOfNonPooledConnections``
       ``NumberOfPooledConnections``
       ``NumberOfReclaimedConnections``
       ``NumberOfStasisConnections``
       ``SoftConnectsPerSecond``
       ``SoftDisconnectsPerSecond``
    |]

/// APP_POOL_WAS: This counter set exposes WAS related counters for IIS Application Pools.
///
/// This performance counter does not have non-instance based counters
module ``APP_POOL_WAS`` =

  [<Literal>]
  let CategoryName = "APP_POOL_WAS"

  let PCC = Category.create CategoryName
  /// Current Application Pool State: The current status of the application pool (1 - Uninitialized, 2 - Initialized, 3 - Running, 4 - Disabling, 5 - Disabled, 6 - Shutdown Pending, 7 - Delete Pending).
  let ``Current Application Pool State`` instance =
    { category = CategoryName; counter = "Current Application Pool State"; instance = instance }
  /// Current Application Pool Uptime: The length of time, in seconds, that the application pool has been running since it was started.
  let ``Current Application Pool Uptime`` instance =
    { category = CategoryName; counter = "Current Application Pool Uptime"; instance = instance }
  /// Current Worker Processes: The current number of worker processes that are running in the application pool.
  let ``Current Worker Processes`` instance =
    { category = CategoryName; counter = "Current Worker Processes"; instance = instance }
  /// Maximum Worker Processes: The maximum number of worker processes that have been created for the application pool since Windows Process Activation Service (WAS) started.
  let ``Maximum Worker Processes`` instance =
    { category = CategoryName; counter = "Maximum Worker Processes"; instance = instance }
  /// Recent Worker Process Failures: The number of times that worker processes for the application pool failed during the rapid-fail protection interval.
  let ``Recent Worker Process Failures`` instance =
    { category = CategoryName; counter = "Recent Worker Process Failures"; instance = instance }
  /// Time Since Last Worker Process Failure: The length of time, in seconds, since the last worker process failure occurred for the application pool.
  let ``Time Since Last Worker Process Failure`` instance =
    { category = CategoryName; counter = "Time Since Last Worker Process Failure"; instance = instance }
  /// Total Application Pool Recycles: The number of times that the application pool has been recycled since Windows Process Activation Service (WAS) started.
  let ``Total Application Pool Recycles`` instance =
    { category = CategoryName; counter = "Total Application Pool Recycles"; instance = instance }
  /// Total Application Pool Uptime: The length of time, in seconds, that the application pool has been running since Windows Process Activation Service (WAS) started.
  let ``Total Application Pool Uptime`` instance =
    { category = CategoryName; counter = "Total Application Pool Uptime"; instance = instance }
  /// Total Worker Process Failures: The number of times that worker processes have crashed since the application pool was started.
  let ``Total Worker Process Failures`` instance =
    { category = CategoryName; counter = "Total Worker Process Failures"; instance = instance }
  /// Total Worker Process Ping Failures: The number of times that Windows Process Activation Service (WAS) did not receive a response to ping messages sent to a worker process.
  let ``Total Worker Process Ping Failures`` instance =
    { category = CategoryName; counter = "Total Worker Process Ping Failures"; instance = instance }
  /// Total Worker Process Shutdown Failures: The number of times that Windows Process Activation Service (WAS) failed to shut down a worker process.
  let ``Total Worker Process Shutdown Failures`` instance =
    { category = CategoryName; counter = "Total Worker Process Shutdown Failures"; instance = instance }
  /// Total Worker Process Startup Failures: The number of times that Windows Process Activation Service (WAS) failed to start a worker process.
  let ``Total Worker Process Startup Failures`` instance =
    { category = CategoryName; counter = "Total Worker Process Startup Failures"; instance = instance }
  /// Total Worker Processes Created: The number of worker processes created for the application pool since Windows Process Activation Service (WAS) started.
  let ``Total Worker Processes Created`` instance =
    { category = CategoryName; counter = "Total Worker Processes Created"; instance = instance }

  let allCounters =
    [| ``Current Application Pool State``
       ``Current Application Pool Uptime``
       ``Current Worker Processes``
       ``Maximum Worker Processes``
       ``Recent Worker Process Failures``
       ``Time Since Last Worker Process Failure``
       ``Total Application Pool Recycles``
       ``Total Application Pool Uptime``
       ``Total Worker Process Failures``
       ``Total Worker Process Ping Failures``
       ``Total Worker Process Shutdown Failures``
       ``Total Worker Process Startup Failures``
       ``Total Worker Processes Created``
    |]

/// ASP.NET: ASP.NET global performance counters
///
/// This performance counter does not have instance based counters
module ``ASP_NET`` =

  [<Literal>]
  let CategoryName = "ASP.NET"

  let PCC = Category.create CategoryName
  /// Application Restarts: Number of times the application has been restarted during the web server's lifetime.
  let ``Application Restarts`` =
    { category = CategoryName; counter = "Application Restarts"; instance = None }
  /// Applications Running: Number of currently running web applications.
  let ``Applications Running`` =
    { category = CategoryName; counter = "Applications Running"; instance = None }
  /// Audit Failure Events Raised: Number of audit failures in the application since it was started.
  let ``Audit Failure Events Raised`` =
    { category = CategoryName; counter = "Audit Failure Events Raised"; instance = None }
  /// Audit Success Events Raised: Number of audit successes in the application since it was started.
  let ``Audit Success Events Raised`` =
    { category = CategoryName; counter = "Audit Success Events Raised"; instance = None }
  /// Error Events Raised: Number of error events raised since the application was started.
  let ``Error Events Raised`` =
    { category = CategoryName; counter = "Error Events Raised"; instance = None }
  /// Infrastructure Error Events Raised: Number of HTTP error events raised since the application was started.
  let ``Infrastructure Error Events Raised`` =
    { category = CategoryName; counter = "Infrastructure Error Events Raised"; instance = None }
  /// Request Error Events Raised: Number of runtime error events raised since the application was started.
  let ``Request Error Events Raised`` =
    { category = CategoryName; counter = "Request Error Events Raised"; instance = None }
  /// Request Execution Time: The number of milliseconds that it took to execute the most recent request.
  let ``Request Execution Time`` =
    { category = CategoryName; counter = "Request Execution Time"; instance = None }
  /// Request Wait Time: The number of milliseconds the most recent request was waiting in the queue.
  let ``Request Wait Time`` =
    { category = CategoryName; counter = "Request Wait Time"; instance = None }
  /// Requests Current: The current number of requests, including those that are queued, currently executing, or waiting to be written to the client.  Under the ASP.NET process model, when this counter exceeds the requestQueueLimit defined in the processModel configuration section, ASP.NET will begin rejecting requests.
  let ``Requests Current`` =
    { category = CategoryName; counter = "Requests Current"; instance = None }
  /// Requests Disconnected: The number of requests disconnected due to communication errors or user terminated.
  let ``Requests Disconnected`` =
    { category = CategoryName; counter = "Requests Disconnected"; instance = None }
  /// Requests In Native Queue: Requests queued because the concurrency limits have been exceeded.
  let ``Requests In Native Queue`` =
    { category = CategoryName; counter = "Requests In Native Queue"; instance = None }
  /// Requests Queued: The number of requests waiting to be processed.
  let ``Requests Queued`` =
    { category = CategoryName; counter = "Requests Queued"; instance = None }
  /// Requests Rejected: The number of requests rejected because the request queue was full.
  let ``Requests Rejected`` =
    { category = CategoryName; counter = "Requests Rejected"; instance = None }
  /// State Server Sessions Abandoned: The number of sessions that have been explicitly abandoned.
  let ``State Server Sessions Abandoned`` =
    { category = CategoryName; counter = "State Server Sessions Abandoned"; instance = None }
  /// State Server Sessions Active: The current number of sessions currently active.
  let ``State Server Sessions Active`` =
    { category = CategoryName; counter = "State Server Sessions Active"; instance = None }
  /// State Server Sessions Timed Out: The number of sessions timed out.
  let ``State Server Sessions Timed Out`` =
    { category = CategoryName; counter = "State Server Sessions Timed Out"; instance = None }
  /// State Server Sessions Total: The number of sessions total.
  let ``State Server Sessions Total`` =
    { category = CategoryName; counter = "State Server Sessions Total"; instance = None }
  /// Worker Process Restarts: Number of times a worker process has restarted on the machine.
  let ``Worker Process Restarts`` =
    { category = CategoryName; counter = "Worker Process Restarts"; instance = None }
  /// Worker Processes Running: Number of worker processes running on the machine.
  let ``Worker Processes Running`` =
    { category = CategoryName; counter = "Worker Processes Running"; instance = None }

  let allCounters =
    [| ``Application Restarts``
       ``Applications Running``
       ``Audit Failure Events Raised``
       ``Audit Success Events Raised``
       ``Error Events Raised``
       ``Infrastructure Error Events Raised``
       ``Request Error Events Raised``
       ``Request Execution Time``
       ``Request Wait Time``
       ``Requests Current``
       ``Requests Disconnected``
       ``Requests In Native Queue``
       ``Requests Queued``
       ``Requests Rejected``
       ``State Server Sessions Abandoned``
       ``State Server Sessions Active``
       ``State Server Sessions Timed Out``
       ``State Server Sessions Total``
       ``Worker Process Restarts``
       ``Worker Processes Running``
    |]

/// ASP.NET Applications: ASP.NET application performance counters
///
/// This performance counter does not have non-instance based counters
module ``ASP_NET Applications`` =

  [<Literal>]
  let CategoryName = "ASP.NET Applications"

  let PCC = Category.create CategoryName
  /// % Managed Processor Time (estimated): Estimated percentage of elapsed time that the processor spends executing managed application code.  This counter only tracks processor time of managed threads in the application.  It does not include additional processor time spent executing on non-managed threads.  Note that this counter is only updated with new data every five seconds.
  let ``% Managed Processor Time (estimated)`` instance =
    { category = CategoryName; counter = "% Managed Processor Time (estimated)"; instance = instance }
  /// % Managed Processor Time Base (estimated): % Managed Processor Time Base (estimated)
  let ``% Managed Processor Time Base (estimated)`` instance =
    { category = CategoryName; counter = "% Managed Processor Time Base (estimated)"; instance = instance }
  /// Anonymous Requests: Number of requests utilizing anonymous authentication.
  let ``Anonymous Requests`` instance =
    { category = CategoryName; counter = "Anonymous Requests"; instance = instance }
  /// Anonymous Requests/Sec: Number of Authentication Anonymous Requests/Sec
  let ``Anonymous Requests/Sec`` instance =
    { category = CategoryName; counter = "Anonymous Requests/Sec"; instance = instance }
  /// Application Lifetime Events: Number of application events raised since the application was started.
  let ``Application Lifetime Events`` instance =
    { category = CategoryName; counter = "Application Lifetime Events"; instance = instance }
  /// Application Lifetime Events/Sec: Number of application events raised per second.
  let ``Application Lifetime Events/Sec`` instance =
    { category = CategoryName; counter = "Application Lifetime Events/Sec"; instance = instance }
  /// Audit Failure Events Raised: Number of audit failures in the application since it was started.
  let ``Audit Failure Events Raised`` instance =
    { category = CategoryName; counter = "Audit Failure Events Raised"; instance = instance }
  /// Audit Success Events Raised: Number of audit successes in the application since it was started.
  let ``Audit Success Events Raised`` instance =
    { category = CategoryName; counter = "Audit Success Events Raised"; instance = instance }
  /// Cache % Machine Memory Limit Used: The amount of physical memory used by the machine divided by the physical memory limit for the cache, as a percentage.  When this reaches 100%, half of the cache entries will be forcibly removed.  The __Total__ instance is the average of all instances, and therefore cannot be used to determine when cache entries will be forcibly removed.
  let ``Cache % Machine Memory Limit Used`` instance =
    { category = CategoryName; counter = "Cache % Machine Memory Limit Used"; instance = instance }
  /// Cache % Machine Memory Limit Used Base: Cache % Machine Memory Limit Used Base
  let ``Cache % Machine Memory Limit Used Base`` instance =
    { category = CategoryName; counter = "Cache % Machine Memory Limit Used Base"; instance = instance }
  /// Cache % Process Memory Limit Used: The value of private bytes for the worker process divided by the private bytes memory limit for the cache, as a percentage.  When this reaches 100%, half of the cache entries will be forcibly removed.  The __Total__ instance is the average of all instances, and therefore cannot be used to determine when cache entries will be forcibly removed.
  let ``Cache % Process Memory Limit Used`` instance =
    { category = CategoryName; counter = "Cache % Process Memory Limit Used"; instance = instance }
  /// Cache % Process Memory Limit Used Base: Cache % Process Memory Limit Used Base
  let ``Cache % Process Memory Limit Used Base`` instance =
    { category = CategoryName; counter = "Cache % Process Memory Limit Used Base"; instance = instance }
  /// Cache API Entries: Total number of entries within the cache added by the user.
  let ``Cache API Entries`` instance =
    { category = CategoryName; counter = "Cache API Entries"; instance = instance }
  /// Cache API Hit Ratio: Ratio of hits called from user code.
  let ``Cache API Hit Ratio`` instance =
    { category = CategoryName; counter = "Cache API Hit Ratio"; instance = instance }
  /// Cache API Hit Ratio Base: Cache API Hit Ratio Base
  let ``Cache API Hit Ratio Base`` instance =
    { category = CategoryName; counter = "Cache API Hit Ratio Base"; instance = instance }
  /// Cache API Hits: Number of cache hits from user code.
  let ``Cache API Hits`` instance =
    { category = CategoryName; counter = "Cache API Hits"; instance = instance }
  /// Cache API Misses: Number of cache misses called from user code.
  let ``Cache API Misses`` instance =
    { category = CategoryName; counter = "Cache API Misses"; instance = instance }
  /// Cache API Trims: Total number of entries forcibly removed from the cache due to memory pressure that were originally inserted into the cache using one of the public cache APIs.
  let ``Cache API Trims`` instance =
    { category = CategoryName; counter = "Cache API Trims"; instance = instance }
  /// Cache API Turnover Rate: Number of additions and removals to the API cache per second.
  let ``Cache API Turnover Rate`` instance =
    { category = CategoryName; counter = "Cache API Turnover Rate"; instance = instance }
  /// Cache Total Entries: Total number of entries within the cache (both internal and user added)
  let ``Cache Total Entries`` instance =
    { category = CategoryName; counter = "Cache Total Entries"; instance = instance }
  /// Cache Total Hit Ratio: Ratio of hits from all cache calls.
  let ``Cache Total Hit Ratio`` instance =
    { category = CategoryName; counter = "Cache Total Hit Ratio"; instance = instance }
  /// Cache Total Hit Ratio Base: Cache Total Hit Ratio Base
  let ``Cache Total Hit Ratio Base`` instance =
    { category = CategoryName; counter = "Cache Total Hit Ratio Base"; instance = instance }
  /// Cache Total Hits: Total number of hits from the cache.
  let ``Cache Total Hits`` instance =
    { category = CategoryName; counter = "Cache Total Hits"; instance = instance }
  /// Cache Total Misses: Total number of cache misses.
  let ``Cache Total Misses`` instance =
    { category = CategoryName; counter = "Cache Total Misses"; instance = instance }
  /// Cache Total Trims: Total number of entries forcibly removed from the cache due to memory pressure.
  let ``Cache Total Trims`` instance =
    { category = CategoryName; counter = "Cache Total Trims"; instance = instance }
  /// Cache Total Turnover Rate: Number of additions and removals to the total cache per second.
  let ``Cache Total Turnover Rate`` instance =
    { category = CategoryName; counter = "Cache Total Turnover Rate"; instance = instance }
  /// Compilations Total: Number of .asax, .ascx, .ashx, .asmx, or .aspx source files dynamically compiled.
  let ``Compilations Total`` instance =
    { category = CategoryName; counter = "Compilations Total"; instance = instance }
  /// Debugging Requests: Number of debugging requests processed.
  let ``Debugging Requests`` instance =
    { category = CategoryName; counter = "Debugging Requests"; instance = instance }
  /// Error Events Raised: Number of error events raised since the application was started.
  let ``Error Events Raised`` instance =
    { category = CategoryName; counter = "Error Events Raised"; instance = instance }
  /// Error Events Raised/Sec: Number of error events per second.
  let ``Error Events Raised/Sec`` instance =
    { category = CategoryName; counter = "Error Events Raised/Sec"; instance = instance }
  /// Errors During Compilation: Number of errors that have occurred during compilation.
  let ``Errors During Compilation`` instance =
    { category = CategoryName; counter = "Errors During Compilation"; instance = instance }
  /// Errors During Execution: Number of errors that have occurred during the processing of a request.
  let ``Errors During Execution`` instance =
    { category = CategoryName; counter = "Errors During Execution"; instance = instance }
  /// Errors During Preprocessing: Number of errors that have occurred during parsing and configuration.
  let ``Errors During Preprocessing`` instance =
    { category = CategoryName; counter = "Errors During Preprocessing"; instance = instance }
  /// Errors Total: Total number of errors occurred.
  let ``Errors Total`` instance =
    { category = CategoryName; counter = "Errors Total"; instance = instance }
  /// Errors Total/Sec: Rate of errors occurred.
  let ``Errors Total/Sec`` instance =
    { category = CategoryName; counter = "Errors Total/Sec"; instance = instance }
  /// Errors Unhandled During Execution: Number of errors not handled by user code, but by the default error handler.
  let ``Errors Unhandled During Execution`` instance =
    { category = CategoryName; counter = "Errors Unhandled During Execution"; instance = instance }
  /// Errors Unhandled During Execution/Sec: Rate of unhandled errors.
  let ``Errors Unhandled During Execution/Sec`` instance =
    { category = CategoryName; counter = "Errors Unhandled During Execution/Sec"; instance = instance }
  /// Events Raised: Total number of instrumentation events raised since the application was started.
  let ``Events Raised`` instance =
    { category = CategoryName; counter = "Events Raised"; instance = instance }
  /// Events Raised/Sec: Total number of instrumentation events per second.
  let ``Events Raised/Sec`` instance =
    { category = CategoryName; counter = "Events Raised/Sec"; instance = instance }
  /// Forms Authentication Failure: Number of failed forms authentication ticket validations since the application was started.
  let ``Forms Authentication Failure`` instance =
    { category = CategoryName; counter = "Forms Authentication Failure"; instance = instance }
  /// Forms Authentication Success: Number of successful forms authentication ticket validations since the application was started.
  let ``Forms Authentication Success`` instance =
    { category = CategoryName; counter = "Forms Authentication Success"; instance = instance }
  /// Infrastructure Error Events Raised: Number of HTTP error events raised since the application was started.
  let ``Infrastructure Error Events Raised`` instance =
    { category = CategoryName; counter = "Infrastructure Error Events Raised"; instance = instance }
  /// Infrastructure Error Events Raised/Sec: Number of HTTP error events raised per second.
  let ``Infrastructure Error Events Raised/Sec`` instance =
    { category = CategoryName; counter = "Infrastructure Error Events Raised/Sec"; instance = instance }
  /// Managed Memory Used (estimated): Estimated managed heap memory consumption (in KB) by the application.  The accuracy of this counter varies depending on the duration of elapsed time since the last full managed memory heap collection.  Note that this counter is only updated with new data every five seconds.
  let ``Managed Memory Used (estimated)`` instance =
    { category = CategoryName; counter = "Managed Memory Used (estimated)"; instance = instance }
  /// Membership Authentication Failure: Number of failed membership credential validations since the application was started.
  let ``Membership Authentication Failure`` instance =
    { category = CategoryName; counter = "Membership Authentication Failure"; instance = instance }
  /// Membership Authentication Success: Number of successful membership credential validations since the application was started.
  let ``Membership Authentication Success`` instance =
    { category = CategoryName; counter = "Membership Authentication Success"; instance = instance }
  /// Output Cache Entries: Current number of entries in the output cache.
  let ``Output Cache Entries`` instance =
    { category = CategoryName; counter = "Output Cache Entries"; instance = instance }
  /// Output Cache Hit Ratio: Ratio of hits to requests for output cacheable requests.
  let ``Output Cache Hit Ratio`` instance =
    { category = CategoryName; counter = "Output Cache Hit Ratio"; instance = instance }
  /// Output Cache Hit Ratio Base: Output Cache Hit Ratio Base
  let ``Output Cache Hit Ratio Base`` instance =
    { category = CategoryName; counter = "Output Cache Hit Ratio Base"; instance = instance }
  /// Output Cache Hits: Total number of output cacheable requests served from the output cache.
  let ``Output Cache Hits`` instance =
    { category = CategoryName; counter = "Output Cache Hits"; instance = instance }
  /// Output Cache Misses: Total number of output cacheable requests not served from the output cache.
  let ``Output Cache Misses`` instance =
    { category = CategoryName; counter = "Output Cache Misses"; instance = instance }
  /// Output Cache Trims: Total number of entries forcibly removed from the cache due to memory pressure that were originally inserted into the cache by the output cache feature.
  let ``Output Cache Trims`` instance =
    { category = CategoryName; counter = "Output Cache Trims"; instance = instance }
  /// Output Cache Turnover Rate: Number of additions and removals to the output cache per second.
  let ``Output Cache Turnover Rate`` instance =
    { category = CategoryName; counter = "Output Cache Turnover Rate"; instance = instance }
  /// Pipeline Instance Count: Number of active pipeline instances.
  let ``Pipeline Instance Count`` instance =
    { category = CategoryName; counter = "Pipeline Instance Count"; instance = instance }
  /// Request Bytes In Total: The total size, in bytes, of all requests.
  let ``Request Bytes In Total`` instance =
    { category = CategoryName; counter = "Request Bytes In Total"; instance = instance }
  /// Request Bytes In Total (WebSockets): The total size, in bytes, of data received by ASP.NET on WebSocket connections.
  let ``Request Bytes In Total (WebSockets)`` instance =
    { category = CategoryName; counter = "Request Bytes In Total (WebSockets)"; instance = instance }
  /// Request Bytes Out Total: The total size, in bytes, of responses sent to a client.  This does not include standard HTTP response headers.
  let ``Request Bytes Out Total`` instance =
    { category = CategoryName; counter = "Request Bytes Out Total"; instance = instance }
  /// Request Bytes Out Total (WebSockets): The total size, in bytes, of data sent to a client on WebSocket connections.
  let ``Request Bytes Out Total (WebSockets)`` instance =
    { category = CategoryName; counter = "Request Bytes Out Total (WebSockets)"; instance = instance }
  /// Request Error Events Raised: Number of runtime error events raised since the application was started.
  let ``Request Error Events Raised`` instance =
    { category = CategoryName; counter = "Request Error Events Raised"; instance = instance }
  /// Request Error Events Raised/Sec: Number of runtime error events per second.
  let ``Request Error Events Raised/Sec`` instance =
    { category = CategoryName; counter = "Request Error Events Raised/Sec"; instance = instance }
  /// Request Events Raised: Number of request events raised since the application was started
  let ``Request Events Raised`` instance =
    { category = CategoryName; counter = "Request Events Raised"; instance = instance }
  /// Request Events Raised/Sec: Number of request events raised per second.
  let ``Request Events Raised/Sec`` instance =
    { category = CategoryName; counter = "Request Events Raised/Sec"; instance = instance }
  /// Request Execution Time: The number of milliseconds that it took to execute the most recent request.
  let ``Request Execution Time`` instance =
    { category = CategoryName; counter = "Request Execution Time"; instance = instance }
  /// Request Wait Time: The number of milliseconds the most recent request was waiting in the queue.
  let ``Request Wait Time`` instance =
    { category = CategoryName; counter = "Request Wait Time"; instance = instance }
  /// Requests Disconnected: The number of requests disconnected due to communication errors or user terminated.
  let ``Requests Disconnected`` instance =
    { category = CategoryName; counter = "Requests Disconnected"; instance = instance }
  /// Requests Executing: The number of requests currently executing.
  let ``Requests Executing`` instance =
    { category = CategoryName; counter = "Requests Executing"; instance = instance }
  /// Requests Executing (WebSockets): The number of WebSocket requests currently executing.
  let ``Requests Executing (WebSockets)`` instance =
    { category = CategoryName; counter = "Requests Executing (WebSockets)"; instance = instance }
  /// Requests Failed: Total number of failed requests.
  let ``Requests Failed`` instance =
    { category = CategoryName; counter = "Requests Failed"; instance = instance }
  /// Requests Failed (WebSockets): Total number of WebSocket requests that ended up in an aborted state.
  let ``Requests Failed (WebSockets)`` instance =
    { category = CategoryName; counter = "Requests Failed (WebSockets)"; instance = instance }
  /// Requests In Application Queue: The number of requests in the application request queue.
  let ``Requests In Application Queue`` instance =
    { category = CategoryName; counter = "Requests In Application Queue"; instance = instance }
  /// Requests Not Authorized: Number of requests failed due to unauthorized access.
  let ``Requests Not Authorized`` instance =
    { category = CategoryName; counter = "Requests Not Authorized"; instance = instance }
  /// Requests Not Found: The number of requests for resources that were not found.
  let ``Requests Not Found`` instance =
    { category = CategoryName; counter = "Requests Not Found"; instance = instance }
  /// Requests Rejected: The number of requests rejected because the application request queue was full.
  let ``Requests Rejected`` instance =
    { category = CategoryName; counter = "Requests Rejected"; instance = instance }
  /// Requests Succeeded: The number of requests that executed successfully.
  let ``Requests Succeeded`` instance =
    { category = CategoryName; counter = "Requests Succeeded"; instance = instance }
  /// Requests Succeeded (WebSockets): Total number of WebSocket requests that completed gracefully.
  let ``Requests Succeeded (WebSockets)`` instance =
    { category = CategoryName; counter = "Requests Succeeded (WebSockets)"; instance = instance }
  /// Requests Timed Out: The number of requests that timed out.
  let ``Requests Timed Out`` instance =
    { category = CategoryName; counter = "Requests Timed Out"; instance = instance }
  /// Requests Total: The total number of requests since the application was started.
  let ``Requests Total`` instance =
    { category = CategoryName; counter = "Requests Total"; instance = instance }
  /// Requests Total (WebSockets): The total number of WebSocket requests since the application was started.
  let ``Requests Total (WebSockets)`` instance =
    { category = CategoryName; counter = "Requests Total (WebSockets)"; instance = instance }
  /// Requests/Sec: The number of requests executed per second.
  let ``Requests/Sec`` instance =
    { category = CategoryName; counter = "Requests/Sec"; instance = instance }
  /// Session SQL Server connections total: The total number of connections to the SQL Server used by session state.
  let ``Session SQL Server connections total`` instance =
    { category = CategoryName; counter = "Session SQL Server connections total"; instance = instance }
  /// Session State Server connections total: The total number of connections to the State Server used by session state.
  let ``Session State Server connections total`` instance =
    { category = CategoryName; counter = "Session State Server connections total"; instance = instance }
  /// Sessions Abandoned: The number of sessions that have been explicitly abandoned.
  let ``Sessions Abandoned`` instance =
    { category = CategoryName; counter = "Sessions Abandoned"; instance = instance }
  /// Sessions Active: The current number of sessions currently active.
  let ``Sessions Active`` instance =
    { category = CategoryName; counter = "Sessions Active"; instance = instance }
  /// Sessions Timed Out: The number of sessions timed out.
  let ``Sessions Timed Out`` instance =
    { category = CategoryName; counter = "Sessions Timed Out"; instance = instance }
  /// Sessions Total: Total number of sessions since the application was started.
  let ``Sessions Total`` instance =
    { category = CategoryName; counter = "Sessions Total"; instance = instance }
  /// Transactions Aborted: The number of transactions aborted.
  let ``Transactions Aborted`` instance =
    { category = CategoryName; counter = "Transactions Aborted"; instance = instance }
  /// Transactions Committed: The number of transactions committed.
  let ``Transactions Committed`` instance =
    { category = CategoryName; counter = "Transactions Committed"; instance = instance }
  /// Transactions Pending: Number of transactions in progress.
  let ``Transactions Pending`` instance =
    { category = CategoryName; counter = "Transactions Pending"; instance = instance }
  /// Transactions Total: The total number of transactions since the application was started.
  let ``Transactions Total`` instance =
    { category = CategoryName; counter = "Transactions Total"; instance = instance }
  /// Transactions/Sec: Transactions started per second.
  let ``Transactions/Sec`` instance =
    { category = CategoryName; counter = "Transactions/Sec"; instance = instance }
  /// Viewstate MAC Validation Failure: Number of viewstate MAC validations that failed since the application was started.
  let ``Viewstate MAC Validation Failure`` instance =
    { category = CategoryName; counter = "Viewstate MAC Validation Failure"; instance = instance }

  let allCounters =
    [| ``% Managed Processor Time (estimated)``
       ``% Managed Processor Time Base (estimated)``
       ``Anonymous Requests``
       ``Anonymous Requests/Sec``
       ``Application Lifetime Events``
       ``Application Lifetime Events/Sec``
       ``Audit Failure Events Raised``
       ``Audit Success Events Raised``
       ``Cache % Machine Memory Limit Used``
       ``Cache % Machine Memory Limit Used Base``
       ``Cache % Process Memory Limit Used``
       ``Cache % Process Memory Limit Used Base``
       ``Cache API Entries``
       ``Cache API Hit Ratio``
       ``Cache API Hit Ratio Base``
       ``Cache API Hits``
       ``Cache API Misses``
       ``Cache API Trims``
       ``Cache API Turnover Rate``
       ``Cache Total Entries``
       ``Cache Total Hit Ratio``
       ``Cache Total Hit Ratio Base``
       ``Cache Total Hits``
       ``Cache Total Misses``
       ``Cache Total Trims``
       ``Cache Total Turnover Rate``
       ``Compilations Total``
       ``Debugging Requests``
       ``Error Events Raised``
       ``Error Events Raised/Sec``
       ``Errors During Compilation``
       ``Errors During Execution``
       ``Errors During Preprocessing``
       ``Errors Total``
       ``Errors Total/Sec``
       ``Errors Unhandled During Execution``
       ``Errors Unhandled During Execution/Sec``
       ``Events Raised``
       ``Events Raised/Sec``
       ``Forms Authentication Failure``
       ``Forms Authentication Success``
       ``Infrastructure Error Events Raised``
       ``Infrastructure Error Events Raised/Sec``
       ``Managed Memory Used (estimated)``
       ``Membership Authentication Failure``
       ``Membership Authentication Success``
       ``Output Cache Entries``
       ``Output Cache Hit Ratio``
       ``Output Cache Hit Ratio Base``
       ``Output Cache Hits``
       ``Output Cache Misses``
       ``Output Cache Trims``
       ``Output Cache Turnover Rate``
       ``Pipeline Instance Count``
       ``Request Bytes In Total``
       ``Request Bytes In Total (WebSockets)``
       ``Request Bytes Out Total``
       ``Request Bytes Out Total (WebSockets)``
       ``Request Error Events Raised``
       ``Request Error Events Raised/Sec``
       ``Request Events Raised``
       ``Request Events Raised/Sec``
       ``Request Execution Time``
       ``Request Wait Time``
       ``Requests Disconnected``
       ``Requests Executing``
       ``Requests Executing (WebSockets)``
       ``Requests Failed``
       ``Requests Failed (WebSockets)``
       ``Requests In Application Queue``
       ``Requests Not Authorized``
       ``Requests Not Found``
       ``Requests Rejected``
       ``Requests Succeeded``
       ``Requests Succeeded (WebSockets)``
       ``Requests Timed Out``
       ``Requests Total``
       ``Requests Total (WebSockets)``
       ``Requests/Sec``
       ``Session SQL Server connections total``
       ``Session State Server connections total``
       ``Sessions Abandoned``
       ``Sessions Active``
       ``Sessions Timed Out``
       ``Sessions Total``
       ``Transactions Aborted``
       ``Transactions Committed``
       ``Transactions Pending``
       ``Transactions Total``
       ``Transactions/Sec``
       ``Viewstate MAC Validation Failure``
    |]

/// ASP.NET Apps v2.0.50727: ASP.NET application performance counters
///
/// This performance counter does not have non-instance based counters
module ``ASP_NET Apps v2_0_50727`` =

  [<Literal>]
  let CategoryName = "ASP.NET Apps v2.0.50727"

  let PCC = Category.create CategoryName
  /// Anonymous Requests: Number of requests utilizing anonymous authentication.
  let ``Anonymous Requests`` instance =
    { category = CategoryName; counter = "Anonymous Requests"; instance = instance }
  /// Anonymous Requests/Sec: Number of Authentication Anonymous Requests/Sec
  let ``Anonymous Requests/Sec`` instance =
    { category = CategoryName; counter = "Anonymous Requests/Sec"; instance = instance }
  /// Application Lifetime Events: Number of application events raised since the application was started.
  let ``Application Lifetime Events`` instance =
    { category = CategoryName; counter = "Application Lifetime Events"; instance = instance }
  /// Application Lifetime Events/Sec: Number of application events raised per second.
  let ``Application Lifetime Events/Sec`` instance =
    { category = CategoryName; counter = "Application Lifetime Events/Sec"; instance = instance }
  /// Audit Failure Events Raised: Number of audit failures in the application since it was started.
  let ``Audit Failure Events Raised`` instance =
    { category = CategoryName; counter = "Audit Failure Events Raised"; instance = instance }
  /// Audit Success Events Raised: Number of audit successes in the application since it was started.
  let ``Audit Success Events Raised`` instance =
    { category = CategoryName; counter = "Audit Success Events Raised"; instance = instance }
  /// Cache % Machine Memory Limit Used: The amount of physical memory used by the machine divided by the physical memory limit for the cache, as a percentage.  When this reaches 100%, half of the cache entries will be forcibly removed.  The __Total__ instance is the average of all instances, and therefore cannot be used to determine when cache entries will be forcibly removed.
  let ``Cache % Machine Memory Limit Used`` instance =
    { category = CategoryName; counter = "Cache % Machine Memory Limit Used"; instance = instance }
  /// Cache % Machine Memory Limit Used Base: Cache % Machine Memory Limit Used Base
  let ``Cache % Machine Memory Limit Used Base`` instance =
    { category = CategoryName; counter = "Cache % Machine Memory Limit Used Base"; instance = instance }
  /// Cache % Process Memory Limit Used: The value of private bytes for the worker process divided by the private bytes memory limit for the cache, as a percentage.  When this reaches 100%, half of the cache entries will be forcibly removed.  The __Total__ instance is the average of all instances, and therefore cannot be used to determine when cache entries will be forcibly removed.
  let ``Cache % Process Memory Limit Used`` instance =
    { category = CategoryName; counter = "Cache % Process Memory Limit Used"; instance = instance }
  /// Cache % Process Memory Limit Used Base: Cache % Process Memory Limit Used Base
  let ``Cache % Process Memory Limit Used Base`` instance =
    { category = CategoryName; counter = "Cache % Process Memory Limit Used Base"; instance = instance }
  /// Cache API Entries: Total number of entries within the cache added by the user.
  let ``Cache API Entries`` instance =
    { category = CategoryName; counter = "Cache API Entries"; instance = instance }
  /// Cache API Hit Ratio: Ratio of hits called from user code.
  let ``Cache API Hit Ratio`` instance =
    { category = CategoryName; counter = "Cache API Hit Ratio"; instance = instance }
  /// Cache API Hit Ratio Base: Cache API Hit Ratio Base
  let ``Cache API Hit Ratio Base`` instance =
    { category = CategoryName; counter = "Cache API Hit Ratio Base"; instance = instance }
  /// Cache API Hits: Number of cache hits from user code.
  let ``Cache API Hits`` instance =
    { category = CategoryName; counter = "Cache API Hits"; instance = instance }
  /// Cache API Misses: Number of cache misses called from user code.
  let ``Cache API Misses`` instance =
    { category = CategoryName; counter = "Cache API Misses"; instance = instance }
  /// Cache API Trims: Total number of entries forcibly removed from the cache due to memory pressure that were originally inserted into the cache using one of the public cache APIs.
  let ``Cache API Trims`` instance =
    { category = CategoryName; counter = "Cache API Trims"; instance = instance }
  /// Cache API Turnover Rate: Number of additions and removals to the API cache per second.
  let ``Cache API Turnover Rate`` instance =
    { category = CategoryName; counter = "Cache API Turnover Rate"; instance = instance }
  /// Cache Total Entries: Total number of entries within the cache (both internal and user added)
  let ``Cache Total Entries`` instance =
    { category = CategoryName; counter = "Cache Total Entries"; instance = instance }
  /// Cache Total Hit Ratio: Ratio of hits from all cache calls.
  let ``Cache Total Hit Ratio`` instance =
    { category = CategoryName; counter = "Cache Total Hit Ratio"; instance = instance }
  /// Cache Total Hit Ratio Base: Cache Total Hit Ratio Base
  let ``Cache Total Hit Ratio Base`` instance =
    { category = CategoryName; counter = "Cache Total Hit Ratio Base"; instance = instance }
  /// Cache Total Hits: Total number of hits from the cache.
  let ``Cache Total Hits`` instance =
    { category = CategoryName; counter = "Cache Total Hits"; instance = instance }
  /// Cache Total Misses: Total number of cache misses.
  let ``Cache Total Misses`` instance =
    { category = CategoryName; counter = "Cache Total Misses"; instance = instance }
  /// Cache Total Trims: Total number of entries forcibly removed from the cache due to memory pressure.
  let ``Cache Total Trims`` instance =
    { category = CategoryName; counter = "Cache Total Trims"; instance = instance }
  /// Cache Total Turnover Rate: Number of additions and removals to the total cache per second.
  let ``Cache Total Turnover Rate`` instance =
    { category = CategoryName; counter = "Cache Total Turnover Rate"; instance = instance }
  /// Compilations Total: Number of .asax, .ascx, .ashx, .asmx, or .aspx source files dynamically compiled.
  let ``Compilations Total`` instance =
    { category = CategoryName; counter = "Compilations Total"; instance = instance }
  /// Debugging Requests: Number of debugging requests processed.
  let ``Debugging Requests`` instance =
    { category = CategoryName; counter = "Debugging Requests"; instance = instance }
  /// Error Events Raised: Number of error events raised since the application was started.
  let ``Error Events Raised`` instance =
    { category = CategoryName; counter = "Error Events Raised"; instance = instance }
  /// Error Events Raised/Sec: Number of error events per second.
  let ``Error Events Raised/Sec`` instance =
    { category = CategoryName; counter = "Error Events Raised/Sec"; instance = instance }
  /// Errors During Compilation: Number of errors that have occurred during compilation.
  let ``Errors During Compilation`` instance =
    { category = CategoryName; counter = "Errors During Compilation"; instance = instance }
  /// Errors During Execution: Number of errors that have occurred during the processing of a request.
  let ``Errors During Execution`` instance =
    { category = CategoryName; counter = "Errors During Execution"; instance = instance }
  /// Errors During Preprocessing: Number of errors that have occurred during parsing and configuration.
  let ``Errors During Preprocessing`` instance =
    { category = CategoryName; counter = "Errors During Preprocessing"; instance = instance }
  /// Errors Total: Total number of errors occurred.
  let ``Errors Total`` instance =
    { category = CategoryName; counter = "Errors Total"; instance = instance }
  /// Errors Total/Sec: Rate of errors occurred.
  let ``Errors Total/Sec`` instance =
    { category = CategoryName; counter = "Errors Total/Sec"; instance = instance }
  /// Errors Unhandled During Execution: Number of errors not handled by user code, but by the default error handler.
  let ``Errors Unhandled During Execution`` instance =
    { category = CategoryName; counter = "Errors Unhandled During Execution"; instance = instance }
  /// Errors Unhandled During Execution/Sec: Rate of unhandled errors.
  let ``Errors Unhandled During Execution/Sec`` instance =
    { category = CategoryName; counter = "Errors Unhandled During Execution/Sec"; instance = instance }
  /// Events Raised: Total number of instrumentation events raised since the application was started.
  let ``Events Raised`` instance =
    { category = CategoryName; counter = "Events Raised"; instance = instance }
  /// Events Raised/Sec: Total number of instrumentation events per second.
  let ``Events Raised/Sec`` instance =
    { category = CategoryName; counter = "Events Raised/Sec"; instance = instance }
  /// Forms Authentication Failure: Number of failed forms authentication ticket validations since the application was started.
  let ``Forms Authentication Failure`` instance =
    { category = CategoryName; counter = "Forms Authentication Failure"; instance = instance }
  /// Forms Authentication Success: Number of successful forms authentication ticket validations since the application was started.
  let ``Forms Authentication Success`` instance =
    { category = CategoryName; counter = "Forms Authentication Success"; instance = instance }
  /// Infrastructure Error Events Raised: Number of HTTP error events raised since the application was started.
  let ``Infrastructure Error Events Raised`` instance =
    { category = CategoryName; counter = "Infrastructure Error Events Raised"; instance = instance }
  /// Infrastructure Error Events Raised/Sec: Number of HTTP error events raised per second.
  let ``Infrastructure Error Events Raised/Sec`` instance =
    { category = CategoryName; counter = "Infrastructure Error Events Raised/Sec"; instance = instance }
  /// Membership Authentication Failure: Number of failed membership credential validations since the application was started.
  let ``Membership Authentication Failure`` instance =
    { category = CategoryName; counter = "Membership Authentication Failure"; instance = instance }
  /// Membership Authentication Success: Number of successful membership credential validations since the application was started.
  let ``Membership Authentication Success`` instance =
    { category = CategoryName; counter = "Membership Authentication Success"; instance = instance }
  /// Output Cache Entries: Current number of entries in the output cache.
  let ``Output Cache Entries`` instance =
    { category = CategoryName; counter = "Output Cache Entries"; instance = instance }
  /// Output Cache Hit Ratio: Ratio of hits to requests for output cacheable requests.
  let ``Output Cache Hit Ratio`` instance =
    { category = CategoryName; counter = "Output Cache Hit Ratio"; instance = instance }
  /// Output Cache Hit Ratio Base: Output Cache Hit Ratio Base
  let ``Output Cache Hit Ratio Base`` instance =
    { category = CategoryName; counter = "Output Cache Hit Ratio Base"; instance = instance }
  /// Output Cache Hits: Total number of output cacheable requests served from the output cache.
  let ``Output Cache Hits`` instance =
    { category = CategoryName; counter = "Output Cache Hits"; instance = instance }
  /// Output Cache Misses: Total number of output cacheable requests not served from the output cache.
  let ``Output Cache Misses`` instance =
    { category = CategoryName; counter = "Output Cache Misses"; instance = instance }
  /// Output Cache Trims: Total number of entries forcibly removed from the cache due to memory pressure that were originally inserted into the cache by the output cache feature.
  let ``Output Cache Trims`` instance =
    { category = CategoryName; counter = "Output Cache Trims"; instance = instance }
  /// Output Cache Turnover Rate: Number of additions and removals to the output cache per second.
  let ``Output Cache Turnover Rate`` instance =
    { category = CategoryName; counter = "Output Cache Turnover Rate"; instance = instance }
  /// Pipeline Instance Count: Number of active pipeline instances.
  let ``Pipeline Instance Count`` instance =
    { category = CategoryName; counter = "Pipeline Instance Count"; instance = instance }
  /// Request Bytes In Total: The total size, in bytes, of all requests.
  let ``Request Bytes In Total`` instance =
    { category = CategoryName; counter = "Request Bytes In Total"; instance = instance }
  /// Request Bytes Out Total: The total size, in bytes, of responses sent to a client.  This does not include standard HTTP response headers.
  let ``Request Bytes Out Total`` instance =
    { category = CategoryName; counter = "Request Bytes Out Total"; instance = instance }
  /// Request Error Events Raised: Number of runtime error events raised since the application was started.
  let ``Request Error Events Raised`` instance =
    { category = CategoryName; counter = "Request Error Events Raised"; instance = instance }
  /// Request Error Events Raised/Sec: Number of runtime error events per second.
  let ``Request Error Events Raised/Sec`` instance =
    { category = CategoryName; counter = "Request Error Events Raised/Sec"; instance = instance }
  /// Request Events Raised: Number of request events raised since the application was started
  let ``Request Events Raised`` instance =
    { category = CategoryName; counter = "Request Events Raised"; instance = instance }
  /// Request Events Raised/Sec: Number of request events raised per second.
  let ``Request Events Raised/Sec`` instance =
    { category = CategoryName; counter = "Request Events Raised/Sec"; instance = instance }
  /// Request Execution Time: The number of milliseconds that it took to execute the most recent request.
  let ``Request Execution Time`` instance =
    { category = CategoryName; counter = "Request Execution Time"; instance = instance }
  /// Request Wait Time: The number of milliseconds the most recent request was waiting in the queue.
  let ``Request Wait Time`` instance =
    { category = CategoryName; counter = "Request Wait Time"; instance = instance }
  /// Requests Disconnected: The number of requests disconnected due to communication errors or user terminated.
  let ``Requests Disconnected`` instance =
    { category = CategoryName; counter = "Requests Disconnected"; instance = instance }
  /// Requests Executing: The number of requests currently executing.
  let ``Requests Executing`` instance =
    { category = CategoryName; counter = "Requests Executing"; instance = instance }
  /// Requests Failed: Total number of failed requests.
  let ``Requests Failed`` instance =
    { category = CategoryName; counter = "Requests Failed"; instance = instance }
  /// Requests In Application Queue: The number of requests in the application request queue.
  let ``Requests In Application Queue`` instance =
    { category = CategoryName; counter = "Requests In Application Queue"; instance = instance }
  /// Requests Not Authorized: Number of requests failed due to unauthorized access.
  let ``Requests Not Authorized`` instance =
    { category = CategoryName; counter = "Requests Not Authorized"; instance = instance }
  /// Requests Not Found: The number of requests for resources that were not found.
  let ``Requests Not Found`` instance =
    { category = CategoryName; counter = "Requests Not Found"; instance = instance }
  /// Requests Rejected: The number of requests rejected because the application request queue was full.
  let ``Requests Rejected`` instance =
    { category = CategoryName; counter = "Requests Rejected"; instance = instance }
  /// Requests Succeeded: The number of requests that executed successfully.
  let ``Requests Succeeded`` instance =
    { category = CategoryName; counter = "Requests Succeeded"; instance = instance }
  /// Requests Timed Out: The number of requests that timed out.
  let ``Requests Timed Out`` instance =
    { category = CategoryName; counter = "Requests Timed Out"; instance = instance }
  /// Requests Total: The total number of requests since the application was started.
  let ``Requests Total`` instance =
    { category = CategoryName; counter = "Requests Total"; instance = instance }
  /// Requests/Sec: The number of requests executed per second.
  let ``Requests/Sec`` instance =
    { category = CategoryName; counter = "Requests/Sec"; instance = instance }
  /// Session SQL Server connections total: The total number of connections to the SQL Server used by session state.
  let ``Session SQL Server connections total`` instance =
    { category = CategoryName; counter = "Session SQL Server connections total"; instance = instance }
  /// Session State Server connections total: The total number of connections to the State Server used by session state.
  let ``Session State Server connections total`` instance =
    { category = CategoryName; counter = "Session State Server connections total"; instance = instance }
  /// Sessions Abandoned: The number of sessions that have been explicitly abandoned.
  let ``Sessions Abandoned`` instance =
    { category = CategoryName; counter = "Sessions Abandoned"; instance = instance }
  /// Sessions Active: The current number of sessions currently active.
  let ``Sessions Active`` instance =
    { category = CategoryName; counter = "Sessions Active"; instance = instance }
  /// Sessions Timed Out: The number of sessions timed out.
  let ``Sessions Timed Out`` instance =
    { category = CategoryName; counter = "Sessions Timed Out"; instance = instance }
  /// Sessions Total: Total number of sessions since the application was started.
  let ``Sessions Total`` instance =
    { category = CategoryName; counter = "Sessions Total"; instance = instance }
  /// Transactions Aborted: The number of transactions aborted.
  let ``Transactions Aborted`` instance =
    { category = CategoryName; counter = "Transactions Aborted"; instance = instance }
  /// Transactions Committed: The number of transactions committed.
  let ``Transactions Committed`` instance =
    { category = CategoryName; counter = "Transactions Committed"; instance = instance }
  /// Transactions Pending: Number of transactions in progress.
  let ``Transactions Pending`` instance =
    { category = CategoryName; counter = "Transactions Pending"; instance = instance }
  /// Transactions Total: The total number of transactions since the application was started.
  let ``Transactions Total`` instance =
    { category = CategoryName; counter = "Transactions Total"; instance = instance }
  /// Transactions/Sec: Transactions started per second.
  let ``Transactions/Sec`` instance =
    { category = CategoryName; counter = "Transactions/Sec"; instance = instance }
  /// Viewstate MAC Validation Failure: Number of viewstate MAC validations that failed since the application was started.
  let ``Viewstate MAC Validation Failure`` instance =
    { category = CategoryName; counter = "Viewstate MAC Validation Failure"; instance = instance }

  let allCounters =
    [| ``Anonymous Requests``
       ``Anonymous Requests/Sec``
       ``Application Lifetime Events``
       ``Application Lifetime Events/Sec``
       ``Audit Failure Events Raised``
       ``Audit Success Events Raised``
       ``Cache % Machine Memory Limit Used``
       ``Cache % Machine Memory Limit Used Base``
       ``Cache % Process Memory Limit Used``
       ``Cache % Process Memory Limit Used Base``
       ``Cache API Entries``
       ``Cache API Hit Ratio``
       ``Cache API Hit Ratio Base``
       ``Cache API Hits``
       ``Cache API Misses``
       ``Cache API Trims``
       ``Cache API Turnover Rate``
       ``Cache Total Entries``
       ``Cache Total Hit Ratio``
       ``Cache Total Hit Ratio Base``
       ``Cache Total Hits``
       ``Cache Total Misses``
       ``Cache Total Trims``
       ``Cache Total Turnover Rate``
       ``Compilations Total``
       ``Debugging Requests``
       ``Error Events Raised``
       ``Error Events Raised/Sec``
       ``Errors During Compilation``
       ``Errors During Execution``
       ``Errors During Preprocessing``
       ``Errors Total``
       ``Errors Total/Sec``
       ``Errors Unhandled During Execution``
       ``Errors Unhandled During Execution/Sec``
       ``Events Raised``
       ``Events Raised/Sec``
       ``Forms Authentication Failure``
       ``Forms Authentication Success``
       ``Infrastructure Error Events Raised``
       ``Infrastructure Error Events Raised/Sec``
       ``Membership Authentication Failure``
       ``Membership Authentication Success``
       ``Output Cache Entries``
       ``Output Cache Hit Ratio``
       ``Output Cache Hit Ratio Base``
       ``Output Cache Hits``
       ``Output Cache Misses``
       ``Output Cache Trims``
       ``Output Cache Turnover Rate``
       ``Pipeline Instance Count``
       ``Request Bytes In Total``
       ``Request Bytes Out Total``
       ``Request Error Events Raised``
       ``Request Error Events Raised/Sec``
       ``Request Events Raised``
       ``Request Events Raised/Sec``
       ``Request Execution Time``
       ``Request Wait Time``
       ``Requests Disconnected``
       ``Requests Executing``
       ``Requests Failed``
       ``Requests In Application Queue``
       ``Requests Not Authorized``
       ``Requests Not Found``
       ``Requests Rejected``
       ``Requests Succeeded``
       ``Requests Timed Out``
       ``Requests Total``
       ``Requests/Sec``
       ``Session SQL Server connections total``
       ``Session State Server connections total``
       ``Sessions Abandoned``
       ``Sessions Active``
       ``Sessions Timed Out``
       ``Sessions Total``
       ``Transactions Aborted``
       ``Transactions Committed``
       ``Transactions Pending``
       ``Transactions Total``
       ``Transactions/Sec``
       ``Viewstate MAC Validation Failure``
    |]

/// ASP.NET Apps v4.0.30319: ASP.NET application performance counters
///
/// This performance counter does not have non-instance based counters
module ``ASP_NET Apps v4_0_30319`` =

  [<Literal>]
  let CategoryName = "ASP.NET Apps v4.0.30319"

  let PCC = Category.create CategoryName
  /// % Managed Processor Time (estimated): Estimated percentage of elapsed time that the processor spends executing managed application code.  This counter only tracks processor time of managed threads in the application.  It does not include additional processor time spent executing on non-managed threads.  Note that this counter is only updated with new data every five seconds.
  let ``% Managed Processor Time (estimated)`` instance =
    { category = CategoryName; counter = "% Managed Processor Time (estimated)"; instance = instance }
  /// % Managed Processor Time Base (estimated): % Managed Processor Time Base (estimated)
  let ``% Managed Processor Time Base (estimated)`` instance =
    { category = CategoryName; counter = "% Managed Processor Time Base (estimated)"; instance = instance }
  /// Anonymous Requests: Number of requests utilizing anonymous authentication.
  let ``Anonymous Requests`` instance =
    { category = CategoryName; counter = "Anonymous Requests"; instance = instance }
  /// Anonymous Requests/Sec: Number of Authentication Anonymous Requests/Sec
  let ``Anonymous Requests/Sec`` instance =
    { category = CategoryName; counter = "Anonymous Requests/Sec"; instance = instance }
  /// Application Lifetime Events: Number of application events raised since the application was started.
  let ``Application Lifetime Events`` instance =
    { category = CategoryName; counter = "Application Lifetime Events"; instance = instance }
  /// Application Lifetime Events/Sec: Number of application events raised per second.
  let ``Application Lifetime Events/Sec`` instance =
    { category = CategoryName; counter = "Application Lifetime Events/Sec"; instance = instance }
  /// Audit Failure Events Raised: Number of audit failures in the application since it was started.
  let ``Audit Failure Events Raised`` instance =
    { category = CategoryName; counter = "Audit Failure Events Raised"; instance = instance }
  /// Audit Success Events Raised: Number of audit successes in the application since it was started.
  let ``Audit Success Events Raised`` instance =
    { category = CategoryName; counter = "Audit Success Events Raised"; instance = instance }
  /// Cache % Machine Memory Limit Used: The amount of physical memory used by the machine divided by the physical memory limit for the cache, as a percentage.  When this reaches 100%, half of the cache entries will be forcibly removed.  The __Total__ instance is the average of all instances, and therefore cannot be used to determine when cache entries will be forcibly removed.
  let ``Cache % Machine Memory Limit Used`` instance =
    { category = CategoryName; counter = "Cache % Machine Memory Limit Used"; instance = instance }
  /// Cache % Machine Memory Limit Used Base: Cache % Machine Memory Limit Used Base
  let ``Cache % Machine Memory Limit Used Base`` instance =
    { category = CategoryName; counter = "Cache % Machine Memory Limit Used Base"; instance = instance }
  /// Cache % Process Memory Limit Used: The value of private bytes for the worker process divided by the private bytes memory limit for the cache, as a percentage.  When this reaches 100%, half of the cache entries will be forcibly removed.  The __Total__ instance is the average of all instances, and therefore cannot be used to determine when cache entries will be forcibly removed.
  let ``Cache % Process Memory Limit Used`` instance =
    { category = CategoryName; counter = "Cache % Process Memory Limit Used"; instance = instance }
  /// Cache % Process Memory Limit Used Base: Cache % Process Memory Limit Used Base
  let ``Cache % Process Memory Limit Used Base`` instance =
    { category = CategoryName; counter = "Cache % Process Memory Limit Used Base"; instance = instance }
  /// Cache API Entries: Total number of entries within the cache added by the user.
  let ``Cache API Entries`` instance =
    { category = CategoryName; counter = "Cache API Entries"; instance = instance }
  /// Cache API Hit Ratio: Ratio of hits called from user code.
  let ``Cache API Hit Ratio`` instance =
    { category = CategoryName; counter = "Cache API Hit Ratio"; instance = instance }
  /// Cache API Hit Ratio Base: Cache API Hit Ratio Base
  let ``Cache API Hit Ratio Base`` instance =
    { category = CategoryName; counter = "Cache API Hit Ratio Base"; instance = instance }
  /// Cache API Hits: Number of cache hits from user code.
  let ``Cache API Hits`` instance =
    { category = CategoryName; counter = "Cache API Hits"; instance = instance }
  /// Cache API Misses: Number of cache misses called from user code.
  let ``Cache API Misses`` instance =
    { category = CategoryName; counter = "Cache API Misses"; instance = instance }
  /// Cache API Trims: Total number of entries forcibly removed from the cache due to memory pressure that were originally inserted into the cache using one of the public cache APIs.
  let ``Cache API Trims`` instance =
    { category = CategoryName; counter = "Cache API Trims"; instance = instance }
  /// Cache API Turnover Rate: Number of additions and removals to the API cache per second.
  let ``Cache API Turnover Rate`` instance =
    { category = CategoryName; counter = "Cache API Turnover Rate"; instance = instance }
  /// Cache Total Entries: Total number of entries within the cache (both internal and user added)
  let ``Cache Total Entries`` instance =
    { category = CategoryName; counter = "Cache Total Entries"; instance = instance }
  /// Cache Total Hit Ratio: Ratio of hits from all cache calls.
  let ``Cache Total Hit Ratio`` instance =
    { category = CategoryName; counter = "Cache Total Hit Ratio"; instance = instance }
  /// Cache Total Hit Ratio Base: Cache Total Hit Ratio Base
  let ``Cache Total Hit Ratio Base`` instance =
    { category = CategoryName; counter = "Cache Total Hit Ratio Base"; instance = instance }
  /// Cache Total Hits: Total number of hits from the cache.
  let ``Cache Total Hits`` instance =
    { category = CategoryName; counter = "Cache Total Hits"; instance = instance }
  /// Cache Total Misses: Total number of cache misses.
  let ``Cache Total Misses`` instance =
    { category = CategoryName; counter = "Cache Total Misses"; instance = instance }
  /// Cache Total Trims: Total number of entries forcibly removed from the cache due to memory pressure.
  let ``Cache Total Trims`` instance =
    { category = CategoryName; counter = "Cache Total Trims"; instance = instance }
  /// Cache Total Turnover Rate: Number of additions and removals to the total cache per second.
  let ``Cache Total Turnover Rate`` instance =
    { category = CategoryName; counter = "Cache Total Turnover Rate"; instance = instance }
  /// Compilations Total: Number of .asax, .ascx, .ashx, .asmx, or .aspx source files dynamically compiled.
  let ``Compilations Total`` instance =
    { category = CategoryName; counter = "Compilations Total"; instance = instance }
  /// Debugging Requests: Number of debugging requests processed.
  let ``Debugging Requests`` instance =
    { category = CategoryName; counter = "Debugging Requests"; instance = instance }
  /// Error Events Raised: Number of error events raised since the application was started.
  let ``Error Events Raised`` instance =
    { category = CategoryName; counter = "Error Events Raised"; instance = instance }
  /// Error Events Raised/Sec: Number of error events per second.
  let ``Error Events Raised/Sec`` instance =
    { category = CategoryName; counter = "Error Events Raised/Sec"; instance = instance }
  /// Errors During Compilation: Number of errors that have occurred during compilation.
  let ``Errors During Compilation`` instance =
    { category = CategoryName; counter = "Errors During Compilation"; instance = instance }
  /// Errors During Execution: Number of errors that have occurred during the processing of a request.
  let ``Errors During Execution`` instance =
    { category = CategoryName; counter = "Errors During Execution"; instance = instance }
  /// Errors During Preprocessing: Number of errors that have occurred during parsing and configuration.
  let ``Errors During Preprocessing`` instance =
    { category = CategoryName; counter = "Errors During Preprocessing"; instance = instance }
  /// Errors Total: Total number of errors occurred.
  let ``Errors Total`` instance =
    { category = CategoryName; counter = "Errors Total"; instance = instance }
  /// Errors Total/Sec: Rate of errors occurred.
  let ``Errors Total/Sec`` instance =
    { category = CategoryName; counter = "Errors Total/Sec"; instance = instance }
  /// Errors Unhandled During Execution: Number of errors not handled by user code, but by the default error handler.
  let ``Errors Unhandled During Execution`` instance =
    { category = CategoryName; counter = "Errors Unhandled During Execution"; instance = instance }
  /// Errors Unhandled During Execution/Sec: Rate of unhandled errors.
  let ``Errors Unhandled During Execution/Sec`` instance =
    { category = CategoryName; counter = "Errors Unhandled During Execution/Sec"; instance = instance }
  /// Events Raised: Total number of instrumentation events raised since the application was started.
  let ``Events Raised`` instance =
    { category = CategoryName; counter = "Events Raised"; instance = instance }
  /// Events Raised/Sec: Total number of instrumentation events per second.
  let ``Events Raised/Sec`` instance =
    { category = CategoryName; counter = "Events Raised/Sec"; instance = instance }
  /// Forms Authentication Failure: Number of failed forms authentication ticket validations since the application was started.
  let ``Forms Authentication Failure`` instance =
    { category = CategoryName; counter = "Forms Authentication Failure"; instance = instance }
  /// Forms Authentication Success: Number of successful forms authentication ticket validations since the application was started.
  let ``Forms Authentication Success`` instance =
    { category = CategoryName; counter = "Forms Authentication Success"; instance = instance }
  /// Infrastructure Error Events Raised: Number of HTTP error events raised since the application was started.
  let ``Infrastructure Error Events Raised`` instance =
    { category = CategoryName; counter = "Infrastructure Error Events Raised"; instance = instance }
  /// Infrastructure Error Events Raised/Sec: Number of HTTP error events raised per second.
  let ``Infrastructure Error Events Raised/Sec`` instance =
    { category = CategoryName; counter = "Infrastructure Error Events Raised/Sec"; instance = instance }
  /// Managed Memory Used (estimated): Estimated managed heap memory consumption (in KB) by the application.  The accuracy of this counter varies depending on the duration of elapsed time since the last full managed memory heap collection.  Note that this counter is only updated with new data every five seconds.
  let ``Managed Memory Used (estimated)`` instance =
    { category = CategoryName; counter = "Managed Memory Used (estimated)"; instance = instance }
  /// Membership Authentication Failure: Number of failed membership credential validations since the application was started.
  let ``Membership Authentication Failure`` instance =
    { category = CategoryName; counter = "Membership Authentication Failure"; instance = instance }
  /// Membership Authentication Success: Number of successful membership credential validations since the application was started.
  let ``Membership Authentication Success`` instance =
    { category = CategoryName; counter = "Membership Authentication Success"; instance = instance }
  /// Output Cache Entries: Current number of entries in the output cache.
  let ``Output Cache Entries`` instance =
    { category = CategoryName; counter = "Output Cache Entries"; instance = instance }
  /// Output Cache Hit Ratio: Ratio of hits to requests for output cacheable requests.
  let ``Output Cache Hit Ratio`` instance =
    { category = CategoryName; counter = "Output Cache Hit Ratio"; instance = instance }
  /// Output Cache Hit Ratio Base: Output Cache Hit Ratio Base
  let ``Output Cache Hit Ratio Base`` instance =
    { category = CategoryName; counter = "Output Cache Hit Ratio Base"; instance = instance }
  /// Output Cache Hits: Total number of output cacheable requests served from the output cache.
  let ``Output Cache Hits`` instance =
    { category = CategoryName; counter = "Output Cache Hits"; instance = instance }
  /// Output Cache Misses: Total number of output cacheable requests not served from the output cache.
  let ``Output Cache Misses`` instance =
    { category = CategoryName; counter = "Output Cache Misses"; instance = instance }
  /// Output Cache Trims: Total number of entries forcibly removed from the cache due to memory pressure that were originally inserted into the cache by the output cache feature.
  let ``Output Cache Trims`` instance =
    { category = CategoryName; counter = "Output Cache Trims"; instance = instance }
  /// Output Cache Turnover Rate: Number of additions and removals to the output cache per second.
  let ``Output Cache Turnover Rate`` instance =
    { category = CategoryName; counter = "Output Cache Turnover Rate"; instance = instance }
  /// Pipeline Instance Count: Number of active pipeline instances.
  let ``Pipeline Instance Count`` instance =
    { category = CategoryName; counter = "Pipeline Instance Count"; instance = instance }
  /// Request Bytes In Total: The total size, in bytes, of all requests.
  let ``Request Bytes In Total`` instance =
    { category = CategoryName; counter = "Request Bytes In Total"; instance = instance }
  /// Request Bytes In Total (WebSockets): The total size, in bytes, of data received by ASP.NET on WebSocket connections.
  let ``Request Bytes In Total (WebSockets)`` instance =
    { category = CategoryName; counter = "Request Bytes In Total (WebSockets)"; instance = instance }
  /// Request Bytes Out Total: The total size, in bytes, of responses sent to a client.  This does not include standard HTTP response headers.
  let ``Request Bytes Out Total`` instance =
    { category = CategoryName; counter = "Request Bytes Out Total"; instance = instance }
  /// Request Bytes Out Total (WebSockets): The total size, in bytes, of data sent to a client on WebSocket connections.
  let ``Request Bytes Out Total (WebSockets)`` instance =
    { category = CategoryName; counter = "Request Bytes Out Total (WebSockets)"; instance = instance }
  /// Request Error Events Raised: Number of runtime error events raised since the application was started.
  let ``Request Error Events Raised`` instance =
    { category = CategoryName; counter = "Request Error Events Raised"; instance = instance }
  /// Request Error Events Raised/Sec: Number of runtime error events per second.
  let ``Request Error Events Raised/Sec`` instance =
    { category = CategoryName; counter = "Request Error Events Raised/Sec"; instance = instance }
  /// Request Events Raised: Number of request events raised since the application was started
  let ``Request Events Raised`` instance =
    { category = CategoryName; counter = "Request Events Raised"; instance = instance }
  /// Request Events Raised/Sec: Number of request events raised per second.
  let ``Request Events Raised/Sec`` instance =
    { category = CategoryName; counter = "Request Events Raised/Sec"; instance = instance }
  /// Request Execution Time: The number of milliseconds that it took to execute the most recent request.
  let ``Request Execution Time`` instance =
    { category = CategoryName; counter = "Request Execution Time"; instance = instance }
  /// Request Wait Time: The number of milliseconds the most recent request was waiting in the queue.
  let ``Request Wait Time`` instance =
    { category = CategoryName; counter = "Request Wait Time"; instance = instance }
  /// Requests Disconnected: The number of requests disconnected due to communication errors or user terminated.
  let ``Requests Disconnected`` instance =
    { category = CategoryName; counter = "Requests Disconnected"; instance = instance }
  /// Requests Executing: The number of requests currently executing.
  let ``Requests Executing`` instance =
    { category = CategoryName; counter = "Requests Executing"; instance = instance }
  /// Requests Executing (WebSockets): The number of WebSocket requests currently executing.
  let ``Requests Executing (WebSockets)`` instance =
    { category = CategoryName; counter = "Requests Executing (WebSockets)"; instance = instance }
  /// Requests Failed: Total number of failed requests.
  let ``Requests Failed`` instance =
    { category = CategoryName; counter = "Requests Failed"; instance = instance }
  /// Requests Failed (WebSockets): Total number of WebSocket requests that ended up in an aborted state.
  let ``Requests Failed (WebSockets)`` instance =
    { category = CategoryName; counter = "Requests Failed (WebSockets)"; instance = instance }
  /// Requests In Application Queue: The number of requests in the application request queue.
  let ``Requests In Application Queue`` instance =
    { category = CategoryName; counter = "Requests In Application Queue"; instance = instance }
  /// Requests Not Authorized: Number of requests failed due to unauthorized access.
  let ``Requests Not Authorized`` instance =
    { category = CategoryName; counter = "Requests Not Authorized"; instance = instance }
  /// Requests Not Found: The number of requests for resources that were not found.
  let ``Requests Not Found`` instance =
    { category = CategoryName; counter = "Requests Not Found"; instance = instance }
  /// Requests Rejected: The number of requests rejected because the application request queue was full.
  let ``Requests Rejected`` instance =
    { category = CategoryName; counter = "Requests Rejected"; instance = instance }
  /// Requests Succeeded: The number of requests that executed successfully.
  let ``Requests Succeeded`` instance =
    { category = CategoryName; counter = "Requests Succeeded"; instance = instance }
  /// Requests Succeeded (WebSockets): Total number of WebSocket requests that completed gracefully.
  let ``Requests Succeeded (WebSockets)`` instance =
    { category = CategoryName; counter = "Requests Succeeded (WebSockets)"; instance = instance }
  /// Requests Timed Out: The number of requests that timed out.
  let ``Requests Timed Out`` instance =
    { category = CategoryName; counter = "Requests Timed Out"; instance = instance }
  /// Requests Total: The total number of requests since the application was started.
  let ``Requests Total`` instance =
    { category = CategoryName; counter = "Requests Total"; instance = instance }
  /// Requests Total (WebSockets): The total number of WebSocket requests since the application was started.
  let ``Requests Total (WebSockets)`` instance =
    { category = CategoryName; counter = "Requests Total (WebSockets)"; instance = instance }
  /// Requests/Sec: The number of requests executed per second.
  let ``Requests/Sec`` instance =
    { category = CategoryName; counter = "Requests/Sec"; instance = instance }
  /// Session SQL Server connections total: The total number of connections to the SQL Server used by session state.
  let ``Session SQL Server connections total`` instance =
    { category = CategoryName; counter = "Session SQL Server connections total"; instance = instance }
  /// Session State Server connections total: The total number of connections to the State Server used by session state.
  let ``Session State Server connections total`` instance =
    { category = CategoryName; counter = "Session State Server connections total"; instance = instance }
  /// Sessions Abandoned: The number of sessions that have been explicitly abandoned.
  let ``Sessions Abandoned`` instance =
    { category = CategoryName; counter = "Sessions Abandoned"; instance = instance }
  /// Sessions Active: The current number of sessions currently active.
  let ``Sessions Active`` instance =
    { category = CategoryName; counter = "Sessions Active"; instance = instance }
  /// Sessions Timed Out: The number of sessions timed out.
  let ``Sessions Timed Out`` instance =
    { category = CategoryName; counter = "Sessions Timed Out"; instance = instance }
  /// Sessions Total: Total number of sessions since the application was started.
  let ``Sessions Total`` instance =
    { category = CategoryName; counter = "Sessions Total"; instance = instance }
  /// Transactions Aborted: The number of transactions aborted.
  let ``Transactions Aborted`` instance =
    { category = CategoryName; counter = "Transactions Aborted"; instance = instance }
  /// Transactions Committed: The number of transactions committed.
  let ``Transactions Committed`` instance =
    { category = CategoryName; counter = "Transactions Committed"; instance = instance }
  /// Transactions Pending: Number of transactions in progress.
  let ``Transactions Pending`` instance =
    { category = CategoryName; counter = "Transactions Pending"; instance = instance }
  /// Transactions Total: The total number of transactions since the application was started.
  let ``Transactions Total`` instance =
    { category = CategoryName; counter = "Transactions Total"; instance = instance }
  /// Transactions/Sec: Transactions started per second.
  let ``Transactions/Sec`` instance =
    { category = CategoryName; counter = "Transactions/Sec"; instance = instance }
  /// Viewstate MAC Validation Failure: Number of viewstate MAC validations that failed since the application was started.
  let ``Viewstate MAC Validation Failure`` instance =
    { category = CategoryName; counter = "Viewstate MAC Validation Failure"; instance = instance }

  let allCounters =
    [| ``% Managed Processor Time (estimated)``
       ``% Managed Processor Time Base (estimated)``
       ``Anonymous Requests``
       ``Anonymous Requests/Sec``
       ``Application Lifetime Events``
       ``Application Lifetime Events/Sec``
       ``Audit Failure Events Raised``
       ``Audit Success Events Raised``
       ``Cache % Machine Memory Limit Used``
       ``Cache % Machine Memory Limit Used Base``
       ``Cache % Process Memory Limit Used``
       ``Cache % Process Memory Limit Used Base``
       ``Cache API Entries``
       ``Cache API Hit Ratio``
       ``Cache API Hit Ratio Base``
       ``Cache API Hits``
       ``Cache API Misses``
       ``Cache API Trims``
       ``Cache API Turnover Rate``
       ``Cache Total Entries``
       ``Cache Total Hit Ratio``
       ``Cache Total Hit Ratio Base``
       ``Cache Total Hits``
       ``Cache Total Misses``
       ``Cache Total Trims``
       ``Cache Total Turnover Rate``
       ``Compilations Total``
       ``Debugging Requests``
       ``Error Events Raised``
       ``Error Events Raised/Sec``
       ``Errors During Compilation``
       ``Errors During Execution``
       ``Errors During Preprocessing``
       ``Errors Total``
       ``Errors Total/Sec``
       ``Errors Unhandled During Execution``
       ``Errors Unhandled During Execution/Sec``
       ``Events Raised``
       ``Events Raised/Sec``
       ``Forms Authentication Failure``
       ``Forms Authentication Success``
       ``Infrastructure Error Events Raised``
       ``Infrastructure Error Events Raised/Sec``
       ``Managed Memory Used (estimated)``
       ``Membership Authentication Failure``
       ``Membership Authentication Success``
       ``Output Cache Entries``
       ``Output Cache Hit Ratio``
       ``Output Cache Hit Ratio Base``
       ``Output Cache Hits``
       ``Output Cache Misses``
       ``Output Cache Trims``
       ``Output Cache Turnover Rate``
       ``Pipeline Instance Count``
       ``Request Bytes In Total``
       ``Request Bytes In Total (WebSockets)``
       ``Request Bytes Out Total``
       ``Request Bytes Out Total (WebSockets)``
       ``Request Error Events Raised``
       ``Request Error Events Raised/Sec``
       ``Request Events Raised``
       ``Request Events Raised/Sec``
       ``Request Execution Time``
       ``Request Wait Time``
       ``Requests Disconnected``
       ``Requests Executing``
       ``Requests Executing (WebSockets)``
       ``Requests Failed``
       ``Requests Failed (WebSockets)``
       ``Requests In Application Queue``
       ``Requests Not Authorized``
       ``Requests Not Found``
       ``Requests Rejected``
       ``Requests Succeeded``
       ``Requests Succeeded (WebSockets)``
       ``Requests Timed Out``
       ``Requests Total``
       ``Requests Total (WebSockets)``
       ``Requests/Sec``
       ``Session SQL Server connections total``
       ``Session State Server connections total``
       ``Sessions Abandoned``
       ``Sessions Active``
       ``Sessions Timed Out``
       ``Sessions Total``
       ``Transactions Aborted``
       ``Transactions Committed``
       ``Transactions Pending``
       ``Transactions Total``
       ``Transactions/Sec``
       ``Viewstate MAC Validation Failure``
    |]

/// ASP.NET State Service: ASP.NET State Service
///
/// This performance counter does not have instance based counters
module ``ASP_NET State Service`` =

  [<Literal>]
  let CategoryName = "ASP.NET State Service"

  let PCC = Category.create CategoryName
  /// State Server Sessions Abandoned: The number of sessions that have been explicitly abandoned.
  let ``State Server Sessions Abandoned`` =
    { category = CategoryName; counter = "State Server Sessions Abandoned"; instance = None }
  /// State Server Sessions Active: The current number of sessions currently active.
  let ``State Server Sessions Active`` =
    { category = CategoryName; counter = "State Server Sessions Active"; instance = None }
  /// State Server Sessions Timed Out: The number of sessions timed out.
  let ``State Server Sessions Timed Out`` =
    { category = CategoryName; counter = "State Server Sessions Timed Out"; instance = None }
  /// State Server Sessions Total: The number of sessions total.
  let ``State Server Sessions Total`` =
    { category = CategoryName; counter = "State Server Sessions Total"; instance = None }

  let allCounters =
    [| ``State Server Sessions Abandoned``
       ``State Server Sessions Active``
       ``State Server Sessions Timed Out``
       ``State Server Sessions Total``
    |]

/// ASP.NET v2.0.50727: ASP.NET global performance counters
///
/// This performance counter does not have instance based counters
module ``ASP_NET v2_0_50727`` =

  [<Literal>]
  let CategoryName = "ASP.NET v2.0.50727"

  let PCC = Category.create CategoryName
  /// Application Restarts: Number of times the application has been restarted during the web server's lifetime.
  let ``Application Restarts`` =
    { category = CategoryName; counter = "Application Restarts"; instance = None }
  /// Applications Running: Number of currently running web applications.
  let ``Applications Running`` =
    { category = CategoryName; counter = "Applications Running"; instance = None }
  /// Audit Failure Events Raised: Number of audit failures in the application since it was started.
  let ``Audit Failure Events Raised`` =
    { category = CategoryName; counter = "Audit Failure Events Raised"; instance = None }
  /// Audit Success Events Raised: Number of audit successes in the application since it was started.
  let ``Audit Success Events Raised`` =
    { category = CategoryName; counter = "Audit Success Events Raised"; instance = None }
  /// Error Events Raised: Number of error events raised since the application was started.
  let ``Error Events Raised`` =
    { category = CategoryName; counter = "Error Events Raised"; instance = None }
  /// Infrastructure Error Events Raised: Number of HTTP error events raised since the application was started.
  let ``Infrastructure Error Events Raised`` =
    { category = CategoryName; counter = "Infrastructure Error Events Raised"; instance = None }
  /// Request Error Events Raised: Number of runtime error events raised since the application was started.
  let ``Request Error Events Raised`` =
    { category = CategoryName; counter = "Request Error Events Raised"; instance = None }
  /// Request Execution Time: The number of milliseconds that it took to execute the most recent request.
  let ``Request Execution Time`` =
    { category = CategoryName; counter = "Request Execution Time"; instance = None }
  /// Request Wait Time: The number of milliseconds the most recent request was waiting in the queue.
  let ``Request Wait Time`` =
    { category = CategoryName; counter = "Request Wait Time"; instance = None }
  /// Requests Current: The current number of requests, including those that are queued, currently executing, or waiting to be written to the client.  Under the ASP.NET process model, when this counter exceeds the requestQueueLimit defined in the processModel configuration section, ASP.NET will begin rejecting requests.
  let ``Requests Current`` =
    { category = CategoryName; counter = "Requests Current"; instance = None }
  /// Requests Disconnected: The number of requests disconnected due to communication errors or user terminated.
  let ``Requests Disconnected`` =
    { category = CategoryName; counter = "Requests Disconnected"; instance = None }
  /// Requests Queued: The number of requests waiting to be processed.
  let ``Requests Queued`` =
    { category = CategoryName; counter = "Requests Queued"; instance = None }
  /// Requests Rejected: The number of requests rejected because the request queue was full.
  let ``Requests Rejected`` =
    { category = CategoryName; counter = "Requests Rejected"; instance = None }
  /// State Server Sessions Abandoned: The number of sessions that have been explicitly abandoned.
  let ``State Server Sessions Abandoned`` =
    { category = CategoryName; counter = "State Server Sessions Abandoned"; instance = None }
  /// State Server Sessions Active: The current number of sessions currently active.
  let ``State Server Sessions Active`` =
    { category = CategoryName; counter = "State Server Sessions Active"; instance = None }
  /// State Server Sessions Timed Out: The number of sessions timed out.
  let ``State Server Sessions Timed Out`` =
    { category = CategoryName; counter = "State Server Sessions Timed Out"; instance = None }
  /// State Server Sessions Total: The number of sessions total.
  let ``State Server Sessions Total`` =
    { category = CategoryName; counter = "State Server Sessions Total"; instance = None }
  /// Worker Process Restarts: Number of times a worker process has restarted on the machine.
  let ``Worker Process Restarts`` =
    { category = CategoryName; counter = "Worker Process Restarts"; instance = None }
  /// Worker Processes Running: Number of worker processes running on the machine.
  let ``Worker Processes Running`` =
    { category = CategoryName; counter = "Worker Processes Running"; instance = None }

  let allCounters =
    [| ``Application Restarts``
       ``Applications Running``
       ``Audit Failure Events Raised``
       ``Audit Success Events Raised``
       ``Error Events Raised``
       ``Infrastructure Error Events Raised``
       ``Request Error Events Raised``
       ``Request Execution Time``
       ``Request Wait Time``
       ``Requests Current``
       ``Requests Disconnected``
       ``Requests Queued``
       ``Requests Rejected``
       ``State Server Sessions Abandoned``
       ``State Server Sessions Active``
       ``State Server Sessions Timed Out``
       ``State Server Sessions Total``
       ``Worker Process Restarts``
       ``Worker Processes Running``
    |]

/// ASP.NET v4.0.30319: ASP.NET global performance counters
///
/// This performance counter does not have instance based counters
module ``ASP_NET v4_0_30319`` =

  [<Literal>]
  let CategoryName = "ASP.NET v4.0.30319"

  let PCC = Category.create CategoryName
  /// Application Restarts: Number of times the application has been restarted during the web server's lifetime.
  let ``Application Restarts`` =
    { category = CategoryName; counter = "Application Restarts"; instance = None }
  /// Applications Running: Number of currently running web applications.
  let ``Applications Running`` =
    { category = CategoryName; counter = "Applications Running"; instance = None }
  /// Audit Failure Events Raised: Number of audit failures in the application since it was started.
  let ``Audit Failure Events Raised`` =
    { category = CategoryName; counter = "Audit Failure Events Raised"; instance = None }
  /// Audit Success Events Raised: Number of audit successes in the application since it was started.
  let ``Audit Success Events Raised`` =
    { category = CategoryName; counter = "Audit Success Events Raised"; instance = None }
  /// Error Events Raised: Number of error events raised since the application was started.
  let ``Error Events Raised`` =
    { category = CategoryName; counter = "Error Events Raised"; instance = None }
  /// Infrastructure Error Events Raised: Number of HTTP error events raised since the application was started.
  let ``Infrastructure Error Events Raised`` =
    { category = CategoryName; counter = "Infrastructure Error Events Raised"; instance = None }
  /// Request Error Events Raised: Number of runtime error events raised since the application was started.
  let ``Request Error Events Raised`` =
    { category = CategoryName; counter = "Request Error Events Raised"; instance = None }
  /// Request Execution Time: The number of milliseconds that it took to execute the most recent request.
  let ``Request Execution Time`` =
    { category = CategoryName; counter = "Request Execution Time"; instance = None }
  /// Request Wait Time: The number of milliseconds the most recent request was waiting in the queue.
  let ``Request Wait Time`` =
    { category = CategoryName; counter = "Request Wait Time"; instance = None }
  /// Requests Current: The current number of requests, including those that are queued, currently executing, or waiting to be written to the client.  Under the ASP.NET process model, when this counter exceeds the requestQueueLimit defined in the processModel configuration section, ASP.NET will begin rejecting requests.
  let ``Requests Current`` =
    { category = CategoryName; counter = "Requests Current"; instance = None }
  /// Requests Disconnected: The number of requests disconnected due to communication errors or user terminated.
  let ``Requests Disconnected`` =
    { category = CategoryName; counter = "Requests Disconnected"; instance = None }
  /// Requests In Native Queue: Requests queued because the concurrency limits have been exceeded.
  let ``Requests In Native Queue`` =
    { category = CategoryName; counter = "Requests In Native Queue"; instance = None }
  /// Requests Queued: The number of requests waiting to be processed.
  let ``Requests Queued`` =
    { category = CategoryName; counter = "Requests Queued"; instance = None }
  /// Requests Rejected: The number of requests rejected because the request queue was full.
  let ``Requests Rejected`` =
    { category = CategoryName; counter = "Requests Rejected"; instance = None }
  /// State Server Sessions Abandoned: The number of sessions that have been explicitly abandoned.
  let ``State Server Sessions Abandoned`` =
    { category = CategoryName; counter = "State Server Sessions Abandoned"; instance = None }
  /// State Server Sessions Active: The current number of sessions currently active.
  let ``State Server Sessions Active`` =
    { category = CategoryName; counter = "State Server Sessions Active"; instance = None }
  /// State Server Sessions Timed Out: The number of sessions timed out.
  let ``State Server Sessions Timed Out`` =
    { category = CategoryName; counter = "State Server Sessions Timed Out"; instance = None }
  /// State Server Sessions Total: The number of sessions total.
  let ``State Server Sessions Total`` =
    { category = CategoryName; counter = "State Server Sessions Total"; instance = None }
  /// Worker Process Restarts: Number of times a worker process has restarted on the machine.
  let ``Worker Process Restarts`` =
    { category = CategoryName; counter = "Worker Process Restarts"; instance = None }
  /// Worker Processes Running: Number of worker processes running on the machine.
  let ``Worker Processes Running`` =
    { category = CategoryName; counter = "Worker Processes Running"; instance = None }

  let allCounters =
    [| ``Application Restarts``
       ``Applications Running``
       ``Audit Failure Events Raised``
       ``Audit Success Events Raised``
       ``Error Events Raised``
       ``Infrastructure Error Events Raised``
       ``Request Error Events Raised``
       ``Request Execution Time``
       ``Request Wait Time``
       ``Requests Current``
       ``Requests Disconnected``
       ``Requests In Native Queue``
       ``Requests Queued``
       ``Requests Rejected``
       ``State Server Sessions Abandoned``
       ``State Server Sessions Active``
       ``State Server Sessions Timed Out``
       ``State Server Sessions Total``
       ``Worker Process Restarts``
       ``Worker Processes Running``
    |]

/// Authorization Manager Applications: The set of Counters for Authorization Manager application object
///
/// This performance counter does not have instance based counters
module ``Authorization Manager Applications`` =

  [<Literal>]
  let CategoryName = "Authorization Manager Applications"

  let PCC = Category.create CategoryName
  /// Number of Scopes loaded in memory: -
  let ``Number of Scopes loaded in memory`` instance =
    { category = CategoryName; counter = "Number of Scopes loaded in memory"; instance = instance }
  /// Total number of scopes: -
  let ``Total number of scopes`` instance =
    { category = CategoryName; counter = "Total number of scopes"; instance = instance }

  let allCounters =
    [| ``Number of Scopes loaded in memory``
       ``Total number of scopes``
    |]

/// BitLocker: BitLocker Drive Encryption performance counters
///
/// This performance counter does not have non-instance based counters
module ``BitLocker`` =

  [<Literal>]
  let CategoryName = "BitLocker"

  let PCC = Category.create CategoryName
  /// Max Read Split Size: Maximum read buffer split size in bytes during last interval
  let ``Max Read Split Size`` instance =
    { category = CategoryName; counter = "Max Read Split Size"; instance = instance }
  /// Max Write Split Size: Maximum write buffer split size in bytes during last interval
  let ``Max Write Split Size`` instance =
    { category = CategoryName; counter = "Max Write Split Size"; instance = instance }
  /// Min Read Split Size: Minimum read buffer split size in bytes during last interval
  let ``Min Read Split Size`` instance =
    { category = CategoryName; counter = "Min Read Split Size"; instance = instance }
  /// Min Write Split Size: Minimum write buffer split size in bytes during last interval
  let ``Min Write Split Size`` instance =
    { category = CategoryName; counter = "Min Write Split Size"; instance = instance }
  /// Read Requests/sec: Number of read requests received over the last second
  let ``Read Requests/sec`` instance =
    { category = CategoryName; counter = "Read Requests/sec"; instance = instance }
  /// Read Subrequests/sec: Number of read subrequests issued over the last second
  let ``Read Subrequests/sec`` instance =
    { category = CategoryName; counter = "Read Subrequests/sec"; instance = instance }
  /// Write Requests/sec: Number of write requests received over the last second
  let ``Write Requests/sec`` instance =
    { category = CategoryName; counter = "Write Requests/sec"; instance = instance }
  /// Write Subrequests/sec: Number of write subrequests issued over the last second
  let ``Write Subrequests/sec`` instance =
    { category = CategoryName; counter = "Write Subrequests/sec"; instance = instance }

  let allCounters =
    [| ``Max Read Split Size``
       ``Max Write Split Size``
       ``Min Read Split Size``
       ``Min Write Split Size``
       ``Read Requests/sec``
       ``Read Subrequests/sec``
       ``Write Requests/sec``
       ``Write Subrequests/sec``
    |]

/// BranchCache: Counters for measuring bandwidth and latency for BranchCache.
///
/// This performance counter does not have instance based counters
module ``BranchCache`` =

  [<Literal>]
  let CategoryName = "BranchCache"

  let PCC = Category.create CategoryName
  /// BITS: Bytes from cache: Total number of bytes received from the local cache or peers.
  let ``BITS: Bytes from cache`` =
    { category = CategoryName; counter = "BITS: Bytes from cache"; instance = None }
  /// BITS: Bytes from server: Total number of bytes received from the original content source.
  let ``BITS: Bytes from server`` =
    { category = CategoryName; counter = "BITS: Bytes from server"; instance = None }
  /// Discovery: Attempted discoveries: Total number of attempted peer discoveries.
  let ``Discovery: Attempted discoveries`` =
    { category = CategoryName; counter = "Discovery: Attempted discoveries"; instance = None }
  /// Discovery: Successful discoveries: Total number of successful discoveries.
  let ``Discovery: Successful discoveries`` =
    { category = CategoryName; counter = "Discovery: Successful discoveries"; instance = None }
  /// Discovery: Weighted average discovery time: Weighted average of time between when a peer discovery query was sent and when the first response arrived.
  let ``Discovery: Weighted average discovery time`` =
    { category = CategoryName; counter = "Discovery: Weighted average discovery time"; instance = None }
  /// Hosted Cache: Client file segment offers made: Count of file segment offers made by peers.
  let ``Hosted Cache: Client file segment offers made`` =
    { category = CategoryName; counter = "Hosted Cache: Client file segment offers made"; instance = None }
  /// Hosted Cache: Segment offers queue size: Total number of segment offers queued for processing by the Hosted Cache.
  let ``Hosted Cache: Segment offers queue size`` =
    { category = CategoryName; counter = "Hosted Cache: Segment offers queue size"; instance = None }
  /// Local Cache: Average access time: Average local cache access time when serving content to other clients or Hosted Caches.
  let ``Local Cache: Average access time`` =
    { category = CategoryName; counter = "Local Cache: Average access time"; instance = None }
  /// Local Cache: Cache complete file segments: Count of complete, content validated, file segments.
  let ``Local Cache: Cache complete file segments`` =
    { category = CategoryName; counter = "Local Cache: Cache complete file segments"; instance = None }
  /// Local Cache: Cache partial file segments: Count of incomplete file segments that need additional data and/or validation.
  let ``Local Cache: Cache partial file segments`` =
    { category = CategoryName; counter = "Local Cache: Cache partial file segments"; instance = None }
  /// OTHER: Bytes from cache: Total number of bytes received from the local cache or peers.
  let ``OTHER: Bytes from cache`` =
    { category = CategoryName; counter = "OTHER: Bytes from cache"; instance = None }
  /// OTHER: Bytes from server: Total number of bytes received from the original content source.
  let ``OTHER: Bytes from server`` =
    { category = CategoryName; counter = "OTHER: Bytes from server"; instance = None }
  /// Publication Cache: Published contents: Count of complete, hash persisted, published contents.
  let ``Publication Cache: Published contents`` =
    { category = CategoryName; counter = "Publication Cache: Published contents"; instance = None }
  /// Retrieval: Average branch rate: Average byte rate observed by the current peer while downloading contents from other peers in the branch.
  let ``Retrieval: Average branch rate`` =
    { category = CategoryName; counter = "Retrieval: Average branch rate"; instance = None }
  /// Retrieval: Bytes from cache: Total number of bytes received from the local cache or peers.
  let ``Retrieval: Bytes from cache`` =
    { category = CategoryName; counter = "Retrieval: Bytes from cache"; instance = None }
  /// Retrieval: Bytes from server: Total number of bytes received from the original content source.
  let ``Retrieval: Bytes from server`` =
    { category = CategoryName; counter = "Retrieval: Bytes from server"; instance = None }
  /// Retrieval: Bytes served: Total number of bytes served by this peer to other peers.
  let ``Retrieval: Bytes served`` =
    { category = CategoryName; counter = "Retrieval: Bytes served"; instance = None }
  /// SMB: Bytes from cache: Total number of bytes received from the local cache or peers.
  let ``SMB: Bytes from cache`` =
    { category = CategoryName; counter = "SMB: Bytes from cache"; instance = None }
  /// SMB: Bytes from server: Total number of bytes received from the original content source.
  let ``SMB: Bytes from server`` =
    { category = CategoryName; counter = "SMB: Bytes from server"; instance = None }
  /// WINHTTP: Bytes from cache: Total number of bytes received from the local cache or peers.
  let ``WINHTTP: Bytes from cache`` =
    { category = CategoryName; counter = "WINHTTP: Bytes from cache"; instance = None }
  /// WINHTTP: Bytes from server: Total number of bytes received from the original content source.
  let ``WINHTTP: Bytes from server`` =
    { category = CategoryName; counter = "WINHTTP: Bytes from server"; instance = None }
  /// WININET: Bytes from cache: Total number of bytes received from the local cache or peers.
  let ``WININET: Bytes from cache`` =
    { category = CategoryName; counter = "WININET: Bytes from cache"; instance = None }
  /// WININET: Bytes from server: Total number of bytes received from the original content source.
  let ``WININET: Bytes from server`` =
    { category = CategoryName; counter = "WININET: Bytes from server"; instance = None }

  let allCounters =
    [| ``BITS: Bytes from cache``
       ``BITS: Bytes from server``
       ``Discovery: Attempted discoveries``
       ``Discovery: Successful discoveries``
       ``Discovery: Weighted average discovery time``
       ``Hosted Cache: Client file segment offers made``
       ``Hosted Cache: Segment offers queue size``
       ``Local Cache: Average access time``
       ``Local Cache: Cache complete file segments``
       ``Local Cache: Cache partial file segments``
       ``OTHER: Bytes from cache``
       ``OTHER: Bytes from server``
       ``Publication Cache: Published contents``
       ``Retrieval: Average branch rate``
       ``Retrieval: Bytes from cache``
       ``Retrieval: Bytes from server``
       ``Retrieval: Bytes served``
       ``SMB: Bytes from cache``
       ``SMB: Bytes from server``
       ``WINHTTP: Bytes from cache``
       ``WINHTTP: Bytes from server``
       ``WININET: Bytes from cache``
       ``WININET: Bytes from server``
    |]

/// Browser: The Browser performance object consists of counters that measure the rates of announcements, enumerations, and other Browser transmissions.
///
/// This performance counter does not have instance based counters
module ``Browser`` =

  [<Literal>]
  let CategoryName = "Browser"

  let PCC = Category.create CategoryName
  /// Announcements Domain/sec: Announcements Domain/sec is the rate at which a domain has announced itself to the network.
  let ``Announcements Domain/sec`` =
    { category = CategoryName; counter = "Announcements Domain/sec"; instance = None }
  /// Announcements Server/sec: Announcements Server/sec is the rate at which the servers in this domain have announced themselves to this server.
  let ``Announcements Server/sec`` =
    { category = CategoryName; counter = "Announcements Server/sec"; instance = None }
  /// Announcements Total/sec: Announcements Total/sec is the sum of Announcements Server/sec and Announcements Domain/sec.
  let ``Announcements Total/sec`` =
    { category = CategoryName; counter = "Announcements Total/sec"; instance = None }
  /// Duplicate Master Announcements: Duplicate Master Announcements indicates the number of times that the master browser has detected another master browser on the same domain.
  let ``Duplicate Master Announcements`` =
    { category = CategoryName; counter = "Duplicate Master Announcements"; instance = None }
  /// Election Packets/sec: Election Packets/sec is the rate at which browser election packets have been received by this workstation.
  let ``Election Packets/sec`` =
    { category = CategoryName; counter = "Election Packets/sec"; instance = None }
  /// Enumerations Domain/sec: Enumerations Domain/sec is the rate at which domain browse requests have been processed by this workstation.
  let ``Enumerations Domain/sec`` =
    { category = CategoryName; counter = "Enumerations Domain/sec"; instance = None }
  /// Enumerations Other/sec: Enumerations Other/sec is the rate at which browse requests processed by this workstation are not domain or server browse requests.
  let ``Enumerations Other/sec`` =
    { category = CategoryName; counter = "Enumerations Other/sec"; instance = None }
  /// Enumerations Server/sec: Enumerations Server/sec is the rate at which server browse requests have been processed by this workstation.
  let ``Enumerations Server/sec`` =
    { category = CategoryName; counter = "Enumerations Server/sec"; instance = None }
  /// Enumerations Total/sec: Enumerations Total/sec is the rate at which browse requests have been processed by this workstation.  This is the sum of Enumerations Server/sec, Enumerations Domain/sec, and Enumerations Other/sec.
  let ``Enumerations Total/sec`` =
    { category = CategoryName; counter = "Enumerations Total/sec"; instance = None }
  /// Illegal Datagrams/sec: Illegal Datagrams/sec is the rate at which incorrectly formatted datagrams have been received by the workstation.
  let ``Illegal Datagrams/sec`` =
    { category = CategoryName; counter = "Illegal Datagrams/sec"; instance = None }
  /// Mailslot Allocations Failed: Mailslot Allocations Failed is the number of times the datagram receiver has failed to allocate a buffer to hold a user mailslot write.
  let ``Mailslot Allocations Failed`` =
    { category = CategoryName; counter = "Mailslot Allocations Failed"; instance = None }
  /// Mailslot Opens Failed/sec: Mailslot Opens Failed/sec indicates the rate at which mailslot messages to be delivered to mailslots that are not present are received by this workstation.
  let ``Mailslot Opens Failed/sec`` =
    { category = CategoryName; counter = "Mailslot Opens Failed/sec"; instance = None }
  /// Mailslot Receives Failed: Mailslot Receives Failed indicates the number of mailslot messages that could not be received due to transport failures.
  let ``Mailslot Receives Failed`` =
    { category = CategoryName; counter = "Mailslot Receives Failed"; instance = None }
  /// Mailslot Writes Failed: Mailslot Writes Failed is the total number of mailslot messages that have been successfully received, but that could not be written to the mailslot.
  let ``Mailslot Writes Failed`` =
    { category = CategoryName; counter = "Mailslot Writes Failed"; instance = None }
  /// Mailslot Writes/sec: Mailslot Writes/sec is the rate at which mailslot messages have been successfully received.
  let ``Mailslot Writes/sec`` =
    { category = CategoryName; counter = "Mailslot Writes/sec"; instance = None }
  /// Missed Mailslot Datagrams: Missed Mailslot Datagrams is the number of Mailslot Datagrams that have been discarded due to configuration or allocation limits.
  let ``Missed Mailslot Datagrams`` =
    { category = CategoryName; counter = "Missed Mailslot Datagrams"; instance = None }
  /// Missed Server Announcements: Missed Server Announcements is the number of server announcements that have been missed due to configuration or allocation limits.
  let ``Missed Server Announcements`` =
    { category = CategoryName; counter = "Missed Server Announcements"; instance = None }
  /// Missed Server List Requests: Missed Server List Requests is the number of requests to retrieve a list of browser servers that were received by this workstation, but could not be processed.
  let ``Missed Server List Requests`` =
    { category = CategoryName; counter = "Missed Server List Requests"; instance = None }
  /// Server Announce Allocations Failed/sec: Server Announce Allocations Failed/sec is the rate at which server (or domain) announcements have failed due to lack of memory.
  let ``Server Announce Allocations Failed/sec`` =
    { category = CategoryName; counter = "Server Announce Allocations Failed/sec"; instance = None }
  /// Server List Requests/sec: Server List Requests/sec is the rate at which requests to retrieve a list of browser servers have been processed by this workstation.
  let ``Server List Requests/sec`` =
    { category = CategoryName; counter = "Server List Requests/sec"; instance = None }

  let allCounters =
    [| ``Announcements Domain/sec``
       ``Announcements Server/sec``
       ``Announcements Total/sec``
       ``Duplicate Master Announcements``
       ``Election Packets/sec``
       ``Enumerations Domain/sec``
       ``Enumerations Other/sec``
       ``Enumerations Server/sec``
       ``Enumerations Total/sec``
       ``Illegal Datagrams/sec``
       ``Mailslot Allocations Failed``
       ``Mailslot Opens Failed/sec``
       ``Mailslot Receives Failed``
       ``Mailslot Writes Failed``
       ``Mailslot Writes/sec``
       ``Missed Mailslot Datagrams``
       ``Missed Server Announcements``
       ``Missed Server List Requests``
       ``Server Announce Allocations Failed/sec``
       ``Server List Requests/sec``
    |]

/// Cache: The Cache performance object  consists of counters that monitor the file system cache, an area of physical memory that stores recently used data as long as possible to permit access to the data without having to read from the disk.  Because applications typically use the cache, the cache is monitored as an indicator of application I/O operations.  When memory is plentiful, the cache can grow, but when memory is scarce, the cache can become too small to be effective.
///
/// This performance counter does not have instance based counters
module ``Cache`` =

  [<Literal>]
  let CategoryName = "Cache"

  let PCC = Category.create CategoryName
  /// Async Copy Reads/sec: Async Copy Reads/sec is the frequency of reads from pages of the file system cache that involve a memory copy of the data from the cache to the application's buffer.  The application will regain control immediately even if the disk must be accessed to retrieve the page.
  let ``Async Copy Reads/sec`` =
    { category = CategoryName; counter = "Async Copy Reads/sec"; instance = None }
  /// Async Data Maps/sec: Async Data Maps/sec is the frequency that an application using a file system, such as NTFS, to map a page of a file into the file system cache to read the page, and does not wait for the page to be retrieved if it is not in main memory.
  let ``Async Data Maps/sec`` =
    { category = CategoryName; counter = "Async Data Maps/sec"; instance = None }
  /// Async Fast Reads/sec: Async Fast Reads/sec is the frequency of reads from the file system cache that bypass the installed file system and retrieve the data directly from the cache.  Normally, file I/O requests will invoke the appropriate file system to retrieve data from a file, but this path permits data to be retrieved from the cache directly (without file system involvement) if the data is in the cache.  Even if the data is not in the cache, one invocation of the file system is avoided.  If the data is not in the cache, the request (application program call) will not wait until the data has been retrieved from disk, but will get control immediately.
  let ``Async Fast Reads/sec`` =
    { category = CategoryName; counter = "Async Fast Reads/sec"; instance = None }
  /// Async MDL Reads/sec: Async MDL Reads/sec is the frequency of reads from the file system cache that use a Memory Descriptor List (MDL) to access the pages.  The MDL contains the physical address of each page in the transfer, thus permitting Direct Memory Access (DMA) of the pages.  If the accessed page(s) are not in main memory, the calling application program will not wait for the pages to fault in from disk.
  let ``Async MDL Reads/sec`` =
    { category = CategoryName; counter = "Async MDL Reads/sec"; instance = None }
  /// Async Pin Reads/sec: Async Pin Reads/sec is the frequency of reading data into the file system cache preparatory to writing the data back to disk.  Pages read in this fashion are pinned in memory at the completion of the read.  The file system will regain control immediately even if the disk must be accessed to retrieve the page.  While pinned, a page's physical address will not be altered.
  let ``Async Pin Reads/sec`` =
    { category = CategoryName; counter = "Async Pin Reads/sec"; instance = None }
  /// Copy Read Hits %: Copy Read Hits is the percentage of cache copy read requests that hit the cache, that is, they did not require a disk read in order to provide access to the page in the cache.  A copy read is a file read operation that is satisfied by a memory copy from a page in the cache to the application's buffer.  The LAN Redirector uses this method for retrieving information from the cache, as does the LAN Server for small transfers.  This is a method used by the disk file systems as well.
  let ``Copy Read Hits %`` =
    { category = CategoryName; counter = "Copy Read Hits %"; instance = None }
  /// Copy Reads/sec: Copy Reads/sec is the frequency of reads from pages of the file system cache that involve a memory copy of the data from the cache to the application's buffer.  The LAN Redirector uses this method for retrieving information from the file system cache, as does the LAN Server for small transfers.  This is a method used by the disk file systems as well.
  let ``Copy Reads/sec`` =
    { category = CategoryName; counter = "Copy Reads/sec"; instance = None }
  /// Data Flush Pages/sec: Data Flush Pages/sec is the number of pages the file system cache has flushed to disk as a result of a request to flush or to satisfy a write-through file write request.  More than one page can be transferred on each flush operation.
  let ``Data Flush Pages/sec`` =
    { category = CategoryName; counter = "Data Flush Pages/sec"; instance = None }
  /// Data Flushes/sec: Data Flushes/sec is the rate at which the file system cache has flushed its contents to disk as the result of a request to flush or to satisfy a write-through file write request.  More than one page can be transferred on each flush operation.
  let ``Data Flushes/sec`` =
    { category = CategoryName; counter = "Data Flushes/sec"; instance = None }
  /// Data Map Hits %: Data Map Hits is the percentage of data maps in the file system cache that could be resolved without having to retrieve a page from the disk, because the page was already in physical memory.
  let ``Data Map Hits %`` =
    { category = CategoryName; counter = "Data Map Hits %"; instance = None }
  /// Data Map Pins/sec: Data Map Pins/sec is the frequency of data maps in the file system cache that resulted in pinning a page in main memory, an action usually preparatory to writing to the file on disk.   While pinned, a page's physical address in main memory and virtual address in the file system cache will not be altered.
  let ``Data Map Pins/sec`` =
    { category = CategoryName; counter = "Data Map Pins/sec"; instance = None }
  /// Data Maps/sec: Data Maps/sec is the frequency that a file system such as NTFS, maps a page of a file into the file system cache to read the page.
  let ``Data Maps/sec`` =
    { category = CategoryName; counter = "Data Maps/sec"; instance = None }
  /// Dirty Page Threshold: Threshold for number of dirty pages on system cache
  let ``Dirty Page Threshold`` =
    { category = CategoryName; counter = "Dirty Page Threshold"; instance = None }
  /// Dirty Pages: Total number of dirty pages on the system cache
  let ``Dirty Pages`` =
    { category = CategoryName; counter = "Dirty Pages"; instance = None }
  /// Fast Read Not Possibles/sec: Fast Read Not Possibles/sec is the frequency of attempts by an Application Program Interface (API) function call to bypass the file system to get to data in the file system cache that could not be honored without invoking the file system.
  let ``Fast Read Not Possibles/sec`` =
    { category = CategoryName; counter = "Fast Read Not Possibles/sec"; instance = None }
  /// Fast Read Resource Misses/sec: Fast Read Resource Misses/sec is the frequency of cache misses necessitated by the lack of available resources to satisfy the request.
  let ``Fast Read Resource Misses/sec`` =
    { category = CategoryName; counter = "Fast Read Resource Misses/sec"; instance = None }
  /// Fast Reads/sec: Fast Reads/sec is the frequency of reads from the file system cache that bypass the installed file system and retrieve the data directly from the cache.  Normally, file I/O requests invoke the appropriate file system to retrieve data from a file, but this path permits direct retrieval of data from the cache without file system involvement if the data is in the cache.  Even if the data is not in the cache, one invocation of the file system is avoided.
  let ``Fast Reads/sec`` =
    { category = CategoryName; counter = "Fast Reads/sec"; instance = None }
  /// Lazy Write Flushes/sec: Lazy Write Flushes/sec is the rate at which the Lazy Writer thread has written to disk.  Lazy Writing is the process of updating the disk after the page has been changed in memory, so that the application that changed the file does not have to wait for the disk write to be complete before proceeding.  More than one page can be transferred by each write operation.
  let ``Lazy Write Flushes/sec`` =
    { category = CategoryName; counter = "Lazy Write Flushes/sec"; instance = None }
  /// Lazy Write Pages/sec: Lazy Write Pages/sec is the rate at which the Lazy Writer thread has written to disk.  Lazy Writing is the process of updating the disk after the page has been changed in memory, so that the application that changed the file does not have to wait for the disk write to be complete before proceeding.  More than one page can be transferred on a single disk write operation.
  let ``Lazy Write Pages/sec`` =
    { category = CategoryName; counter = "Lazy Write Pages/sec"; instance = None }
  /// MDL Read Hits %: MDL Read Hits is the percentage of Memory Descriptor List (MDL) Read requests to the file system cache that hit the cache, i.e., did not require disk accesses in order to provide memory access to the page(s) in the cache.
  let ``MDL Read Hits %`` =
    { category = CategoryName; counter = "MDL Read Hits %"; instance = None }
  /// MDL Reads/sec: MDL Reads/sec is the frequency of reads from the file system cache that use a Memory Descriptor List (MDL) to access the data.  The MDL contains the physical address of each page involved in the transfer, and thus can employ a hardware Direct Memory Access (DMA) device to effect the copy.  The LAN Server uses this method for large transfers out of the server.
  let ``MDL Reads/sec`` =
    { category = CategoryName; counter = "MDL Reads/sec"; instance = None }
  /// Pin Read Hits %: Pin Read Hits is the percentage of pin read requests that hit the file system cache, i.e., did not require a disk read in order to provide access to the page in the file system cache.  While pinned, a page's physical address in the file system cache will not be altered.  The LAN Redirector uses this method for retrieving data from the cache, as does the LAN Server for small transfers.  This is usually the method used by the disk file systems as well.
  let ``Pin Read Hits %`` =
    { category = CategoryName; counter = "Pin Read Hits %"; instance = None }
  /// Pin Reads/sec: Pin Reads/sec is the frequency of reading data into the file system cache preparatory to writing the data back to disk.  Pages read in this fashion are pinned in memory at the completion of the read.  While pinned, a page's physical address in the file system cache will not be altered.
  let ``Pin Reads/sec`` =
    { category = CategoryName; counter = "Pin Reads/sec"; instance = None }
  /// Read Aheads/sec: Read Aheads/sec is the frequency of reads from the file system cache in which the Cache detects sequential access to a file.  The read aheads permit the data to be transferred in larger blocks than those being requested by the application, reducing the overhead per access.
  let ``Read Aheads/sec`` =
    { category = CategoryName; counter = "Read Aheads/sec"; instance = None }
  /// Sync Copy Reads/sec: Sync Copy Reads/sec is the frequency of reads from pages of the file system cache that involve a memory copy of the data from the cache to the application's buffer.  The file system will not regain control until the copy operation is complete, even if the disk must be accessed to retrieve the page.
  let ``Sync Copy Reads/sec`` =
    { category = CategoryName; counter = "Sync Copy Reads/sec"; instance = None }
  /// Sync Data Maps/sec: Sync Data Maps/sec counts the frequency that a file system, such as NTFS, maps a page of a file into the file system cache to read the page, and wishes to wait for the page to be retrieved if it is not in main memory.
  let ``Sync Data Maps/sec`` =
    { category = CategoryName; counter = "Sync Data Maps/sec"; instance = None }
  /// Sync Fast Reads/sec: Sync Fast Reads/sec is the frequency of reads from the file system cache that bypass the installed file system and retrieve the data directly from the cache.  Normally, file I/O requests invoke the appropriate file system to retrieve data from a file, but this path permits direct retrieval of data from the cache without file system involvement if the data is in the cache.  Even if the data is not in the cache, one invocation of the file system is avoided.  If the data is not in the cache, the request (application program call) will wait until the data has been retrieved from disk.
  let ``Sync Fast Reads/sec`` =
    { category = CategoryName; counter = "Sync Fast Reads/sec"; instance = None }
  /// Sync MDL Reads/sec: Sync MDL Reads/sec is the frequency of reads from the file system cache that use a Memory Descriptor List (MDL) to access the pages.  The MDL contains the physical address of each page in the transfer, thus permitting Direct Memory Access (DMA) of the pages.  If the accessed page(s) are not in main memory, the caller will wait for the pages to fault in from the disk.
  let ``Sync MDL Reads/sec`` =
    { category = CategoryName; counter = "Sync MDL Reads/sec"; instance = None }
  /// Sync Pin Reads/sec: Sync Pin Reads/sec is the frequency of reading data into the file system cache preparatory to writing the data back to disk.  Pages read in this fashion are pinned in memory at the completion of the read.  The file system will not regain control until the page is pinned in the file system cache, in particular if the disk must be accessed to retrieve the page.  While pinned, a page's physical address in the file system cache will not be altered.
  let ``Sync Pin Reads/sec`` =
    { category = CategoryName; counter = "Sync Pin Reads/sec"; instance = None }

  let allCounters =
    [| ``Async Copy Reads/sec``
       ``Async Data Maps/sec``
       ``Async Fast Reads/sec``
       ``Async MDL Reads/sec``
       ``Async Pin Reads/sec``
       ``Copy Read Hits %``
       ``Copy Reads/sec``
       ``Data Flush Pages/sec``
       ``Data Flushes/sec``
       ``Data Map Hits %``
       ``Data Map Pins/sec``
       ``Data Maps/sec``
       ``Dirty Page Threshold``
       ``Dirty Pages``
       ``Fast Read Not Possibles/sec``
       ``Fast Read Resource Misses/sec``
       ``Fast Reads/sec``
       ``Lazy Write Flushes/sec``
       ``Lazy Write Pages/sec``
       ``MDL Read Hits %``
       ``MDL Reads/sec``
       ``Pin Read Hits %``
       ``Pin Reads/sec``
       ``Read Aheads/sec``
       ``Sync Copy Reads/sec``
       ``Sync Data Maps/sec``
       ``Sync Fast Reads/sec``
       ``Sync MDL Reads/sec``
       ``Sync Pin Reads/sec``
    |]

/// Classification Engine: Content Analysis Session: Classification Engine: Content Analysis Session
///
/// This performance counter does not have instance based counters
module ``Classification Engine: Content Analysis Session`` =

  [<Literal>]
  let CategoryName = "Classification Engine: Content Analysis Session"

  let PCC = Category.create CategoryName
  /// Average Time to Classify All Rules: -
  let ``Average Time to Classify All Rules`` instance =
    { category = CategoryName; counter = "Average Time to Classify All Rules"; instance = instance }
  /// Average Time to Classify OOB Rules: -
  let ``Average Time to Classify OOB Rules`` instance =
    { category = CategoryName; counter = "Average Time to Classify OOB Rules"; instance = instance }
  /// Average Time to Retrieve Data: -
  let ``Average Time to Retrieve Data`` instance =
    { category = CategoryName; counter = "Average Time to Retrieve Data"; instance = instance }

  let allCounters =
    [| ``Average Time to Classify All Rules``
       ``Average Time to Classify OOB Rules``
       ``Average Time to Retrieve Data``
    |]

/// Classification Engine: Rule Package Cache: Classification Engine: Rule Package Cache
///
/// This performance counter does not have instance based counters
module ``Classification Engine: Rule Package Cache`` =

  [<Literal>]
  let CategoryName = "Classification Engine: Rule Package Cache"

  let PCC = Category.create CategoryName
  /// Average Time to Load Rules: -
  let ``Average Time to Load Rules`` instance =
    { category = CategoryName; counter = "Average Time to Load Rules"; instance = instance }
  /// Average Time to Retrieve Rules: -
  let ``Average Time to Retrieve Rules`` instance =
    { category = CategoryName; counter = "Average Time to Retrieve Rules"; instance = instance }
  /// Forced Rule Package Retrievals: -
  let ``Forced Rule Package Retrievals`` instance =
    { category = CategoryName; counter = "Forced Rule Package Retrievals"; instance = instance }
  /// Recoverable Cache Misses: -
  let ``Recoverable Cache Misses`` instance =
    { category = CategoryName; counter = "Recoverable Cache Misses"; instance = instance }
  /// Rule Package Count Evictions: -
  let ``Rule Package Count Evictions`` instance =
    { category = CategoryName; counter = "Rule Package Count Evictions"; instance = instance }
  /// Rule Package Memory Evictions: -
  let ``Rule Package Memory Evictions`` instance =
    { category = CategoryName; counter = "Rule Package Memory Evictions"; instance = instance }
  /// Successful Cache Hits: -
  let ``Successful Cache Hits`` instance =
    { category = CategoryName; counter = "Successful Cache Hits"; instance = instance }
  /// Unrecoverable Cache Misses: -
  let ``Unrecoverable Cache Misses`` instance =
    { category = CategoryName; counter = "Unrecoverable Cache Misses"; instance = instance }

  let allCounters =
    [| ``Average Time to Load Rules``
       ``Average Time to Retrieve Rules``
       ``Forced Rule Package Retrievals``
       ``Recoverable Cache Misses``
       ``Rule Package Count Evictions``
       ``Rule Package Memory Evictions``
       ``Successful Cache Hits``
       ``Unrecoverable Cache Misses``
    |]

/// Client Side Caching: Performance counters for SMB BranchCache for reduced bandwidth consumption
///
/// This performance counter does not have instance based counters
module ``Client Side Caching`` =

  [<Literal>]
  let CategoryName = "Client Side Caching"

  let PCC = Category.create CategoryName
  /// Application Bytes Read From Cache: Transparently cached bytes read by applications from the Client Side Cache
  let ``Application Bytes Read From Cache`` =
    { category = CategoryName; counter = "Application Bytes Read From Cache"; instance = None }
  /// Application Bytes Read From Server: Transparently cached bytes read by applications from the server
  let ``Application Bytes Read From Server`` =
    { category = CategoryName; counter = "Application Bytes Read From Server"; instance = None }
  /// Application Bytes Read From Server (Not Cached): Transparently cached bytes read by applications from the server and not cached by the client
  let ``Application Bytes Read From Server (Not Cached)`` =
    { category = CategoryName; counter = "Application Bytes Read From Server (Not Cached)"; instance = None }
  /// Prefetch Bytes Read From Cache: Bytes read by the BranchCache prefetcher service from the Client Side Cache
  let ``Prefetch Bytes Read From Cache`` =
    { category = CategoryName; counter = "Prefetch Bytes Read From Cache"; instance = None }
  /// Prefetch Bytes Read From Server: Bytes read by the BranchCache prefetcher from the server
  let ``Prefetch Bytes Read From Server`` =
    { category = CategoryName; counter = "Prefetch Bytes Read From Server"; instance = None }
  /// Prefetch Operations Queued: Count of prefetch operations queued to retrieve or publish BranchCache data
  let ``Prefetch Operations Queued`` =
    { category = CategoryName; counter = "Prefetch Operations Queued"; instance = None }
  /// SMB BranchCache Bytes Published: Bytes published back to BranchCache
  let ``SMB BranchCache Bytes Published`` =
    { category = CategoryName; counter = "SMB BranchCache Bytes Published"; instance = None }
  /// SMB BranchCache Bytes Received: Bytes received from BranchCache
  let ``SMB BranchCache Bytes Received`` =
    { category = CategoryName; counter = "SMB BranchCache Bytes Received"; instance = None }
  /// SMB BranchCache Bytes Requested: Bytes requested from BranchCache
  let ``SMB BranchCache Bytes Requested`` =
    { category = CategoryName; counter = "SMB BranchCache Bytes Requested"; instance = None }
  /// SMB BranchCache Bytes Requested From Server: Bytes not found in BranchCache and retrieved from the server
  let ``SMB BranchCache Bytes Requested From Server`` =
    { category = CategoryName; counter = "SMB BranchCache Bytes Requested From Server"; instance = None }
  /// SMB BranchCache Hash Bytes Received: Bytes of hash data successfully received back from the server for BranchCache lookup
  let ``SMB BranchCache Hash Bytes Received`` =
    { category = CategoryName; counter = "SMB BranchCache Hash Bytes Received"; instance = None }
  /// SMB BranchCache Hashes Received: Count of hash requests successfully receieved back from the server for BranchCache lookup
  let ``SMB BranchCache Hashes Received`` =
    { category = CategoryName; counter = "SMB BranchCache Hashes Received"; instance = None }
  /// SMB BranchCache Hashes Requested: Count of hash requests sent to the server for BranchCache lookup
  let ``SMB BranchCache Hashes Requested`` =
    { category = CategoryName; counter = "SMB BranchCache Hashes Requested"; instance = None }

  let allCounters =
    [| ``Application Bytes Read From Cache``
       ``Application Bytes Read From Server``
       ``Application Bytes Read From Server (Not Cached)``
       ``Prefetch Bytes Read From Cache``
       ``Prefetch Bytes Read From Server``
       ``Prefetch Operations Queued``
       ``SMB BranchCache Bytes Published``
       ``SMB BranchCache Bytes Received``
       ``SMB BranchCache Bytes Requested``
       ``SMB BranchCache Bytes Requested From Server``
       ``SMB BranchCache Hash Bytes Received``
       ``SMB BranchCache Hashes Received``
       ``SMB BranchCache Hashes Requested``
    |]

/// DNS64 Global: Statistics of DNS64 on this machine.
///
/// This performance counter does not have non-instance based counters
module ``DNS64 Global`` =

  [<Literal>]
  let CategoryName = "DNS64 Global"

  let PCC = Category.create CategoryName
  /// AAAA - Synthesized records: Number of synthesized AAAA records.
  let ``AAAA - Synthesized records`` instance =
    { category = CategoryName; counter = "AAAA - Synthesized records"; instance = instance }
  /// AAAA queries - Failed: Number of AAAA queries unsuccessfully served by the DNS64 server.
  let ``AAAA queries - Failed`` instance =
    { category = CategoryName; counter = "AAAA queries - Failed"; instance = instance }
  /// AAAA queries - Successful: Number of AAAA queries successfully served by the DNS64 server.
  let ``AAAA queries - Successful`` instance =
    { category = CategoryName; counter = "AAAA queries - Successful"; instance = instance }
  /// IP6.ARPA queries - Matched: Number of IP6.ARPA PTR queries, matched configured prefixes.
  let ``IP6.ARPA queries - Matched`` instance =
    { category = CategoryName; counter = "IP6.ARPA queries - Matched"; instance = instance }
  /// Other queries - Failed: Number of unsuccessfully served pass-through queries.
  let ``Other queries - Failed`` instance =
    { category = CategoryName; counter = "Other queries - Failed"; instance = instance }
  /// Other queries - Successful: Number of successfully served pass-through queries.
  let ``Other queries - Successful`` instance =
    { category = CategoryName; counter = "Other queries - Successful"; instance = instance }

  let allCounters =
    [| ``AAAA - Synthesized records``
       ``AAAA queries - Failed``
       ``AAAA queries - Successful``
       ``IP6.ARPA queries - Matched``
       ``Other queries - Failed``
       ``Other queries - Successful``
    |]

/// Delivery Optimization Swarm: The Delivery Optimization Swarm Set contains counters pertaining various statistics of an active Swarm.
///
/// This performance counter does not have instance based counters
module ``Delivery Optimization Swarm`` =

  [<Literal>]
  let CategoryName = "Delivery Optimization Swarm"

  let PCC = Category.create CategoryName
  /// CDN download rate in the swarm: -
  let ``CDN download rate in the swarm`` instance =
    { category = CategoryName; counter = "CDN download rate in the swarm"; instance = instance }
  /// Number of peers in swarm: -
  let ``Number of peers in swarm`` instance =
    { category = CategoryName; counter = "Number of peers in swarm"; instance = instance }
  /// Peers download rate in the swarm: -
  let ``Peers download rate in the swarm`` instance =
    { category = CategoryName; counter = "Peers download rate in the swarm"; instance = instance }
  /// Peers upload rate in the swarm: -
  let ``Peers upload rate in the swarm`` instance =
    { category = CategoryName; counter = "Peers upload rate in the swarm"; instance = instance }
  /// Swarm download rate: -
  let ``Swarm download rate`` instance =
    { category = CategoryName; counter = "Swarm download rate"; instance = instance }

  let allCounters =
    [| ``CDN download rate in the swarm``
       ``Number of peers in swarm``
       ``Peers download rate in the swarm``
       ``Peers upload rate in the swarm``
       ``Swarm download rate``
    |]

/// Distributed Routing Table: The Distributed Routing Table (DRT) performance object consists of counters that monitor the local DRT cache as well as counters that measure the rates at which DRT protocol messages are sent and received.
///
/// This performance counter does not have instance based counters
module ``Distributed Routing Table`` =

  [<Literal>]
  let CategoryName = "Distributed Routing Table"

  let PCC = Category.create CategoryName
  /// Ack Messages Received/second: -
  let ``Ack Messages Received/second`` instance =
    { category = CategoryName; counter = "Ack Messages Received/second"; instance = instance }
  /// Ack Messages Sent/second: -
  let ``Ack Messages Sent/second`` instance =
    { category = CategoryName; counter = "Ack Messages Sent/second"; instance = instance }
  /// Advertise Messages Received/second: -
  let ``Advertise Messages Received/second`` instance =
    { category = CategoryName; counter = "Advertise Messages Received/second"; instance = instance }
  /// Advertise Messages Sent/second: -
  let ``Advertise Messages Sent/second`` instance =
    { category = CategoryName; counter = "Advertise Messages Sent/second"; instance = instance }
  /// Authority Messages Received/second: -
  let ``Authority Messages Received/second`` instance =
    { category = CategoryName; counter = "Authority Messages Received/second"; instance = instance }
  /// Authority Sent/second: -
  let ``Authority Sent/second`` instance =
    { category = CategoryName; counter = "Authority Sent/second"; instance = instance }
  /// Average Bytes/second Received: -
  let ``Average Bytes/second Received`` instance =
    { category = CategoryName; counter = "Average Bytes/second Received"; instance = instance }
  /// Average Bytes/second Sent: -
  let ``Average Bytes/second Sent`` instance =
    { category = CategoryName; counter = "Average Bytes/second Sent"; instance = instance }
  /// Cache Entries: -
  let ``Cache Entries`` instance =
    { category = CategoryName; counter = "Cache Entries"; instance = instance }
  /// Estimated cloud size: -
  let ``Estimated cloud size`` instance =
    { category = CategoryName; counter = "Estimated cloud size"; instance = instance }
  /// Flood Messages Received/second: -
  let ``Flood Messages Received/second`` instance =
    { category = CategoryName; counter = "Flood Messages Received/second"; instance = instance }
  /// Flood Messages Sent/second: -
  let ``Flood Messages Sent/second`` instance =
    { category = CategoryName; counter = "Flood Messages Sent/second"; instance = instance }
  /// Inquire Messages Received/second: -
  let ``Inquire Messages Received/second`` instance =
    { category = CategoryName; counter = "Inquire Messages Received/second"; instance = instance }
  /// Inquire Messages Sent/second: -
  let ``Inquire Messages Sent/second`` instance =
    { category = CategoryName; counter = "Inquire Messages Sent/second"; instance = instance }
  /// Lookup Messages Received/second: -
  let ``Lookup Messages Received/second`` instance =
    { category = CategoryName; counter = "Lookup Messages Received/second"; instance = instance }
  /// Lookup Messages Sent/second: -
  let ``Lookup Messages Sent/second`` instance =
    { category = CategoryName; counter = "Lookup Messages Sent/second"; instance = instance }
  /// Receive Failures: -
  let ``Receive Failures`` instance =
    { category = CategoryName; counter = "Receive Failures"; instance = instance }
  /// Registrations: -
  let ``Registrations`` instance =
    { category = CategoryName; counter = "Registrations"; instance = instance }
  /// Request Messages Received/second: -
  let ``Request Messages Received/second`` instance =
    { category = CategoryName; counter = "Request Messages Received/second"; instance = instance }
  /// Request Messages Sent/second: -
  let ``Request Messages Sent/second`` instance =
    { category = CategoryName; counter = "Request Messages Sent/second"; instance = instance }
  /// Searches: -
  let ``Searches`` instance =
    { category = CategoryName; counter = "Searches"; instance = instance }
  /// Send Failures: -
  let ``Send Failures`` instance =
    { category = CategoryName; counter = "Send Failures"; instance = instance }
  /// Solicit Messages Received/second: -
  let ``Solicit Messages Received/second`` instance =
    { category = CategoryName; counter = "Solicit Messages Received/second"; instance = instance }
  /// Solicit Messages Sent/second: -
  let ``Solicit Messages Sent/second`` instance =
    { category = CategoryName; counter = "Solicit Messages Sent/second"; instance = instance }
  /// Stale Cache Entries: -
  let ``Stale Cache Entries`` instance =
    { category = CategoryName; counter = "Stale Cache Entries"; instance = instance }
  /// Unrecognized Messages Received: -
  let ``Unrecognized Messages Received`` instance =
    { category = CategoryName; counter = "Unrecognized Messages Received"; instance = instance }

  let allCounters =
    [| ``Ack Messages Received/second``
       ``Ack Messages Sent/second``
       ``Advertise Messages Received/second``
       ``Advertise Messages Sent/second``
       ``Authority Messages Received/second``
       ``Authority Sent/second``
       ``Average Bytes/second Received``
       ``Average Bytes/second Sent``
       ``Cache Entries``
       ``Estimated cloud size``
       ``Flood Messages Received/second``
       ``Flood Messages Sent/second``
       ``Inquire Messages Received/second``
       ``Inquire Messages Sent/second``
       ``Lookup Messages Received/second``
       ``Lookup Messages Sent/second``
       ``Receive Failures``
       ``Registrations``
       ``Request Messages Received/second``
       ``Request Messages Sent/second``
       ``Searches``
       ``Send Failures``
       ``Solicit Messages Received/second``
       ``Solicit Messages Sent/second``
       ``Stale Cache Entries``
       ``Unrecognized Messages Received``
    |]

/// Distributed Transaction Coordinator: Microsoft Distributed Transaction Coordinator performance counters
///
/// This performance counter does not have instance based counters
module ``Distributed Transaction Coordinator`` =

  [<Literal>]
  let CategoryName = "Distributed Transaction Coordinator"

  let PCC = Category.create CategoryName
  /// Aborted Transactions: Number of aborted transactions
  let ``Aborted Transactions`` =
    { category = CategoryName; counter = "Aborted Transactions"; instance = None }
  /// Aborted Transactions/sec: Transactions aborted per second
  let ``Aborted Transactions/sec`` =
    { category = CategoryName; counter = "Aborted Transactions/sec"; instance = None }
  /// Active Transactions: Number of currently active transactions
  let ``Active Transactions`` =
    { category = CategoryName; counter = "Active Transactions"; instance = None }
  /// Active Transactions Maximum: Maximum number of transactions ever concurrently active
  let ``Active Transactions Maximum`` =
    { category = CategoryName; counter = "Active Transactions Maximum"; instance = None }
  /// Committed Transactions: Number of committed transactions
  let ``Committed Transactions`` =
    { category = CategoryName; counter = "Committed Transactions"; instance = None }
  /// Committed Transactions/sec: Transactions committed per second
  let ``Committed Transactions/sec`` =
    { category = CategoryName; counter = "Committed Transactions/sec"; instance = None }
  /// Force Aborted Transactions: Number of transactions aborted by the system administrator
  let ``Force Aborted Transactions`` =
    { category = CategoryName; counter = "Force Aborted Transactions"; instance = None }
  /// Force Committed Transactions: Number of transactions committed by the system administrator
  let ``Force Committed Transactions`` =
    { category = CategoryName; counter = "Force Committed Transactions"; instance = None }
  /// In Doubt Transactions: Number of in doubt transactions
  let ``In Doubt Transactions`` =
    { category = CategoryName; counter = "In Doubt Transactions"; instance = None }
  /// Response Time -- Average: Average time delta between transaction begin and commit
  let ``Response Time -- Average`` =
    { category = CategoryName; counter = "Response Time -- Average"; instance = None }
  /// Response Time -- Maximum: Maximum time delta between transaction begin and commit
  let ``Response Time -- Maximum`` =
    { category = CategoryName; counter = "Response Time -- Maximum"; instance = None }
  /// Response Time -- Minimum: Minimum time delta between transaction begin and commit
  let ``Response Time -- Minimum`` =
    { category = CategoryName; counter = "Response Time -- Minimum"; instance = None }
  /// Transactions/sec: Transactions performed per second
  let ``Transactions/sec`` =
    { category = CategoryName; counter = "Transactions/sec"; instance = None }

  let allCounters =
    [| ``Aborted Transactions``
       ``Aborted Transactions/sec``
       ``Active Transactions``
       ``Active Transactions Maximum``
       ``Committed Transactions``
       ``Committed Transactions/sec``
       ``Force Aborted Transactions``
       ``Force Committed Transactions``
       ``In Doubt Transactions``
       ``Response Time -- Average``
       ``Response Time -- Maximum``
       ``Response Time -- Minimum``
       ``Transactions/sec``
    |]

/// Energy Meter: The Energy Meter performance object measures total energy consumption.
///
/// This performance counter does not have instance based counters
module ``Energy Meter`` =

  [<Literal>]
  let CategoryName = "Energy Meter"

  let PCC = Category.create CategoryName
  /// Energy: -
  let ``Energy`` instance =
    { category = CategoryName; counter = "Energy"; instance = instance }
  /// Power: -
  let ``Power`` instance =
    { category = CategoryName; counter = "Power"; instance = instance }
  /// Time: -
  let ``Time`` instance =
    { category = CategoryName; counter = "Time"; instance = instance }

  let allCounters =
    [| ``Energy``
       ``Power``
       ``Time``
    |]

/// Event Tracing for Windows: The counters in this collection refer to system-wide metrics about the performance of the Event Tracing for Windows subsystem.
///
/// This performance counter does not have instance based counters
module ``Event Tracing for Windows`` =

  [<Literal>]
  let CategoryName = "Event Tracing for Windows"

  let PCC = Category.create CategoryName
  /// Total Memory Usage --- Non-Paged Pool: Current size of non-paged memory allocated for the buffers associated with all active sessions (in bytes).
  let ``Total Memory Usage --- Non-Paged Pool`` =
    { category = CategoryName; counter = "Total Memory Usage --- Non-Paged Pool"; instance = None }
  /// Total Memory Usage --- Paged Pool: Current size of paged memory allocated for the buffers associated with all active sessions (in bytes).
  let ``Total Memory Usage --- Paged Pool`` =
    { category = CategoryName; counter = "Total Memory Usage --- Paged Pool"; instance = None }
  /// Total Number of Active Sessions: Number of ETW tracing sessions currently active.
  let ``Total Number of Active Sessions`` =
    { category = CategoryName; counter = "Total Number of Active Sessions"; instance = None }
  /// Total Number of Distinct Disabled Providers: Number of unique tracing providers that are registered with the tracing subsystem but are not actively enabled to any trace session; multiple registered instances of a provider are counted only once.
  let ``Total Number of Distinct Disabled Providers`` =
    { category = CategoryName; counter = "Total Number of Distinct Disabled Providers"; instance = None }
  /// Total Number of Distinct Enabled Providers: Number of distinct event providers that are enabled to ETW sessions; multiple instances of a provider are counted only once.
  let ``Total Number of Distinct Enabled Providers`` =
    { category = CategoryName; counter = "Total Number of Distinct Enabled Providers"; instance = None }
  /// Total Number of Distinct Pre-Enabled Providers: Number of unique tracing providers that have been enabled to a trace session but have not yet registered with ETW.
  let ``Total Number of Distinct Pre-Enabled Providers`` =
    { category = CategoryName; counter = "Total Number of Distinct Pre-Enabled Providers"; instance = None }

  let allCounters =
    [| ``Total Memory Usage --- Non-Paged Pool``
       ``Total Memory Usage --- Paged Pool``
       ``Total Number of Active Sessions``
       ``Total Number of Distinct Disabled Providers``
       ``Total Number of Distinct Enabled Providers``
       ``Total Number of Distinct Pre-Enabled Providers``
    |]

/// Event Tracing for Windows Session: The counters in this collection are related to individual Event Tracing for Windows sessions.
///
/// This performance counter does not have non-instance based counters
module ``Event Tracing for Windows Session`` =

  [<Literal>]
  let CategoryName = "Event Tracing for Windows Session"

  let PCC = Category.create CategoryName
  /// Buffer Memory Usage -- Non-Paged Pool: Current size of non-paged memory allocated for the buffers associated with this session (in bytes).
  let ``Buffer Memory Usage -- Non-Paged Pool`` instance =
    { category = CategoryName; counter = "Buffer Memory Usage -- Non-Paged Pool"; instance = instance }
  /// Buffer Memory Usage -- Paged Pool: Current size of paged memory allocated for the buffers associated with this session (in bytes).
  let ``Buffer Memory Usage -- Paged Pool`` instance =
    { category = CategoryName; counter = "Buffer Memory Usage -- Paged Pool"; instance = instance }
  /// Events Logged per sec: Rate at which events are logged to this session by providers that are enabled to this session (events/sec).
  let ``Events Logged per sec`` instance =
    { category = CategoryName; counter = "Events Logged per sec"; instance = instance }
  /// Events Lost: Total number of events that were not successfully logged since the start of the tracing session.  Events are lost due to limited space in the session's buffers.  To avoid lost events, consider increasing the buffer size or the number of buffers.
  let ``Events Lost`` instance =
    { category = CategoryName; counter = "Events Lost"; instance = instance }
  /// Number of Real-Time Consumers: Number of consumers currently reading events from this session in real-time mode.
  let ``Number of Real-Time Consumers`` instance =
    { category = CategoryName; counter = "Number of Real-Time Consumers"; instance = instance }

  let allCounters =
    [| ``Buffer Memory Usage -- Non-Paged Pool``
       ``Buffer Memory Usage -- Paged Pool``
       ``Events Logged per sec``
       ``Events Lost``
       ``Number of Real-Time Consumers``
    |]

/// Fax Service: Fax Service Counter Set
///
/// This performance counter does not have instance based counters
module ``Fax Service`` =

  [<Literal>]
  let CategoryName = "Fax Service"

  let PCC = Category.create CategoryName
  /// Bytes received: Number of bytes received.
  let ``Bytes received`` =
    { category = CategoryName; counter = "Bytes received"; instance = None }
  /// Bytes sent: Number of bytes sent.
  let ``Bytes sent`` =
    { category = CategoryName; counter = "Bytes sent"; instance = None }
  /// Failed faxes transmissions: Number of faxes that failed.
  let ``Failed faxes transmissions`` =
    { category = CategoryName; counter = "Failed faxes transmissions"; instance = None }
  /// Failed outgoing connections: Number of outgoing connections that failed.
  let ``Failed outgoing connections`` =
    { category = CategoryName; counter = "Failed outgoing connections"; instance = None }
  /// Failed receptions: Number of faxes that service failed to receive.
  let ``Failed receptions`` =
    { category = CategoryName; counter = "Failed receptions"; instance = None }
  /// Faxes sent: Number of faxes successfully sent.
  let ``Faxes sent`` =
    { category = CategoryName; counter = "Faxes sent"; instance = None }
  /// Minutes receiving: Number of minutes that the service received faxes.
  let ``Minutes receiving`` =
    { category = CategoryName; counter = "Minutes receiving"; instance = None }
  /// Minutes sending: Number of minutes that the service spent in sending successfully transmitted faxes.
  let ``Minutes sending`` =
    { category = CategoryName; counter = "Minutes sending"; instance = None }
  /// Pages sent: Number of pages sent.
  let ``Pages sent`` =
    { category = CategoryName; counter = "Pages sent"; instance = None }
  /// Received faxes: Number of successfully received faxes.
  let ``Received faxes`` =
    { category = CategoryName; counter = "Received faxes"; instance = None }
  /// Received pages: Number of pages received.
  let ``Received pages`` =
    { category = CategoryName; counter = "Received pages"; instance = None }
  /// Total bytes: Total number of bytes sent and received.
  let ``Total bytes`` =
    { category = CategoryName; counter = "Total bytes"; instance = None }
  /// Total faxes sent and received: Total number of faxes sent and received.
  let ``Total faxes sent and received`` =
    { category = CategoryName; counter = "Total faxes sent and received"; instance = None }
  /// Total minutes sending and receiving: Total number of minutes that the service sent and received faxes.
  let ``Total minutes sending and receiving`` =
    { category = CategoryName; counter = "Total minutes sending and receiving"; instance = None }
  /// Total pages: Total number of pages sent and received.
  let ``Total pages`` =
    { category = CategoryName; counter = "Total pages"; instance = None }

  let allCounters =
    [| ``Bytes received``
       ``Bytes sent``
       ``Failed faxes transmissions``
       ``Failed outgoing connections``
       ``Failed receptions``
       ``Faxes sent``
       ``Minutes receiving``
       ``Minutes sending``
       ``Pages sent``
       ``Received faxes``
       ``Received pages``
       ``Total bytes``
       ``Total faxes sent and received``
       ``Total minutes sending and receiving``
       ``Total pages``
    |]

/// FileSystem Disk Activity: The FileSystem Disk Activity performance counter set consists of counters that measure the aspect of filesystem's IO Activity.  This counter set measures the number of bytes filesystem read from and wrote to the disk drive.
///
/// This performance counter does not have non-instance based counters
module ``FileSystem Disk Activity`` =

  [<Literal>]
  let CategoryName = "FileSystem Disk Activity"

  let PCC = Category.create CategoryName
  /// FileSystem Bytes Read: Total Bytes Read by the FileSystem from disk drive
  let ``FileSystem Bytes Read`` instance =
    { category = CategoryName; counter = "FileSystem Bytes Read"; instance = instance }
  /// FileSystem Bytes Written: Total Bytes Written by the FileSystem from disk drive
  let ``FileSystem Bytes Written`` instance =
    { category = CategoryName; counter = "FileSystem Bytes Written"; instance = instance }

  let allCounters =
    [| ``FileSystem Bytes Read``
       ``FileSystem Bytes Written``
    |]

/// Generic IKEv1, AuthIP, and IKEv2: Generic IKEv1, AuthIP, and IKEv2 is the set of Internet Protocol security (IPsec) Internet Key Exchange Version 1 (IKEv1), Authenticated IP (AuthIP), and Internet Key Exchange Version 2 (IKEv2) counters that are generic and do not apply to a specific Internet Protocol version.
///
/// This performance counter does not have instance based counters
module ``Generic IKEv1_ AuthIP_ and IKEv2`` =

  [<Literal>]
  let CategoryName = "Generic IKEv1, AuthIP, and IKEv2"

  let PCC = Category.create CategoryName
  /// AuthIP Main Mode Negotiation Time: AuthIP Main Mode Negotiation Time is the number of milliseconds taken for the last Authenticated IP main mode security association negotiated.
  let ``AuthIP Main Mode Negotiation Time`` =
    { category = CategoryName; counter = "AuthIP Main Mode Negotiation Time"; instance = None }
  /// AuthIP Quick Mode Negotiation Time: AuthIP Quick Mode Negotiation Time is the number of milliseconds taken for the last Authenticated IP quick mode security association negotiated.
  let ``AuthIP Quick Mode Negotiation Time`` =
    { category = CategoryName; counter = "AuthIP Quick Mode Negotiation Time"; instance = None }
  /// Extended Mode Negotiation Time: Extended Mode Negotiation Time is the number of milliseconds taken for the last extended mode security association negotiated.
  let ``Extended Mode Negotiation Time`` =
    { category = CategoryName; counter = "Extended Mode Negotiation Time"; instance = None }
  /// Failed Negotiations: Failed Negotiations is the number of failed negotiations for IKEv1, AuthIP, and IKEv2 since IPsec was last started.
  let ``Failed Negotiations`` =
    { category = CategoryName; counter = "Failed Negotiations"; instance = None }
  /// Failed Negotiations/sec: Failed Negotiations per Second is the rate of failed negotiations attempted for IKEv1, AuthIP, and IKEv2.
  let ``Failed Negotiations/sec`` =
    { category = CategoryName; counter = "Failed Negotiations/sec"; instance = None }
  /// IKEv1 Main Mode Negotiation Time: IKEv1 Main Mode Negotiation Time is the number of milliseconds taken for the last IKEv1 main mode security association negotiated.
  let ``IKEv1 Main Mode Negotiation Time`` =
    { category = CategoryName; counter = "IKEv1 Main Mode Negotiation Time"; instance = None }
  /// IKEv1 Quick Mode Negotiation Time: IKEv1 Quick Mode Negotiation Time is the number of milliseconds taken for the last IKEv1 quick mode security association negotiated.
  let ``IKEv1 Quick Mode Negotiation Time`` =
    { category = CategoryName; counter = "IKEv1 Quick Mode Negotiation Time"; instance = None }
  /// IKEv2 Main Mode Negotiation Time: IKEv2 Main Mode Negotiation Time is the number of milliseconds taken for the last IKEv2 main mode security association negotiated.
  let ``IKEv2 Main Mode Negotiation Time`` =
    { category = CategoryName; counter = "IKEv2 Main Mode Negotiation Time"; instance = None }
  /// IKEv2 Quick Mode Negotiation Time: IKEv2 Quick Mode Negotiation Time is the number of milliseconds taken for the last IKEv2 quick mode security association negotiated.
  let ``IKEv2 Quick Mode Negotiation Time`` =
    { category = CategoryName; counter = "IKEv2 Quick Mode Negotiation Time"; instance = None }
  /// Invalid Packets Received/sec: Invalid Packets Received per Second is the rate at which invalid IPsec packets are being received.
  let ``Invalid Packets Received/sec`` =
    { category = CategoryName; counter = "Invalid Packets Received/sec"; instance = None }
  /// Packets Received/sec: Packets Received per Second is the rate at which validated IPsec packets are being received.
  let ``Packets Received/sec`` =
    { category = CategoryName; counter = "Packets Received/sec"; instance = None }
  /// Successful Negotiations: Successful Negotiations is the number of negotiations completed for IKEv1, AuthIP, and IKEv2 since IPsec was last started.
  let ``Successful Negotiations`` =
    { category = CategoryName; counter = "Successful Negotiations"; instance = None }
  /// Successful Negotiations/sec: Successful Negotiations per Second is the rate of negotiations completed for IKEv1, AuthIP, and IKEv2.
  let ``Successful Negotiations/sec`` =
    { category = CategoryName; counter = "Successful Negotiations/sec"; instance = None }

  let allCounters =
    [| ``AuthIP Main Mode Negotiation Time``
       ``AuthIP Quick Mode Negotiation Time``
       ``Extended Mode Negotiation Time``
       ``Failed Negotiations``
       ``Failed Negotiations/sec``
       ``IKEv1 Main Mode Negotiation Time``
       ``IKEv1 Quick Mode Negotiation Time``
       ``IKEv2 Main Mode Negotiation Time``
       ``IKEv2 Quick Mode Negotiation Time``
       ``Invalid Packets Received/sec``
       ``Packets Received/sec``
       ``Successful Negotiations``
       ``Successful Negotiations/sec``
    |]

/// Hyper-V Configuration: This counter set represents the statistics for HyperVStorage files.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Configuration`` =

  [<Literal>]
  let CategoryName = "Hyper-V Configuration"

  let PCC = Category.create CategoryName
  /// Cache update average milliseconds: -
  let ``Cache update average milliseconds`` instance =
    { category = CategoryName; counter = "Cache update average milliseconds"; instance = instance }
  /// Cache update count: -
  let ``Cache update count`` instance =
    { category = CategoryName; counter = "Cache update count"; instance = instance }
  /// Commit average milliseconds: -
  let ``Commit average milliseconds`` instance =
    { category = CategoryName; counter = "Commit average milliseconds"; instance = instance }
  /// Commit bytes per second average: -
  let ``Commit bytes per second average`` instance =
    { category = CategoryName; counter = "Commit bytes per second average"; instance = instance }
  /// Commit count: -
  let ``Commit count`` instance =
    { category = CategoryName; counter = "Commit count"; instance = instance }
  /// Compact average milliseconds: -
  let ``Compact average milliseconds`` instance =
    { category = CategoryName; counter = "Compact average milliseconds"; instance = instance }
  /// Compact count: -
  let ``Compact count`` instance =
    { category = CategoryName; counter = "Compact count"; instance = instance }
  /// Config lock acquire average milliseconds: -
  let ``Config lock acquire average milliseconds`` instance =
    { category = CategoryName; counter = "Config lock acquire average milliseconds"; instance = instance }
  /// Config lock count: -
  let ``Config lock count`` instance =
    { category = CategoryName; counter = "Config lock count"; instance = instance }
  /// File lock acquire average milliseconds: -
  let ``File lock acquire average milliseconds`` instance =
    { category = CategoryName; counter = "File lock acquire average milliseconds"; instance = instance }
  /// File lock release average milliseconds: -
  let ``File lock release average milliseconds`` instance =
    { category = CategoryName; counter = "File lock release average milliseconds"; instance = instance }
  /// Get average milliseconds: -
  let ``Get average milliseconds`` instance =
    { category = CategoryName; counter = "Get average milliseconds"; instance = instance }
  /// Get count: -
  let ``Get count`` instance =
    { category = CategoryName; counter = "Get count"; instance = instance }
  /// Load file average milliseconds: -
  let ``Load file average milliseconds`` instance =
    { category = CategoryName; counter = "Load file average milliseconds"; instance = instance }
  /// Lock acquire average milliseconds: -
  let ``Lock acquire average milliseconds`` instance =
    { category = CategoryName; counter = "Lock acquire average milliseconds"; instance = instance }
  /// Lock count: -
  let ``Lock count`` instance =
    { category = CategoryName; counter = "Lock count"; instance = instance }
  /// Lock release average milliseconds: -
  let ``Lock release average milliseconds`` instance =
    { category = CategoryName; counter = "Lock release average milliseconds"; instance = instance }
  /// Query size average size milliseconds: -
  let ``Query size average size milliseconds`` instance =
    { category = CategoryName; counter = "Query size average size milliseconds"; instance = instance }
  /// Query size count: -
  let ``Query size count`` instance =
    { category = CategoryName; counter = "Query size count"; instance = instance }
  /// Read bytes: -
  let ``Read bytes`` instance =
    { category = CategoryName; counter = "Read bytes"; instance = instance }
  /// Read bytes per second average: -
  let ``Read bytes per second average`` instance =
    { category = CategoryName; counter = "Read bytes per second average"; instance = instance }
  /// Read file bytes: -
  let ``Read file bytes`` instance =
    { category = CategoryName; counter = "Read file bytes"; instance = instance }
  /// Read file bytes per second average: -
  let ``Read file bytes per second average`` instance =
    { category = CategoryName; counter = "Read file bytes per second average"; instance = instance }
  /// Read file count: -
  let ``Read file count`` instance =
    { category = CategoryName; counter = "Read file count"; instance = instance }
  /// Remove average milliseconds: -
  let ``Remove average milliseconds`` instance =
    { category = CategoryName; counter = "Remove average milliseconds"; instance = instance }
  /// Remove count: -
  let ``Remove count`` instance =
    { category = CategoryName; counter = "Remove count"; instance = instance }
  /// Set average milliseconds: -
  let ``Set average milliseconds`` instance =
    { category = CategoryName; counter = "Set average milliseconds"; instance = instance }
  /// Set count: -
  let ``Set count`` instance =
    { category = CategoryName; counter = "Set count"; instance = instance }
  /// Write bytes: -
  let ``Write bytes`` instance =
    { category = CategoryName; counter = "Write bytes"; instance = instance }
  /// Write bytes per second average: -
  let ``Write bytes per second average`` instance =
    { category = CategoryName; counter = "Write bytes per second average"; instance = instance }
  /// Write file bytes: -
  let ``Write file bytes`` instance =
    { category = CategoryName; counter = "Write file bytes"; instance = instance }
  /// Write file count: -
  let ``Write file count`` instance =
    { category = CategoryName; counter = "Write file count"; instance = instance }

  let allCounters =
    [| ``Cache update average milliseconds``
       ``Cache update count``
       ``Commit average milliseconds``
       ``Commit bytes per second average``
       ``Commit count``
       ``Compact average milliseconds``
       ``Compact count``
       ``Config lock acquire average milliseconds``
       ``Config lock count``
       ``File lock acquire average milliseconds``
       ``File lock release average milliseconds``
       ``Get average milliseconds``
       ``Get count``
       ``Load file average milliseconds``
       ``Lock acquire average milliseconds``
       ``Lock count``
       ``Lock release average milliseconds``
       ``Query size average size milliseconds``
       ``Query size count``
       ``Read bytes``
       ``Read bytes per second average``
       ``Read file bytes``
       ``Read file bytes per second average``
       ``Read file count``
       ``Remove average milliseconds``
       ``Remove count``
       ``Set average milliseconds``
       ``Set count``
       ``Write bytes``
       ``Write bytes per second average``
       ``Write file bytes``
       ``Write file count``
    |]

/// Hyper-V Dynamic Memory Balancer: This counter set represents the statistics for the Microsoft Dynamic Memory Balancer.
///
/// This performance counter does not have non-instance based counters
module ``Hyper-V Dynamic Memory Balancer`` =

  [<Literal>]
  let CategoryName = "Hyper-V Dynamic Memory Balancer"

  let PCC = Category.create CategoryName
  /// Available Memory: This counter represents the amount of memory left on the node.
  let ``Available Memory`` instance =
    { category = CategoryName; counter = "Available Memory"; instance = instance }
  /// Average Pressure: This counter represents the average system pressure on the balancer node among all balanced objects.
  let ``Average Pressure`` instance =
    { category = CategoryName; counter = "Average Pressure"; instance = instance }

  let allCounters =
    [| ``Available Memory``
       ``Average Pressure``
    |]

/// Hyper-V Dynamic Memory Integration Service: This counter set represents the statistics for Dynamic Memory Integration Services
///
/// This performance counter does not have instance based counters
module ``Hyper-V Dynamic Memory Integration Service`` =

  [<Literal>]
  let CategoryName = "Hyper-V Dynamic Memory Integration Service"

  let PCC = Category.create CategoryName
  /// Maximum Memory, Mbytes: 
  let ``Maximum Memory, Mbytes`` =
    { category = CategoryName; counter = "Maximum Memory, Mbytes"; instance = None }

  let allCounters =
    [| ``Maximum Memory, Mbytes``

    |]

/// Hyper-V Dynamic Memory VM: This counter set represents the memory statistics for a Virtual Machine.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Dynamic Memory VM`` =

  [<Literal>]
  let CategoryName = "Hyper-V Dynamic Memory VM"

  let PCC = Category.create CategoryName
  /// Average Pressure: -
  let ``Average Pressure`` instance =
    { category = CategoryName; counter = "Average Pressure"; instance = instance }
  /// Current Pressure: -
  let ``Current Pressure`` instance =
    { category = CategoryName; counter = "Current Pressure"; instance = instance }
  /// Guest Visible Physical Memory: -
  let ``Guest Visible Physical Memory`` instance =
    { category = CategoryName; counter = "Guest Visible Physical Memory"; instance = instance }
  /// Maximum Pressure: -
  let ``Maximum Pressure`` instance =
    { category = CategoryName; counter = "Maximum Pressure"; instance = instance }
  /// Minimum Pressure: -
  let ``Minimum Pressure`` instance =
    { category = CategoryName; counter = "Minimum Pressure"; instance = instance }
  /// Physical Memory: -
  let ``Physical Memory`` instance =
    { category = CategoryName; counter = "Physical Memory"; instance = instance }
  /// Smart Paging Working Set Size: -
  let ``Smart Paging Working Set Size`` instance =
    { category = CategoryName; counter = "Smart Paging Working Set Size"; instance = instance }

  let allCounters =
    [| ``Average Pressure``
       ``Current Pressure``
       ``Guest Visible Physical Memory``
       ``Maximum Pressure``
       ``Minimum Pressure``
       ``Physical Memory``
       ``Smart Paging Working Set Size``
    |]

/// Hyper-V Hypervisor: Information on the hypervisor.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Hypervisor`` =

  [<Literal>]
  let CategoryName = "Hyper-V Hypervisor"

  let PCC = Category.create CategoryName
  /// Logical Processors: The number of logical processors present in the system.
  let ``Logical Processors`` =
    { category = CategoryName; counter = "Logical Processors"; instance = None }
  /// Modern Standby Entries: The number of modern/connected standby entry notifications received.
  let ``Modern Standby Entries`` =
    { category = CategoryName; counter = "Modern Standby Entries"; instance = None }
  /// Monitored Notifications: The number of monitored notifications registered with the hypervisor.
  let ``Monitored Notifications`` =
    { category = CategoryName; counter = "Monitored Notifications"; instance = None }
  /// Partitions: The number of partitions (virtual machines) present in the system.
  let ``Partitions`` =
    { category = CategoryName; counter = "Partitions"; instance = None }
  /// Platform Idle Transitions: The number of platform idle transitions.
  let ``Platform Idle Transitions`` =
    { category = CategoryName; counter = "Platform Idle Transitions"; instance = None }
  /// Total Pages: The number of bootstrap and deposited pages in the hypervisor.
  let ``Total Pages`` =
    { category = CategoryName; counter = "Total Pages"; instance = None }
  /// Virtual Processors: The number of virtual processors present in the system.
  let ``Virtual Processors`` =
    { category = CategoryName; counter = "Virtual Processors"; instance = None }

  let allCounters =
    [| ``Logical Processors``
       ``Modern Standby Entries``
       ``Monitored Notifications``
       ``Partitions``
       ``Platform Idle Transitions``
       ``Total Pages``
       ``Virtual Processors``
    |]

/// Hyper-V Hypervisor Logical Processor: Information on logical processors.
///
/// This performance counter does not have non-instance based counters
module ``Hyper-V Hypervisor Logical Processor`` =

  [<Literal>]
  let CategoryName = "Hyper-V Hypervisor Logical Processor"

  let PCC = Category.create CategoryName
  /// % C1 Time: % C1 Time is the percentage of time the processor spends in the C1 low-power idle state. % C1 Time is a subset of the total processor idle time.
  let ``% C1 Time`` instance =
    { category = CategoryName; counter = "% C1 Time"; instance = instance }
  /// % C2 Time: % C2 Time is the percentage of time the processor spends in the C2 low-power idle state. % C2 Time is a subset of the total processor idle time.
  let ``% C2 Time`` instance =
    { category = CategoryName; counter = "% C2 Time"; instance = instance }
  /// % C3 Time: % C3 Time is the percentage of time the processor spends in the C3 low-power idle state. % C3 Time is a subset of the total processor idle time.
  let ``% C3 Time`` instance =
    { category = CategoryName; counter = "% C3 Time"; instance = instance }
  /// % Guest Run Time: The percentage of time spent by the processor in guest code.
  let ``% Guest Run Time`` instance =
    { category = CategoryName; counter = "% Guest Run Time"; instance = instance }
  /// % Hypervisor Run Time: The percentage of time spent by the processor in hypervisor code.
  let ``% Hypervisor Run Time`` instance =
    { category = CategoryName; counter = "% Hypervisor Run Time"; instance = instance }
  /// % Idle Time: The percentage of time spent by the processor in an idle state.
  let ``% Idle Time`` instance =
    { category = CategoryName; counter = "% Idle Time"; instance = instance }
  /// % Total Run Time: The percentage of time spent by the processor in guest and hypervisor code.
  let ``% Total Run Time`` instance =
    { category = CategoryName; counter = "% Total Run Time"; instance = instance }
  /// % of Max Frequency: % of Maximum Frequency is the percentage of the current processor's maximum frequency.
  let ``% of Max Frequency`` instance =
    { category = CategoryName; counter = "% of Max Frequency"; instance = instance }
  /// C1 Transitions/sec: C1 Transitions/sec is the rate that CPU enters the C1 low-power idle state.
  let ``C1 Transitions/sec`` instance =
    { category = CategoryName; counter = "C1 Transitions/sec"; instance = instance }
  /// C2 Transitions/sec: C2 Transitions/sec is the rate that CPU enters the C2 low-power idle state.
  let ``C2 Transitions/sec`` instance =
    { category = CategoryName; counter = "C2 Transitions/sec"; instance = instance }
  /// C3 Transitions/sec: C3 Transitions/sec is the rate that CPU enters the C3 low-power idle state.
  let ``C3 Transitions/sec`` instance =
    { category = CategoryName; counter = "C3 Transitions/sec"; instance = instance }
  /// Context Switches/sec: The rate of virtual processor context switches on the processor.
  let ``Context Switches/sec`` instance =
    { category = CategoryName; counter = "Context Switches/sec"; instance = instance }
  /// Frequency: Processor Frequency is the frequency of the current processor in megahertz.
  let ``Frequency`` instance =
    { category = CategoryName; counter = "Frequency"; instance = instance }
  /// Hardware Interrupts/sec: The rate of hardware interrupts on the processor (excluding hypervisor interrupts).
  let ``Hardware Interrupts/sec`` instance =
    { category = CategoryName; counter = "Hardware Interrupts/sec"; instance = instance }
  /// Inter-Processor Interrupts Sent/sec: The rate of hypervisor inter-processor interrupts sent by the processor.
  let ``Inter-Processor Interrupts Sent/sec`` instance =
    { category = CategoryName; counter = "Inter-Processor Interrupts Sent/sec"; instance = instance }
  /// Inter-Processor Interrupts/sec: The rate of hypervisor inter-processor interrupts delivered to the processor.
  let ``Inter-Processor Interrupts/sec`` instance =
    { category = CategoryName; counter = "Inter-Processor Interrupts/sec"; instance = instance }
  /// Monitor Transition Cost: The hardware cost of transitions into the hypervisor.
  let ``Monitor Transition Cost`` instance =
    { category = CategoryName; counter = "Monitor Transition Cost"; instance = instance }
  /// Parking Status: Parking Status represents whether a processor is parked or not.
  let ``Parking Status`` instance =
    { category = CategoryName; counter = "Parking Status"; instance = instance }
  /// Processor State Flags: Processor State Flags
  let ``Processor State Flags`` instance =
    { category = CategoryName; counter = "Processor State Flags"; instance = instance }
  /// Root Vp Index: Index of the root virtual processor that is affinity bound to this logical processor.  A value that is greater than the maximum possible root VP index indicates no binding.
  let ``Root Vp Index`` instance =
    { category = CategoryName; counter = "Root Vp Index"; instance = instance }
  /// Scheduler Interrupts/sec: The rate of hypervisor scheduler interrupts on the processor.
  let ``Scheduler Interrupts/sec`` instance =
    { category = CategoryName; counter = "Scheduler Interrupts/sec"; instance = instance }
  /// Timer Interrupts/sec: The rate of hypervisor timer interrupts on the processor.
  let ``Timer Interrupts/sec`` instance =
    { category = CategoryName; counter = "Timer Interrupts/sec"; instance = instance }
  /// Total Interrupts/sec: The rate of hardware and hypervisor interrupts/sec.
  let ``Total Interrupts/sec`` instance =
    { category = CategoryName; counter = "Total Interrupts/sec"; instance = instance }

  let allCounters =
    [| ``% C1 Time``
       ``% C2 Time``
       ``% C3 Time``
       ``% Guest Run Time``
       ``% Hypervisor Run Time``
       ``% Idle Time``
       ``% Total Run Time``
       ``% of Max Frequency``
       ``C1 Transitions/sec``
       ``C2 Transitions/sec``
       ``C3 Transitions/sec``
       ``Context Switches/sec``
       ``Frequency``
       ``Hardware Interrupts/sec``
       ``Inter-Processor Interrupts Sent/sec``
       ``Inter-Processor Interrupts/sec``
       ``Monitor Transition Cost``
       ``Parking Status``
       ``Processor State Flags``
       ``Root Vp Index``
       ``Scheduler Interrupts/sec``
       ``Timer Interrupts/sec``
       ``Total Interrupts/sec``
    |]

/// Hyper-V Hypervisor Partition: Information on virtual machines
///
/// This performance counter does not have instance based counters
module ``Hyper-V Hypervisor Partition`` =

  [<Literal>]
  let CategoryName = "Hyper-V Hypervisor Partition"

  let PCC = Category.create CategoryName
  /// 1G GPA pages: -
  let ``1G GPA pages`` instance =
    { category = CategoryName; counter = "1G GPA pages"; instance = instance }
  /// 1G device pages: -
  let ``1G device pages`` instance =
    { category = CategoryName; counter = "1G device pages"; instance = instance }
  /// 2M GPA pages: -
  let ``2M GPA pages`` instance =
    { category = CategoryName; counter = "2M GPA pages"; instance = instance }
  /// 2M device pages: -
  let ``2M device pages`` instance =
    { category = CategoryName; counter = "2M device pages"; instance = instance }
  /// 4K GPA pages: -
  let ``4K GPA pages`` instance =
    { category = CategoryName; counter = "4K GPA pages"; instance = instance }
  /// 4K device pages: -
  let ``4K device pages`` instance =
    { category = CategoryName; counter = "4K device pages"; instance = instance }
  /// Address Spaces: -
  let ``Address Spaces`` instance =
    { category = CategoryName; counter = "Address Spaces"; instance = instance }
  /// Attached Devices: -
  let ``Attached Devices`` instance =
    { category = CategoryName; counter = "Attached Devices"; instance = instance }
  /// Deposited Pages: -
  let ``Deposited Pages`` instance =
    { category = CategoryName; counter = "Deposited Pages"; instance = instance }
  /// Device DMA Errors: -
  let ``Device DMA Errors`` instance =
    { category = CategoryName; counter = "Device DMA Errors"; instance = instance }
  /// Device Interrupt Errors: -
  let ``Device Interrupt Errors`` instance =
    { category = CategoryName; counter = "Device Interrupt Errors"; instance = instance }
  /// Device Interrupt Mappings: -
  let ``Device Interrupt Mappings`` instance =
    { category = CategoryName; counter = "Device Interrupt Mappings"; instance = instance }
  /// Device Interrupt Throttle Events: -
  let ``Device Interrupt Throttle Events`` instance =
    { category = CategoryName; counter = "Device Interrupt Throttle Events"; instance = instance }
  /// GPA Pages: -
  let ``GPA Pages`` instance =
    { category = CategoryName; counter = "GPA Pages"; instance = instance }
  /// GPA Space Modifications/sec: -
  let ``GPA Space Modifications/sec`` instance =
    { category = CategoryName; counter = "GPA Space Modifications/sec"; instance = instance }
  /// I/O TLB Flush Cost: -
  let ``I/O TLB Flush Cost`` instance =
    { category = CategoryName; counter = "I/O TLB Flush Cost"; instance = instance }
  /// I/O TLB Flushes/sec: -
  let ``I/O TLB Flushes/sec`` instance =
    { category = CategoryName; counter = "I/O TLB Flushes/sec"; instance = instance }
  /// Recommended Virtual TLB Size: -
  let ``Recommended Virtual TLB Size`` instance =
    { category = CategoryName; counter = "Recommended Virtual TLB Size"; instance = instance }
  /// Skipped Timer Ticks: -
  let ``Skipped Timer Ticks`` instance =
    { category = CategoryName; counter = "Skipped Timer Ticks"; instance = instance }
  /// Virtual Processors: -
  let ``Virtual Processors`` instance =
    { category = CategoryName; counter = "Virtual Processors"; instance = instance }
  /// Virtual TLB Flush Entires/sec: -
  let ``Virtual TLB Flush Entires/sec`` instance =
    { category = CategoryName; counter = "Virtual TLB Flush Entires/sec"; instance = instance }
  /// Virtual TLB Pages: -
  let ``Virtual TLB Pages`` instance =
    { category = CategoryName; counter = "Virtual TLB Pages"; instance = instance }

  let allCounters =
    [| ``1G GPA pages``
       ``1G device pages``
       ``2M GPA pages``
       ``2M device pages``
       ``4K GPA pages``
       ``4K device pages``
       ``Address Spaces``
       ``Attached Devices``
       ``Deposited Pages``
       ``Device DMA Errors``
       ``Device Interrupt Errors``
       ``Device Interrupt Mappings``
       ``Device Interrupt Throttle Events``
       ``GPA Pages``
       ``GPA Space Modifications/sec``
       ``I/O TLB Flush Cost``
       ``I/O TLB Flushes/sec``
       ``Recommended Virtual TLB Size``
       ``Skipped Timer Ticks``
       ``Virtual Processors``
       ``Virtual TLB Flush Entires/sec``
       ``Virtual TLB Pages``
    |]

/// Hyper-V Hypervisor Root Partition: Information on virtual machines
///
/// This performance counter does not have non-instance based counters
module ``Hyper-V Hypervisor Root Partition`` =

  [<Literal>]
  let CategoryName = "Hyper-V Hypervisor Root Partition"

  let PCC = Category.create CategoryName
  /// 1G GPA pages: The number of 1G pages present in the GPA space of the partition.
  let ``1G GPA pages`` instance =
    { category = CategoryName; counter = "1G GPA pages"; instance = instance }
  /// 1G device pages: The number of 1G pages present in the device space of the partition.
  let ``1G device pages`` instance =
    { category = CategoryName; counter = "1G device pages"; instance = instance }
  /// 2M GPA pages: The number of 2M pages present in the GPA space of the partition.
  let ``2M GPA pages`` instance =
    { category = CategoryName; counter = "2M GPA pages"; instance = instance }
  /// 2M device pages: The number of 2M pages present in the device space of the partition.
  let ``2M device pages`` instance =
    { category = CategoryName; counter = "2M device pages"; instance = instance }
  /// 4K GPA pages: The number of 4K pages present in the GPA space of the partition.
  let ``4K GPA pages`` instance =
    { category = CategoryName; counter = "4K GPA pages"; instance = instance }
  /// 4K device pages: The number of 4K pages present in the device space of the partition.
  let ``4K device pages`` instance =
    { category = CategoryName; counter = "4K device pages"; instance = instance }
  /// Address Spaces: The number of address spaces in the virtual TLB of the partition.
  let ``Address Spaces`` instance =
    { category = CategoryName; counter = "Address Spaces"; instance = instance }
  /// Attached Devices: The number of devices attached to the partition.
  let ``Attached Devices`` instance =
    { category = CategoryName; counter = "Attached Devices"; instance = instance }
  /// Deposited Pages: The number of pages deposited into the partition.
  let ``Deposited Pages`` instance =
    { category = CategoryName; counter = "Deposited Pages"; instance = instance }
  /// Device DMA Errors: An indicator of illegal DMA requests generated by all devices assigned to the partition.
  let ``Device DMA Errors`` instance =
    { category = CategoryName; counter = "Device DMA Errors"; instance = instance }
  /// Device Interrupt Errors: An indicator of illegal interrupt requests generated by all devices assigned to the partition.
  let ``Device Interrupt Errors`` instance =
    { category = CategoryName; counter = "Device Interrupt Errors"; instance = instance }
  /// Device Interrupt Mappings: The number of device interrupt mappings used by the partition.
  let ``Device Interrupt Mappings`` instance =
    { category = CategoryName; counter = "Device Interrupt Mappings"; instance = instance }
  /// Device Interrupt Throttle Events: The number of times an interrupt from a device assigned to the partition was temporarily throttled because the device was generating too many interrupts.
  let ``Device Interrupt Throttle Events`` instance =
    { category = CategoryName; counter = "Device Interrupt Throttle Events"; instance = instance }
  /// GPA Pages: The number of pages present in the GPA space of the partition (zero for root partition).
  let ``GPA Pages`` instance =
    { category = CategoryName; counter = "GPA Pages"; instance = instance }
  /// GPA Space Modifications/sec: The rate of modifications to the GPA space of the partition.
  let ``GPA Space Modifications/sec`` instance =
    { category = CategoryName; counter = "GPA Space Modifications/sec"; instance = instance }
  /// I/O TLB Flush Cost: The average time (in nanoseconds) spent processing an I/O TLB flush.
  let ``I/O TLB Flush Cost`` instance =
    { category = CategoryName; counter = "I/O TLB Flush Cost"; instance = instance }
  /// I/O TLB Flushes/sec: The rate of flushes of I/O TLBs of the partition.
  let ``I/O TLB Flushes/sec`` instance =
    { category = CategoryName; counter = "I/O TLB Flushes/sec"; instance = instance }
  /// Recommended Virtual TLB Size: The recommended number of pages to be deposited for the virtual TLB.
  let ``Recommended Virtual TLB Size`` instance =
    { category = CategoryName; counter = "Recommended Virtual TLB Size"; instance = instance }
  /// Skipped Timer Ticks: The number of timer interrupts skipped for the partition.
  let ``Skipped Timer Ticks`` instance =
    { category = CategoryName; counter = "Skipped Timer Ticks"; instance = instance }
  /// Virtual Processors: The number of virtual processors present in the partition.
  let ``Virtual Processors`` instance =
    { category = CategoryName; counter = "Virtual Processors"; instance = instance }
  /// Virtual TLB Flush Entires/sec: The rate of flushes of the entire virtual TLB.
  let ``Virtual TLB Flush Entires/sec`` instance =
    { category = CategoryName; counter = "Virtual TLB Flush Entires/sec"; instance = instance }
  /// Virtual TLB Pages: The number of pages used by the virtual TLB of the partition.
  let ``Virtual TLB Pages`` instance =
    { category = CategoryName; counter = "Virtual TLB Pages"; instance = instance }

  let allCounters =
    [| ``1G GPA pages``
       ``1G device pages``
       ``2M GPA pages``
       ``2M device pages``
       ``4K GPA pages``
       ``4K device pages``
       ``Address Spaces``
       ``Attached Devices``
       ``Deposited Pages``
       ``Device DMA Errors``
       ``Device Interrupt Errors``
       ``Device Interrupt Mappings``
       ``Device Interrupt Throttle Events``
       ``GPA Pages``
       ``GPA Space Modifications/sec``
       ``I/O TLB Flush Cost``
       ``I/O TLB Flushes/sec``
       ``Recommended Virtual TLB Size``
       ``Skipped Timer Ticks``
       ``Virtual Processors``
       ``Virtual TLB Flush Entires/sec``
       ``Virtual TLB Pages``
    |]

/// Hyper-V Hypervisor Root Virtual Processor: Information on virtual processors
///
/// This performance counter does not have non-instance based counters
module ``Hyper-V Hypervisor Root Virtual Processor`` =

  [<Literal>]
  let CategoryName = "Hyper-V Hypervisor Root Virtual Processor"

  let PCC = Category.create CategoryName
  /// % Guest Run Time: The percentage of time spent by the virtual processor in guest code.
  let ``% Guest Run Time`` instance =
    { category = CategoryName; counter = "% Guest Run Time"; instance = instance }
  /// % Hypervisor Run Time: The percentage of time spent by the virtual processor in hypervisor code.
  let ``% Hypervisor Run Time`` instance =
    { category = CategoryName; counter = "% Hypervisor Run Time"; instance = instance }
  /// % Remote Run Time: The percentage of time spent by the virtual processor running on a remote node.
  let ``% Remote Run Time`` instance =
    { category = CategoryName; counter = "% Remote Run Time"; instance = instance }
  /// % Total Run Time: The percentage of time spent by the virtual processor in guest and hypervisor code.
  let ``% Total Run Time`` instance =
    { category = CategoryName; counter = "% Total Run Time"; instance = instance }
  /// APIC EOI Accesses/sec: The rate of APIC EOI register writes by guest code on the virtual processor.
  let ``APIC EOI Accesses/sec`` instance =
    { category = CategoryName; counter = "APIC EOI Accesses/sec"; instance = instance }
  /// APIC IPIs Sent/sec: The rate of APIC inter-processor interrupts (including to self) sent by the virtual processor.
  let ``APIC IPIs Sent/sec`` instance =
    { category = CategoryName; counter = "APIC IPIs Sent/sec"; instance = instance }
  /// APIC MMIO Accesses/sec: The rate of APIC MMIO register accesses by guest code on the virtual processor.
  let ``APIC MMIO Accesses/sec`` instance =
    { category = CategoryName; counter = "APIC MMIO Accesses/sec"; instance = instance }
  /// APIC Self IPIs Sent/sec: The rate of APIC interrupts sent by the virtual processor to itself.
  let ``APIC Self IPIs Sent/sec`` instance =
    { category = CategoryName; counter = "APIC Self IPIs Sent/sec"; instance = instance }
  /// APIC TPR Accesses/sec: The rate of APIC TPR accesses by guest code on the virtual processor.
  let ``APIC TPR Accesses/sec`` instance =
    { category = CategoryName; counter = "APIC TPR Accesses/sec"; instance = instance }
  /// Address Domain Flushes/sec: The rate of explicit flushes of the virtual TLB by guest code on the virtual processor.
  let ``Address Domain Flushes/sec`` instance =
    { category = CategoryName; counter = "Address Domain Flushes/sec"; instance = instance }
  /// Address Space Evictions/sec: The rate of address space evictions in the virtual TLB.
  let ``Address Space Evictions/sec`` instance =
    { category = CategoryName; counter = "Address Space Evictions/sec"; instance = instance }
  /// Address Space Flushes/sec: The rate of explicit flushes of one address space by guest code on the virtual processor.
  let ``Address Space Flushes/sec`` instance =
    { category = CategoryName; counter = "Address Space Flushes/sec"; instance = instance }
  /// Address Space Switches/sec: The rate of address space switches by guest code on the virtual processor.
  let ``Address Space Switches/sec`` instance =
    { category = CategoryName; counter = "Address Space Switches/sec"; instance = instance }
  /// CPU Wait Time Per Dispatch: The average time (in nanoseconds) spent waiting for a virtual processor to be dispatched onto a logical processor.
  let ``CPU Wait Time Per Dispatch`` instance =
    { category = CategoryName; counter = "CPU Wait Time Per Dispatch"; instance = instance }
  /// CPUID Instructions Cost: The average time (in nanoseconds) spent processing a CPUID instruction.
  let ``CPUID Instructions Cost`` instance =
    { category = CategoryName; counter = "CPUID Instructions Cost"; instance = instance }
  /// CPUID Instructions Forwarded/sec: The rate of CPUID instructions forwarded to the nested hypervisor on the virtual processor.
  let ``CPUID Instructions Forwarded/sec`` instance =
    { category = CategoryName; counter = "CPUID Instructions Forwarded/sec"; instance = instance }
  /// CPUID Instructions Forwarding Cost: The average time (in nanoseconds) spent forwarding a CPUID instruction.
  let ``CPUID Instructions Forwarding Cost`` instance =
    { category = CategoryName; counter = "CPUID Instructions Forwarding Cost"; instance = instance }
  /// CPUID Instructions/sec: The rate of CPUID instructions executed by guest code on the virtual processor.
  let ``CPUID Instructions/sec`` instance =
    { category = CategoryName; counter = "CPUID Instructions/sec"; instance = instance }
  /// Control Register Accesses Cost: The average time (in nanoseconds) spent processing a control register access.
  let ``Control Register Accesses Cost`` instance =
    { category = CategoryName; counter = "Control Register Accesses Cost"; instance = instance }
  /// Control Register Accesses Forwarded/sec: The rate of control register accesses forwarded to the nested hypervisor on the virtual processor.
  let ``Control Register Accesses Forwarded/sec`` instance =
    { category = CategoryName; counter = "Control Register Accesses Forwarded/sec"; instance = instance }
  /// Control Register Accesses Forwarding Cost: The average time (in nanoseconds) spent forwarding a control register access.
  let ``Control Register Accesses Forwarding Cost`` instance =
    { category = CategoryName; counter = "Control Register Accesses Forwarding Cost"; instance = instance }
  /// Control Register Accesses/sec: The rate of control register accesses by guest code on the virtual processor.
  let ``Control Register Accesses/sec`` instance =
    { category = CategoryName; counter = "Control Register Accesses/sec"; instance = instance }
  /// Debug Register Accesses Cost: The average time (in nanoseconds) spent handling a debug register access.
  let ``Debug Register Accesses Cost`` instance =
    { category = CategoryName; counter = "Debug Register Accesses Cost"; instance = instance }
  /// Debug Register Accesses Forwarded/sec: The rate of debug register accesses forwarded to the nested hypervisor on the virtual processor.
  let ``Debug Register Accesses Forwarded/sec`` instance =
    { category = CategoryName; counter = "Debug Register Accesses Forwarded/sec"; instance = instance }
  /// Debug Register Accesses Forwarding Cost: The average time (in nanoseconds) spent forwarding a debug register access.
  let ``Debug Register Accesses Forwarding Cost`` instance =
    { category = CategoryName; counter = "Debug Register Accesses Forwarding Cost"; instance = instance }
  /// Debug Register Accesses/sec: The rate of debug register accesses by guest code on the virtual processor.
  let ``Debug Register Accesses/sec`` instance =
    { category = CategoryName; counter = "Debug Register Accesses/sec"; instance = instance }
  /// Emulated Instructions Cost: The average time (in nanoseconds) spent emulating an instruction.
  let ``Emulated Instructions Cost`` instance =
    { category = CategoryName; counter = "Emulated Instructions Cost"; instance = instance }
  /// Emulated Instructions Forwarded/sec: The rate of emulated instructions forwarded to the nested hypervisor on the virtual processor.
  let ``Emulated Instructions Forwarded/sec`` instance =
    { category = CategoryName; counter = "Emulated Instructions Forwarded/sec"; instance = instance }
  /// Emulated Instructions Forwarding Cost: The average time (in nanoseconds) spent forwareding an emulated instruction.
  let ``Emulated Instructions Forwarding Cost`` instance =
    { category = CategoryName; counter = "Emulated Instructions Forwarding Cost"; instance = instance }
  /// Emulated Instructions/sec: The rate of emulated instructions while executing guest code on the virtual processor.
  let ``Emulated Instructions/sec`` instance =
    { category = CategoryName; counter = "Emulated Instructions/sec"; instance = instance }
  /// Extended Hypercall Intercept Messages/sec: The rate of extended hypercall intercept messages to the parent partition.
  let ``Extended Hypercall Intercept Messages/sec`` instance =
    { category = CategoryName; counter = "Extended Hypercall Intercept Messages/sec"; instance = instance }
  /// Extended Hypercalls/sec: The number of extended hypercalls made by guest code on the virtual processor.
  let ``Extended Hypercalls/sec`` instance =
    { category = CategoryName; counter = "Extended Hypercalls/sec"; instance = instance }
  /// External Interrupts Cost: The average time (in nanoseconds) spent processing an external interrupt.
  let ``External Interrupts Cost`` instance =
    { category = CategoryName; counter = "External Interrupts Cost"; instance = instance }
  /// External Interrupts Forwarded/sec: The rate of external interrupts forwarded to the nested hypervisor on the virtual processor.
  let ``External Interrupts Forwarded/sec`` instance =
    { category = CategoryName; counter = "External Interrupts Forwarded/sec"; instance = instance }
  /// External Interrupts Forwarding Cost: The average time (in nanoseconds) spent forwarding an external interrupt.
  let ``External Interrupts Forwarding Cost`` instance =
    { category = CategoryName; counter = "External Interrupts Forwarding Cost"; instance = instance }
  /// External Interrupts/sec: The rate of external interrupts received by the hypervisor while executing guest code on the virtual processor.
  let ``External Interrupts/sec`` instance =
    { category = CategoryName; counter = "External Interrupts/sec"; instance = instance }
  /// GPA Space Hypercalls/sec: The rate of Guest Physical Address Space hypercalls made by guest code on the virtual processor.
  let ``GPA Space Hypercalls/sec`` instance =
    { category = CategoryName; counter = "GPA Space Hypercalls/sec"; instance = instance }
  /// Global GVA Range Flushes/sec: The rate of explicit flushes of a virtual address range in all address spaces by guest code on the virtual processor.
  let ``Global GVA Range Flushes/sec`` instance =
    { category = CategoryName; counter = "Global GVA Range Flushes/sec"; instance = instance }
  /// Global I/O TLB Flush Cost: The average time (in nanoseconds) spent processing a global I/O TLB flush.
  let ``Global I/O TLB Flush Cost`` instance =
    { category = CategoryName; counter = "Global I/O TLB Flush Cost"; instance = instance }
  /// Global I/O TLB Flushes/sec: The rate of flushes of I/O TLBs for all PASIDs made by the virtual processor.
  let ``Global I/O TLB Flushes/sec`` instance =
    { category = CategoryName; counter = "Global I/O TLB Flushes/sec"; instance = instance }
  /// Guest Page Table Maps/sec: The rate of map operations for guest page table pages.
  let ``Guest Page Table Maps/sec`` instance =
    { category = CategoryName; counter = "Guest Page Table Maps/sec"; instance = instance }
  /// HLT Instructions Cost: The average time (in nanoseconds) spent processing a HLT instruction.
  let ``HLT Instructions Cost`` instance =
    { category = CategoryName; counter = "HLT Instructions Cost"; instance = instance }
  /// HLT Instructions Forwarded/sec: The rate of HLT instructions forwarded to the nested hypervisor on the virtual processor.
  let ``HLT Instructions Forwarded/sec`` instance =
    { category = CategoryName; counter = "HLT Instructions Forwarded/sec"; instance = instance }
  /// HLT Instructions Forwarding Cost: The average time (in nanoseconds) spent forwarding a HLT instruction.
  let ``HLT Instructions Forwarding Cost`` instance =
    { category = CategoryName; counter = "HLT Instructions Forwarding Cost"; instance = instance }
  /// HLT Instructions/sec: The rate of HLT instructions executed by guest code on the virtual processor.
  let ``HLT Instructions/sec`` instance =
    { category = CategoryName; counter = "HLT Instructions/sec"; instance = instance }
  /// Hardware Interrupts/sec: The rate of hardware interrupts from attached devices on the virtual processor.
  let ``Hardware Interrupts/sec`` instance =
    { category = CategoryName; counter = "Hardware Interrupts/sec"; instance = instance }
  /// Hypercalls Cost: The average time (in nanoseconds) spent processing a hypercall.
  let ``Hypercalls Cost`` instance =
    { category = CategoryName; counter = "Hypercalls Cost"; instance = instance }
  /// Hypercalls Forwarded/sec: The rate of hypercalls forwarded to the nested hypervisor on the virtual processor.
  let ``Hypercalls Forwarded/sec`` instance =
    { category = CategoryName; counter = "Hypercalls Forwarded/sec"; instance = instance }
  /// Hypercalls Forwarding Cost: The average time (in nanoseconds) spent forwarding a hypercall.
  let ``Hypercalls Forwarding Cost`` instance =
    { category = CategoryName; counter = "Hypercalls Forwarding Cost"; instance = instance }
  /// Hypercalls/sec: The rate of hypercalls made by guest code on the virtual processor.
  let ``Hypercalls/sec`` instance =
    { category = CategoryName; counter = "Hypercalls/sec"; instance = instance }
  /// IO Instructions Cost: The average time (in nanoseconds) spent processing an IO instruction.
  let ``IO Instructions Cost`` instance =
    { category = CategoryName; counter = "IO Instructions Cost"; instance = instance }
  /// IO Instructions Forwarded/sec: The rate of IO instructions forwarded to the nested hypervisor on the virtual processor.
  let ``IO Instructions Forwarded/sec`` instance =
    { category = CategoryName; counter = "IO Instructions Forwarded/sec"; instance = instance }
  /// IO Instructions Forwarding Cost: The average time (in nanoseconds) spent forwarding an IO instruction.
  let ``IO Instructions Forwarding Cost`` instance =
    { category = CategoryName; counter = "IO Instructions Forwarding Cost"; instance = instance }
  /// IO Instructions/sec: The rate of IO instructions executed by guest code on the virtual processor.
  let ``IO Instructions/sec`` instance =
    { category = CategoryName; counter = "IO Instructions/sec"; instance = instance }
  /// IO Intercept Messages/sec: The rate of IO intercept messages sent to the parent partition.
  let ``IO Intercept Messages/sec`` instance =
    { category = CategoryName; counter = "IO Intercept Messages/sec"; instance = instance }
  /// InvEpt All Context Emulation Intercepts/sec: The rate of InvEpt All Context instructions emulated while executing guest code on the virtual processor.
  let ``InvEpt All Context Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "InvEpt All Context Emulation Intercepts/sec"; instance = instance }
  /// InvEpt All Context Instruction Emulation Cost: The average time (in nanoseconds) spent emulating an InvEpt All Context intercept.
  let ``InvEpt All Context Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "InvEpt All Context Instruction Emulation Cost"; instance = instance }
  /// InvEpt Single Context Emulation Intercepts/sec: The rate of InvEpt Single Context instructions emulated while executing guest code on the virtual processor.
  let ``InvEpt Single Context Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "InvEpt Single Context Emulation Intercepts/sec"; instance = instance }
  /// InvEpt Single Context Instruction Emulation Cost: The average time (in nanoseconds) spent emulating an InvEpt Single Context intercept.
  let ``InvEpt Single Context Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "InvEpt Single Context Instruction Emulation Cost"; instance = instance }
  /// InvVpid All Context Emulation Intercepts/sec: The rate of InvVpid All Context instructions emulated while executing guest code on the virtual processor.
  let ``InvVpid All Context Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "InvVpid All Context Emulation Intercepts/sec"; instance = instance }
  /// InvVpid All Context Instruction Emulation Cost: The average time (in nanoseconds) spent emulating an InvVpid All Context intercept.
  let ``InvVpid All Context Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "InvVpid All Context Instruction Emulation Cost"; instance = instance }
  /// InvVpid Single Address Emulation Intercepts/sec: The rate of InvVpid Single Address instructions emulated while executing guest code on the virtual processor.
  let ``InvVpid Single Address Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "InvVpid Single Address Emulation Intercepts/sec"; instance = instance }
  /// InvVpid Single Address Instruction Emulation Cost: The average time (in nanoseconds) spent emulating an InvVpid Single Address intercept.
  let ``InvVpid Single Address Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "InvVpid Single Address Instruction Emulation Cost"; instance = instance }
  /// InvVpid Single Context Emulation Intercepts/sec: The rate of InvVpid Single Context instructions emulated while executing guest code on the virtual processor.
  let ``InvVpid Single Context Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "InvVpid Single Context Emulation Intercepts/sec"; instance = instance }
  /// InvVpid Single Context Instruction Emulation Cost: The average time (in nanoseconds) spent emulating an InvVpid Single Context intercept.
  let ``InvVpid Single Context Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "InvVpid Single Context Instruction Emulation Cost"; instance = instance }
  /// Large Page TLB Fills/sec: The rate of virtual TLB misses on large pages.
  let ``Large Page TLB Fills/sec`` instance =
    { category = CategoryName; counter = "Large Page TLB Fills/sec"; instance = instance }
  /// Local Flushed GVA Ranges/sec: The rate of explicit flushes of a virtual address range in one address space by guest code on the virtual processor.
  let ``Local Flushed GVA Ranges/sec`` instance =
    { category = CategoryName; counter = "Local Flushed GVA Ranges/sec"; instance = instance }
  /// Local I/O TLB Flush Cost: The average time (in nanoseconds) spent processing a local I/O TLB flush.
  let ``Local I/O TLB Flush Cost`` instance =
    { category = CategoryName; counter = "Local I/O TLB Flush Cost"; instance = instance }
  /// Local I/O TLB Flushes/sec: The rate of flushes of I/O TLBs for one PASID made by the virtual processor.
  let ``Local I/O TLB Flushes/sec`` instance =
    { category = CategoryName; counter = "Local I/O TLB Flushes/sec"; instance = instance }
  /// Logical Processor Dispatches/sec: The rate of dispatches of this virtual processor onto logical processors.
  let ``Logical Processor Dispatches/sec`` instance =
    { category = CategoryName; counter = "Logical Processor Dispatches/sec"; instance = instance }
  /// Logical Processor Hypercalls/sec: The rate of Logical Processor hypercalls made by guest code on the virtual processor.
  let ``Logical Processor Hypercalls/sec`` instance =
    { category = CategoryName; counter = "Logical Processor Hypercalls/sec"; instance = instance }
  /// Logical Processor Migrations/sec: The rate of migrations by the virtual processor to a different logical processor.
  let ``Logical Processor Migrations/sec`` instance =
    { category = CategoryName; counter = "Logical Processor Migrations/sec"; instance = instance }
  /// Long Spin Wait Hypercalls/sec: The rate of Long Spin Wait hypercalls made by guest code on the virtual processor.
  let ``Long Spin Wait Hypercalls/sec`` instance =
    { category = CategoryName; counter = "Long Spin Wait Hypercalls/sec"; instance = instance }
  /// MBEC Nested Page Table Switches/sec: The rate of nested page table switches for mode based execution that the hypervisor initiated while executing the guest virtual processor.
  let ``MBEC Nested Page Table Switches/sec`` instance =
    { category = CategoryName; counter = "MBEC Nested Page Table Switches/sec"; instance = instance }
  /// MSR Accesses Cost: The average time (in nanoseconds) spent processing an MSR instruction.
  let ``MSR Accesses Cost`` instance =
    { category = CategoryName; counter = "MSR Accesses Cost"; instance = instance }
  /// MSR Accesses Forwarded/sec: The rate of MSR instructions forwarded to the nested hypervisor on the virtual processor.
  let ``MSR Accesses Forwarded/sec`` instance =
    { category = CategoryName; counter = "MSR Accesses Forwarded/sec"; instance = instance }
  /// MSR Accesses Forwarding Cost: The average time (in nanoseconds) spent forwarding an MSR instruction.
  let ``MSR Accesses Forwarding Cost`` instance =
    { category = CategoryName; counter = "MSR Accesses Forwarding Cost"; instance = instance }
  /// MSR Accesses/sec: The rate of MSR instructions executed by guest code on the virtual processor.
  let ``MSR Accesses/sec`` instance =
    { category = CategoryName; counter = "MSR Accesses/sec"; instance = instance }
  /// MWAIT Instructions Cost: The average time (in nanoseconds) spent processing an MWAIT instruction.
  let ``MWAIT Instructions Cost`` instance =
    { category = CategoryName; counter = "MWAIT Instructions Cost"; instance = instance }
  /// MWAIT Instructions Forwarded/sec: The rate of MWAIT instructions forwarded to the nested hypervisor on the virtual processor.
  let ``MWAIT Instructions Forwarded/sec`` instance =
    { category = CategoryName; counter = "MWAIT Instructions Forwarded/sec"; instance = instance }
  /// MWAIT Instructions Forwarding Cost: The average time (in nanoseconds) spent forwarding an MWAIT instruction.
  let ``MWAIT Instructions Forwarding Cost`` instance =
    { category = CategoryName; counter = "MWAIT Instructions Forwarding Cost"; instance = instance }
  /// MWAIT Instructions/sec: The rate of MWAIT instructions executed by guest code on the virtual processor.
  let ``MWAIT Instructions/sec`` instance =
    { category = CategoryName; counter = "MWAIT Instructions/sec"; instance = instance }
  /// Memory Intercept Messages/sec: The rate of memory intercept messages sent to the parent partition.
  let ``Memory Intercept Messages/sec`` instance =
    { category = CategoryName; counter = "Memory Intercept Messages/sec"; instance = instance }
  /// Nested Page Fault Intercepts Cost: The average time (in nanoseconds) spent processing a nested page fault intercept.
  let ``Nested Page Fault Intercepts Cost`` instance =
    { category = CategoryName; counter = "Nested Page Fault Intercepts Cost"; instance = instance }
  /// Nested Page Fault Intercepts/sec: The rate of nested page fault exceptions intercepted by the hypervisor while executing the guest virtual processor.
  let ``Nested Page Fault Intercepts/sec`` instance =
    { category = CategoryName; counter = "Nested Page Fault Intercepts/sec"; instance = instance }
  /// Nested SLAT Hard Page Faults Cost: The average time (in nanoseconds) spent processing a nested SLAT hard page fault.
  let ``Nested SLAT Hard Page Faults Cost`` instance =
    { category = CategoryName; counter = "Nested SLAT Hard Page Faults Cost"; instance = instance }
  /// Nested SLAT Hard Page Faults/sec: The rate of nested SLAT hard page faults while executing guest code on the virtual processor.
  let ``Nested SLAT Hard Page Faults/sec`` instance =
    { category = CategoryName; counter = "Nested SLAT Hard Page Faults/sec"; instance = instance }
  /// Nested SLAT Soft Page Faults Cost: The average time (in nanoseconds) spent processing a nested SLAT soft page fault.
  let ``Nested SLAT Soft Page Faults Cost`` instance =
    { category = CategoryName; counter = "Nested SLAT Soft Page Faults Cost"; instance = instance }
  /// Nested SLAT Soft Page Faults/sec: The rate of nested SLAT soft page faults while executing guest code on the virtual processor.
  let ``Nested SLAT Soft Page Faults/sec`` instance =
    { category = CategoryName; counter = "Nested SLAT Soft Page Faults/sec"; instance = instance }
  /// Nested SLAT page table evictions/sec: The rate of evictions of shadow nested page tables.
  let ``Nested SLAT page table evictions/sec`` instance =
    { category = CategoryName; counter = "Nested SLAT page table evictions/sec"; instance = instance }
  /// Nested SLAT page table reclamations/sec: The rate of reclamations of unlinked shadow nested page tables.
  let ``Nested SLAT page table reclamations/sec`` instance =
    { category = CategoryName; counter = "Nested SLAT page table reclamations/sec"; instance = instance }
  /// Nested VM Entries Cost: The average time (in nanoseconds) spent processing a nested VM entry.
  let ``Nested VM Entries Cost`` instance =
    { category = CategoryName; counter = "Nested VM Entries Cost"; instance = instance }
  /// Nested VM Entries/sec: The rate of nested VM entries while executing guest code on the virtual processor.
  let ``Nested VM Entries/sec`` instance =
    { category = CategoryName; counter = "Nested VM Entries/sec"; instance = instance }
  /// Other Hypercalls/sec: The rate of other hypercalls made by guest code on the virtual processor.
  let ``Other Hypercalls/sec`` instance =
    { category = CategoryName; counter = "Other Hypercalls/sec"; instance = instance }
  /// Other Intercepts Cost: The average time (in nanoseconds) spent processing other intercepts.
  let ``Other Intercepts Cost`` instance =
    { category = CategoryName; counter = "Other Intercepts Cost"; instance = instance }
  /// Other Intercepts Forwarded/sec: The rate of other intercepts forwarded to the nested hypervisor on the virtual processor.
  let ``Other Intercepts Forwarded/sec`` instance =
    { category = CategoryName; counter = "Other Intercepts Forwarded/sec"; instance = instance }
  /// Other Intercepts Forwarding Cost: The average time (in nanoseconds) spent forwarding other intercepts.
  let ``Other Intercepts Forwarding Cost`` instance =
    { category = CategoryName; counter = "Other Intercepts Forwarding Cost"; instance = instance }
  /// Other Intercepts/sec: The rate of other intercepts triggered by guest code on the virtual processor.
  let ``Other Intercepts/sec`` instance =
    { category = CategoryName; counter = "Other Intercepts/sec"; instance = instance }
  /// Other Messages/sec: The rate of other intercept messages sent to the parent partition.
  let ``Other Messages/sec`` instance =
    { category = CategoryName; counter = "Other Messages/sec"; instance = instance }
  /// Other Reflected Guest Exceptions/sec: The rate of non-page fault exceptions delivered to the guest.
  let ``Other Reflected Guest Exceptions/sec`` instance =
    { category = CategoryName; counter = "Other Reflected Guest Exceptions/sec"; instance = instance }
  /// Page Fault Intercepts Cost: The average time (in nanoseconds) spent processing a page fault intercept.
  let ``Page Fault Intercepts Cost`` instance =
    { category = CategoryName; counter = "Page Fault Intercepts Cost"; instance = instance }
  /// Page Fault Intercepts Forwarded/sec: The rate of page fault exceptions forwarded to the nested hypervisor while executing guest code on the virtual processor.
  let ``Page Fault Intercepts Forwarded/sec`` instance =
    { category = CategoryName; counter = "Page Fault Intercepts Forwarded/sec"; instance = instance }
  /// Page Fault Intercepts Forwarding Cost: The average time (in nanoseconds) spent forwarding a page fault intercept.
  let ``Page Fault Intercepts Forwarding Cost`` instance =
    { category = CategoryName; counter = "Page Fault Intercepts Forwarding Cost"; instance = instance }
  /// Page Fault Intercepts/sec: The rate of page fault exceptions intercepted by the hypervisor while executing guest code on the virtual processor.
  let ``Page Fault Intercepts/sec`` instance =
    { category = CategoryName; counter = "Page Fault Intercepts/sec"; instance = instance }
  /// Page Invalidations Cost: The average time (in nanoseconds) spent processing an INVLPG instruction.
  let ``Page Invalidations Cost`` instance =
    { category = CategoryName; counter = "Page Invalidations Cost"; instance = instance }
  /// Page Invalidations Forwarded/sec: The rate of INVLPG instructions forwarded to the nested hypervisor on the virtual processor.
  let ``Page Invalidations Forwarded/sec`` instance =
    { category = CategoryName; counter = "Page Invalidations Forwarded/sec"; instance = instance }
  /// Page Invalidations Forwarding Cost: The average time (in nanoseconds) spent forwarding an INVLPG instruction.
  let ``Page Invalidations Forwarding Cost`` instance =
    { category = CategoryName; counter = "Page Invalidations Forwarding Cost"; instance = instance }
  /// Page Invalidations/sec: The rate of INVLPG instructions executed by guest code on the virtual processor.
  let ``Page Invalidations/sec`` instance =
    { category = CategoryName; counter = "Page Invalidations/sec"; instance = instance }
  /// Page Table Allocations/sec: The rate of page table allocations in the virtual TLB.
  let ``Page Table Allocations/sec`` instance =
    { category = CategoryName; counter = "Page Table Allocations/sec"; instance = instance }
  /// Page Table Evictions/sec: The rate of page table evictions in the virtual TLB.
  let ``Page Table Evictions/sec`` instance =
    { category = CategoryName; counter = "Page Table Evictions/sec"; instance = instance }
  /// Page Table Reclamations/sec: The rate of reclamations of unreferenced page tables in the virtual TLB.
  let ``Page Table Reclamations/sec`` instance =
    { category = CategoryName; counter = "Page Table Reclamations/sec"; instance = instance }
  /// Page Table Resets/sec: The rate of page table resets in the virtual TLB.
  let ``Page Table Resets/sec`` instance =
    { category = CategoryName; counter = "Page Table Resets/sec"; instance = instance }
  /// Page Table Validations/sec: The rate of page table validations to remove stale entries in the virtual TLB.
  let ``Page Table Validations/sec`` instance =
    { category = CategoryName; counter = "Page Table Validations/sec"; instance = instance }
  /// Page Table Write Intercepts/sec: The rate of write intercepts on guest page tables by guest code on the virtual processor.
  let ``Page Table Write Intercepts/sec`` instance =
    { category = CategoryName; counter = "Page Table Write Intercepts/sec"; instance = instance }
  /// Pending Interrupts Cost: The average time (in nanoseconds) spent processing a pending interrupt intercept.
  let ``Pending Interrupts Cost`` instance =
    { category = CategoryName; counter = "Pending Interrupts Cost"; instance = instance }
  /// Pending Interrupts Forwarded/sec: The rate of intercepts due to a task priority (TPR) reduction forwarded to the nested hypervisor on the virtual processor.
  let ``Pending Interrupts Forwarded/sec`` instance =
    { category = CategoryName; counter = "Pending Interrupts Forwarded/sec"; instance = instance }
  /// Pending Interrupts Forwarding Cost: The average time (in nanoseconds) spent forwarding a pending interrupt intercept.
  let ``Pending Interrupts Forwarding Cost`` instance =
    { category = CategoryName; counter = "Pending Interrupts Forwarding Cost"; instance = instance }
  /// Pending Interrupts/sec: The rate of intercepts due to a task priority (TPR) reduction by guest code on the virtual processor.
  let ``Pending Interrupts/sec`` instance =
    { category = CategoryName; counter = "Pending Interrupts/sec"; instance = instance }
  /// Reflected Guest Page Faults/sec: The rate of page fault exceptions delivered to the guest.
  let ``Reflected Guest Page Faults/sec`` instance =
    { category = CategoryName; counter = "Reflected Guest Page Faults/sec"; instance = instance }
  /// Small Page TLB Fills/sec: The rate of virtual TLB misses on 4K pages.
  let ``Small Page TLB Fills/sec`` instance =
    { category = CategoryName; counter = "Small Page TLB Fills/sec"; instance = instance }
  /// Synthetic Interrupt Hypercalls/sec: The rate of Synthetic Interrupt hypercalls made by guest code on the virtual processor.
  let ``Synthetic Interrupt Hypercalls/sec`` instance =
    { category = CategoryName; counter = "Synthetic Interrupt Hypercalls/sec"; instance = instance }
  /// Synthetic Interrupts/sec: The rate of synthetic interrupts delivered to the virtual processor.
  let ``Synthetic Interrupts/sec`` instance =
    { category = CategoryName; counter = "Synthetic Interrupts/sec"; instance = instance }
  /// Total Intercepts Cost: The average time (in nanoseconds) spent handling a hypervisor intercept.
  let ``Total Intercepts Cost`` instance =
    { category = CategoryName; counter = "Total Intercepts Cost"; instance = instance }
  /// Total Intercepts Forwarded/sec: The rate of hypervisor intercept forwards.
  let ``Total Intercepts Forwarded/sec`` instance =
    { category = CategoryName; counter = "Total Intercepts Forwarded/sec"; instance = instance }
  /// Total Intercepts Forwarding Cost: The average time (in nanoseconds) spent forwarding a hypervisor intercept.
  let ``Total Intercepts Forwarding Cost`` instance =
    { category = CategoryName; counter = "Total Intercepts Forwarding Cost"; instance = instance }
  /// Total Intercepts/sec: The rate of hypervisor intercepts messages.
  let ``Total Intercepts/sec`` instance =
    { category = CategoryName; counter = "Total Intercepts/sec"; instance = instance }
  /// Total Messages/sec: The rate of total messages sent to the parent partition.
  let ``Total Messages/sec`` instance =
    { category = CategoryName; counter = "Total Messages/sec"; instance = instance }
  /// Total Virtualization Instructions Emulated/sec: The rate of virtualization instructions emulated.
  let ``Total Virtualization Instructions Emulated/sec`` instance =
    { category = CategoryName; counter = "Total Virtualization Instructions Emulated/sec"; instance = instance }
  /// Total Virtualization Instructions Emulation Cost: The average time (in nanoseconds) spent emulating a virtualization extension instruction.
  let ``Total Virtualization Instructions Emulation Cost`` instance =
    { category = CategoryName; counter = "Total Virtualization Instructions Emulation Cost"; instance = instance }
  /// VMCLEAR Emulation Intercepts/sec: The rate of VMCLEAR instructions emulated while executing guest code on the virtual processor.
  let ``VMCLEAR Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "VMCLEAR Emulation Intercepts/sec"; instance = instance }
  /// VMCLEAR Instruction Emulation Cost: The average time (in nanoseconds) spent enumulating a VMCLEAR instruction.
  let ``VMCLEAR Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "VMCLEAR Instruction Emulation Cost"; instance = instance }
  /// VMPTRLD Emulation Intercepts/sec: The rate of VMPTRLD instructions emulated while executing guest code on the virtual processor.
  let ``VMPTRLD Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "VMPTRLD Emulation Intercepts/sec"; instance = instance }
  /// VMPTRLD Instruction Emulation Cost: The average time (in nanoseconds) spent enumulating a VMPTRLD instruction.
  let ``VMPTRLD Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "VMPTRLD Instruction Emulation Cost"; instance = instance }
  /// VMPTRST Emulation Intercepts/sec: The rate of VMPTRST instructions emulated while executing guest code on the virtual processor.
  let ``VMPTRST Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "VMPTRST Emulation Intercepts/sec"; instance = instance }
  /// VMPTRST Instruction Emulation Cost: The average time (in nanoseconds) spent enumulating a VMPTRST instruction.
  let ``VMPTRST Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "VMPTRST Instruction Emulation Cost"; instance = instance }
  /// VMREAD Emulation Intercepts/sec: The rate of VMREAD instructions emulated while executing guest code on the virtual processor.
  let ``VMREAD Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "VMREAD Emulation Intercepts/sec"; instance = instance }
  /// VMREAD Instruction Emulation Cost: The average time (in nanoseconds) spent enumulating a VMREAD instruction.
  let ``VMREAD Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "VMREAD Instruction Emulation Cost"; instance = instance }
  /// VMWRITE Emulation Intercepts/sec: The rate of VMWRITE instructions emulated while executing guest code on the virtual processor.
  let ``VMWRITE Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "VMWRITE Emulation Intercepts/sec"; instance = instance }
  /// VMWRITE Instruction Emulation Cost: The average time (in nanoseconds) spent enumulating a VMWRITE instruction.
  let ``VMWRITE Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "VMWRITE Instruction Emulation Cost"; instance = instance }
  /// VMXOFF Emulation Intercepts/sec: The rate of VMXOFF instructions emulated while executing guest code on the virtual processor.
  let ``VMXOFF Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "VMXOFF Emulation Intercepts/sec"; instance = instance }
  /// VMXOFF Instruction Emulation Cost: The average time (in nanoseconds) spent enumulating a VMXOFF instruction.
  let ``VMXOFF Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "VMXOFF Instruction Emulation Cost"; instance = instance }
  /// VMXON Emulation Intercepts/sec: The rate of VMXON instructions emulated while executing guest code on the virtual processor.
  let ``VMXON Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "VMXON Emulation Intercepts/sec"; instance = instance }
  /// VMXON Instruction Emulation Cost: The average time (in nanoseconds) spent enumulating a VMXON instruction.
  let ``VMXON Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "VMXON Instruction Emulation Cost"; instance = instance }
  /// Virtual Interrupt Hypercalls/sec: The rate of Virtual Interrupt hypercalls made by guest code on the virtual processor.
  let ``Virtual Interrupt Hypercalls/sec`` instance =
    { category = CategoryName; counter = "Virtual Interrupt Hypercalls/sec"; instance = instance }
  /// Virtual Interrupts/sec: The rate of interrupts (including synthetic interrupts) delivered to the virtual processor.
  let ``Virtual Interrupts/sec`` instance =
    { category = CategoryName; counter = "Virtual Interrupts/sec"; instance = instance }
  /// Virtual MMU Hypercalls/sec: The rate of Virtual MMU hypercalls made by guest code on the virtual processor.
  let ``Virtual MMU Hypercalls/sec`` instance =
    { category = CategoryName; counter = "Virtual MMU Hypercalls/sec"; instance = instance }
  /// Virtual Processor Hypercalls/sec: The rate of Virtual Processor hypercalls made by guest code on the virtual processor.
  let ``Virtual Processor Hypercalls/sec`` instance =
    { category = CategoryName; counter = "Virtual Processor Hypercalls/sec"; instance = instance }

  let allCounters =
    [| ``% Guest Run Time``
       ``% Hypervisor Run Time``
       ``% Remote Run Time``
       ``% Total Run Time``
       ``APIC EOI Accesses/sec``
       ``APIC IPIs Sent/sec``
       ``APIC MMIO Accesses/sec``
       ``APIC Self IPIs Sent/sec``
       ``APIC TPR Accesses/sec``
       ``Address Domain Flushes/sec``
       ``Address Space Evictions/sec``
       ``Address Space Flushes/sec``
       ``Address Space Switches/sec``
       ``CPU Wait Time Per Dispatch``
       ``CPUID Instructions Cost``
       ``CPUID Instructions Forwarded/sec``
       ``CPUID Instructions Forwarding Cost``
       ``CPUID Instructions/sec``
       ``Control Register Accesses Cost``
       ``Control Register Accesses Forwarded/sec``
       ``Control Register Accesses Forwarding Cost``
       ``Control Register Accesses/sec``
       ``Debug Register Accesses Cost``
       ``Debug Register Accesses Forwarded/sec``
       ``Debug Register Accesses Forwarding Cost``
       ``Debug Register Accesses/sec``
       ``Emulated Instructions Cost``
       ``Emulated Instructions Forwarded/sec``
       ``Emulated Instructions Forwarding Cost``
       ``Emulated Instructions/sec``
       ``Extended Hypercall Intercept Messages/sec``
       ``Extended Hypercalls/sec``
       ``External Interrupts Cost``
       ``External Interrupts Forwarded/sec``
       ``External Interrupts Forwarding Cost``
       ``External Interrupts/sec``
       ``GPA Space Hypercalls/sec``
       ``Global GVA Range Flushes/sec``
       ``Global I/O TLB Flush Cost``
       ``Global I/O TLB Flushes/sec``
       ``Guest Page Table Maps/sec``
       ``HLT Instructions Cost``
       ``HLT Instructions Forwarded/sec``
       ``HLT Instructions Forwarding Cost``
       ``HLT Instructions/sec``
       ``Hardware Interrupts/sec``
       ``Hypercalls Cost``
       ``Hypercalls Forwarded/sec``
       ``Hypercalls Forwarding Cost``
       ``Hypercalls/sec``
       ``IO Instructions Cost``
       ``IO Instructions Forwarded/sec``
       ``IO Instructions Forwarding Cost``
       ``IO Instructions/sec``
       ``IO Intercept Messages/sec``
       ``InvEpt All Context Emulation Intercepts/sec``
       ``InvEpt All Context Instruction Emulation Cost``
       ``InvEpt Single Context Emulation Intercepts/sec``
       ``InvEpt Single Context Instruction Emulation Cost``
       ``InvVpid All Context Emulation Intercepts/sec``
       ``InvVpid All Context Instruction Emulation Cost``
       ``InvVpid Single Address Emulation Intercepts/sec``
       ``InvVpid Single Address Instruction Emulation Cost``
       ``InvVpid Single Context Emulation Intercepts/sec``
       ``InvVpid Single Context Instruction Emulation Cost``
       ``Large Page TLB Fills/sec``
       ``Local Flushed GVA Ranges/sec``
       ``Local I/O TLB Flush Cost``
       ``Local I/O TLB Flushes/sec``
       ``Logical Processor Dispatches/sec``
       ``Logical Processor Hypercalls/sec``
       ``Logical Processor Migrations/sec``
       ``Long Spin Wait Hypercalls/sec``
       ``MBEC Nested Page Table Switches/sec``
       ``MSR Accesses Cost``
       ``MSR Accesses Forwarded/sec``
       ``MSR Accesses Forwarding Cost``
       ``MSR Accesses/sec``
       ``MWAIT Instructions Cost``
       ``MWAIT Instructions Forwarded/sec``
       ``MWAIT Instructions Forwarding Cost``
       ``MWAIT Instructions/sec``
       ``Memory Intercept Messages/sec``
       ``Nested Page Fault Intercepts Cost``
       ``Nested Page Fault Intercepts/sec``
       ``Nested SLAT Hard Page Faults Cost``
       ``Nested SLAT Hard Page Faults/sec``
       ``Nested SLAT Soft Page Faults Cost``
       ``Nested SLAT Soft Page Faults/sec``
       ``Nested SLAT page table evictions/sec``
       ``Nested SLAT page table reclamations/sec``
       ``Nested VM Entries Cost``
       ``Nested VM Entries/sec``
       ``Other Hypercalls/sec``
       ``Other Intercepts Cost``
       ``Other Intercepts Forwarded/sec``
       ``Other Intercepts Forwarding Cost``
       ``Other Intercepts/sec``
       ``Other Messages/sec``
       ``Other Reflected Guest Exceptions/sec``
       ``Page Fault Intercepts Cost``
       ``Page Fault Intercepts Forwarded/sec``
       ``Page Fault Intercepts Forwarding Cost``
       ``Page Fault Intercepts/sec``
       ``Page Invalidations Cost``
       ``Page Invalidations Forwarded/sec``
       ``Page Invalidations Forwarding Cost``
       ``Page Invalidations/sec``
       ``Page Table Allocations/sec``
       ``Page Table Evictions/sec``
       ``Page Table Reclamations/sec``
       ``Page Table Resets/sec``
       ``Page Table Validations/sec``
       ``Page Table Write Intercepts/sec``
       ``Pending Interrupts Cost``
       ``Pending Interrupts Forwarded/sec``
       ``Pending Interrupts Forwarding Cost``
       ``Pending Interrupts/sec``
       ``Reflected Guest Page Faults/sec``
       ``Small Page TLB Fills/sec``
       ``Synthetic Interrupt Hypercalls/sec``
       ``Synthetic Interrupts/sec``
       ``Total Intercepts Cost``
       ``Total Intercepts Forwarded/sec``
       ``Total Intercepts Forwarding Cost``
       ``Total Intercepts/sec``
       ``Total Messages/sec``
       ``Total Virtualization Instructions Emulated/sec``
       ``Total Virtualization Instructions Emulation Cost``
       ``VMCLEAR Emulation Intercepts/sec``
       ``VMCLEAR Instruction Emulation Cost``
       ``VMPTRLD Emulation Intercepts/sec``
       ``VMPTRLD Instruction Emulation Cost``
       ``VMPTRST Emulation Intercepts/sec``
       ``VMPTRST Instruction Emulation Cost``
       ``VMREAD Emulation Intercepts/sec``
       ``VMREAD Instruction Emulation Cost``
       ``VMWRITE Emulation Intercepts/sec``
       ``VMWRITE Instruction Emulation Cost``
       ``VMXOFF Emulation Intercepts/sec``
       ``VMXOFF Instruction Emulation Cost``
       ``VMXON Emulation Intercepts/sec``
       ``VMXON Instruction Emulation Cost``
       ``Virtual Interrupt Hypercalls/sec``
       ``Virtual Interrupts/sec``
       ``Virtual MMU Hypercalls/sec``
       ``Virtual Processor Hypercalls/sec``
    |]

/// Hyper-V Hypervisor Virtual Processor: Information on virtual processors
///
/// This performance counter does not have instance based counters
module ``Hyper-V Hypervisor Virtual Processor`` =

  [<Literal>]
  let CategoryName = "Hyper-V Hypervisor Virtual Processor"

  let PCC = Category.create CategoryName
  /// % Guest Run Time: -
  let ``% Guest Run Time`` instance =
    { category = CategoryName; counter = "% Guest Run Time"; instance = instance }
  /// % Hypervisor Run Time: -
  let ``% Hypervisor Run Time`` instance =
    { category = CategoryName; counter = "% Hypervisor Run Time"; instance = instance }
  /// % Remote Run Time: -
  let ``% Remote Run Time`` instance =
    { category = CategoryName; counter = "% Remote Run Time"; instance = instance }
  /// % Total Run Time: -
  let ``% Total Run Time`` instance =
    { category = CategoryName; counter = "% Total Run Time"; instance = instance }
  /// APIC EOI Accesses/sec: -
  let ``APIC EOI Accesses/sec`` instance =
    { category = CategoryName; counter = "APIC EOI Accesses/sec"; instance = instance }
  /// APIC IPIs Sent/sec: -
  let ``APIC IPIs Sent/sec`` instance =
    { category = CategoryName; counter = "APIC IPIs Sent/sec"; instance = instance }
  /// APIC MMIO Accesses/sec: -
  let ``APIC MMIO Accesses/sec`` instance =
    { category = CategoryName; counter = "APIC MMIO Accesses/sec"; instance = instance }
  /// APIC Self IPIs Sent/sec: -
  let ``APIC Self IPIs Sent/sec`` instance =
    { category = CategoryName; counter = "APIC Self IPIs Sent/sec"; instance = instance }
  /// APIC TPR Accesses/sec: -
  let ``APIC TPR Accesses/sec`` instance =
    { category = CategoryName; counter = "APIC TPR Accesses/sec"; instance = instance }
  /// Address Domain Flushes/sec: -
  let ``Address Domain Flushes/sec`` instance =
    { category = CategoryName; counter = "Address Domain Flushes/sec"; instance = instance }
  /// Address Space Evictions/sec: -
  let ``Address Space Evictions/sec`` instance =
    { category = CategoryName; counter = "Address Space Evictions/sec"; instance = instance }
  /// Address Space Flushes/sec: -
  let ``Address Space Flushes/sec`` instance =
    { category = CategoryName; counter = "Address Space Flushes/sec"; instance = instance }
  /// Address Space Switches/sec: -
  let ``Address Space Switches/sec`` instance =
    { category = CategoryName; counter = "Address Space Switches/sec"; instance = instance }
  /// CPU Wait Time Per Dispatch: -
  let ``CPU Wait Time Per Dispatch`` instance =
    { category = CategoryName; counter = "CPU Wait Time Per Dispatch"; instance = instance }
  /// CPUID Instructions Cost: -
  let ``CPUID Instructions Cost`` instance =
    { category = CategoryName; counter = "CPUID Instructions Cost"; instance = instance }
  /// CPUID Instructions Forwarded/sec: -
  let ``CPUID Instructions Forwarded/sec`` instance =
    { category = CategoryName; counter = "CPUID Instructions Forwarded/sec"; instance = instance }
  /// CPUID Instructions Forwarding Cost: -
  let ``CPUID Instructions Forwarding Cost`` instance =
    { category = CategoryName; counter = "CPUID Instructions Forwarding Cost"; instance = instance }
  /// CPUID Instructions/sec: -
  let ``CPUID Instructions/sec`` instance =
    { category = CategoryName; counter = "CPUID Instructions/sec"; instance = instance }
  /// Control Register Accesses Cost: -
  let ``Control Register Accesses Cost`` instance =
    { category = CategoryName; counter = "Control Register Accesses Cost"; instance = instance }
  /// Control Register Accesses Forwarded/sec: -
  let ``Control Register Accesses Forwarded/sec`` instance =
    { category = CategoryName; counter = "Control Register Accesses Forwarded/sec"; instance = instance }
  /// Control Register Accesses Forwarding Cost: -
  let ``Control Register Accesses Forwarding Cost`` instance =
    { category = CategoryName; counter = "Control Register Accesses Forwarding Cost"; instance = instance }
  /// Control Register Accesses/sec: -
  let ``Control Register Accesses/sec`` instance =
    { category = CategoryName; counter = "Control Register Accesses/sec"; instance = instance }
  /// Debug Register Accesses Cost: -
  let ``Debug Register Accesses Cost`` instance =
    { category = CategoryName; counter = "Debug Register Accesses Cost"; instance = instance }
  /// Debug Register Accesses Forwarded/sec: -
  let ``Debug Register Accesses Forwarded/sec`` instance =
    { category = CategoryName; counter = "Debug Register Accesses Forwarded/sec"; instance = instance }
  /// Debug Register Accesses Forwarding Cost: -
  let ``Debug Register Accesses Forwarding Cost`` instance =
    { category = CategoryName; counter = "Debug Register Accesses Forwarding Cost"; instance = instance }
  /// Debug Register Accesses/sec: -
  let ``Debug Register Accesses/sec`` instance =
    { category = CategoryName; counter = "Debug Register Accesses/sec"; instance = instance }
  /// Emulated Instructions Cost: -
  let ``Emulated Instructions Cost`` instance =
    { category = CategoryName; counter = "Emulated Instructions Cost"; instance = instance }
  /// Emulated Instructions Forwarded/sec: -
  let ``Emulated Instructions Forwarded/sec`` instance =
    { category = CategoryName; counter = "Emulated Instructions Forwarded/sec"; instance = instance }
  /// Emulated Instructions Forwarding Cost: -
  let ``Emulated Instructions Forwarding Cost`` instance =
    { category = CategoryName; counter = "Emulated Instructions Forwarding Cost"; instance = instance }
  /// Emulated Instructions/sec: -
  let ``Emulated Instructions/sec`` instance =
    { category = CategoryName; counter = "Emulated Instructions/sec"; instance = instance }
  /// Extended Hypercall Intercept Messages/sec: -
  let ``Extended Hypercall Intercept Messages/sec`` instance =
    { category = CategoryName; counter = "Extended Hypercall Intercept Messages/sec"; instance = instance }
  /// Extended Hypercalls/sec: -
  let ``Extended Hypercalls/sec`` instance =
    { category = CategoryName; counter = "Extended Hypercalls/sec"; instance = instance }
  /// External Interrupts Cost: -
  let ``External Interrupts Cost`` instance =
    { category = CategoryName; counter = "External Interrupts Cost"; instance = instance }
  /// External Interrupts Forwarded/sec: -
  let ``External Interrupts Forwarded/sec`` instance =
    { category = CategoryName; counter = "External Interrupts Forwarded/sec"; instance = instance }
  /// External Interrupts Forwarding Cost: -
  let ``External Interrupts Forwarding Cost`` instance =
    { category = CategoryName; counter = "External Interrupts Forwarding Cost"; instance = instance }
  /// External Interrupts/sec: -
  let ``External Interrupts/sec`` instance =
    { category = CategoryName; counter = "External Interrupts/sec"; instance = instance }
  /// GPA Space Hypercalls/sec: -
  let ``GPA Space Hypercalls/sec`` instance =
    { category = CategoryName; counter = "GPA Space Hypercalls/sec"; instance = instance }
  /// Global GVA Range Flushes/sec: -
  let ``Global GVA Range Flushes/sec`` instance =
    { category = CategoryName; counter = "Global GVA Range Flushes/sec"; instance = instance }
  /// Global I/O TLB Flush Cost: -
  let ``Global I/O TLB Flush Cost`` instance =
    { category = CategoryName; counter = "Global I/O TLB Flush Cost"; instance = instance }
  /// Global I/O TLB Flushes/sec: -
  let ``Global I/O TLB Flushes/sec`` instance =
    { category = CategoryName; counter = "Global I/O TLB Flushes/sec"; instance = instance }
  /// Guest Page Table Maps/sec: -
  let ``Guest Page Table Maps/sec`` instance =
    { category = CategoryName; counter = "Guest Page Table Maps/sec"; instance = instance }
  /// HLT Instructions Cost: -
  let ``HLT Instructions Cost`` instance =
    { category = CategoryName; counter = "HLT Instructions Cost"; instance = instance }
  /// HLT Instructions Forwarded/sec: -
  let ``HLT Instructions Forwarded/sec`` instance =
    { category = CategoryName; counter = "HLT Instructions Forwarded/sec"; instance = instance }
  /// HLT Instructions Forwarding Cost: -
  let ``HLT Instructions Forwarding Cost`` instance =
    { category = CategoryName; counter = "HLT Instructions Forwarding Cost"; instance = instance }
  /// HLT Instructions/sec: -
  let ``HLT Instructions/sec`` instance =
    { category = CategoryName; counter = "HLT Instructions/sec"; instance = instance }
  /// Hardware Interrupts/sec: -
  let ``Hardware Interrupts/sec`` instance =
    { category = CategoryName; counter = "Hardware Interrupts/sec"; instance = instance }
  /// Hypercalls Cost: -
  let ``Hypercalls Cost`` instance =
    { category = CategoryName; counter = "Hypercalls Cost"; instance = instance }
  /// Hypercalls Forwarded/sec: -
  let ``Hypercalls Forwarded/sec`` instance =
    { category = CategoryName; counter = "Hypercalls Forwarded/sec"; instance = instance }
  /// Hypercalls Forwarding Cost: -
  let ``Hypercalls Forwarding Cost`` instance =
    { category = CategoryName; counter = "Hypercalls Forwarding Cost"; instance = instance }
  /// Hypercalls/sec: -
  let ``Hypercalls/sec`` instance =
    { category = CategoryName; counter = "Hypercalls/sec"; instance = instance }
  /// IO Instructions Cost: -
  let ``IO Instructions Cost`` instance =
    { category = CategoryName; counter = "IO Instructions Cost"; instance = instance }
  /// IO Instructions Forwarded/sec: -
  let ``IO Instructions Forwarded/sec`` instance =
    { category = CategoryName; counter = "IO Instructions Forwarded/sec"; instance = instance }
  /// IO Instructions Forwarding Cost: -
  let ``IO Instructions Forwarding Cost`` instance =
    { category = CategoryName; counter = "IO Instructions Forwarding Cost"; instance = instance }
  /// IO Instructions/sec: -
  let ``IO Instructions/sec`` instance =
    { category = CategoryName; counter = "IO Instructions/sec"; instance = instance }
  /// IO Intercept Messages/sec: -
  let ``IO Intercept Messages/sec`` instance =
    { category = CategoryName; counter = "IO Intercept Messages/sec"; instance = instance }
  /// InvEpt All Context Emulation Intercepts/sec: -
  let ``InvEpt All Context Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "InvEpt All Context Emulation Intercepts/sec"; instance = instance }
  /// InvEpt All Context Instruction Emulation Cost: -
  let ``InvEpt All Context Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "InvEpt All Context Instruction Emulation Cost"; instance = instance }
  /// InvEpt Single Context Emulation Intercepts/sec: -
  let ``InvEpt Single Context Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "InvEpt Single Context Emulation Intercepts/sec"; instance = instance }
  /// InvEpt Single Context Instruction Emulation Cost: -
  let ``InvEpt Single Context Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "InvEpt Single Context Instruction Emulation Cost"; instance = instance }
  /// InvVpid All Context Emulation Intercepts/sec: -
  let ``InvVpid All Context Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "InvVpid All Context Emulation Intercepts/sec"; instance = instance }
  /// InvVpid All Context Instruction Emulation Cost: -
  let ``InvVpid All Context Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "InvVpid All Context Instruction Emulation Cost"; instance = instance }
  /// InvVpid Single Address Emulation Intercepts/sec: -
  let ``InvVpid Single Address Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "InvVpid Single Address Emulation Intercepts/sec"; instance = instance }
  /// InvVpid Single Address Instruction Emulation Cost: -
  let ``InvVpid Single Address Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "InvVpid Single Address Instruction Emulation Cost"; instance = instance }
  /// InvVpid Single Context Emulation Intercepts/sec: -
  let ``InvVpid Single Context Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "InvVpid Single Context Emulation Intercepts/sec"; instance = instance }
  /// InvVpid Single Context Instruction Emulation Cost: -
  let ``InvVpid Single Context Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "InvVpid Single Context Instruction Emulation Cost"; instance = instance }
  /// Large Page TLB Fills/sec: -
  let ``Large Page TLB Fills/sec`` instance =
    { category = CategoryName; counter = "Large Page TLB Fills/sec"; instance = instance }
  /// Local Flushed GVA Ranges/sec: -
  let ``Local Flushed GVA Ranges/sec`` instance =
    { category = CategoryName; counter = "Local Flushed GVA Ranges/sec"; instance = instance }
  /// Local I/O TLB Flush Cost: -
  let ``Local I/O TLB Flush Cost`` instance =
    { category = CategoryName; counter = "Local I/O TLB Flush Cost"; instance = instance }
  /// Local I/O TLB Flushes/sec: -
  let ``Local I/O TLB Flushes/sec`` instance =
    { category = CategoryName; counter = "Local I/O TLB Flushes/sec"; instance = instance }
  /// Logical Processor Dispatches/sec: -
  let ``Logical Processor Dispatches/sec`` instance =
    { category = CategoryName; counter = "Logical Processor Dispatches/sec"; instance = instance }
  /// Logical Processor Hypercalls/sec: -
  let ``Logical Processor Hypercalls/sec`` instance =
    { category = CategoryName; counter = "Logical Processor Hypercalls/sec"; instance = instance }
  /// Logical Processor Migrations/sec: -
  let ``Logical Processor Migrations/sec`` instance =
    { category = CategoryName; counter = "Logical Processor Migrations/sec"; instance = instance }
  /// Long Spin Wait Hypercalls/sec: -
  let ``Long Spin Wait Hypercalls/sec`` instance =
    { category = CategoryName; counter = "Long Spin Wait Hypercalls/sec"; instance = instance }
  /// MBEC Nested Page Table Switches/sec: -
  let ``MBEC Nested Page Table Switches/sec`` instance =
    { category = CategoryName; counter = "MBEC Nested Page Table Switches/sec"; instance = instance }
  /// MSR Accesses Cost: -
  let ``MSR Accesses Cost`` instance =
    { category = CategoryName; counter = "MSR Accesses Cost"; instance = instance }
  /// MSR Accesses Forwarded/sec: -
  let ``MSR Accesses Forwarded/sec`` instance =
    { category = CategoryName; counter = "MSR Accesses Forwarded/sec"; instance = instance }
  /// MSR Accesses Forwarding Cost: -
  let ``MSR Accesses Forwarding Cost`` instance =
    { category = CategoryName; counter = "MSR Accesses Forwarding Cost"; instance = instance }
  /// MSR Accesses/sec: -
  let ``MSR Accesses/sec`` instance =
    { category = CategoryName; counter = "MSR Accesses/sec"; instance = instance }
  /// MWAIT Instructions Cost: -
  let ``MWAIT Instructions Cost`` instance =
    { category = CategoryName; counter = "MWAIT Instructions Cost"; instance = instance }
  /// MWAIT Instructions Forwarded/sec: -
  let ``MWAIT Instructions Forwarded/sec`` instance =
    { category = CategoryName; counter = "MWAIT Instructions Forwarded/sec"; instance = instance }
  /// MWAIT Instructions Forwarding Cost: -
  let ``MWAIT Instructions Forwarding Cost`` instance =
    { category = CategoryName; counter = "MWAIT Instructions Forwarding Cost"; instance = instance }
  /// MWAIT Instructions/sec: -
  let ``MWAIT Instructions/sec`` instance =
    { category = CategoryName; counter = "MWAIT Instructions/sec"; instance = instance }
  /// Memory Intercept Messages/sec: -
  let ``Memory Intercept Messages/sec`` instance =
    { category = CategoryName; counter = "Memory Intercept Messages/sec"; instance = instance }
  /// Nested Page Fault Intercepts Cost: -
  let ``Nested Page Fault Intercepts Cost`` instance =
    { category = CategoryName; counter = "Nested Page Fault Intercepts Cost"; instance = instance }
  /// Nested Page Fault Intercepts/sec: -
  let ``Nested Page Fault Intercepts/sec`` instance =
    { category = CategoryName; counter = "Nested Page Fault Intercepts/sec"; instance = instance }
  /// Nested SLAT Hard Page Faults Cost: -
  let ``Nested SLAT Hard Page Faults Cost`` instance =
    { category = CategoryName; counter = "Nested SLAT Hard Page Faults Cost"; instance = instance }
  /// Nested SLAT Hard Page Faults/sec: -
  let ``Nested SLAT Hard Page Faults/sec`` instance =
    { category = CategoryName; counter = "Nested SLAT Hard Page Faults/sec"; instance = instance }
  /// Nested SLAT Soft Page Faults Cost: -
  let ``Nested SLAT Soft Page Faults Cost`` instance =
    { category = CategoryName; counter = "Nested SLAT Soft Page Faults Cost"; instance = instance }
  /// Nested SLAT Soft Page Faults/sec: -
  let ``Nested SLAT Soft Page Faults/sec`` instance =
    { category = CategoryName; counter = "Nested SLAT Soft Page Faults/sec"; instance = instance }
  /// Nested SLAT page table evictions/sec: -
  let ``Nested SLAT page table evictions/sec`` instance =
    { category = CategoryName; counter = "Nested SLAT page table evictions/sec"; instance = instance }
  /// Nested SLAT page table reclamations/sec: -
  let ``Nested SLAT page table reclamations/sec`` instance =
    { category = CategoryName; counter = "Nested SLAT page table reclamations/sec"; instance = instance }
  /// Nested VM Entries Cost: -
  let ``Nested VM Entries Cost`` instance =
    { category = CategoryName; counter = "Nested VM Entries Cost"; instance = instance }
  /// Nested VM Entries/sec: -
  let ``Nested VM Entries/sec`` instance =
    { category = CategoryName; counter = "Nested VM Entries/sec"; instance = instance }
  /// Other Hypercalls/sec: -
  let ``Other Hypercalls/sec`` instance =
    { category = CategoryName; counter = "Other Hypercalls/sec"; instance = instance }
  /// Other Intercepts Cost: -
  let ``Other Intercepts Cost`` instance =
    { category = CategoryName; counter = "Other Intercepts Cost"; instance = instance }
  /// Other Intercepts Forwarded/sec: -
  let ``Other Intercepts Forwarded/sec`` instance =
    { category = CategoryName; counter = "Other Intercepts Forwarded/sec"; instance = instance }
  /// Other Intercepts Forwarding Cost: -
  let ``Other Intercepts Forwarding Cost`` instance =
    { category = CategoryName; counter = "Other Intercepts Forwarding Cost"; instance = instance }
  /// Other Intercepts/sec: -
  let ``Other Intercepts/sec`` instance =
    { category = CategoryName; counter = "Other Intercepts/sec"; instance = instance }
  /// Other Messages/sec: -
  let ``Other Messages/sec`` instance =
    { category = CategoryName; counter = "Other Messages/sec"; instance = instance }
  /// Other Reflected Guest Exceptions/sec: -
  let ``Other Reflected Guest Exceptions/sec`` instance =
    { category = CategoryName; counter = "Other Reflected Guest Exceptions/sec"; instance = instance }
  /// Page Fault Intercepts Cost: -
  let ``Page Fault Intercepts Cost`` instance =
    { category = CategoryName; counter = "Page Fault Intercepts Cost"; instance = instance }
  /// Page Fault Intercepts Forwarded/sec: -
  let ``Page Fault Intercepts Forwarded/sec`` instance =
    { category = CategoryName; counter = "Page Fault Intercepts Forwarded/sec"; instance = instance }
  /// Page Fault Intercepts Forwarding Cost: -
  let ``Page Fault Intercepts Forwarding Cost`` instance =
    { category = CategoryName; counter = "Page Fault Intercepts Forwarding Cost"; instance = instance }
  /// Page Fault Intercepts/sec: -
  let ``Page Fault Intercepts/sec`` instance =
    { category = CategoryName; counter = "Page Fault Intercepts/sec"; instance = instance }
  /// Page Invalidations Cost: -
  let ``Page Invalidations Cost`` instance =
    { category = CategoryName; counter = "Page Invalidations Cost"; instance = instance }
  /// Page Invalidations Forwarded/sec: -
  let ``Page Invalidations Forwarded/sec`` instance =
    { category = CategoryName; counter = "Page Invalidations Forwarded/sec"; instance = instance }
  /// Page Invalidations Forwarding Cost: -
  let ``Page Invalidations Forwarding Cost`` instance =
    { category = CategoryName; counter = "Page Invalidations Forwarding Cost"; instance = instance }
  /// Page Invalidations/sec: -
  let ``Page Invalidations/sec`` instance =
    { category = CategoryName; counter = "Page Invalidations/sec"; instance = instance }
  /// Page Table Allocations/sec: -
  let ``Page Table Allocations/sec`` instance =
    { category = CategoryName; counter = "Page Table Allocations/sec"; instance = instance }
  /// Page Table Evictions/sec: -
  let ``Page Table Evictions/sec`` instance =
    { category = CategoryName; counter = "Page Table Evictions/sec"; instance = instance }
  /// Page Table Reclamations/sec: -
  let ``Page Table Reclamations/sec`` instance =
    { category = CategoryName; counter = "Page Table Reclamations/sec"; instance = instance }
  /// Page Table Resets/sec: -
  let ``Page Table Resets/sec`` instance =
    { category = CategoryName; counter = "Page Table Resets/sec"; instance = instance }
  /// Page Table Validations/sec: -
  let ``Page Table Validations/sec`` instance =
    { category = CategoryName; counter = "Page Table Validations/sec"; instance = instance }
  /// Page Table Write Intercepts/sec: -
  let ``Page Table Write Intercepts/sec`` instance =
    { category = CategoryName; counter = "Page Table Write Intercepts/sec"; instance = instance }
  /// Pending Interrupts Cost: -
  let ``Pending Interrupts Cost`` instance =
    { category = CategoryName; counter = "Pending Interrupts Cost"; instance = instance }
  /// Pending Interrupts Forwarded/sec: -
  let ``Pending Interrupts Forwarded/sec`` instance =
    { category = CategoryName; counter = "Pending Interrupts Forwarded/sec"; instance = instance }
  /// Pending Interrupts Forwarding Cost: -
  let ``Pending Interrupts Forwarding Cost`` instance =
    { category = CategoryName; counter = "Pending Interrupts Forwarding Cost"; instance = instance }
  /// Pending Interrupts/sec: -
  let ``Pending Interrupts/sec`` instance =
    { category = CategoryName; counter = "Pending Interrupts/sec"; instance = instance }
  /// Reflected Guest Page Faults/sec: -
  let ``Reflected Guest Page Faults/sec`` instance =
    { category = CategoryName; counter = "Reflected Guest Page Faults/sec"; instance = instance }
  /// Small Page TLB Fills/sec: -
  let ``Small Page TLB Fills/sec`` instance =
    { category = CategoryName; counter = "Small Page TLB Fills/sec"; instance = instance }
  /// Synthetic Interrupt Hypercalls/sec: -
  let ``Synthetic Interrupt Hypercalls/sec`` instance =
    { category = CategoryName; counter = "Synthetic Interrupt Hypercalls/sec"; instance = instance }
  /// Synthetic Interrupts/sec: -
  let ``Synthetic Interrupts/sec`` instance =
    { category = CategoryName; counter = "Synthetic Interrupts/sec"; instance = instance }
  /// Total Intercepts Cost: -
  let ``Total Intercepts Cost`` instance =
    { category = CategoryName; counter = "Total Intercepts Cost"; instance = instance }
  /// Total Intercepts Forwarded/sec: -
  let ``Total Intercepts Forwarded/sec`` instance =
    { category = CategoryName; counter = "Total Intercepts Forwarded/sec"; instance = instance }
  /// Total Intercepts Forwarding Cost: -
  let ``Total Intercepts Forwarding Cost`` instance =
    { category = CategoryName; counter = "Total Intercepts Forwarding Cost"; instance = instance }
  /// Total Intercepts/sec: -
  let ``Total Intercepts/sec`` instance =
    { category = CategoryName; counter = "Total Intercepts/sec"; instance = instance }
  /// Total Messages/sec: -
  let ``Total Messages/sec`` instance =
    { category = CategoryName; counter = "Total Messages/sec"; instance = instance }
  /// Total Virtualization Instructions Emulated/sec: -
  let ``Total Virtualization Instructions Emulated/sec`` instance =
    { category = CategoryName; counter = "Total Virtualization Instructions Emulated/sec"; instance = instance }
  /// Total Virtualization Instructions Emulation Cost: -
  let ``Total Virtualization Instructions Emulation Cost`` instance =
    { category = CategoryName; counter = "Total Virtualization Instructions Emulation Cost"; instance = instance }
  /// VMCLEAR Emulation Intercepts/sec: -
  let ``VMCLEAR Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "VMCLEAR Emulation Intercepts/sec"; instance = instance }
  /// VMCLEAR Instruction Emulation Cost: -
  let ``VMCLEAR Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "VMCLEAR Instruction Emulation Cost"; instance = instance }
  /// VMPTRLD Emulation Intercepts/sec: -
  let ``VMPTRLD Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "VMPTRLD Emulation Intercepts/sec"; instance = instance }
  /// VMPTRLD Instruction Emulation Cost: -
  let ``VMPTRLD Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "VMPTRLD Instruction Emulation Cost"; instance = instance }
  /// VMPTRST Emulation Intercepts/sec: -
  let ``VMPTRST Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "VMPTRST Emulation Intercepts/sec"; instance = instance }
  /// VMPTRST Instruction Emulation Cost: -
  let ``VMPTRST Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "VMPTRST Instruction Emulation Cost"; instance = instance }
  /// VMREAD Emulation Intercepts/sec: -
  let ``VMREAD Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "VMREAD Emulation Intercepts/sec"; instance = instance }
  /// VMREAD Instruction Emulation Cost: -
  let ``VMREAD Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "VMREAD Instruction Emulation Cost"; instance = instance }
  /// VMWRITE Emulation Intercepts/sec: -
  let ``VMWRITE Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "VMWRITE Emulation Intercepts/sec"; instance = instance }
  /// VMWRITE Instruction Emulation Cost: -
  let ``VMWRITE Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "VMWRITE Instruction Emulation Cost"; instance = instance }
  /// VMXOFF Emulation Intercepts/sec: -
  let ``VMXOFF Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "VMXOFF Emulation Intercepts/sec"; instance = instance }
  /// VMXOFF Instruction Emulation Cost: -
  let ``VMXOFF Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "VMXOFF Instruction Emulation Cost"; instance = instance }
  /// VMXON Emulation Intercepts/sec: -
  let ``VMXON Emulation Intercepts/sec`` instance =
    { category = CategoryName; counter = "VMXON Emulation Intercepts/sec"; instance = instance }
  /// VMXON Instruction Emulation Cost: -
  let ``VMXON Instruction Emulation Cost`` instance =
    { category = CategoryName; counter = "VMXON Instruction Emulation Cost"; instance = instance }
  /// Virtual Interrupt Hypercalls/sec: -
  let ``Virtual Interrupt Hypercalls/sec`` instance =
    { category = CategoryName; counter = "Virtual Interrupt Hypercalls/sec"; instance = instance }
  /// Virtual Interrupts/sec: -
  let ``Virtual Interrupts/sec`` instance =
    { category = CategoryName; counter = "Virtual Interrupts/sec"; instance = instance }
  /// Virtual MMU Hypercalls/sec: -
  let ``Virtual MMU Hypercalls/sec`` instance =
    { category = CategoryName; counter = "Virtual MMU Hypercalls/sec"; instance = instance }
  /// Virtual Processor Hypercalls/sec: -
  let ``Virtual Processor Hypercalls/sec`` instance =
    { category = CategoryName; counter = "Virtual Processor Hypercalls/sec"; instance = instance }

  let allCounters =
    [| ``% Guest Run Time``
       ``% Hypervisor Run Time``
       ``% Remote Run Time``
       ``% Total Run Time``
       ``APIC EOI Accesses/sec``
       ``APIC IPIs Sent/sec``
       ``APIC MMIO Accesses/sec``
       ``APIC Self IPIs Sent/sec``
       ``APIC TPR Accesses/sec``
       ``Address Domain Flushes/sec``
       ``Address Space Evictions/sec``
       ``Address Space Flushes/sec``
       ``Address Space Switches/sec``
       ``CPU Wait Time Per Dispatch``
       ``CPUID Instructions Cost``
       ``CPUID Instructions Forwarded/sec``
       ``CPUID Instructions Forwarding Cost``
       ``CPUID Instructions/sec``
       ``Control Register Accesses Cost``
       ``Control Register Accesses Forwarded/sec``
       ``Control Register Accesses Forwarding Cost``
       ``Control Register Accesses/sec``
       ``Debug Register Accesses Cost``
       ``Debug Register Accesses Forwarded/sec``
       ``Debug Register Accesses Forwarding Cost``
       ``Debug Register Accesses/sec``
       ``Emulated Instructions Cost``
       ``Emulated Instructions Forwarded/sec``
       ``Emulated Instructions Forwarding Cost``
       ``Emulated Instructions/sec``
       ``Extended Hypercall Intercept Messages/sec``
       ``Extended Hypercalls/sec``
       ``External Interrupts Cost``
       ``External Interrupts Forwarded/sec``
       ``External Interrupts Forwarding Cost``
       ``External Interrupts/sec``
       ``GPA Space Hypercalls/sec``
       ``Global GVA Range Flushes/sec``
       ``Global I/O TLB Flush Cost``
       ``Global I/O TLB Flushes/sec``
       ``Guest Page Table Maps/sec``
       ``HLT Instructions Cost``
       ``HLT Instructions Forwarded/sec``
       ``HLT Instructions Forwarding Cost``
       ``HLT Instructions/sec``
       ``Hardware Interrupts/sec``
       ``Hypercalls Cost``
       ``Hypercalls Forwarded/sec``
       ``Hypercalls Forwarding Cost``
       ``Hypercalls/sec``
       ``IO Instructions Cost``
       ``IO Instructions Forwarded/sec``
       ``IO Instructions Forwarding Cost``
       ``IO Instructions/sec``
       ``IO Intercept Messages/sec``
       ``InvEpt All Context Emulation Intercepts/sec``
       ``InvEpt All Context Instruction Emulation Cost``
       ``InvEpt Single Context Emulation Intercepts/sec``
       ``InvEpt Single Context Instruction Emulation Cost``
       ``InvVpid All Context Emulation Intercepts/sec``
       ``InvVpid All Context Instruction Emulation Cost``
       ``InvVpid Single Address Emulation Intercepts/sec``
       ``InvVpid Single Address Instruction Emulation Cost``
       ``InvVpid Single Context Emulation Intercepts/sec``
       ``InvVpid Single Context Instruction Emulation Cost``
       ``Large Page TLB Fills/sec``
       ``Local Flushed GVA Ranges/sec``
       ``Local I/O TLB Flush Cost``
       ``Local I/O TLB Flushes/sec``
       ``Logical Processor Dispatches/sec``
       ``Logical Processor Hypercalls/sec``
       ``Logical Processor Migrations/sec``
       ``Long Spin Wait Hypercalls/sec``
       ``MBEC Nested Page Table Switches/sec``
       ``MSR Accesses Cost``
       ``MSR Accesses Forwarded/sec``
       ``MSR Accesses Forwarding Cost``
       ``MSR Accesses/sec``
       ``MWAIT Instructions Cost``
       ``MWAIT Instructions Forwarded/sec``
       ``MWAIT Instructions Forwarding Cost``
       ``MWAIT Instructions/sec``
       ``Memory Intercept Messages/sec``
       ``Nested Page Fault Intercepts Cost``
       ``Nested Page Fault Intercepts/sec``
       ``Nested SLAT Hard Page Faults Cost``
       ``Nested SLAT Hard Page Faults/sec``
       ``Nested SLAT Soft Page Faults Cost``
       ``Nested SLAT Soft Page Faults/sec``
       ``Nested SLAT page table evictions/sec``
       ``Nested SLAT page table reclamations/sec``
       ``Nested VM Entries Cost``
       ``Nested VM Entries/sec``
       ``Other Hypercalls/sec``
       ``Other Intercepts Cost``
       ``Other Intercepts Forwarded/sec``
       ``Other Intercepts Forwarding Cost``
       ``Other Intercepts/sec``
       ``Other Messages/sec``
       ``Other Reflected Guest Exceptions/sec``
       ``Page Fault Intercepts Cost``
       ``Page Fault Intercepts Forwarded/sec``
       ``Page Fault Intercepts Forwarding Cost``
       ``Page Fault Intercepts/sec``
       ``Page Invalidations Cost``
       ``Page Invalidations Forwarded/sec``
       ``Page Invalidations Forwarding Cost``
       ``Page Invalidations/sec``
       ``Page Table Allocations/sec``
       ``Page Table Evictions/sec``
       ``Page Table Reclamations/sec``
       ``Page Table Resets/sec``
       ``Page Table Validations/sec``
       ``Page Table Write Intercepts/sec``
       ``Pending Interrupts Cost``
       ``Pending Interrupts Forwarded/sec``
       ``Pending Interrupts Forwarding Cost``
       ``Pending Interrupts/sec``
       ``Reflected Guest Page Faults/sec``
       ``Small Page TLB Fills/sec``
       ``Synthetic Interrupt Hypercalls/sec``
       ``Synthetic Interrupts/sec``
       ``Total Intercepts Cost``
       ``Total Intercepts Forwarded/sec``
       ``Total Intercepts Forwarding Cost``
       ``Total Intercepts/sec``
       ``Total Messages/sec``
       ``Total Virtualization Instructions Emulated/sec``
       ``Total Virtualization Instructions Emulation Cost``
       ``VMCLEAR Emulation Intercepts/sec``
       ``VMCLEAR Instruction Emulation Cost``
       ``VMPTRLD Emulation Intercepts/sec``
       ``VMPTRLD Instruction Emulation Cost``
       ``VMPTRST Emulation Intercepts/sec``
       ``VMPTRST Instruction Emulation Cost``
       ``VMREAD Emulation Intercepts/sec``
       ``VMREAD Instruction Emulation Cost``
       ``VMWRITE Emulation Intercepts/sec``
       ``VMWRITE Instruction Emulation Cost``
       ``VMXOFF Emulation Intercepts/sec``
       ``VMXOFF Instruction Emulation Cost``
       ``VMXON Emulation Intercepts/sec``
       ``VMXON Instruction Emulation Cost``
       ``Virtual Interrupt Hypercalls/sec``
       ``Virtual Interrupts/sec``
       ``Virtual MMU Hypercalls/sec``
       ``Virtual Processor Hypercalls/sec``
    |]

/// Hyper-V Legacy Network Adapter: Performance counters for a virtual machine's Ethernet controller.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Legacy Network Adapter`` =

  [<Literal>]
  let CategoryName = "Hyper-V Legacy Network Adapter"

  let PCC = Category.create CategoryName
  /// Bytes Dropped: -
  let ``Bytes Dropped`` instance =
    { category = CategoryName; counter = "Bytes Dropped"; instance = instance }
  /// Bytes Received/sec: -
  let ``Bytes Received/sec`` instance =
    { category = CategoryName; counter = "Bytes Received/sec"; instance = instance }
  /// Bytes Sent/sec: -
  let ``Bytes Sent/sec`` instance =
    { category = CategoryName; counter = "Bytes Sent/sec"; instance = instance }
  /// Frames Dropped: -
  let ``Frames Dropped`` instance =
    { category = CategoryName; counter = "Frames Dropped"; instance = instance }
  /// Frames Received/sec: -
  let ``Frames Received/sec`` instance =
    { category = CategoryName; counter = "Frames Received/sec"; instance = instance }
  /// Frames Sent/sec: -
  let ``Frames Sent/sec`` instance =
    { category = CategoryName; counter = "Frames Sent/sec"; instance = instance }

  let allCounters =
    [| ``Bytes Dropped``
       ``Bytes Received/sec``
       ``Bytes Sent/sec``
       ``Frames Dropped``
       ``Frames Received/sec``
       ``Frames Sent/sec``
    |]

/// Hyper-V Replica VM: This counter set represents the Hyper-V Replica statistics for a virtual machine.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Replica VM`` =

  [<Literal>]
  let CategoryName = "Hyper-V Replica VM"

  let PCC = Category.create CategoryName
  /// Average Replication Latency: -
  let ``Average Replication Latency`` instance =
    { category = CategoryName; counter = "Average Replication Latency"; instance = instance }
  /// Average Replication Size: -
  let ``Average Replication Size`` instance =
    { category = CategoryName; counter = "Average Replication Size"; instance = instance }
  /// Compression Efficiency: -
  let ``Compression Efficiency`` instance =
    { category = CategoryName; counter = "Compression Efficiency"; instance = instance }
  /// Last Replication Size: -
  let ``Last Replication Size`` instance =
    { category = CategoryName; counter = "Last Replication Size"; instance = instance }
  /// Network Bytes Recv: -
  let ``Network Bytes Recv`` instance =
    { category = CategoryName; counter = "Network Bytes Recv"; instance = instance }
  /// Network Bytes Sent: -
  let ``Network Bytes Sent`` instance =
    { category = CategoryName; counter = "Network Bytes Sent"; instance = instance }
  /// Replication Count: -
  let ``Replication Count`` instance =
    { category = CategoryName; counter = "Replication Count"; instance = instance }
  /// Replication Latency: -
  let ``Replication Latency`` instance =
    { category = CategoryName; counter = "Replication Latency"; instance = instance }
  /// Resynchronized Bytes: -
  let ``Resynchronized Bytes`` instance =
    { category = CategoryName; counter = "Resynchronized Bytes"; instance = instance }

  let allCounters =
    [| ``Average Replication Latency``
       ``Average Replication Size``
       ``Compression Efficiency``
       ``Last Replication Size``
       ``Network Bytes Recv``
       ``Network Bytes Sent``
       ``Replication Count``
       ``Replication Latency``
       ``Resynchronized Bytes``
    |]


/// Hyper-V VM Live Migration: Performance counters for a virtual machine's live migration.
///
/// This performance counter does not have instance based counters
module ``Hyper-V VM Live Migration`` =

  [<Literal>]
  let CategoryName = "Hyper-V VM Live Migration"

  let PCC = Category.create CategoryName
  /// Compressor: Bytes to be Compressed: -
  let ``Compressor: Bytes to be Compressed`` instance =
    { category = CategoryName; counter = "Compressor: Bytes to be Compressed"; instance = instance }
  /// Compressor: Compressed Bytes Sent: -
  let ``Compressor: Compressed Bytes Sent`` instance =
    { category = CategoryName; counter = "Compressor: Compressed Bytes Sent"; instance = instance }
  /// Compressor: Compressed Bytes Sent/sec: -
  let ``Compressor: Compressed Bytes Sent/sec`` instance =
    { category = CategoryName; counter = "Compressor: Compressed Bytes Sent/sec"; instance = instance }
  /// Compressor: Enabled Threads: -
  let ``Compressor: Enabled Threads`` instance =
    { category = CategoryName; counter = "Compressor: Enabled Threads"; instance = instance }
  /// Compressor: Maximum Threads: -
  let ``Compressor: Maximum Threads`` instance =
    { category = CategoryName; counter = "Compressor: Maximum Threads"; instance = instance }
  /// Memory Walker: Bytes Read/sec: -
  let ``Memory Walker: Bytes Read/sec`` instance =
    { category = CategoryName; counter = "Memory Walker: Bytes Read/sec"; instance = instance }
  /// Memory Walker: Bytes Sent for Compression: -
  let ``Memory Walker: Bytes Sent for Compression`` instance =
    { category = CategoryName; counter = "Memory Walker: Bytes Sent for Compression"; instance = instance }
  /// Memory Walker: Bytes Sent for Compression/sec: -
  let ``Memory Walker: Bytes Sent for Compression/sec`` instance =
    { category = CategoryName; counter = "Memory Walker: Bytes Sent for Compression/sec"; instance = instance }
  /// Memory Walker: Maximum Threads: -
  let ``Memory Walker: Maximum Threads`` instance =
    { category = CategoryName; counter = "Memory Walker: Maximum Threads"; instance = instance }
  /// Memory Walker: Uncompressed Bytes Sent: -
  let ``Memory Walker: Uncompressed Bytes Sent`` instance =
    { category = CategoryName; counter = "Memory Walker: Uncompressed Bytes Sent"; instance = instance }
  /// Memory Walker: Uncompressed Bytes Sent/sec: -
  let ``Memory Walker: Uncompressed Bytes Sent/sec`` instance =
    { category = CategoryName; counter = "Memory Walker: Uncompressed Bytes Sent/sec"; instance = instance }
  /// Receiver: Bytes Pending Decompression: -
  let ``Receiver: Bytes Pending Decompression`` instance =
    { category = CategoryName; counter = "Receiver: Bytes Pending Decompression"; instance = instance }
  /// Receiver: Bytes Pending Write: -
  let ``Receiver: Bytes Pending Write`` instance =
    { category = CategoryName; counter = "Receiver: Bytes Pending Write"; instance = instance }
  /// Receiver: Bytes Written/sec: -
  let ``Receiver: Bytes Written/sec`` instance =
    { category = CategoryName; counter = "Receiver: Bytes Written/sec"; instance = instance }
  /// Receiver: Compressed Bytes Received/sec: -
  let ``Receiver: Compressed Bytes Received/sec`` instance =
    { category = CategoryName; counter = "Receiver: Compressed Bytes Received/sec"; instance = instance }
  /// Receiver: Decompressed Bytes/sec: -
  let ``Receiver: Decompressed Bytes/sec`` instance =
    { category = CategoryName; counter = "Receiver: Decompressed Bytes/sec"; instance = instance }
  /// Receiver: Maximum Threadpool Thread Count: -
  let ``Receiver: Maximum Threadpool Thread Count`` instance =
    { category = CategoryName; counter = "Receiver: Maximum Threadpool Thread Count"; instance = instance }
  /// Receiver: Uncompressed Bytes Received/sec: -
  let ``Receiver: Uncompressed Bytes Received/sec`` instance =
    { category = CategoryName; counter = "Receiver: Uncompressed Bytes Received/sec"; instance = instance }
  /// SMB Transport: Bytes Sent: -
  let ``SMB Transport: Bytes Sent`` instance =
    { category = CategoryName; counter = "SMB Transport: Bytes Sent"; instance = instance }
  /// SMB Transport: Bytes Sent/sec: -
  let ``SMB Transport: Bytes Sent/sec`` instance =
    { category = CategoryName; counter = "SMB Transport: Bytes Sent/sec"; instance = instance }
  /// SMB Transport: Pending Send Bytes: -
  let ``SMB Transport: Pending Send Bytes`` instance =
    { category = CategoryName; counter = "SMB Transport: Pending Send Bytes"; instance = instance }
  /// SMB Transport: Pending Send Count: -
  let ``SMB Transport: Pending Send Count`` instance =
    { category = CategoryName; counter = "SMB Transport: Pending Send Count"; instance = instance }
  /// TCP Transport: Bytes Pending Processing: -
  let ``TCP Transport: Bytes Pending Processing`` instance =
    { category = CategoryName; counter = "TCP Transport: Bytes Pending Processing"; instance = instance }
  /// TCP Transport: Bytes Pending Send: -
  let ``TCP Transport: Bytes Pending Send`` instance =
    { category = CategoryName; counter = "TCP Transport: Bytes Pending Send"; instance = instance }
  /// TCP Transport: Bytes Received/sec: -
  let ``TCP Transport: Bytes Received/sec`` instance =
    { category = CategoryName; counter = "TCP Transport: Bytes Received/sec"; instance = instance }
  /// TCP Transport: Bytes Sent/sec: -
  let ``TCP Transport: Bytes Sent/sec`` instance =
    { category = CategoryName; counter = "TCP Transport: Bytes Sent/sec"; instance = instance }
  /// TCP Transport: Pending Send Count: -
  let ``TCP Transport: Pending Send Count`` instance =
    { category = CategoryName; counter = "TCP Transport: Pending Send Count"; instance = instance }
  /// TCP Transport: Posted Receive Buffer Count: -
  let ``TCP Transport: Posted Receive Buffer Count`` instance =
    { category = CategoryName; counter = "TCP Transport: Posted Receive Buffer Count"; instance = instance }
  /// TCP Transport: Total buffer count: -
  let ``TCP Transport: Total buffer count`` instance =
    { category = CategoryName; counter = "TCP Transport: Total buffer count"; instance = instance }
  /// Transfer Pass: Is blackout: -
  let ``Transfer Pass: Is blackout`` instance =
    { category = CategoryName; counter = "Transfer Pass: Is blackout"; instance = instance }
  /// Transfer Pass: Number: -
  let ``Transfer Pass: Number`` instance =
    { category = CategoryName; counter = "Transfer Pass: Number"; instance = instance }
  /// Transfer pass: CPU Cap: -
  let ``Transfer pass: CPU Cap`` instance =
    { category = CategoryName; counter = "Transfer pass: CPU Cap"; instance = instance }
  /// Transfer pass: Dirty Page Count: -
  let ``Transfer pass: Dirty Page Count`` instance =
    { category = CategoryName; counter = "Transfer pass: Dirty Page Count"; instance = instance }

  let allCounters =
    [| ``Compressor: Bytes to be Compressed``
       ``Compressor: Compressed Bytes Sent``
       ``Compressor: Compressed Bytes Sent/sec``
       ``Compressor: Enabled Threads``
       ``Compressor: Maximum Threads``
       ``Memory Walker: Bytes Read/sec``
       ``Memory Walker: Bytes Sent for Compression``
       ``Memory Walker: Bytes Sent for Compression/sec``
       ``Memory Walker: Maximum Threads``
       ``Memory Walker: Uncompressed Bytes Sent``
       ``Memory Walker: Uncompressed Bytes Sent/sec``
       ``Receiver: Bytes Pending Decompression``
       ``Receiver: Bytes Pending Write``
       ``Receiver: Bytes Written/sec``
       ``Receiver: Compressed Bytes Received/sec``
       ``Receiver: Decompressed Bytes/sec``
       ``Receiver: Maximum Threadpool Thread Count``
       ``Receiver: Uncompressed Bytes Received/sec``
       ``SMB Transport: Bytes Sent``
       ``SMB Transport: Bytes Sent/sec``
       ``SMB Transport: Pending Send Bytes``
       ``SMB Transport: Pending Send Count``
       ``TCP Transport: Bytes Pending Processing``
       ``TCP Transport: Bytes Pending Send``
       ``TCP Transport: Bytes Received/sec``
       ``TCP Transport: Bytes Sent/sec``
       ``TCP Transport: Pending Send Count``
       ``TCP Transport: Posted Receive Buffer Count``
       ``TCP Transport: Total buffer count``
       ``Transfer Pass: Is blackout``
       ``Transfer Pass: Number``
       ``Transfer pass: CPU Cap``
       ``Transfer pass: Dirty Page Count``
    |]

/// Hyper-V VM Remoting: Performance counters for a virtual machine's remoting system.
///
/// This performance counter does not have instance based counters
module ``Hyper-V VM Remoting`` =

  [<Literal>]
  let CategoryName = "Hyper-V VM Remoting"

  let PCC = Category.create CategoryName
  /// Connected Clients: -
  let ``Connected Clients`` instance =
    { category = CategoryName; counter = "Connected Clients"; instance = instance }
  /// Updated Pixels/sec: -
  let ``Updated Pixels/sec`` instance =
    { category = CategoryName; counter = "Updated Pixels/sec"; instance = instance }

  let allCounters =
    [| ``Connected Clients``
       ``Updated Pixels/sec``
    |]

/// Hyper-V VM Save, Snapshot, and Restore: Performance counters for a virtual machine's save, snapshot, and restore systems.
///
/// This performance counter does not have instance based counters
module ``Hyper-V VM Save_ Snapshot_ and Restore`` =

  [<Literal>]
  let CategoryName = "Hyper-V VM Save, Snapshot, and Restore"

  let PCC = Category.create CategoryName
  /// Operation Time: -
  let ``Operation Time`` instance =
    { category = CategoryName; counter = "Operation Time"; instance = instance }
  /// Requests Active: -
  let ``Requests Active`` instance =
    { category = CategoryName; counter = "Requests Active"; instance = instance }
  /// Requests Dispatched: -
  let ``Requests Dispatched`` instance =
    { category = CategoryName; counter = "Requests Dispatched"; instance = instance }
  /// Requests High Priority: -
  let ``Requests High Priority`` instance =
    { category = CategoryName; counter = "Requests High Priority"; instance = instance }
  /// Requests Processed: -
  let ``Requests Processed`` instance =
    { category = CategoryName; counter = "Requests Processed"; instance = instance }
  /// Threads Spawned: -
  let ``Threads Spawned`` instance =
    { category = CategoryName; counter = "Threads Spawned"; instance = instance }

  let allCounters =
    [| ``Operation Time``
       ``Requests Active``
       ``Requests Dispatched``
       ``Requests High Priority``
       ``Requests Processed``
       ``Threads Spawned``
    |]


/// Hyper-V VM Vid Numa Node: The perf counters for a numa node.
///
/// This performance counter does not have non-instance based counters
module ``Hyper-V VM Vid Numa Node`` =

  [<Literal>]
  let CategoryName = "Hyper-V VM Vid Numa Node"

  let PCC = Category.create CategoryName
  /// PageCount: The number of physical pages detected on this NUMA node.
  let ``PageCount`` instance =
    { category = CategoryName; counter = "PageCount"; instance = instance }
  /// ProcessorCount: The number of logical processors detected on this NUMA node.
  let ``ProcessorCount`` instance =
    { category = CategoryName; counter = "ProcessorCount"; instance = instance }

  let allCounters =
    [| ``PageCount``
       ``ProcessorCount``
    |]

/// Hyper-V VM Vid Partition: These are the perf counters for a VID partition object.
///
/// This performance counter does not have instance based counters
module ``Hyper-V VM Vid Partition`` =

  [<Literal>]
  let CategoryName = "Hyper-V VM Vid Partition"

  let PCC = Category.create CategoryName
  /// Physical Pages Allocated: -
  let ``Physical Pages Allocated`` instance =
    { category = CategoryName; counter = "Physical Pages Allocated"; instance = instance }
  /// Preferred NUMA Node Index: -
  let ``Preferred NUMA Node Index`` instance =
    { category = CategoryName; counter = "Preferred NUMA Node Index"; instance = instance }
  /// Remote Physical Pages: -
  let ``Remote Physical Pages`` instance =
    { category = CategoryName; counter = "Remote Physical Pages"; instance = instance }

  let allCounters =
    [| ``Physical Pages Allocated``
       ``Preferred NUMA Node Index``
       ``Remote Physical Pages``
    |]

/// Hyper-V VM Virtual Device Pipe IO: Worker process per-pipe statistics, for performance debugging.
///
/// This performance counter does not have instance based counters
module ``Hyper-V VM Virtual Device Pipe IO`` =

  [<Literal>]
  let CategoryName = "Hyper-V VM Virtual Device Pipe IO"

  let PCC = Category.create CategoryName
  /// Receive Message Quota Exceeded: -
  let ``Receive Message Quota Exceeded`` instance =
    { category = CategoryName; counter = "Receive Message Quota Exceeded"; instance = instance }
  /// Receive QoS - Conformant Messages/sec: -
  let ``Receive QoS - Conformant Messages/sec`` instance =
    { category = CategoryName; counter = "Receive QoS - Conformant Messages/sec"; instance = instance }
  /// Receive QoS - Exempt Messages/sec: -
  let ``Receive QoS - Exempt Messages/sec`` instance =
    { category = CategoryName; counter = "Receive QoS - Exempt Messages/sec"; instance = instance }
  /// Receive QoS - Non-Conformant Messages/sec: -
  let ``Receive QoS - Non-Conformant Messages/sec`` instance =
    { category = CategoryName; counter = "Receive QoS - Non-Conformant Messages/sec"; instance = instance }
  /// Receive QoS - Total Message Delay Time (100ns): -
  let ``Receive QoS - Total Message Delay Time (100ns)`` instance =
    { category = CategoryName; counter = "Receive QoS - Total Message Delay Time (100ns)"; instance = instance }

  let allCounters =
    [| ``Receive Message Quota Exceeded``
       ``Receive QoS - Conformant Messages/sec``
       ``Receive QoS - Exempt Messages/sec``
       ``Receive QoS - Non-Conformant Messages/sec``
       ``Receive QoS - Total Message Delay Time (100ns)``
    |]


/// Hyper-V Virtual IDE Controller (Emulated): Performance counters for a virtual machine's IDE Controller.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Virtual IDE Controller (Emulated)`` =

  [<Literal>]
  let CategoryName = "Hyper-V Virtual IDE Controller (Emulated)"

  let PCC = Category.create CategoryName
  /// Read Bytes/sec: -
  let ``Read Bytes/sec`` instance =
    { category = CategoryName; counter = "Read Bytes/sec"; instance = instance }
  /// Read Sectors/sec: -
  let ``Read Sectors/sec`` instance =
    { category = CategoryName; counter = "Read Sectors/sec"; instance = instance }
  /// Write Bytes/sec: -
  let ``Write Bytes/sec`` instance =
    { category = CategoryName; counter = "Write Bytes/sec"; instance = instance }
  /// Written Sectors/sec: -
  let ``Written Sectors/sec`` instance =
    { category = CategoryName; counter = "Written Sectors/sec"; instance = instance }

  let allCounters =
    [| ``Read Bytes/sec``
       ``Read Sectors/sec``
       ``Write Bytes/sec``
       ``Written Sectors/sec``
    |]

/// Hyper-V Virtual Machine Bus: This counter set represents the statistics for the virtual machine bus.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Virtual Machine Bus`` =

  [<Literal>]
  let CategoryName = "Hyper-V Virtual Machine Bus"

  let PCC = Category.create CategoryName
  /// Interrupts Received/sec: This counter represents the rate of interrupts received.
  let ``Interrupts Received/sec`` =
    { category = CategoryName; counter = "Interrupts Received/sec"; instance = None }
  /// Interrupts Sent/sec: This counter represents the rate of interrupts sent.
  let ``Interrupts Sent/sec`` =
    { category = CategoryName; counter = "Interrupts Sent/sec"; instance = None }
  /// Throttle Events: This counter represents the total number of times that any partition has been throttled, which is to say that its interrupts were disabled.
  let ``Throttle Events`` =
    { category = CategoryName; counter = "Throttle Events"; instance = None }

  let allCounters =
    [| ``Interrupts Received/sec``
       ``Interrupts Sent/sec``
       ``Throttle Events``
    |]

/// Hyper-V Virtual Machine Bus Pipes: Per-Pipe statistics, for performance debugging.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Virtual Machine Bus Pipes`` =

  [<Literal>]
  let CategoryName = "Hyper-V Virtual Machine Bus Pipes"

  let PCC = Category.create CategoryName
  /// Bytes Read/sec: -
  let ``Bytes Read/sec`` instance =
    { category = CategoryName; counter = "Bytes Read/sec"; instance = instance }
  /// Bytes Written/sec: -
  let ``Bytes Written/sec`` instance =
    { category = CategoryName; counter = "Bytes Written/sec"; instance = instance }
  /// Reads/sec: -
  let ``Reads/sec`` instance =
    { category = CategoryName; counter = "Reads/sec"; instance = instance }
  /// Writes/sec: -
  let ``Writes/sec`` instance =
    { category = CategoryName; counter = "Writes/sec"; instance = instance }

  let allCounters =
    [| ``Bytes Read/sec``
       ``Bytes Written/sec``
       ``Reads/sec``
       ``Writes/sec``
    |]

/// Hyper-V Virtual Machine Bus Provider Pipes: Per-Pipe statistics, for performance debugging.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Virtual Machine Bus Provider Pipes`` =

  [<Literal>]
  let CategoryName = "Hyper-V Virtual Machine Bus Provider Pipes"

  let PCC = Category.create CategoryName
  /// Bytes Read/sec: -
  let ``Bytes Read/sec`` instance =
    { category = CategoryName; counter = "Bytes Read/sec"; instance = instance }
  /// Bytes Written/sec: -
  let ``Bytes Written/sec`` instance =
    { category = CategoryName; counter = "Bytes Written/sec"; instance = instance }
  /// Reads/sec: -
  let ``Reads/sec`` instance =
    { category = CategoryName; counter = "Reads/sec"; instance = instance }
  /// Writes/sec: -
  let ``Writes/sec`` instance =
    { category = CategoryName; counter = "Writes/sec"; instance = instance }

  let allCounters =
    [| ``Bytes Read/sec``
       ``Bytes Written/sec``
       ``Reads/sec``
       ``Writes/sec``
    |]

/// Hyper-V Virtual Machine Health Summary: This counter set represents the health summary statistics for the Virtual Machine Management Service.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Virtual Machine Health Summary`` =

  [<Literal>]
  let CategoryName = "Hyper-V Virtual Machine Health Summary"

  let PCC = Category.create CategoryName
  /// Health Critical: This counter represents the number of virtual machines with critical health.
  let ``Health Critical`` =
    { category = CategoryName; counter = "Health Critical"; instance = None }
  /// Health Ok: This counter represents the number of virtual machines with ok health.
  let ``Health Ok`` =
    { category = CategoryName; counter = "Health Ok"; instance = None }

  let allCounters =
    [| ``Health Critical``
       ``Health Ok``
    |]

/// Hyper-V Virtual Network Adapter: This counter set represents the statistics for the Microsoft Hyper-V network adapter.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Virtual Network Adapter`` =

  [<Literal>]
  let CategoryName = "Hyper-V Virtual Network Adapter"

  let PCC = Category.create CategoryName
  /// Broadcast Packets Received/sec: -
  let ``Broadcast Packets Received/sec`` instance =
    { category = CategoryName; counter = "Broadcast Packets Received/sec"; instance = instance }
  /// Broadcast Packets Sent/sec: -
  let ``Broadcast Packets Sent/sec`` instance =
    { category = CategoryName; counter = "Broadcast Packets Sent/sec"; instance = instance }
  /// Bytes Received/sec: -
  let ``Bytes Received/sec`` instance =
    { category = CategoryName; counter = "Bytes Received/sec"; instance = instance }
  /// Bytes Sent/sec: -
  let ``Bytes Sent/sec`` instance =
    { category = CategoryName; counter = "Bytes Sent/sec"; instance = instance }
  /// Bytes/sec: -
  let ``Bytes/sec`` instance =
    { category = CategoryName; counter = "Bytes/sec"; instance = instance }
  /// Directed Packets Received/sec: -
  let ``Directed Packets Received/sec`` instance =
    { category = CategoryName; counter = "Directed Packets Received/sec"; instance = instance }
  /// Directed Packets Sent/sec: -
  let ``Directed Packets Sent/sec`` instance =
    { category = CategoryName; counter = "Directed Packets Sent/sec"; instance = instance }
  /// Dropped Packets Incoming/sec: -
  let ``Dropped Packets Incoming/sec`` instance =
    { category = CategoryName; counter = "Dropped Packets Incoming/sec"; instance = instance }
  /// Dropped Packets Outgoing/sec: -
  let ``Dropped Packets Outgoing/sec`` instance =
    { category = CategoryName; counter = "Dropped Packets Outgoing/sec"; instance = instance }
  /// Extensions Dropped Packets Incoming/sec: -
  let ``Extensions Dropped Packets Incoming/sec`` instance =
    { category = CategoryName; counter = "Extensions Dropped Packets Incoming/sec"; instance = instance }
  /// Extensions Dropped Packets Outgoing/sec: -
  let ``Extensions Dropped Packets Outgoing/sec`` instance =
    { category = CategoryName; counter = "Extensions Dropped Packets Outgoing/sec"; instance = instance }
  /// IPsec offload Bytes Receive/sec: -
  let ``IPsec offload Bytes Receive/sec`` instance =
    { category = CategoryName; counter = "IPsec offload Bytes Receive/sec"; instance = instance }
  /// IPsec offload Bytes Sent/sec: -
  let ``IPsec offload Bytes Sent/sec`` instance =
    { category = CategoryName; counter = "IPsec offload Bytes Sent/sec"; instance = instance }
  /// Multicast Packets Received/sec: -
  let ``Multicast Packets Received/sec`` instance =
    { category = CategoryName; counter = "Multicast Packets Received/sec"; instance = instance }
  /// Multicast Packets Sent/sec: -
  let ``Multicast Packets Sent/sec`` instance =
    { category = CategoryName; counter = "Multicast Packets Sent/sec"; instance = instance }
  /// Packets Received/sec: -
  let ``Packets Received/sec`` instance =
    { category = CategoryName; counter = "Packets Received/sec"; instance = instance }
  /// Packets Sent/sec: -
  let ``Packets Sent/sec`` instance =
    { category = CategoryName; counter = "Packets Sent/sec"; instance = instance }
  /// Packets/sec: -
  let ``Packets/sec`` instance =
    { category = CategoryName; counter = "Packets/sec"; instance = instance }

  let allCounters =
    [| ``Broadcast Packets Received/sec``
       ``Broadcast Packets Sent/sec``
       ``Bytes Received/sec``
       ``Bytes Sent/sec``
       ``Bytes/sec``
       ``Directed Packets Received/sec``
       ``Directed Packets Sent/sec``
       ``Dropped Packets Incoming/sec``
       ``Dropped Packets Outgoing/sec``
       ``Extensions Dropped Packets Incoming/sec``
       ``Extensions Dropped Packets Outgoing/sec``
       ``IPsec offload Bytes Receive/sec``
       ``IPsec offload Bytes Sent/sec``
       ``Multicast Packets Received/sec``
       ``Multicast Packets Sent/sec``
       ``Packets Received/sec``
       ``Packets Sent/sec``
       ``Packets/sec``
    |]

/// Hyper-V Virtual Network Adapter VRSS: This counter set represents the statistics for the Microsoft Hyper-V network adapter vRSS entries.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Virtual Network Adapter VRSS`` =

  [<Literal>]
  let CategoryName = "Hyper-V Virtual Network Adapter VRSS"

  let PCC = Category.create CategoryName
  /// ReceivePacketPerSecond: -
  let ``ReceivePacketPerSecond`` instance =
    { category = CategoryName; counter = "ReceivePacketPerSecond"; instance = instance }
  /// ReceiveProcessor: -
  let ``ReceiveProcessor`` instance =
    { category = CategoryName; counter = "ReceiveProcessor"; instance = instance }
  /// SendPacketPerSecond: -
  let ``SendPacketPerSecond`` instance =
    { category = CategoryName; counter = "SendPacketPerSecond"; instance = instance }
  /// SendProcessor: -
  let ``SendProcessor`` instance =
    { category = CategoryName; counter = "SendProcessor"; instance = instance }

  let allCounters =
    [| ``ReceivePacketPerSecond``
       ``ReceiveProcessor``
       ``SendPacketPerSecond``
       ``SendProcessor``
    |]

/// Hyper-V Virtual Storage Device: This counter set represents the statistics for a virtual storage device.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Virtual Storage Device`` =

  [<Literal>]
  let CategoryName = "Hyper-V Virtual Storage Device"

  let PCC = Category.create CategoryName
  /// Byte Quota Replenishment Rate: -
  let ``Byte Quota Replenishment Rate`` instance =
    { category = CategoryName; counter = "Byte Quota Replenishment Rate"; instance = instance }
  /// Error Count: -
  let ``Error Count`` instance =
    { category = CategoryName; counter = "Error Count"; instance = instance }
  /// Flush Count: -
  let ``Flush Count`` instance =
    { category = CategoryName; counter = "Flush Count"; instance = instance }
  /// Io Quota Replenishment Rate: -
  let ``Io Quota Replenishment Rate`` instance =
    { category = CategoryName; counter = "Io Quota Replenishment Rate"; instance = instance }
  /// Latency: -
  let ``Latency`` instance =
    { category = CategoryName; counter = "Latency"; instance = instance }
  /// Lower Latency: -
  let ``Lower Latency`` instance =
    { category = CategoryName; counter = "Lower Latency"; instance = instance }
  /// Lower Queue Length: -
  let ``Lower Queue Length`` instance =
    { category = CategoryName; counter = "Lower Queue Length"; instance = instance }
  /// Maximum Bandwidth: -
  let ``Maximum Bandwidth`` instance =
    { category = CategoryName; counter = "Maximum Bandwidth"; instance = instance }
  /// Maximum IO Rate: -
  let ``Maximum IO Rate`` instance =
    { category = CategoryName; counter = "Maximum IO Rate"; instance = instance }
  /// Minimum IO Rate: -
  let ``Minimum IO Rate`` instance =
    { category = CategoryName; counter = "Minimum IO Rate"; instance = instance }
  /// Normalized Throughput: -
  let ``Normalized Throughput`` instance =
    { category = CategoryName; counter = "Normalized Throughput"; instance = instance }
  /// Queue Length: -
  let ``Queue Length`` instance =
    { category = CategoryName; counter = "Queue Length"; instance = instance }
  /// Read Bytes/sec: -
  let ``Read Bytes/sec`` instance =
    { category = CategoryName; counter = "Read Bytes/sec"; instance = instance }
  /// Read Count: -
  let ``Read Count`` instance =
    { category = CategoryName; counter = "Read Count"; instance = instance }
  /// Read Operations/Sec: -
  let ``Read Operations/Sec`` instance =
    { category = CategoryName; counter = "Read Operations/Sec"; instance = instance }
  /// Throughput: -
  let ``Throughput`` instance =
    { category = CategoryName; counter = "Throughput"; instance = instance }
  /// Write Bytes/sec: -
  let ``Write Bytes/sec`` instance =
    { category = CategoryName; counter = "Write Bytes/sec"; instance = instance }
  /// Write Count: -
  let ``Write Count`` instance =
    { category = CategoryName; counter = "Write Count"; instance = instance }
  /// Write Operations/Sec: -
  let ``Write Operations/Sec`` instance =
    { category = CategoryName; counter = "Write Operations/Sec"; instance = instance }

  let allCounters =
    [| ``Byte Quota Replenishment Rate``
       ``Error Count``
       ``Flush Count``
       ``Io Quota Replenishment Rate``
       ``Latency``
       ``Lower Latency``
       ``Lower Queue Length``
       ``Maximum Bandwidth``
       ``Maximum IO Rate``
       ``Minimum IO Rate``
       ``Normalized Throughput``
       ``Queue Length``
       ``Read Bytes/sec``
       ``Read Count``
       ``Read Operations/Sec``
       ``Throughput``
       ``Write Bytes/sec``
       ``Write Count``
       ``Write Operations/Sec``
    |]

/// Hyper-V Virtual Switch: This counter set represents the statistics for the Microsoft Hyper-V switch.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Virtual Switch`` =

  [<Literal>]
  let CategoryName = "Hyper-V Virtual Switch"

  let PCC = Category.create CategoryName
  /// Broadcast Packets Received/sec: -
  let ``Broadcast Packets Received/sec`` instance =
    { category = CategoryName; counter = "Broadcast Packets Received/sec"; instance = instance }
  /// Broadcast Packets Sent/sec: -
  let ``Broadcast Packets Sent/sec`` instance =
    { category = CategoryName; counter = "Broadcast Packets Sent/sec"; instance = instance }
  /// Bytes Received/sec: -
  let ``Bytes Received/sec`` instance =
    { category = CategoryName; counter = "Bytes Received/sec"; instance = instance }
  /// Bytes Sent/sec: -
  let ``Bytes Sent/sec`` instance =
    { category = CategoryName; counter = "Bytes Sent/sec"; instance = instance }
  /// Bytes/sec: -
  let ``Bytes/sec`` instance =
    { category = CategoryName; counter = "Bytes/sec"; instance = instance }
  /// Directed Packets Received/sec: -
  let ``Directed Packets Received/sec`` instance =
    { category = CategoryName; counter = "Directed Packets Received/sec"; instance = instance }
  /// Directed Packets Sent/sec: -
  let ``Directed Packets Sent/sec`` instance =
    { category = CategoryName; counter = "Directed Packets Sent/sec"; instance = instance }
  /// Dropped Packets Incoming/sec: -
  let ``Dropped Packets Incoming/sec`` instance =
    { category = CategoryName; counter = "Dropped Packets Incoming/sec"; instance = instance }
  /// Dropped Packets Outgoing/sec: -
  let ``Dropped Packets Outgoing/sec`` instance =
    { category = CategoryName; counter = "Dropped Packets Outgoing/sec"; instance = instance }
  /// Extensions Dropped Packets Incoming/sec: -
  let ``Extensions Dropped Packets Incoming/sec`` instance =
    { category = CategoryName; counter = "Extensions Dropped Packets Incoming/sec"; instance = instance }
  /// Extensions Dropped Packets Outgoing/sec: -
  let ``Extensions Dropped Packets Outgoing/sec`` instance =
    { category = CategoryName; counter = "Extensions Dropped Packets Outgoing/sec"; instance = instance }
  /// Learned Mac Addresses: -
  let ``Learned Mac Addresses`` instance =
    { category = CategoryName; counter = "Learned Mac Addresses"; instance = instance }
  /// Learned Mac Addresses/sec: -
  let ``Learned Mac Addresses/sec`` instance =
    { category = CategoryName; counter = "Learned Mac Addresses/sec"; instance = instance }
  /// Multicast Packets Received/sec: -
  let ``Multicast Packets Received/sec`` instance =
    { category = CategoryName; counter = "Multicast Packets Received/sec"; instance = instance }
  /// Multicast Packets Sent/sec: -
  let ``Multicast Packets Sent/sec`` instance =
    { category = CategoryName; counter = "Multicast Packets Sent/sec"; instance = instance }
  /// Number of Send Channel Moves/sec: -
  let ``Number of Send Channel Moves/sec`` instance =
    { category = CategoryName; counter = "Number of Send Channel Moves/sec"; instance = instance }
  /// Number of VMQ Moves/sec: -
  let ``Number of VMQ Moves/sec`` instance =
    { category = CategoryName; counter = "Number of VMQ Moves/sec"; instance = instance }
  /// Packets Flooded: -
  let ``Packets Flooded`` instance =
    { category = CategoryName; counter = "Packets Flooded"; instance = instance }
  /// Packets Flooded/sec: -
  let ``Packets Flooded/sec`` instance =
    { category = CategoryName; counter = "Packets Flooded/sec"; instance = instance }
  /// Packets Received/sec: -
  let ``Packets Received/sec`` instance =
    { category = CategoryName; counter = "Packets Received/sec"; instance = instance }
  /// Packets Sent/sec: -
  let ``Packets Sent/sec`` instance =
    { category = CategoryName; counter = "Packets Sent/sec"; instance = instance }
  /// Packets/sec: -
  let ``Packets/sec`` instance =
    { category = CategoryName; counter = "Packets/sec"; instance = instance }
  /// Purged Mac Addresses: -
  let ``Purged Mac Addresses`` instance =
    { category = CategoryName; counter = "Purged Mac Addresses"; instance = instance }
  /// Purged Mac Addresses/sec: -
  let ``Purged Mac Addresses/sec`` instance =
    { category = CategoryName; counter = "Purged Mac Addresses/sec"; instance = instance }

  let allCounters =
    [| ``Broadcast Packets Received/sec``
       ``Broadcast Packets Sent/sec``
       ``Bytes Received/sec``
       ``Bytes Sent/sec``
       ``Bytes/sec``
       ``Directed Packets Received/sec``
       ``Directed Packets Sent/sec``
       ``Dropped Packets Incoming/sec``
       ``Dropped Packets Outgoing/sec``
       ``Extensions Dropped Packets Incoming/sec``
       ``Extensions Dropped Packets Outgoing/sec``
       ``Learned Mac Addresses``
       ``Learned Mac Addresses/sec``
       ``Multicast Packets Received/sec``
       ``Multicast Packets Sent/sec``
       ``Number of Send Channel Moves/sec``
       ``Number of VMQ Moves/sec``
       ``Packets Flooded``
       ``Packets Flooded/sec``
       ``Packets Received/sec``
       ``Packets Sent/sec``
       ``Packets/sec``
       ``Purged Mac Addresses``
       ``Purged Mac Addresses/sec``
    |]

/// Hyper-V Virtual Switch Port: This counter set represents the statistics for the Microsoft Hyper-V switch port.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Virtual Switch Port`` =

  [<Literal>]
  let CategoryName = "Hyper-V Virtual Switch Port"

  let PCC = Category.create CategoryName
  /// Broadcast Packets Received/sec: -
  let ``Broadcast Packets Received/sec`` instance =
    { category = CategoryName; counter = "Broadcast Packets Received/sec"; instance = instance }
  /// Broadcast Packets Sent/sec: -
  let ``Broadcast Packets Sent/sec`` instance =
    { category = CategoryName; counter = "Broadcast Packets Sent/sec"; instance = instance }
  /// Bytes Received/sec: -
  let ``Bytes Received/sec`` instance =
    { category = CategoryName; counter = "Bytes Received/sec"; instance = instance }
  /// Bytes Sent/sec: -
  let ``Bytes Sent/sec`` instance =
    { category = CategoryName; counter = "Bytes Sent/sec"; instance = instance }
  /// Bytes/sec: -
  let ``Bytes/sec`` instance =
    { category = CategoryName; counter = "Bytes/sec"; instance = instance }
  /// Directed Packets Received/sec: -
  let ``Directed Packets Received/sec`` instance =
    { category = CategoryName; counter = "Directed Packets Received/sec"; instance = instance }
  /// Directed Packets Sent/sec: -
  let ``Directed Packets Sent/sec`` instance =
    { category = CategoryName; counter = "Directed Packets Sent/sec"; instance = instance }
  /// Dropped Packets Incoming/sec: -
  let ``Dropped Packets Incoming/sec`` instance =
    { category = CategoryName; counter = "Dropped Packets Incoming/sec"; instance = instance }
  /// Dropped Packets Outgoing/sec: -
  let ``Dropped Packets Outgoing/sec`` instance =
    { category = CategoryName; counter = "Dropped Packets Outgoing/sec"; instance = instance }
  /// Extensions Dropped Packets Incoming/sec: -
  let ``Extensions Dropped Packets Incoming/sec`` instance =
    { category = CategoryName; counter = "Extensions Dropped Packets Incoming/sec"; instance = instance }
  /// Extensions Dropped Packets Outgoing/sec: -
  let ``Extensions Dropped Packets Outgoing/sec`` instance =
    { category = CategoryName; counter = "Extensions Dropped Packets Outgoing/sec"; instance = instance }
  /// IPsec SAs Offloaded : -
  let ``IPsec SAs Offloaded `` instance =
    { category = CategoryName; counter = "IPsec SAs Offloaded "; instance = instance }
  /// IPsec offload Bytes Receive/sec: -
  let ``IPsec offload Bytes Receive/sec`` instance =
    { category = CategoryName; counter = "IPsec offload Bytes Receive/sec"; instance = instance }
  /// IPsec offload Bytes Sent/sec: -
  let ``IPsec offload Bytes Sent/sec`` instance =
    { category = CategoryName; counter = "IPsec offload Bytes Sent/sec"; instance = instance }
  /// Multicast Packets Received/sec: -
  let ``Multicast Packets Received/sec`` instance =
    { category = CategoryName; counter = "Multicast Packets Received/sec"; instance = instance }
  /// Multicast Packets Sent/sec: -
  let ``Multicast Packets Sent/sec`` instance =
    { category = CategoryName; counter = "Multicast Packets Sent/sec"; instance = instance }
  /// Packets Received/sec: -
  let ``Packets Received/sec`` instance =
    { category = CategoryName; counter = "Packets Received/sec"; instance = instance }
  /// Packets Sent/sec: -
  let ``Packets Sent/sec`` instance =
    { category = CategoryName; counter = "Packets Sent/sec"; instance = instance }
  /// Packets/sec: -
  let ``Packets/sec`` instance =
    { category = CategoryName; counter = "Packets/sec"; instance = instance }

  let allCounters =
    [| ``Broadcast Packets Received/sec``
       ``Broadcast Packets Sent/sec``
       ``Bytes Received/sec``
       ``Bytes Sent/sec``
       ``Bytes/sec``
       ``Directed Packets Received/sec``
       ``Directed Packets Sent/sec``
       ``Dropped Packets Incoming/sec``
       ``Dropped Packets Outgoing/sec``
       ``Extensions Dropped Packets Incoming/sec``
       ``Extensions Dropped Packets Outgoing/sec``
       ``IPsec SAs Offloaded ``
       ``IPsec offload Bytes Receive/sec``
       ``IPsec offload Bytes Sent/sec``
       ``Multicast Packets Received/sec``
       ``Multicast Packets Sent/sec``
       ``Packets Received/sec``
       ``Packets Sent/sec``
       ``Packets/sec``
    |]

/// Hyper-V Virtual Switch Processor: This counter set represents the statistics for the Microsoft Hyper-V switch processor.
///
/// This performance counter does not have non-instance based counters
module ``Hyper-V Virtual Switch Processor`` =

  [<Literal>]
  let CategoryName = "Hyper-V Virtual Switch Processor"

  let PCC = Category.create CategoryName
  /// Number of Transmit Completes/sec: This counter represents the number of transmit completes per second targeting on the virtual switch processor.
  let ``Number of Transmit Completes/sec`` instance =
    { category = CategoryName; counter = "Number of Transmit Completes/sec"; instance = instance }
  /// Number of VMQs: This counter represents the number of VMQs targeting on the virtual switch processor.
  let ``Number of VMQs`` instance =
    { category = CategoryName; counter = "Number of VMQs"; instance = instance }
  /// Packets from External/sec: This counter represents the number of packets from the external NIC that enter the virtual switch per second on the virtual switch processor.
  let ``Packets from External/sec`` instance =
    { category = CategoryName; counter = "Packets from External/sec"; instance = instance }
  /// Packets from Internal/sec: This counter represents the number of packets from the VM/host that enter the virtual switch per second on the virtual switch processor.
  let ``Packets from Internal/sec`` instance =
    { category = CategoryName; counter = "Packets from Internal/sec"; instance = instance }

  let allCounters =
    [| ``Number of Transmit Completes/sec``
       ``Number of VMQs``
       ``Packets from External/sec``
       ``Packets from Internal/sec``
    |]

/// Hyper-V Worker Virtual Processor: Performance counters for the virtual processor of a virtual machine.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Worker Virtual Processor`` =

  [<Literal>]
  let CategoryName = "Hyper-V Worker Virtual Processor"

  let PCC = Category.create CategoryName
  /// Intercept Delay Time (ms): -
  let ``Intercept Delay Time (ms)`` instance =
    { category = CategoryName; counter = "Intercept Delay Time (ms)"; instance = instance }
  /// Intercepts Delayed: -
  let ``Intercepts Delayed`` instance =
    { category = CategoryName; counter = "Intercepts Delayed"; instance = instance }

  let allCounters =
    [| ``Intercept Delay Time (ms)``
       ``Intercepts Delayed``
    |]

/// ICMP: The ICMP performance object consists of counters that measure the rates at which messages are sent and received by using ICMP protocols.  It also includes counters that monitor ICMP protocol errors.
///
/// This performance counter does not have instance based counters
module ``ICMP`` =

  [<Literal>]
  let CategoryName = "ICMP"

  let PCC = Category.create CategoryName
  /// Messages Outbound Errors: Messages Outbound Errors is the number of ICMP messages that were not send due to problems within ICMP, such as lack of buffers.  This value does not include errors discovered outside the ICMP layer, such as those recording the failure of IP to route the resultant datagram.  In some implementations, none of the error types are included in the value of this counter.
  let ``Messages Outbound Errors`` =
    { category = CategoryName; counter = "Messages Outbound Errors"; instance = None }
  /// Messages Received Errors: Messages Received Errors is the number of ICMP messages that the entity received but had errors, such as bad ICMP checksums, bad length, etc.
  let ``Messages Received Errors`` =
    { category = CategoryName; counter = "Messages Received Errors"; instance = None }
  /// Messages Received/sec: Messages Received/sec is the rate, in incidents per second at which ICMP messages were received. The rate includes messages received in error.
  let ``Messages Received/sec`` =
    { category = CategoryName; counter = "Messages Received/sec"; instance = None }
  /// Messages Sent/sec: Messages Sent/sec is the rate, in incidents per second, at which the server attempted to send. The rate includes those messages sent in error.
  let ``Messages Sent/sec`` =
    { category = CategoryName; counter = "Messages Sent/sec"; instance = None }
  /// Messages/sec: Messages/sec is the total rate, in incidents per second, at which ICMP messages were sent and received by the entity. The rate includes messages received or sent in error.
  let ``Messages/sec`` =
    { category = CategoryName; counter = "Messages/sec"; instance = None }
  /// Received Address Mask: Received Address Mask is the number of ICMP Address Mask Request messages received.
  let ``Received Address Mask`` =
    { category = CategoryName; counter = "Received Address Mask"; instance = None }
  /// Received Address Mask Reply: Received Address Mask Reply is the number of ICMP Address Mask Reply messages received.
  let ``Received Address Mask Reply`` =
    { category = CategoryName; counter = "Received Address Mask Reply"; instance = None }
  /// Received Dest. Unreachable: Received Destination Unreachable is the number of ICMP Destination Unreachable messages received.
  let ``Received Dest. Unreachable`` =
    { category = CategoryName; counter = "Received Dest. Unreachable"; instance = None }
  /// Received Echo Reply/sec: Received Echo Reply/sec is the rate, in incidents per second, at which ICMP Echo Reply messages were received.
  let ``Received Echo Reply/sec`` =
    { category = CategoryName; counter = "Received Echo Reply/sec"; instance = None }
  /// Received Echo/sec: Received Echo/sec is the rate, in incidents per second, at which ICMP Echo messages were received.
  let ``Received Echo/sec`` =
    { category = CategoryName; counter = "Received Echo/sec"; instance = None }
  /// Received Parameter Problem: Received Parameter Problem is the number of ICMP Parameter Problem messages received.
  let ``Received Parameter Problem`` =
    { category = CategoryName; counter = "Received Parameter Problem"; instance = None }
  /// Received Redirect/sec: Received Redirect/sec is the rate, in incidents per second, at which ICMP Redirect messages were received.
  let ``Received Redirect/sec`` =
    { category = CategoryName; counter = "Received Redirect/sec"; instance = None }
  /// Received Source Quench: Received Source Quench is the number of ICMP Source Quench messages received.
  let ``Received Source Quench`` =
    { category = CategoryName; counter = "Received Source Quench"; instance = None }
  /// Received Time Exceeded: Received Time Exceeded is the number of ICMP Time Exceeded messages received.
  let ``Received Time Exceeded`` =
    { category = CategoryName; counter = "Received Time Exceeded"; instance = None }
  /// Received Timestamp Reply/sec: Received Timestamp Reply/sec is the rate of ICMP Timestamp Reply messages received.
  let ``Received Timestamp Reply/sec`` =
    { category = CategoryName; counter = "Received Timestamp Reply/sec"; instance = None }
  /// Received Timestamp/sec: Received Timestamp/sec is the rate, in incidents per second at which ICMP Timestamp Request messages were received.
  let ``Received Timestamp/sec`` =
    { category = CategoryName; counter = "Received Timestamp/sec"; instance = None }
  /// Sent Address Mask: Sent Address Mask is the number of ICMP Address Mask Request messages sent.
  let ``Sent Address Mask`` =
    { category = CategoryName; counter = "Sent Address Mask"; instance = None }
  /// Sent Address Mask Reply: Sent Address Mask Reply is the number of ICMP Address Mask Reply messages sent.
  let ``Sent Address Mask Reply`` =
    { category = CategoryName; counter = "Sent Address Mask Reply"; instance = None }
  /// Sent Destination Unreachable: Sent Destination Unreachable is the number of ICMP Destination Unreachable messages sent.
  let ``Sent Destination Unreachable`` =
    { category = CategoryName; counter = "Sent Destination Unreachable"; instance = None }
  /// Sent Echo Reply/sec: Sent Echo Reply/sec is the rate, in incidents per second, at which ICMP Echo Reply messages were sent.
  let ``Sent Echo Reply/sec`` =
    { category = CategoryName; counter = "Sent Echo Reply/sec"; instance = None }
  /// Sent Echo/sec: Sent Echo/sec is the rate of ICMP Echo messages sent.
  let ``Sent Echo/sec`` =
    { category = CategoryName; counter = "Sent Echo/sec"; instance = None }
  /// Sent Parameter Problem: Sent Parameter Problem is the number of ICMP Parameter Problem messages sent.
  let ``Sent Parameter Problem`` =
    { category = CategoryName; counter = "Sent Parameter Problem"; instance = None }
  /// Sent Redirect/sec: Sent Redirect/sec is the rate, in incidents per second, at which ICMP Redirect messages were sent.
  let ``Sent Redirect/sec`` =
    { category = CategoryName; counter = "Sent Redirect/sec"; instance = None }
  /// Sent Source Quench: Sent Source Quench is the number of ICMP Source Quench messages sent.
  let ``Sent Source Quench`` =
    { category = CategoryName; counter = "Sent Source Quench"; instance = None }
  /// Sent Time Exceeded: Sent Time Exceeded is the number of ICMP Time Exceeded messages sent.
  let ``Sent Time Exceeded`` =
    { category = CategoryName; counter = "Sent Time Exceeded"; instance = None }
  /// Sent Timestamp Reply/sec: Sent Timestamp Reply/sec is the rate, in incidents per second,  at which ICMP Timestamp Reply messages were sent.
  let ``Sent Timestamp Reply/sec`` =
    { category = CategoryName; counter = "Sent Timestamp Reply/sec"; instance = None }
  /// Sent Timestamp/sec: Sent Timestamp/sec is the rate, in incidents per second, at which ICMP Timestamp Request messages were sent.
  let ``Sent Timestamp/sec`` =
    { category = CategoryName; counter = "Sent Timestamp/sec"; instance = None }

  let allCounters =
    [| ``Messages Outbound Errors``
       ``Messages Received Errors``
       ``Messages Received/sec``
       ``Messages Sent/sec``
       ``Messages/sec``
       ``Received Address Mask``
       ``Received Address Mask Reply``
       ``Received Dest. Unreachable``
       ``Received Echo Reply/sec``
       ``Received Echo/sec``
       ``Received Parameter Problem``
       ``Received Redirect/sec``
       ``Received Source Quench``
       ``Received Time Exceeded``
       ``Received Timestamp Reply/sec``
       ``Received Timestamp/sec``
       ``Sent Address Mask``
       ``Sent Address Mask Reply``
       ``Sent Destination Unreachable``
       ``Sent Echo Reply/sec``
       ``Sent Echo/sec``
       ``Sent Parameter Problem``
       ``Sent Redirect/sec``
       ``Sent Source Quench``
       ``Sent Time Exceeded``
       ``Sent Timestamp Reply/sec``
       ``Sent Timestamp/sec``
    |]

/// ICMPv6: The ICMP performance object consists of counters that measure the rates at which messages are sent and received by using ICMP protocols.  It also includes counters that monitor ICMP protocol errors.
///
/// This performance counter does not have instance based counters
module ``ICMPv6`` =

  [<Literal>]
  let CategoryName = "ICMPv6"

  let PCC = Category.create CategoryName
  /// Messages Outbound Errors: Messages Outbound Errors is the number of ICMP messages that were not send due to problems within ICMP, such as lack of buffers.  This value does not include errors discovered outside the ICMP layer, such as those recording the failure of IP to route the resultant datagram.  In some implementations, none of the error types are included in the value of this counter.
  let ``Messages Outbound Errors`` =
    { category = CategoryName; counter = "Messages Outbound Errors"; instance = None }
  /// Messages Received Errors: Messages Received Errors is the number of ICMP messages that the entity received but had errors, such as bad ICMP checksums, bad length, etc.
  let ``Messages Received Errors`` =
    { category = CategoryName; counter = "Messages Received Errors"; instance = None }
  /// Messages Received/sec: Messages Received/sec is the rate, in incidents per second at which ICMP messages were received. The rate includes messages received in error.
  let ``Messages Received/sec`` =
    { category = CategoryName; counter = "Messages Received/sec"; instance = None }
  /// Messages Sent/sec: Messages Sent/sec is the rate, in incidents per second, at which the server attempted to send. The rate includes those messages sent in error.
  let ``Messages Sent/sec`` =
    { category = CategoryName; counter = "Messages Sent/sec"; instance = None }
  /// Messages/sec: Messages/sec is the total rate, in incidents per second, at which ICMP messages were sent and received by the entity. The rate includes messages received or sent in error.
  let ``Messages/sec`` =
    { category = CategoryName; counter = "Messages/sec"; instance = None }
  /// Received Dest. Unreachable: Received Destination Unreachable is the number of ICMP Destination Unreachable messages received.
  let ``Received Dest. Unreachable`` =
    { category = CategoryName; counter = "Received Dest. Unreachable"; instance = None }
  /// Received Echo Reply/sec: Received Echo Reply/sec is the rate, in incidents per second, at which ICMP Echo Reply messages were received.
  let ``Received Echo Reply/sec`` =
    { category = CategoryName; counter = "Received Echo Reply/sec"; instance = None }
  /// Received Echo/sec: Received Echo/sec is the rate, in incidents per second, at which ICMP Echo messages were received.
  let ``Received Echo/sec`` =
    { category = CategoryName; counter = "Received Echo/sec"; instance = None }
  /// Received Membership Query: Received Membership Query is the number of packets received thatquery their membership to a group.
  let ``Received Membership Query`` =
    { category = CategoryName; counter = "Received Membership Query"; instance = None }
  /// Received Membership Reduction: Received Membership Reduction is the number of packets received thatcancelled their membership to a group.
  let ``Received Membership Reduction`` =
    { category = CategoryName; counter = "Received Membership Reduction"; instance = None }
  /// Received Membership Report: Received Membership Report is the number of packets received thatreport their membership to a group.
  let ``Received Membership Report`` =
    { category = CategoryName; counter = "Received Membership Report"; instance = None }
  /// Received Neighbor Advert: Received Neighbor Advert is the number of packets received thatadvert a neighbor.
  let ``Received Neighbor Advert`` =
    { category = CategoryName; counter = "Received Neighbor Advert"; instance = None }
  /// Received Neighbor Solicit: Received Neighbor Solicit is the number of packets received thatsolicit a neighbor.
  let ``Received Neighbor Solicit`` =
    { category = CategoryName; counter = "Received Neighbor Solicit"; instance = None }
  /// Received Packet Too Big: Received Packet Too Big is the number of received packets thatare larger than anticipated.
  let ``Received Packet Too Big`` =
    { category = CategoryName; counter = "Received Packet Too Big"; instance = None }
  /// Received Parameter Problem: Received Parameter Problem is the number of ICMP Parameter Problem messages received.
  let ``Received Parameter Problem`` =
    { category = CategoryName; counter = "Received Parameter Problem"; instance = None }
  /// Received Redirect/sec: Received Redirect/sec is the rate, in incidents per second, at which ICMP Redirect messages were received.
  let ``Received Redirect/sec`` =
    { category = CategoryName; counter = "Received Redirect/sec"; instance = None }
  /// Received Router Advert: Received Router Advert is the number of packets received thatadvert the router.
  let ``Received Router Advert`` =
    { category = CategoryName; counter = "Received Router Advert"; instance = None }
  /// Received Router Solicit: Received Router Solicit is the number of packets received thatsolicit the router.
  let ``Received Router Solicit`` =
    { category = CategoryName; counter = "Received Router Solicit"; instance = None }
  /// Received Time Exceeded: Received Time Exceeded is the number of ICMP Time Exceeded messages received.
  let ``Received Time Exceeded`` =
    { category = CategoryName; counter = "Received Time Exceeded"; instance = None }
  /// Sent Destination Unreachable: Sent Destination Unreachable is the number of ICMP Destination Unreachable messages sent.
  let ``Sent Destination Unreachable`` =
    { category = CategoryName; counter = "Sent Destination Unreachable"; instance = None }
  /// Sent Echo Reply/sec: Sent Echo Reply/sec is the rate, in incidents per second, at which ICMP Echo Reply messages were sent.
  let ``Sent Echo Reply/sec`` =
    { category = CategoryName; counter = "Sent Echo Reply/sec"; instance = None }
  /// Sent Echo/sec: Sent Echo/sec is the rate of ICMP Echo messages sent.
  let ``Sent Echo/sec`` =
    { category = CategoryName; counter = "Sent Echo/sec"; instance = None }
  /// Sent Membership Query: Sent Membership Query is the number of packets sent thatquery their membership to a group.
  let ``Sent Membership Query`` =
    { category = CategoryName; counter = "Sent Membership Query"; instance = None }
  /// Sent Membership Reduction: Sent Membership Reduction is the number of packets sent thatcancelled their membership to a group.
  let ``Sent Membership Reduction`` =
    { category = CategoryName; counter = "Sent Membership Reduction"; instance = None }
  /// Sent Membership Report: Sent Membership Report is the number of packets sent thatreport their membership to a group.
  let ``Sent Membership Report`` =
    { category = CategoryName; counter = "Sent Membership Report"; instance = None }
  /// Sent Neighbor Advert: Sent Neighbor Advert is the number of packets sent thatadvert a neighbor.
  let ``Sent Neighbor Advert`` =
    { category = CategoryName; counter = "Sent Neighbor Advert"; instance = None }
  /// Sent Neighbor Solicit: Sent Neighbor Solicit is the number of packets sent thatsolicit a neighbor.
  let ``Sent Neighbor Solicit`` =
    { category = CategoryName; counter = "Sent Neighbor Solicit"; instance = None }
  /// Sent Packet Too Big: Sent Packet Too Big is the number of sent packets thatare larger than anticipated.
  let ``Sent Packet Too Big`` =
    { category = CategoryName; counter = "Sent Packet Too Big"; instance = None }
  /// Sent Parameter Problem: Sent Parameter Problem is the number of ICMP Parameter Problem messages sent.
  let ``Sent Parameter Problem`` =
    { category = CategoryName; counter = "Sent Parameter Problem"; instance = None }
  /// Sent Redirect/sec: Sent Redirect/sec is the rate, in incidents per second, at which ICMP Redirect messages were sent.
  let ``Sent Redirect/sec`` =
    { category = CategoryName; counter = "Sent Redirect/sec"; instance = None }
  /// Sent Router Advert: Sent Router Advert is the number of packets sent thatadvert the router.
  let ``Sent Router Advert`` =
    { category = CategoryName; counter = "Sent Router Advert"; instance = None }
  /// Sent Router Solicit: Sent Router Solicit is the number of packets sent thatsolicit the router.
  let ``Sent Router Solicit`` =
    { category = CategoryName; counter = "Sent Router Solicit"; instance = None }
  /// Sent Time Exceeded: Sent Time Exceeded is the number of ICMP Time Exceeded messages sent.
  let ``Sent Time Exceeded`` =
    { category = CategoryName; counter = "Sent Time Exceeded"; instance = None }

  let allCounters =
    [| ``Messages Outbound Errors``
       ``Messages Received Errors``
       ``Messages Received/sec``
       ``Messages Sent/sec``
       ``Messages/sec``
       ``Received Dest. Unreachable``
       ``Received Echo Reply/sec``
       ``Received Echo/sec``
       ``Received Membership Query``
       ``Received Membership Reduction``
       ``Received Membership Report``
       ``Received Neighbor Advert``
       ``Received Neighbor Solicit``
       ``Received Packet Too Big``
       ``Received Parameter Problem``
       ``Received Redirect/sec``
       ``Received Router Advert``
       ``Received Router Solicit``
       ``Received Time Exceeded``
       ``Sent Destination Unreachable``
       ``Sent Echo Reply/sec``
       ``Sent Echo/sec``
       ``Sent Membership Query``
       ``Sent Membership Reduction``
       ``Sent Membership Report``
       ``Sent Neighbor Advert``
       ``Sent Neighbor Solicit``
       ``Sent Packet Too Big``
       ``Sent Parameter Problem``
       ``Sent Redirect/sec``
       ``Sent Router Advert``
       ``Sent Router Solicit``
       ``Sent Time Exceeded``
    |]

/// IPHTTPS Global: Statistics of IPHTTPS server on this machine.
///
/// This performance counter does not have non-instance based counters
module ``IPHTTPS Global`` =

  [<Literal>]
  let CategoryName = "IPHTTPS Global"

  let PCC = Category.create CategoryName
  /// Drops - Neighbor resolution timeouts: Total packets dropped waiting for neighbor resolution.
  let ``Drops - Neighbor resolution timeouts`` instance =
    { category = CategoryName; counter = "Drops - Neighbor resolution timeouts"; instance = instance }
  /// Errors - Authentication Errors: Total authentication errors.
  let ``Errors - Authentication Errors`` instance =
    { category = CategoryName; counter = "Errors - Authentication Errors"; instance = instance }
  /// Errors - Receive errors on the server: Total receive errors on the server.
  let ``Errors - Receive errors on the server`` instance =
    { category = CategoryName; counter = "Errors - Receive errors on the server"; instance = instance }
  /// Errors - Transmit errors on the server: Total transmit errors on the server.
  let ``Errors - Transmit errors on the server`` instance =
    { category = CategoryName; counter = "Errors - Transmit errors on the server"; instance = instance }
  /// In - Total bytes received: Total bytes received on the IPHTTPS server.
  let ``In - Total bytes received`` instance =
    { category = CategoryName; counter = "In - Total bytes received"; instance = instance }
  /// In - Total packets received: Total packets received on the server.
  let ``In - Total packets received`` instance =
    { category = CategoryName; counter = "In - Total packets received"; instance = instance }
  /// Out - Total bytes forwarded: Total bytes forwarded at link layer.
  let ``Out - Total bytes forwarded`` instance =
    { category = CategoryName; counter = "Out - Total bytes forwarded"; instance = instance }
  /// Out - Total bytes sent: Total bytes sent on the IPHTTPS server.
  let ``Out - Total bytes sent`` instance =
    { category = CategoryName; counter = "Out - Total bytes sent"; instance = instance }
  /// Out - Total packets sent: Total packets sent from the server.
  let ``Out - Total packets sent`` instance =
    { category = CategoryName; counter = "Out - Total packets sent"; instance = instance }
  /// Sessions - Total sessions: Total number of sessions on the server.
  let ``Sessions - Total sessions`` instance =
    { category = CategoryName; counter = "Sessions - Total sessions"; instance = instance }

  let allCounters =
    [| ``Drops - Neighbor resolution timeouts``
       ``Errors - Authentication Errors``
       ``Errors - Receive errors on the server``
       ``Errors - Transmit errors on the server``
       ``In - Total bytes received``
       ``In - Total packets received``
       ``Out - Total bytes forwarded``
       ``Out - Total bytes sent``
       ``Out - Total packets sent``
       ``Sessions - Total sessions``
    |]

/// IPHTTPS Session: Per session statistics on this IPHTTPS server.
///
/// This performance counter does not have instance based counters
module ``IPHTTPS Session`` =

  [<Literal>]
  let CategoryName = "IPHTTPS Session"

  let PCC = Category.create CategoryName
  /// Bytes received on this session: -
  let ``Bytes received on this session`` instance =
    { category = CategoryName; counter = "Bytes received on this session"; instance = instance }
  /// Bytes sent on this session: -
  let ``Bytes sent on this session`` instance =
    { category = CategoryName; counter = "Bytes sent on this session"; instance = instance }
  /// Duration - Duration of the session (Seconds): -
  let ``Duration - Duration of the session (Seconds)`` instance =
    { category = CategoryName; counter = "Duration - Duration of the session (Seconds)"; instance = instance }
  /// Errors - Receive errors on this session: -
  let ``Errors - Receive errors on this session`` instance =
    { category = CategoryName; counter = "Errors - Receive errors on this session"; instance = instance }
  /// Errors - Transmit errors on this session: -
  let ``Errors - Transmit errors on this session`` instance =
    { category = CategoryName; counter = "Errors - Transmit errors on this session"; instance = instance }
  /// Packets received on this session: -
  let ``Packets received on this session`` instance =
    { category = CategoryName; counter = "Packets received on this session"; instance = instance }
  /// Packets sent on this session: -
  let ``Packets sent on this session`` instance =
    { category = CategoryName; counter = "Packets sent on this session"; instance = instance }

  let allCounters =
    [| ``Bytes received on this session``
       ``Bytes sent on this session``
       ``Duration - Duration of the session (Seconds)``
       ``Errors - Receive errors on this session``
       ``Errors - Transmit errors on this session``
       ``Packets received on this session``
       ``Packets sent on this session``
    |]

/// IPsec AuthIP IPv4: IPsec AuthIP IPv4 is the set of Internet Protocol security (IPsec) Authenticated IP (AuthIP) counters that apply to traffic and connections over Internet Protocol version 4.
///
/// This performance counter does not have instance based counters
module ``IPsec AuthIP IPv4`` =

  [<Literal>]
  let CategoryName = "IPsec AuthIP IPv4"

  let PCC = Category.create CategoryName
  /// Active Extended Mode SAs: Active Extended Mode SAs is the number of currently active extended mode security associations.
  let ``Active Extended Mode SAs`` =
    { category = CategoryName; counter = "Active Extended Mode SAs"; instance = None }
  /// Active Main Mode SAs: Active Main Mode SAs is the number of currently active main mode security associations.
  let ``Active Main Mode SAs`` =
    { category = CategoryName; counter = "Active Main Mode SAs"; instance = None }
  /// Active Quick Mode SAs: Active Quick Mode SAs is the number of currently active quick mode security associations.
  let ``Active Quick Mode SAs`` =
    { category = CategoryName; counter = "Active Quick Mode SAs"; instance = None }
  /// Extended Mode Negotiations: Extended Mode Negotiations is the number of extended mode negotiations attempted since IPsec was last started.
  let ``Extended Mode Negotiations`` =
    { category = CategoryName; counter = "Extended Mode Negotiations"; instance = None }
  /// Extended Mode Negotiations/sec: Extended Mode Negotiations per Second is the rate at which extended mode negotiations are being attempted.
  let ``Extended Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Extended Mode Negotiations/sec"; instance = None }
  /// Extended Mode SAs That Used Impersonation: Extended Mode SAs That Used Impersonation is the number of extended mode security associations completed using impersonation since IPsec was last started.
  let ``Extended Mode SAs That Used Impersonation`` =
    { category = CategoryName; counter = "Extended Mode SAs That Used Impersonation"; instance = None }
  /// Failed Extended Mode Negotiations: Failed Extended Mode Negotiations is the number of failed extended mode negotiations since IPsec was last started.
  let ``Failed Extended Mode Negotiations`` =
    { category = CategoryName; counter = "Failed Extended Mode Negotiations"; instance = None }
  /// Failed Extended Mode Negotiations/sec: Failed Extended Mode Negotiations per Second is the rate of failed extended mode negotiations.
  let ``Failed Extended Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Failed Extended Mode Negotiations/sec"; instance = None }
  /// Failed Main Mode Negotiations: Failed Main Mode Negotiations is the number of failed main mode negotiations since IPsec was last started.
  let ``Failed Main Mode Negotiations`` =
    { category = CategoryName; counter = "Failed Main Mode Negotiations"; instance = None }
  /// Failed Main Mode Negotiations/sec: Failed Main Mode Negotiations per Second is the rate of failed main mode negotiations.
  let ``Failed Main Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Failed Main Mode Negotiations/sec"; instance = None }
  /// Failed Quick Mode Negotiations: Failed Quick Mode Negotiations is the number of failed quick mode negotiations since IPsec was last started.
  let ``Failed Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Failed Quick Mode Negotiations"; instance = None }
  /// Failed Quick Mode Negotiations/sec: Failed Quick Mode Negotiations per Second is the rate of failed quick mode negotiations.
  let ``Failed Quick Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Failed Quick Mode Negotiations/sec"; instance = None }
  /// Main Mode Negotiation Requests Received: Main Mode Negotiation Requests Received is the number of main mode negotiations initiated by a peer since IPsec was last started.
  let ``Main Mode Negotiation Requests Received`` =
    { category = CategoryName; counter = "Main Mode Negotiation Requests Received"; instance = None }
  /// Main Mode Negotiation Requests Received/sec: Main Mode Negotiation Requests Received per Second is the rate of main mode negotiations initiated by a peer.
  let ``Main Mode Negotiation Requests Received/sec`` =
    { category = CategoryName; counter = "Main Mode Negotiation Requests Received/sec"; instance = None }
  /// Main Mode Negotiations: Main Mode Negotiations is the number of main mode negotiations attempted since IPsec was last started.
  let ``Main Mode Negotiations`` =
    { category = CategoryName; counter = "Main Mode Negotiations"; instance = None }
  /// Main Mode Negotiations/sec: Main Mode Negotiations per Second is the rate at which main mode negotiations are being attempted.
  let ``Main Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Main Mode Negotiations/sec"; instance = None }
  /// Main Mode SAs That Used Impersonation: Main Mode SAs That Used Impersonation is the number of main mode security associations completed using impersonation since IPsec was last started.
  let ``Main Mode SAs That Used Impersonation`` =
    { category = CategoryName; counter = "Main Mode SAs That Used Impersonation"; instance = None }
  /// Main Mode SAs That Used Impersonation/sec: Main Mode SAs That Used Impersonation per Second is the rate of main mode security associations completed using impersonation.
  let ``Main Mode SAs That Used Impersonation/sec`` =
    { category = CategoryName; counter = "Main Mode SAs That Used Impersonation/sec"; instance = None }
  /// Pending Extended Mode Negotiations: Pending Extended Mode Negotiations is the number of pending extended mode negotiations.
  let ``Pending Extended Mode Negotiations`` =
    { category = CategoryName; counter = "Pending Extended Mode Negotiations"; instance = None }
  /// Pending Main Mode Negotiations: Pending Main Mode Negotiations is the number of pending main mode negotiations.
  let ``Pending Main Mode Negotiations`` =
    { category = CategoryName; counter = "Pending Main Mode Negotiations"; instance = None }
  /// Pending Quick Mode Negotiations: Pending Quick Mode Negotiations is the number of pending quick mode negotiations.
  let ``Pending Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Pending Quick Mode Negotiations"; instance = None }
  /// Quick Mode Negotiations: Quick Mode Negotiations is the number of quick mode negotiations attempted since IPsec was last started.
  let ``Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Quick Mode Negotiations"; instance = None }
  /// Quick Mode Negotiations/sec: Quick Mode Negotiations per Second is the rate at which quick mode negotiations are being attempted.
  let ``Quick Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Quick Mode Negotiations/sec"; instance = None }
  /// Successful Extended Mode Negotiations: Successful Extended Mode Negotiations is the number of extended mode negotiations completed since IPsec was last started.
  let ``Successful Extended Mode Negotiations`` =
    { category = CategoryName; counter = "Successful Extended Mode Negotiations"; instance = None }
  /// Successful Extended Mode Negotiations/sec: Successful Extended Mode Negotiations per Second is the rate of extended mode negotiations completed.
  let ``Successful Extended Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Successful Extended Mode Negotiations/sec"; instance = None }
  /// Successful Main Mode Negotiations: Successful Main Mode Negotiations is the number of main mode negotiations completed since IPsec was last started.
  let ``Successful Main Mode Negotiations`` =
    { category = CategoryName; counter = "Successful Main Mode Negotiations"; instance = None }
  /// Successful Main Mode Negotiations/sec: Successful Main Mode Negotiations per Second is the rate of main mode negotiations completed.
  let ``Successful Main Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Successful Main Mode Negotiations/sec"; instance = None }
  /// Successful Quick Mode Negotiations: Successful Quick Mode Negotiations is the number of quick mode negotiations completed since IPsec was last started.
  let ``Successful Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Successful Quick Mode Negotiations"; instance = None }
  /// Successful Quick Mode Negotiations/sec: Successful Quick Mode Negotiations per Second is the rate of quick mode negotiations completed.
  let ``Successful Quick Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Successful Quick Mode Negotiations/sec"; instance = None }

  let allCounters =
    [| ``Active Extended Mode SAs``
       ``Active Main Mode SAs``
       ``Active Quick Mode SAs``
       ``Extended Mode Negotiations``
       ``Extended Mode Negotiations/sec``
       ``Extended Mode SAs That Used Impersonation``
       ``Failed Extended Mode Negotiations``
       ``Failed Extended Mode Negotiations/sec``
       ``Failed Main Mode Negotiations``
       ``Failed Main Mode Negotiations/sec``
       ``Failed Quick Mode Negotiations``
       ``Failed Quick Mode Negotiations/sec``
       ``Main Mode Negotiation Requests Received``
       ``Main Mode Negotiation Requests Received/sec``
       ``Main Mode Negotiations``
       ``Main Mode Negotiations/sec``
       ``Main Mode SAs That Used Impersonation``
       ``Main Mode SAs That Used Impersonation/sec``
       ``Pending Extended Mode Negotiations``
       ``Pending Main Mode Negotiations``
       ``Pending Quick Mode Negotiations``
       ``Quick Mode Negotiations``
       ``Quick Mode Negotiations/sec``
       ``Successful Extended Mode Negotiations``
       ``Successful Extended Mode Negotiations/sec``
       ``Successful Main Mode Negotiations``
       ``Successful Main Mode Negotiations/sec``
       ``Successful Quick Mode Negotiations``
       ``Successful Quick Mode Negotiations/sec``
    |]

/// IPsec AuthIP IPv6: IPsec AuthIP IPv6 is the set of Internet Protocol security (IPsec) Authenticated IP (AuthIP) counters that apply to traffic and connections over Internet Protocol version 6.
///
/// This performance counter does not have instance based counters
module ``IPsec AuthIP IPv6`` =

  [<Literal>]
  let CategoryName = "IPsec AuthIP IPv6"

  let PCC = Category.create CategoryName
  /// Active Extended Mode SAs: Active Extended Mode SAs is the number of currently active extended mode security associations.
  let ``Active Extended Mode SAs`` =
    { category = CategoryName; counter = "Active Extended Mode SAs"; instance = None }
  /// Active Main Mode SAs: Active Main Mode SAs is the number of currently active main mode security associations.
  let ``Active Main Mode SAs`` =
    { category = CategoryName; counter = "Active Main Mode SAs"; instance = None }
  /// Active Quick Mode SAs: Active Quick Mode SAs is the number of currently active quick mode security associations.
  let ``Active Quick Mode SAs`` =
    { category = CategoryName; counter = "Active Quick Mode SAs"; instance = None }
  /// Extended Mode Negotiations: Extended Mode Negotiations is the number of extended mode negotiations attempted since IPsec was last started.
  let ``Extended Mode Negotiations`` =
    { category = CategoryName; counter = "Extended Mode Negotiations"; instance = None }
  /// Extended Mode Negotiations/sec: Extended Mode Negotiations per Second is the rate at which extended mode negotiations are being attempted.
  let ``Extended Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Extended Mode Negotiations/sec"; instance = None }
  /// Extended Mode SAs That Used Impersonation: Extended Mode SAs That Used Impersonation is the number of extended mode security associations completed using impersonation since IPsec was last started.
  let ``Extended Mode SAs That Used Impersonation`` =
    { category = CategoryName; counter = "Extended Mode SAs That Used Impersonation"; instance = None }
  /// Failed Extended Mode Negotiations: Failed Extended Mode Negotiations is the number of failed extended mode negotiations since IPsec was last started.
  let ``Failed Extended Mode Negotiations`` =
    { category = CategoryName; counter = "Failed Extended Mode Negotiations"; instance = None }
  /// Failed Extended Mode Negotiations/sec: Failed Extended Mode Negotiations per Second is the rate of failed extended mode negotiations.
  let ``Failed Extended Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Failed Extended Mode Negotiations/sec"; instance = None }
  /// Failed Main Mode Negotiations: Failed Main Mode Negotiations is the number of failed main mode negotiations since IPsec was last started.
  let ``Failed Main Mode Negotiations`` =
    { category = CategoryName; counter = "Failed Main Mode Negotiations"; instance = None }
  /// Failed Main Mode Negotiations/sec: Failed Main Mode Negotiations per Second is the rate of failed main mode negotiations.
  let ``Failed Main Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Failed Main Mode Negotiations/sec"; instance = None }
  /// Failed Quick Mode Negotiations: Failed Quick Mode Negotiations is the number of failed quick mode negotiations since IPsec was last started.
  let ``Failed Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Failed Quick Mode Negotiations"; instance = None }
  /// Failed Quick Mode Negotiations/sec: Failed Quick Mode Negotiations per Second is the rate of failed quick mode negotiations.
  let ``Failed Quick Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Failed Quick Mode Negotiations/sec"; instance = None }
  /// Main Mode Negotiation Requests Received: Main Mode Negotiation Requests Received is the number of main mode negotiations initiated by a peer since IPsec was last started.
  let ``Main Mode Negotiation Requests Received`` =
    { category = CategoryName; counter = "Main Mode Negotiation Requests Received"; instance = None }
  /// Main Mode Negotiation Requests Received/sec: Main Mode Negotiation Requests Received per Second is the rate of main mode negotiations initiated by a peer.
  let ``Main Mode Negotiation Requests Received/sec`` =
    { category = CategoryName; counter = "Main Mode Negotiation Requests Received/sec"; instance = None }
  /// Main Mode Negotiations: Main Mode Negotiations is the number of main mode negotiations attempted since IPsec was last started.
  let ``Main Mode Negotiations`` =
    { category = CategoryName; counter = "Main Mode Negotiations"; instance = None }
  /// Main Mode Negotiations/sec: Main Mode Negotiations per Second is the rate at which main mode negotiations are being attempted.
  let ``Main Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Main Mode Negotiations/sec"; instance = None }
  /// Main Mode SAs That Used Impersonation: Main Mode SAs That Used Impersonation is the number of main mode security associations completed using impersonation since IPsec was last started.
  let ``Main Mode SAs That Used Impersonation`` =
    { category = CategoryName; counter = "Main Mode SAs That Used Impersonation"; instance = None }
  /// Main Mode SAs That Used Impersonation/sec: Main Mode SAs That Used Impersonation per Second is the rate of main mode security associations completed using impersonation.
  let ``Main Mode SAs That Used Impersonation/sec`` =
    { category = CategoryName; counter = "Main Mode SAs That Used Impersonation/sec"; instance = None }
  /// Pending Extended Mode Negotiations: Pending Extended Mode Negotiations is the number of pending extended mode negotiations.
  let ``Pending Extended Mode Negotiations`` =
    { category = CategoryName; counter = "Pending Extended Mode Negotiations"; instance = None }
  /// Pending Main Mode Negotiations: Pending Main Mode Negotiations is the number of pending main mode negotiations.
  let ``Pending Main Mode Negotiations`` =
    { category = CategoryName; counter = "Pending Main Mode Negotiations"; instance = None }
  /// Pending Quick Mode Negotiations: Pending Quick Mode Negotiations is the number of pending quick mode negotiations.
  let ``Pending Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Pending Quick Mode Negotiations"; instance = None }
  /// Quick Mode Negotiations: Quick Mode Negotiations is the number of quick mode negotiations attempted since IPsec was last started.
  let ``Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Quick Mode Negotiations"; instance = None }
  /// Quick Mode Negotiations/sec: Quick Mode Negotiations per Second is the rate at which quick mode negotiations are being attempted.
  let ``Quick Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Quick Mode Negotiations/sec"; instance = None }
  /// Successful Extended Mode Negotiations: Successful Extended Mode Negotiations is the number of extended mode negotiations completed since IPsec was last started.
  let ``Successful Extended Mode Negotiations`` =
    { category = CategoryName; counter = "Successful Extended Mode Negotiations"; instance = None }
  /// Successful Extended Mode Negotiations/sec: Successful Extended Mode Negotiations per Second is the rate of extended mode negotiations completed.
  let ``Successful Extended Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Successful Extended Mode Negotiations/sec"; instance = None }
  /// Successful Main Mode Negotiations: Successful Main Mode Negotiations is the number of main mode negotiations completed since IPsec was last started.
  let ``Successful Main Mode Negotiations`` =
    { category = CategoryName; counter = "Successful Main Mode Negotiations"; instance = None }
  /// Successful Main Mode Negotiations/sec: Successful Main Mode Negotiations per Second is the rate of main mode negotiations completed.
  let ``Successful Main Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Successful Main Mode Negotiations/sec"; instance = None }
  /// Successful Quick Mode Negotiations: Successful Quick Mode Negotiations is the number of quick mode negotiations completed since IPsec was last started.
  let ``Successful Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Successful Quick Mode Negotiations"; instance = None }
  /// Successful Quick Mode Negotiations/sec: Successful Quick Mode Negotiations per Second is the rate of quick mode negotiations completed.
  let ``Successful Quick Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Successful Quick Mode Negotiations/sec"; instance = None }

  let allCounters =
    [| ``Active Extended Mode SAs``
       ``Active Main Mode SAs``
       ``Active Quick Mode SAs``
       ``Extended Mode Negotiations``
       ``Extended Mode Negotiations/sec``
       ``Extended Mode SAs That Used Impersonation``
       ``Failed Extended Mode Negotiations``
       ``Failed Extended Mode Negotiations/sec``
       ``Failed Main Mode Negotiations``
       ``Failed Main Mode Negotiations/sec``
       ``Failed Quick Mode Negotiations``
       ``Failed Quick Mode Negotiations/sec``
       ``Main Mode Negotiation Requests Received``
       ``Main Mode Negotiation Requests Received/sec``
       ``Main Mode Negotiations``
       ``Main Mode Negotiations/sec``
       ``Main Mode SAs That Used Impersonation``
       ``Main Mode SAs That Used Impersonation/sec``
       ``Pending Extended Mode Negotiations``
       ``Pending Main Mode Negotiations``
       ``Pending Quick Mode Negotiations``
       ``Quick Mode Negotiations``
       ``Quick Mode Negotiations/sec``
       ``Successful Extended Mode Negotiations``
       ``Successful Extended Mode Negotiations/sec``
       ``Successful Main Mode Negotiations``
       ``Successful Main Mode Negotiations/sec``
       ``Successful Quick Mode Negotiations``
       ``Successful Quick Mode Negotiations/sec``
    |]

/// IPsec Connections: IPsec Connections is the set of Internet Protocol security (IPsec) counters that apply to IPsec encapsulated connections.
///
/// This performance counter does not have instance based counters
module ``IPsec Connections`` =

  [<Literal>]
  let CategoryName = "IPsec Connections"

  let PCC = Category.create CategoryName
  /// Max number of connections since boot: Max number of connections since boot
  let ``Max number of connections since boot`` =
    { category = CategoryName; counter = "Max number of connections since boot"; instance = None }
  /// Number of failed authentications: Number of failed authentications
  let ``Number of failed authentications`` =
    { category = CategoryName; counter = "Number of failed authentications"; instance = None }
  /// Total Bytes In since start: Total Bytes In since boot
  let ``Total Bytes In since start`` =
    { category = CategoryName; counter = "Total Bytes In since start"; instance = None }
  /// Total Bytes Out since start: Total Bytes Out since boot
  let ``Total Bytes Out since start`` =
    { category = CategoryName; counter = "Total Bytes Out since start"; instance = None }
  /// Total Number current Connections: Total Number current Connections
  let ``Total Number current Connections`` =
    { category = CategoryName; counter = "Total Number current Connections"; instance = None }
  /// Total number of cumulative connections since boot: Total number of cumulative connections since boot
  let ``Total number of cumulative connections since boot`` =
    { category = CategoryName; counter = "Total number of cumulative connections since boot"; instance = None }

  let allCounters =
    [| ``Max number of connections since boot``
       ``Number of failed authentications``
       ``Total Bytes In since start``
       ``Total Bytes Out since start``
       ``Total Number current Connections``
       ``Total number of cumulative connections since boot``
    |]

/// IPsec Driver: IPsec Driver is the set of Internet Protocol security (IPsec) driver counters that apply to traffic over Internet Protocol version 4 and Internet Protocol version 6.
///
/// This performance counter does not have instance based counters
module ``IPsec Driver`` =

  [<Literal>]
  let CategoryName = "IPsec Driver"

  let PCC = Category.create CategoryName
  /// Active Security Associations: Active Security Associations is the number of active quick mode security associations.
  let ``Active Security Associations`` =
    { category = CategoryName; counter = "Active Security Associations"; instance = None }
  /// Bytes Received in Transport Mode/sec: Bytes Received in Transport Mode per Second is the rate of bytes received using transport mode.
  let ``Bytes Received in Transport Mode/sec`` =
    { category = CategoryName; counter = "Bytes Received in Transport Mode/sec"; instance = None }
  /// Bytes Received in Tunnel Mode/sec: Bytes Received in Tunnel Mode per Second is the rate of bytes received using tunnel mode.
  let ``Bytes Received in Tunnel Mode/sec`` =
    { category = CategoryName; counter = "Bytes Received in Tunnel Mode/sec"; instance = None }
  /// Bytes Sent in Transport Mode/sec: Bytes Sent in Transport Mode per Second is the rate of bytes sent using transport mode.
  let ``Bytes Sent in Transport Mode/sec`` =
    { category = CategoryName; counter = "Bytes Sent in Transport Mode/sec"; instance = None }
  /// Bytes Sent in Tunnel Mode/sec: Bytes Sent in Tunnel Mode per Second is the rate of bytes sent using tunnel mode.
  let ``Bytes Sent in Tunnel Mode/sec`` =
    { category = CategoryName; counter = "Bytes Sent in Tunnel Mode/sec"; instance = None }
  /// Inbound Packets Dropped/sec: Inbound Packets Dropped per Second is the rate of inbound packets dropped by IPsec.
  let ``Inbound Packets Dropped/sec`` =
    { category = CategoryName; counter = "Inbound Packets Dropped/sec"; instance = None }
  /// Inbound Packets Received/sec: Inbound Packets Received per Second is the rate of inbound packets successfully processed by IPsec.
  let ``Inbound Packets Received/sec`` =
    { category = CategoryName; counter = "Inbound Packets Received/sec"; instance = None }
  /// Incorrect SPI Packets: Incorrect SPI packets is the number of packets for which the Security Parameter Index (SPI) was incorrect since the computer was last started. A large number of packets with bad SPIs within a short amount of time might indicate a packet spoofing attack.
  let ``Incorrect SPI Packets`` =
    { category = CategoryName; counter = "Incorrect SPI Packets"; instance = None }
  /// Incorrect SPI Packets/sec: Incorrect SPI packets per Second is the rate of packets for which the Security Parameter Index (SPI) was incorrect since the computer was last started. A large number of packets with bad SPIs within a short amount of time might indicate a packet spoofing attack.
  let ``Incorrect SPI Packets/sec`` =
    { category = CategoryName; counter = "Incorrect SPI Packets/sec"; instance = None }
  /// Offloaded Bytes Received/sec: Offloaded Bytes Received per Second is the rate of bytes received using IPsec hardware offload. Certain network adapters can accelerate IPsec processing by performing hardware offload of IPsec cryptographic functions.
  let ``Offloaded Bytes Received/sec`` =
    { category = CategoryName; counter = "Offloaded Bytes Received/sec"; instance = None }
  /// Offloaded Bytes Sent/sec: Offloaded Bytes Sent per Second is the rate of bytes sent using IPsec hardware offload. Certain network adapters can accelerate IPsec processing by performing hardware offload of IPsec cryptographic functions.
  let ``Offloaded Bytes Sent/sec`` =
    { category = CategoryName; counter = "Offloaded Bytes Sent/sec"; instance = None }
  /// Offloaded Security Associations: Offloaded Security Associations is the number of active quick mode security associations offloaded to hardware. Certain network adapters can accelerate IPsec processing by performing hardware offload of IPsec cryptographic functions.
  let ``Offloaded Security Associations`` =
    { category = CategoryName; counter = "Offloaded Security Associations"; instance = None }
  /// Packets Not Authenticated: Packets Not Authenticated is the number of packets for which data could not be verified (for which the integrity hash verification failed) since the computer was last started. Increases in this counter might indicate an IPsec packet spoofing or modification attack, or packet corruption by network devices.
  let ``Packets Not Authenticated`` =
    { category = CategoryName; counter = "Packets Not Authenticated"; instance = None }
  /// Packets Not Authenticated/sec: Packets Not Authenticated per Second is the rate of packets for which data could not be verified (for which the integrity hash verification failed) since the computer was last started. Increases in this counter might indicate an IPsec packet spoofing or modification attack, or packet corruption by network devices.
  let ``Packets Not Authenticated/sec`` =
    { category = CategoryName; counter = "Packets Not Authenticated/sec"; instance = None }
  /// Packets Not Decrypted: Packets Not Decrypted is the number of packets that could not be decrypted since the computer was last started. A packet might not be decrypted if it fails a validation check.
  let ``Packets Not Decrypted`` =
    { category = CategoryName; counter = "Packets Not Decrypted"; instance = None }
  /// Packets Not Decrypted/sec: Packets Not Decrypted per Second is the rate of packets that could not be decrypted since the computer was last started. A packet might not be decrypted if it fails a validation check.
  let ``Packets Not Decrypted/sec`` =
    { category = CategoryName; counter = "Packets Not Decrypted/sec"; instance = None }
  /// Packets Received Over Wrong SA: Packets Received Over Wrong SA is the number of packets received over the wrong security association since the computer was last started.
  let ``Packets Received Over Wrong SA`` =
    { category = CategoryName; counter = "Packets Received Over Wrong SA"; instance = None }
  /// Packets Received Over Wrong SA/sec: Packets Received Over Wrong SA per Second is the rate of packets received over the wrong security association since the computer was last started.
  let ``Packets Received Over Wrong SA/sec`` =
    { category = CategoryName; counter = "Packets Received Over Wrong SA/sec"; instance = None }
  /// Packets That Failed ESP Validation: Packets That Failed ESP Validation is the number of packets received that failed ESP validation since the computer was last started.
  let ``Packets That Failed ESP Validation`` =
    { category = CategoryName; counter = "Packets That Failed ESP Validation"; instance = None }
  /// Packets That Failed ESP Validation/sec: Packets That Failed ESP Validation per Second is the rate of packets received that failed ESP validation since the computer was last started.
  let ``Packets That Failed ESP Validation/sec`` =
    { category = CategoryName; counter = "Packets That Failed ESP Validation/sec"; instance = None }
  /// Packets That Failed Replay Detection: Packets That Failed Replay Detection is the number of packets that contained an invalid sequence number since the computer was last started. Increases in this counter might indicate a network problem or replay attack.
  let ``Packets That Failed Replay Detection`` =
    { category = CategoryName; counter = "Packets That Failed Replay Detection"; instance = None }
  /// Packets That Failed Replay Detection/sec: Packets That Failed Replay Detection per Second is the rate of packets that contained an invalid sequence number since the computer was last started. Increases in this counter might indicate a network problem or replay attack.
  let ``Packets That Failed Replay Detection/sec`` =
    { category = CategoryName; counter = "Packets That Failed Replay Detection/sec"; instance = None }
  /// Packets That Failed UDP-ESP Validation: Packets That Failed UDP-ESP Validation is the number of packets received that failed UDP-ESP validation (used for NAT traversal) since the computer was last started.
  let ``Packets That Failed UDP-ESP Validation`` =
    { category = CategoryName; counter = "Packets That Failed UDP-ESP Validation"; instance = None }
  /// Packets That Failed UDP-ESP Validation/sec: Packets That Failed UDP-ESP Validation per Second is the rate of packets received that failed UDP-ESP validation (used for NAT traversal) since the computer was last started.
  let ``Packets That Failed UDP-ESP Validation/sec`` =
    { category = CategoryName; counter = "Packets That Failed UDP-ESP Validation/sec"; instance = None }
  /// Pending Security Associations: Pending Security Associations is the number of pending quick mode security associations.
  let ``Pending Security Associations`` =
    { category = CategoryName; counter = "Pending Security Associations"; instance = None }
  /// Plaintext Packets Received: Plaintext Packets Received is the number of clear text packets received since the computer was last started.
  let ``Plaintext Packets Received`` =
    { category = CategoryName; counter = "Plaintext Packets Received"; instance = None }
  /// Plaintext Packets Received/sec: Plaintext Packets Received per Second is the rate of clear text packets received since the computer was last started.
  let ``Plaintext Packets Received/sec`` =
    { category = CategoryName; counter = "Plaintext Packets Received/sec"; instance = None }
  /// SA Rekeys: SA Rekeys is the number of successful rekey operations for quick mode security associations since the computer was last started.
  let ``SA Rekeys`` =
    { category = CategoryName; counter = "SA Rekeys"; instance = None }
  /// Security Associations Added: Security Associations Added is the number of security associations added since the computer was last started.
  let ``Security Associations Added`` =
    { category = CategoryName; counter = "Security Associations Added"; instance = None }
  /// Total Inbound Packets Dropped: Total Inbound Packets Dropped is the total number of inbound packets dropped by IPsec, since the computer was last started.
  let ``Total Inbound Packets Dropped`` =
    { category = CategoryName; counter = "Total Inbound Packets Dropped"; instance = None }
  /// Total Inbound Packets Received: Total Inbound Packets Received is the total number of inbound packets successfully processed by IPsec, since the computer was last started.
  let ``Total Inbound Packets Received`` =
    { category = CategoryName; counter = "Total Inbound Packets Received"; instance = None }

  let allCounters =
    [| ``Active Security Associations``
       ``Bytes Received in Transport Mode/sec``
       ``Bytes Received in Tunnel Mode/sec``
       ``Bytes Sent in Transport Mode/sec``
       ``Bytes Sent in Tunnel Mode/sec``
       ``Inbound Packets Dropped/sec``
       ``Inbound Packets Received/sec``
       ``Incorrect SPI Packets``
       ``Incorrect SPI Packets/sec``
       ``Offloaded Bytes Received/sec``
       ``Offloaded Bytes Sent/sec``
       ``Offloaded Security Associations``
       ``Packets Not Authenticated``
       ``Packets Not Authenticated/sec``
       ``Packets Not Decrypted``
       ``Packets Not Decrypted/sec``
       ``Packets Received Over Wrong SA``
       ``Packets Received Over Wrong SA/sec``
       ``Packets That Failed ESP Validation``
       ``Packets That Failed ESP Validation/sec``
       ``Packets That Failed Replay Detection``
       ``Packets That Failed Replay Detection/sec``
       ``Packets That Failed UDP-ESP Validation``
       ``Packets That Failed UDP-ESP Validation/sec``
       ``Pending Security Associations``
       ``Plaintext Packets Received``
       ``Plaintext Packets Received/sec``
       ``SA Rekeys``
       ``Security Associations Added``
       ``Total Inbound Packets Dropped``
       ``Total Inbound Packets Received``
    |]

/// IPsec IKEv1 IPv4: IPsec IKEv1 IPv4 is the set of Internet Protocol security (IPsec) Internet Key Exchange version 1 (IKEv1) counters that apply to traffic and connections over Internet Protocol version 4.
///
/// This performance counter does not have instance based counters
module ``IPsec IKEv1 IPv4`` =

  [<Literal>]
  let CategoryName = "IPsec IKEv1 IPv4"

  let PCC = Category.create CategoryName
  /// Active Main Mode SAs: Active Main Mode SAs is the number of currently active main mode security associations.
  let ``Active Main Mode SAs`` =
    { category = CategoryName; counter = "Active Main Mode SAs"; instance = None }
  /// Active Quick Mode SAs: Active Quick Mode SAs is the number of currently active quick mode security associations.
  let ``Active Quick Mode SAs`` =
    { category = CategoryName; counter = "Active Quick Mode SAs"; instance = None }
  /// Failed Main Mode Negotiations: Failed Main Mode Negotiations is the number of failed main mode negotiations since IPsec was last started.
  let ``Failed Main Mode Negotiations`` =
    { category = CategoryName; counter = "Failed Main Mode Negotiations"; instance = None }
  /// Failed Main Mode Negotiations/sec: Failed Main Mode Negotiations per Second is the rate of failed main mode negotiations.
  let ``Failed Main Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Failed Main Mode Negotiations/sec"; instance = None }
  /// Failed Quick Mode Negotiations: Failed Quick Mode Negotiations is the number of failed quick mode negotiations since IPsec was last started.
  let ``Failed Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Failed Quick Mode Negotiations"; instance = None }
  /// Failed Quick Mode Negotiations/sec: Failed Quick Mode Negotiations per Second is the rate of failed quick mode negotiations.
  let ``Failed Quick Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Failed Quick Mode Negotiations/sec"; instance = None }
  /// Main Mode Negotiation Requests Received: Main Mode Negotiation Requests Received is the number of main mode negotiations initiated by a peer since IPsec was last started.
  let ``Main Mode Negotiation Requests Received`` =
    { category = CategoryName; counter = "Main Mode Negotiation Requests Received"; instance = None }
  /// Main Mode Negotiation Requests Received/sec: Main Mode Negotiation Requests Received per Second is the rate of main mode negotiations initiated by a peer.
  let ``Main Mode Negotiation Requests Received/sec`` =
    { category = CategoryName; counter = "Main Mode Negotiation Requests Received/sec"; instance = None }
  /// Main Mode Negotiations: Main Mode Negotiations is the number of main mode negotiations attempted since IPsec was last started.
  let ``Main Mode Negotiations`` =
    { category = CategoryName; counter = "Main Mode Negotiations"; instance = None }
  /// Main Mode Negotiations/sec: Main Mode Negotiations per Second is the rate at which main mode negotiations are being attempted.
  let ``Main Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Main Mode Negotiations/sec"; instance = None }
  /// Pending Main Mode Negotiations: Pending Main Mode Negotiations is the number of pending main mode negotiations.
  let ``Pending Main Mode Negotiations`` =
    { category = CategoryName; counter = "Pending Main Mode Negotiations"; instance = None }
  /// Pending Quick Mode Negotiations: Pending Quick Mode Negotiations is the number of pending quick mode negotiations.
  let ``Pending Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Pending Quick Mode Negotiations"; instance = None }
  /// Quick Mode Negotiations: Quick Mode Negotiations is the number of quick mode negotiations attempted since IPsec was last started.
  let ``Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Quick Mode Negotiations"; instance = None }
  /// Quick Mode Negotiations/sec: Quick Mode Negotiations per Second is the rate at which quick mode negotiations are being attempted.
  let ``Quick Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Quick Mode Negotiations/sec"; instance = None }
  /// Successful Main Mode Negotiations: Successful Main Mode Negotiations is the number of main mode negotiations completed since IPsec was last started.
  let ``Successful Main Mode Negotiations`` =
    { category = CategoryName; counter = "Successful Main Mode Negotiations"; instance = None }
  /// Successful Main Mode Negotiations/sec: Successful Main Mode Negotiations per Second is the rate of main mode negotiations completed.
  let ``Successful Main Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Successful Main Mode Negotiations/sec"; instance = None }
  /// Successful Quick Mode Negotiations: Successful Quick Mode Negotiations is the number of quick mode negotiations completed since IPsec was last started.
  let ``Successful Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Successful Quick Mode Negotiations"; instance = None }
  /// Successful Quick Mode Negotiations/sec: Successful Quick Mode Negotiations per Second is the rate of quick mode negotiations completed.
  let ``Successful Quick Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Successful Quick Mode Negotiations/sec"; instance = None }

  let allCounters =
    [| ``Active Main Mode SAs``
       ``Active Quick Mode SAs``
       ``Failed Main Mode Negotiations``
       ``Failed Main Mode Negotiations/sec``
       ``Failed Quick Mode Negotiations``
       ``Failed Quick Mode Negotiations/sec``
       ``Main Mode Negotiation Requests Received``
       ``Main Mode Negotiation Requests Received/sec``
       ``Main Mode Negotiations``
       ``Main Mode Negotiations/sec``
       ``Pending Main Mode Negotiations``
       ``Pending Quick Mode Negotiations``
       ``Quick Mode Negotiations``
       ``Quick Mode Negotiations/sec``
       ``Successful Main Mode Negotiations``
       ``Successful Main Mode Negotiations/sec``
       ``Successful Quick Mode Negotiations``
       ``Successful Quick Mode Negotiations/sec``
    |]

/// IPsec IKEv1 IPv6: IPsec IKEv1 IPv6 is the set of Internet Protocol security (IPsec) Internet Key Exchange version 1 (IKEv1) counters that apply to traffic and connections over Internet Protocol version 6.
///
/// This performance counter does not have instance based counters
module ``IPsec IKEv1 IPv6`` =

  [<Literal>]
  let CategoryName = "IPsec IKEv1 IPv6"

  let PCC = Category.create CategoryName
  /// Active Main Mode SAs: Active Main Mode SAs is the number of currently active main mode security associations.
  let ``Active Main Mode SAs`` =
    { category = CategoryName; counter = "Active Main Mode SAs"; instance = None }
  /// Active Quick Mode SAs: Active Quick Mode SAs is the number of currently active quick mode security associations.
  let ``Active Quick Mode SAs`` =
    { category = CategoryName; counter = "Active Quick Mode SAs"; instance = None }
  /// Failed Main Mode Negotiations: Failed Main Mode Negotiations is the number of failed main mode negotiations since IPsec was last started.
  let ``Failed Main Mode Negotiations`` =
    { category = CategoryName; counter = "Failed Main Mode Negotiations"; instance = None }
  /// Failed Main Mode Negotiations/sec: Failed Main Mode Negotiations per Second is the rate of failed main mode negotiations.
  let ``Failed Main Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Failed Main Mode Negotiations/sec"; instance = None }
  /// Failed Quick Mode Negotiations: Failed Quick Mode Negotiations is the number of failed quick mode negotiations since IPsec was last started.
  let ``Failed Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Failed Quick Mode Negotiations"; instance = None }
  /// Failed Quick Mode Negotiations/sec: Failed Quick Mode Negotiations per Second is the rate of failed quick mode negotiations.
  let ``Failed Quick Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Failed Quick Mode Negotiations/sec"; instance = None }
  /// Main Mode Negotiation Requests Received: Main Mode Negotiation Requests Received is the number of main mode negotiations initiated by a peer since IPsec was last started.
  let ``Main Mode Negotiation Requests Received`` =
    { category = CategoryName; counter = "Main Mode Negotiation Requests Received"; instance = None }
  /// Main Mode Negotiation Requests Received/sec: Main Mode Negotiation Requests Received per Second is the rate of main mode negotiations initiated by a peer.
  let ``Main Mode Negotiation Requests Received/sec`` =
    { category = CategoryName; counter = "Main Mode Negotiation Requests Received/sec"; instance = None }
  /// Main Mode Negotiations: Main Mode Negotiations is the number of main mode negotiations attempted since IPsec was last started.
  let ``Main Mode Negotiations`` =
    { category = CategoryName; counter = "Main Mode Negotiations"; instance = None }
  /// Main Mode Negotiations/sec: Main Mode Negotiations per Second is the rate at which main mode negotiations are being attempted.
  let ``Main Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Main Mode Negotiations/sec"; instance = None }
  /// Pending Main Mode Negotiations: Pending Main Mode Negotiations is the number of pending main mode negotiations.
  let ``Pending Main Mode Negotiations`` =
    { category = CategoryName; counter = "Pending Main Mode Negotiations"; instance = None }
  /// Pending Quick Mode Negotiations: Pending Quick Mode Negotiations is the number of pending quick mode negotiations.
  let ``Pending Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Pending Quick Mode Negotiations"; instance = None }
  /// Quick Mode Negotiations: Quick Mode Negotiations is the number of quick mode negotiations attempted since IPsec was last started.
  let ``Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Quick Mode Negotiations"; instance = None }
  /// Quick Mode Negotiations/sec: Quick Mode Negotiations per Second is the rate at which quick mode negotiations are being attempted.
  let ``Quick Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Quick Mode Negotiations/sec"; instance = None }
  /// Successful Main Mode Negotiations: Successful Main Mode Negotiations is the number of main mode negotiations completed since IPsec was last started.
  let ``Successful Main Mode Negotiations`` =
    { category = CategoryName; counter = "Successful Main Mode Negotiations"; instance = None }
  /// Successful Main Mode Negotiations/sec: Successful Main Mode Negotiations per Second is the rate of main mode negotiations completed.
  let ``Successful Main Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Successful Main Mode Negotiations/sec"; instance = None }
  /// Successful Quick Mode Negotiations: Successful Quick Mode Negotiations is the number of quick mode negotiations completed since IPsec was last started.
  let ``Successful Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Successful Quick Mode Negotiations"; instance = None }
  /// Successful Quick Mode Negotiations/sec: Successful Quick Mode Negotiations per Second is the rate of quick mode negotiations completed.
  let ``Successful Quick Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Successful Quick Mode Negotiations/sec"; instance = None }

  let allCounters =
    [| ``Active Main Mode SAs``
       ``Active Quick Mode SAs``
       ``Failed Main Mode Negotiations``
       ``Failed Main Mode Negotiations/sec``
       ``Failed Quick Mode Negotiations``
       ``Failed Quick Mode Negotiations/sec``
       ``Main Mode Negotiation Requests Received``
       ``Main Mode Negotiation Requests Received/sec``
       ``Main Mode Negotiations``
       ``Main Mode Negotiations/sec``
       ``Pending Main Mode Negotiations``
       ``Pending Quick Mode Negotiations``
       ``Quick Mode Negotiations``
       ``Quick Mode Negotiations/sec``
       ``Successful Main Mode Negotiations``
       ``Successful Main Mode Negotiations/sec``
       ``Successful Quick Mode Negotiations``
       ``Successful Quick Mode Negotiations/sec``
    |]

/// IPsec IKEv2 IPv4: IPsec IKEv2 IPv4 is the set of Internet Protocol security (IPsec) Internet Key Exchange version 2 (IKEv2) counters that apply to traffic and connections over Internet Protocol version 4.
///
/// This performance counter does not have instance based counters
module ``IPsec IKEv2 IPv4`` =

  [<Literal>]
  let CategoryName = "IPsec IKEv2 IPv4"

  let PCC = Category.create CategoryName
  /// Active Main Mode SAs: Active Main Mode SAs is the number of currently active main mode security associations.
  let ``Active Main Mode SAs`` =
    { category = CategoryName; counter = "Active Main Mode SAs"; instance = None }
  /// Active Quick Mode SAs: Active Quick Mode SAs is the number of currently active quick mode security associations.
  let ``Active Quick Mode SAs`` =
    { category = CategoryName; counter = "Active Quick Mode SAs"; instance = None }
  /// Failed Main Mode Negotiations: Failed Main Mode Negotiations is the number of failed main mode negotiations since IPsec was last started.
  let ``Failed Main Mode Negotiations`` =
    { category = CategoryName; counter = "Failed Main Mode Negotiations"; instance = None }
  /// Failed Main Mode Negotiations/sec: Failed Main Mode Negotiations per Second is the rate of failed main mode negotiations.
  let ``Failed Main Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Failed Main Mode Negotiations/sec"; instance = None }
  /// Failed Quick Mode Negotiations: Failed Quick Mode Negotiations is the number of failed quick mode negotiations since IPsec was last started.
  let ``Failed Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Failed Quick Mode Negotiations"; instance = None }
  /// Failed Quick Mode Negotiations/sec: Failed Quick Mode Negotiations per Second is the rate of failed quick mode negotiations.
  let ``Failed Quick Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Failed Quick Mode Negotiations/sec"; instance = None }
  /// Main Mode Negotiation Requests Received: Main Mode Negotiation Requests Received is the number of main mode negotiations initiated by a peer since IPsec was last started.
  let ``Main Mode Negotiation Requests Received`` =
    { category = CategoryName; counter = "Main Mode Negotiation Requests Received"; instance = None }
  /// Main Mode Negotiation Requests Received/sec: Main Mode Negotiation Requests Received per Second is the rate of main mode negotiations initiated by a peer.
  let ``Main Mode Negotiation Requests Received/sec`` =
    { category = CategoryName; counter = "Main Mode Negotiation Requests Received/sec"; instance = None }
  /// Main Mode Negotiations: Main Mode Negotiations is the number of main mode negotiations attempted since IPsec was last started.
  let ``Main Mode Negotiations`` =
    { category = CategoryName; counter = "Main Mode Negotiations"; instance = None }
  /// Main Mode Negotiations/sec: Main Mode Negotiations per Second is the rate at which main mode negotiations are being attempted.
  let ``Main Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Main Mode Negotiations/sec"; instance = None }
  /// Pending Main Mode Negotiations: Pending Main Mode Negotiations is the number of pending main mode negotiations.
  let ``Pending Main Mode Negotiations`` =
    { category = CategoryName; counter = "Pending Main Mode Negotiations"; instance = None }
  /// Pending Quick Mode Negotiations: Pending Quick Mode Negotiations is the number of pending quick mode negotiations.
  let ``Pending Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Pending Quick Mode Negotiations"; instance = None }
  /// Quick Mode Negotiations: Quick Mode Negotiations is the number of quick mode negotiations attempted since IPsec was last started.
  let ``Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Quick Mode Negotiations"; instance = None }
  /// Quick Mode Negotiations/sec: Quick Mode Negotiations per Second is the rate at which quick mode negotiations are being attempted.
  let ``Quick Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Quick Mode Negotiations/sec"; instance = None }
  /// Successful Main Mode Negotiations: Successful Main Mode Negotiations is the number of main mode negotiations completed since IPsec was last started.
  let ``Successful Main Mode Negotiations`` =
    { category = CategoryName; counter = "Successful Main Mode Negotiations"; instance = None }
  /// Successful Main Mode Negotiations/sec: Successful Main Mode Negotiations per Second is the rate of main mode negotiations completed.
  let ``Successful Main Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Successful Main Mode Negotiations/sec"; instance = None }
  /// Successful Quick Mode Negotiations: Successful Quick Mode Negotiations is the number of quick mode negotiations completed since IPsec was last started.
  let ``Successful Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Successful Quick Mode Negotiations"; instance = None }
  /// Successful Quick Mode Negotiations/sec: Successful Quick Mode Negotiations per Second is the rate of quick mode negotiations completed.
  let ``Successful Quick Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Successful Quick Mode Negotiations/sec"; instance = None }

  let allCounters =
    [| ``Active Main Mode SAs``
       ``Active Quick Mode SAs``
       ``Failed Main Mode Negotiations``
       ``Failed Main Mode Negotiations/sec``
       ``Failed Quick Mode Negotiations``
       ``Failed Quick Mode Negotiations/sec``
       ``Main Mode Negotiation Requests Received``
       ``Main Mode Negotiation Requests Received/sec``
       ``Main Mode Negotiations``
       ``Main Mode Negotiations/sec``
       ``Pending Main Mode Negotiations``
       ``Pending Quick Mode Negotiations``
       ``Quick Mode Negotiations``
       ``Quick Mode Negotiations/sec``
       ``Successful Main Mode Negotiations``
       ``Successful Main Mode Negotiations/sec``
       ``Successful Quick Mode Negotiations``
       ``Successful Quick Mode Negotiations/sec``
    |]

/// IPsec IKEv2 IPv6: IPsec IKEv2 IPv6 is the set of Internet Protocol security (IPsec) Internet Key Exchange version 2 (IKEv2) counters that apply to traffic and connections over Internet Protocol version 6.
///
/// This performance counter does not have instance based counters
module ``IPsec IKEv2 IPv6`` =

  [<Literal>]
  let CategoryName = "IPsec IKEv2 IPv6"

  let PCC = Category.create CategoryName
  /// Active Main Mode SAs: Active Main Mode SAs is the number of currently active main mode security associations.
  let ``Active Main Mode SAs`` =
    { category = CategoryName; counter = "Active Main Mode SAs"; instance = None }
  /// Active Quick Mode SAs: Active Quick Mode SAs is the number of currently active quick mode security associations.
  let ``Active Quick Mode SAs`` =
    { category = CategoryName; counter = "Active Quick Mode SAs"; instance = None }
  /// Failed Main Mode Negotiations: Failed Main Mode Negotiations is the number of failed main mode negotiations since IPsec was last started.
  let ``Failed Main Mode Negotiations`` =
    { category = CategoryName; counter = "Failed Main Mode Negotiations"; instance = None }
  /// Failed Main Mode Negotiations/sec: Failed Main Mode Negotiations per Second is the rate of failed main mode negotiations.
  let ``Failed Main Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Failed Main Mode Negotiations/sec"; instance = None }
  /// Failed Quick Mode Negotiations: Failed Quick Mode Negotiations is the number of failed quick mode negotiations since IPsec was last started.
  let ``Failed Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Failed Quick Mode Negotiations"; instance = None }
  /// Failed Quick Mode Negotiations/sec: Failed Quick Mode Negotiations per Second is the rate of failed quick mode negotiations.
  let ``Failed Quick Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Failed Quick Mode Negotiations/sec"; instance = None }
  /// Main Mode Negotiation Requests Received: Main Mode Negotiation Requests Received is the number of main mode negotiations initiated by a peer since IPsec was last started.
  let ``Main Mode Negotiation Requests Received`` =
    { category = CategoryName; counter = "Main Mode Negotiation Requests Received"; instance = None }
  /// Main Mode Negotiation Requests Received/sec: Main Mode Negotiation Requests Received per Second is the rate of main mode negotiations initiated by a peer.
  let ``Main Mode Negotiation Requests Received/sec`` =
    { category = CategoryName; counter = "Main Mode Negotiation Requests Received/sec"; instance = None }
  /// Main Mode Negotiations: Main Mode Negotiations is the number of main mode negotiations attempted since IPsec was last started.
  let ``Main Mode Negotiations`` =
    { category = CategoryName; counter = "Main Mode Negotiations"; instance = None }
  /// Main Mode Negotiations/sec: Main Mode Negotiations per Second is the rate at which main mode negotiations are being attempted.
  let ``Main Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Main Mode Negotiations/sec"; instance = None }
  /// Pending Main Mode Negotiations: Pending Main Mode Negotiations is the number of pending main mode negotiations.
  let ``Pending Main Mode Negotiations`` =
    { category = CategoryName; counter = "Pending Main Mode Negotiations"; instance = None }
  /// Pending Quick Mode Negotiations: Pending Quick Mode Negotiations is the number of pending quick mode negotiations.
  let ``Pending Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Pending Quick Mode Negotiations"; instance = None }
  /// Quick Mode Negotiations: Quick Mode Negotiations is the number of quick mode negotiations attempted since IPsec was last started.
  let ``Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Quick Mode Negotiations"; instance = None }
  /// Quick Mode Negotiations/sec: Quick Mode Negotiations per Second is the rate at which quick mode negotiations are being attempted.
  let ``Quick Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Quick Mode Negotiations/sec"; instance = None }
  /// Successful Main Mode Negotiations: Successful Main Mode Negotiations is the number of main mode negotiations completed since IPsec was last started.
  let ``Successful Main Mode Negotiations`` =
    { category = CategoryName; counter = "Successful Main Mode Negotiations"; instance = None }
  /// Successful Main Mode Negotiations/sec: Successful Main Mode Negotiations per Second is the rate of main mode negotiations completed.
  let ``Successful Main Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Successful Main Mode Negotiations/sec"; instance = None }
  /// Successful Quick Mode Negotiations: Successful Quick Mode Negotiations is the number of quick mode negotiations completed since IPsec was last started.
  let ``Successful Quick Mode Negotiations`` =
    { category = CategoryName; counter = "Successful Quick Mode Negotiations"; instance = None }
  /// Successful Quick Mode Negotiations/sec: Successful Quick Mode Negotiations per Second is the rate of quick mode negotiations completed.
  let ``Successful Quick Mode Negotiations/sec`` =
    { category = CategoryName; counter = "Successful Quick Mode Negotiations/sec"; instance = None }

  let allCounters =
    [| ``Active Main Mode SAs``
       ``Active Quick Mode SAs``
       ``Failed Main Mode Negotiations``
       ``Failed Main Mode Negotiations/sec``
       ``Failed Quick Mode Negotiations``
       ``Failed Quick Mode Negotiations/sec``
       ``Main Mode Negotiation Requests Received``
       ``Main Mode Negotiation Requests Received/sec``
       ``Main Mode Negotiations``
       ``Main Mode Negotiations/sec``
       ``Pending Main Mode Negotiations``
       ``Pending Quick Mode Negotiations``
       ``Quick Mode Negotiations``
       ``Quick Mode Negotiations/sec``
       ``Successful Main Mode Negotiations``
       ``Successful Main Mode Negotiations/sec``
       ``Successful Quick Mode Negotiations``
       ``Successful Quick Mode Negotiations/sec``
    |]

/// IPv4: The IP performance object consists of counters that measure the rates at which IP datagrams are sent and received by using IP protocols.  It also includes counters that monitor IP protocol errors.
///
/// This performance counter does not have instance based counters
module ``IPv4`` =

  [<Literal>]
  let CategoryName = "IPv4"

  let PCC = Category.create CategoryName
  /// Datagrams Forwarded/sec: Datagrams Forwarded/sec is the rate, in incidents per second, at which attemps were made to find routes to forward input datagrams their final destination, because the local server was not the final IP destination. In servers that do not act as IP Gateways, this rate includes only packets that were source-routed via this entity, where the source-route option processing was successful.
  let ``Datagrams Forwarded/sec`` =
    { category = CategoryName; counter = "Datagrams Forwarded/sec"; instance = None }
  /// Datagrams Outbound Discarded: Datagrams Outbound Discarded is the number of output IP datagrams that were discarded even though no problems were encountered to prevent their transmission to their destination (for example, lack of buffer space). This counter includes datagrams counted in Datagrams Forwarded/sec that meet this criterion.
  let ``Datagrams Outbound Discarded`` =
    { category = CategoryName; counter = "Datagrams Outbound Discarded"; instance = None }
  /// Datagrams Outbound No Route: Datagrams Outbound No Route is the number of IP datagrams that were discarded because no route could be found to transmit them to their destination.  This counter includes any packets counted in Datagrams Forwarded/sec that meet this `no route' criterion.
  let ``Datagrams Outbound No Route`` =
    { category = CategoryName; counter = "Datagrams Outbound No Route"; instance = None }
  /// Datagrams Received Address Errors: Datagrams Received Address Errors is the number of input datagrams that were discarded because the IP address in their IP header destination field was not valid for the computer. This count includes invalid addresses (for example, 0.0.  0.0) and addresses of unsupported Classes (for example, Class E). For entities that are not IP gateways and do not forward datagrams, this counter includes datagrams that were discarded because the destination address was not a local address.
  let ``Datagrams Received Address Errors`` =
    { category = CategoryName; counter = "Datagrams Received Address Errors"; instance = None }
  /// Datagrams Received Delivered/sec: Datagrams Received Delivered/sec is the rate, in incidents per second, at which input datagrams were successfully delivered to IP user-protocols, including Internet Control Message Protocol (ICMP).
  let ``Datagrams Received Delivered/sec`` =
    { category = CategoryName; counter = "Datagrams Received Delivered/sec"; instance = None }
  /// Datagrams Received Discarded: Datagrams Received Discarded is the number of input IP datagrams that were discarded even though problems prevented their continued processing (for example, lack of buffer space). This counter does not include any datagrams discarded while awaiting re-assembly.
  let ``Datagrams Received Discarded`` =
    { category = CategoryName; counter = "Datagrams Received Discarded"; instance = None }
  /// Datagrams Received Header Errors: Datagrams Received Header Errors is the number of input datagrams that were discarded due to errors in the IP headers, including bad checksums, version number mismatch, other format errors, time-to-live exceeded, errors discovered in processing their IP options, etc.
  let ``Datagrams Received Header Errors`` =
    { category = CategoryName; counter = "Datagrams Received Header Errors"; instance = None }
  /// Datagrams Received Unknown Protocol: Datagrams Received Unknown Protocol is the number of locally-addressed datagrams that were successfully received but were discarded because of an unknown or unsupported protocol.
  let ``Datagrams Received Unknown Protocol`` =
    { category = CategoryName; counter = "Datagrams Received Unknown Protocol"; instance = None }
  /// Datagrams Received/sec: Datagrams Received/sec is the rate, in incidents per second, at which IP datagrams are received from the interfaces, including those in error. Datagrams Received/sec is a subset of Datagrams/sec.
  let ``Datagrams Received/sec`` =
    { category = CategoryName; counter = "Datagrams Received/sec"; instance = None }
  /// Datagrams Sent/sec: Datagrams Sent/sec is the rate, in incidents per second, at which IP datagrams were supplied for transmission by local IP user-protocols (including ICMP). This counter does not include any datagrams counted in Datagrams Forwarded/sec. Datagrams Sent/sec is a subset of Datagrams/sec.
  let ``Datagrams Sent/sec`` =
    { category = CategoryName; counter = "Datagrams Sent/sec"; instance = None }
  /// Datagrams/sec: Datagrams/sec is the rate, in incidents per second, at which IP datagrams were received from or sent to the interfaces, including those in error. Forwarded datagrams are not included in this rate.
  let ``Datagrams/sec`` =
    { category = CategoryName; counter = "Datagrams/sec"; instance = None }
  /// Fragment Re-assembly Failures: Fragment Re-assembly Failures is the number of failures detected by the IP reassembly algorithm, such as time outs, errors, etc.  This is not necessarily a count of discarded IP fragments since some algorithms (notably RFC 815) lose track of the number of fragments by combining them as they are received.
  let ``Fragment Re-assembly Failures`` =
    { category = CategoryName; counter = "Fragment Re-assembly Failures"; instance = None }
  /// Fragmentation Failures: Fragmentation Failures is the number of IP datagrams that were discarded because they needed to be fragmented at but could not be (for example, because the `Don't Fragment' flag was set).
  let ``Fragmentation Failures`` =
    { category = CategoryName; counter = "Fragmentation Failures"; instance = None }
  /// Fragmented Datagrams/sec: Fragmented Datagrams/sec is the rate, in incidents per second, at which datagrams are successfully fragmented.
  let ``Fragmented Datagrams/sec`` =
    { category = CategoryName; counter = "Fragmented Datagrams/sec"; instance = None }
  /// Fragments Created/sec: Fragments Created/sec is the rate, in incidents per second, at which IP datagram fragments were generated as a result of fragmentation.
  let ``Fragments Created/sec`` =
    { category = CategoryName; counter = "Fragments Created/sec"; instance = None }
  /// Fragments Re-assembled/sec: Fragments Re-assembled/sec is the rate, in incidents per second, at which IP fragments were successfully reassembled.
  let ``Fragments Re-assembled/sec`` =
    { category = CategoryName; counter = "Fragments Re-assembled/sec"; instance = None }
  /// Fragments Received/sec: Fragments Received/sec is the rate, in incidents per second, at which IP fragments that need to be reassembled at this entity are received.
  let ``Fragments Received/sec`` =
    { category = CategoryName; counter = "Fragments Received/sec"; instance = None }

  let allCounters =
    [| ``Datagrams Forwarded/sec``
       ``Datagrams Outbound Discarded``
       ``Datagrams Outbound No Route``
       ``Datagrams Received Address Errors``
       ``Datagrams Received Delivered/sec``
       ``Datagrams Received Discarded``
       ``Datagrams Received Header Errors``
       ``Datagrams Received Unknown Protocol``
       ``Datagrams Received/sec``
       ``Datagrams Sent/sec``
       ``Datagrams/sec``
       ``Fragment Re-assembly Failures``
       ``Fragmentation Failures``
       ``Fragmented Datagrams/sec``
       ``Fragments Created/sec``
       ``Fragments Re-assembled/sec``
       ``Fragments Received/sec``
    |]

/// IPv6: The IP performance object consists of counters that measure the rates at which IP datagrams are sent and received by using IP protocols.  It also includes counters that monitor IP protocol errors.
///
/// This performance counter does not have instance based counters
module ``IPv6`` =

  [<Literal>]
  let CategoryName = "IPv6"

  let PCC = Category.create CategoryName
  /// Datagrams Forwarded/sec: Datagrams Forwarded/sec is the rate, in incidents per second, at which attemps were made to find routes to forward input datagrams their final destination, because the local server was not the final IP destination. In servers that do not act as IP Gateways, this rate includes only packets that were source-routed via this entity, where the source-route option processing was successful.
  let ``Datagrams Forwarded/sec`` =
    { category = CategoryName; counter = "Datagrams Forwarded/sec"; instance = None }
  /// Datagrams Outbound Discarded: Datagrams Outbound Discarded is the number of output IP datagrams that were discarded even though no problems were encountered to prevent their transmission to their destination (for example, lack of buffer space). This counter includes datagrams counted in Datagrams Forwarded/sec that meet this criterion.
  let ``Datagrams Outbound Discarded`` =
    { category = CategoryName; counter = "Datagrams Outbound Discarded"; instance = None }
  /// Datagrams Outbound No Route: Datagrams Outbound No Route is the number of IP datagrams that were discarded because no route could be found to transmit them to their destination.  This counter includes any packets counted in Datagrams Forwarded/sec that meet this `no route' criterion.
  let ``Datagrams Outbound No Route`` =
    { category = CategoryName; counter = "Datagrams Outbound No Route"; instance = None }
  /// Datagrams Received Address Errors: Datagrams Received Address Errors is the number of input datagrams that were discarded because the IP address in their IP header destination field was not valid for the computer. This count includes invalid addresses (for example, 0.0.  0.0) and addresses of unsupported Classes (for example, Class E). For entities that are not IP gateways and do not forward datagrams, this counter includes datagrams that were discarded because the destination address was not a local address.
  let ``Datagrams Received Address Errors`` =
    { category = CategoryName; counter = "Datagrams Received Address Errors"; instance = None }
  /// Datagrams Received Delivered/sec: Datagrams Received Delivered/sec is the rate, in incidents per second, at which input datagrams were successfully delivered to IP user-protocols, including Internet Control Message Protocol (ICMP).
  let ``Datagrams Received Delivered/sec`` =
    { category = CategoryName; counter = "Datagrams Received Delivered/sec"; instance = None }
  /// Datagrams Received Discarded: Datagrams Received Discarded is the number of input IP datagrams that were discarded even though problems prevented their continued processing (for example, lack of buffer space). This counter does not include any datagrams discarded while awaiting re-assembly.
  let ``Datagrams Received Discarded`` =
    { category = CategoryName; counter = "Datagrams Received Discarded"; instance = None }
  /// Datagrams Received Header Errors: Datagrams Received Header Errors is the number of input datagrams that were discarded due to errors in the IP headers, including bad checksums, version number mismatch, other format errors, time-to-live exceeded, errors discovered in processing their IP options, etc.
  let ``Datagrams Received Header Errors`` =
    { category = CategoryName; counter = "Datagrams Received Header Errors"; instance = None }
  /// Datagrams Received Unknown Protocol: Datagrams Received Unknown Protocol is the number of locally-addressed datagrams that were successfully received but were discarded because of an unknown or unsupported protocol.
  let ``Datagrams Received Unknown Protocol`` =
    { category = CategoryName; counter = "Datagrams Received Unknown Protocol"; instance = None }
  /// Datagrams Received/sec: Datagrams Received/sec is the rate, in incidents per second, at which IP datagrams are received from the interfaces, including those in error. Datagrams Received/sec is a subset of Datagrams/sec.
  let ``Datagrams Received/sec`` =
    { category = CategoryName; counter = "Datagrams Received/sec"; instance = None }
  /// Datagrams Sent/sec: Datagrams Sent/sec is the rate, in incidents per second, at which IP datagrams were supplied for transmission by local IP user-protocols (including ICMP). This counter does not include any datagrams counted in Datagrams Forwarded/sec. Datagrams Sent/sec is a subset of Datagrams/sec.
  let ``Datagrams Sent/sec`` =
    { category = CategoryName; counter = "Datagrams Sent/sec"; instance = None }
  /// Datagrams/sec: Datagrams/sec is the rate, in incidents per second, at which IP datagrams were received from or sent to the interfaces, including those in error. Forwarded datagrams are not included in this rate.
  let ``Datagrams/sec`` =
    { category = CategoryName; counter = "Datagrams/sec"; instance = None }
  /// Fragment Re-assembly Failures: Fragment Re-assembly Failures is the number of failures detected by the IP reassembly algorithm, such as time outs, errors, etc.  This is not necessarily a count of discarded IP fragments since some algorithms (notably RFC 815) lose track of the number of fragments by combining them as they are received.
  let ``Fragment Re-assembly Failures`` =
    { category = CategoryName; counter = "Fragment Re-assembly Failures"; instance = None }
  /// Fragmentation Failures: Fragmentation Failures is the number of IP datagrams that were discarded because they needed to be fragmented at but could not be (for example, because the `Don't Fragment' flag was set).
  let ``Fragmentation Failures`` =
    { category = CategoryName; counter = "Fragmentation Failures"; instance = None }
  /// Fragmented Datagrams/sec: Fragmented Datagrams/sec is the rate, in incidents per second, at which datagrams are successfully fragmented.
  let ``Fragmented Datagrams/sec`` =
    { category = CategoryName; counter = "Fragmented Datagrams/sec"; instance = None }
  /// Fragments Created/sec: Fragments Created/sec is the rate, in incidents per second, at which IP datagram fragments were generated as a result of fragmentation.
  let ``Fragments Created/sec`` =
    { category = CategoryName; counter = "Fragments Created/sec"; instance = None }
  /// Fragments Re-assembled/sec: Fragments Re-assembled/sec is the rate, in incidents per second, at which IP fragments were successfully reassembled.
  let ``Fragments Re-assembled/sec`` =
    { category = CategoryName; counter = "Fragments Re-assembled/sec"; instance = None }
  /// Fragments Received/sec: Fragments Received/sec is the rate, in incidents per second, at which IP fragments that need to be reassembled at this entity are received.
  let ``Fragments Received/sec`` =
    { category = CategoryName; counter = "Fragments Received/sec"; instance = None }

  let allCounters =
    [| ``Datagrams Forwarded/sec``
       ``Datagrams Outbound Discarded``
       ``Datagrams Outbound No Route``
       ``Datagrams Received Address Errors``
       ``Datagrams Received Delivered/sec``
       ``Datagrams Received Discarded``
       ``Datagrams Received Header Errors``
       ``Datagrams Received Unknown Protocol``
       ``Datagrams Received/sec``
       ``Datagrams Sent/sec``
       ``Datagrams/sec``
       ``Fragment Re-assembly Failures``
       ``Fragmentation Failures``
       ``Fragmented Datagrams/sec``
       ``Fragments Created/sec``
       ``Fragments Re-assembled/sec``
       ``Fragments Received/sec``
    |]

/// Job Object: Reports the accounting and processor usage data collected by each active named Job object.
///
/// This performance counter does not have instance based counters
module ``Job Object`` =

  [<Literal>]
  let CategoryName = "Job Object"

  let PCC = Category.create CategoryName
  /// Current % Kernel Mode Time: -
  let ``Current % Kernel Mode Time`` instance =
    { category = CategoryName; counter = "Current % Kernel Mode Time"; instance = instance }
  /// Current % Processor Time: -
  let ``Current % Processor Time`` instance =
    { category = CategoryName; counter = "Current % Processor Time"; instance = instance }
  /// Current % User Mode Time: -
  let ``Current % User Mode Time`` instance =
    { category = CategoryName; counter = "Current % User Mode Time"; instance = instance }
  /// Pages/Sec: -
  let ``Pages/Sec`` instance =
    { category = CategoryName; counter = "Pages/Sec"; instance = instance }
  /// Process Count - Active: -
  let ``Process Count - Active`` instance =
    { category = CategoryName; counter = "Process Count - Active"; instance = instance }
  /// Process Count - Terminated: -
  let ``Process Count - Terminated`` instance =
    { category = CategoryName; counter = "Process Count - Terminated"; instance = instance }
  /// Process Count - Total: -
  let ``Process Count - Total`` instance =
    { category = CategoryName; counter = "Process Count - Total"; instance = instance }
  /// This Period mSec - Kernel Mode: -
  let ``This Period mSec - Kernel Mode`` instance =
    { category = CategoryName; counter = "This Period mSec - Kernel Mode"; instance = instance }
  /// This Period mSec - Processor: -
  let ``This Period mSec - Processor`` instance =
    { category = CategoryName; counter = "This Period mSec - Processor"; instance = instance }
  /// This Period mSec - User Mode: -
  let ``This Period mSec - User Mode`` instance =
    { category = CategoryName; counter = "This Period mSec - User Mode"; instance = instance }
  /// Total mSec - Kernel Mode: -
  let ``Total mSec - Kernel Mode`` instance =
    { category = CategoryName; counter = "Total mSec - Kernel Mode"; instance = instance }
  /// Total mSec - Processor: -
  let ``Total mSec - Processor`` instance =
    { category = CategoryName; counter = "Total mSec - Processor"; instance = instance }
  /// Total mSec - User Mode: -
  let ``Total mSec - User Mode`` instance =
    { category = CategoryName; counter = "Total mSec - User Mode"; instance = instance }

  let allCounters =
    [| ``Current % Kernel Mode Time``
       ``Current % Processor Time``
       ``Current % User Mode Time``
       ``Pages/Sec``
       ``Process Count - Active``
       ``Process Count - Terminated``
       ``Process Count - Total``
       ``This Period mSec - Kernel Mode``
       ``This Period mSec - Processor``
       ``This Period mSec - User Mode``
       ``Total mSec - Kernel Mode``
       ``Total mSec - Processor``
       ``Total mSec - User Mode``
    |]

/// Job Object Details: % Job object Details shows detailed performance information about the active processes that make up a Job object.
///
/// This performance counter does not have instance based counters
module ``Job Object Details`` =

  [<Literal>]
  let CategoryName = "Job Object Details"

  let PCC = Category.create CategoryName
  /// % Privileged Time: -
  let ``% Privileged Time`` instance =
    { category = CategoryName; counter = "% Privileged Time"; instance = instance }
  /// % Processor Time: -
  let ``% Processor Time`` instance =
    { category = CategoryName; counter = "% Processor Time"; instance = instance }
  /// % User Time: -
  let ``% User Time`` instance =
    { category = CategoryName; counter = "% User Time"; instance = instance }
  /// Creating Process ID: -
  let ``Creating Process ID`` instance =
    { category = CategoryName; counter = "Creating Process ID"; instance = instance }
  /// Elapsed Time: -
  let ``Elapsed Time`` instance =
    { category = CategoryName; counter = "Elapsed Time"; instance = instance }
  /// Handle Count: -
  let ``Handle Count`` instance =
    { category = CategoryName; counter = "Handle Count"; instance = instance }
  /// ID Process: -
  let ``ID Process`` instance =
    { category = CategoryName; counter = "ID Process"; instance = instance }
  /// IO Data Bytes/sec: -
  let ``IO Data Bytes/sec`` instance =
    { category = CategoryName; counter = "IO Data Bytes/sec"; instance = instance }
  /// IO Data Operations/sec: -
  let ``IO Data Operations/sec`` instance =
    { category = CategoryName; counter = "IO Data Operations/sec"; instance = instance }
  /// IO Other Bytes/sec: -
  let ``IO Other Bytes/sec`` instance =
    { category = CategoryName; counter = "IO Other Bytes/sec"; instance = instance }
  /// IO Other Operations/sec: -
  let ``IO Other Operations/sec`` instance =
    { category = CategoryName; counter = "IO Other Operations/sec"; instance = instance }
  /// IO Read Bytes/sec: -
  let ``IO Read Bytes/sec`` instance =
    { category = CategoryName; counter = "IO Read Bytes/sec"; instance = instance }
  /// IO Read Operations/sec: -
  let ``IO Read Operations/sec`` instance =
    { category = CategoryName; counter = "IO Read Operations/sec"; instance = instance }
  /// IO Write Bytes/sec: -
  let ``IO Write Bytes/sec`` instance =
    { category = CategoryName; counter = "IO Write Bytes/sec"; instance = instance }
  /// IO Write Operations/sec: -
  let ``IO Write Operations/sec`` instance =
    { category = CategoryName; counter = "IO Write Operations/sec"; instance = instance }
  /// Page Faults/sec: -
  let ``Page Faults/sec`` instance =
    { category = CategoryName; counter = "Page Faults/sec"; instance = instance }
  /// Page File Bytes: -
  let ``Page File Bytes`` instance =
    { category = CategoryName; counter = "Page File Bytes"; instance = instance }
  /// Page File Bytes Peak: -
  let ``Page File Bytes Peak`` instance =
    { category = CategoryName; counter = "Page File Bytes Peak"; instance = instance }
  /// Pool Nonpaged Bytes: -
  let ``Pool Nonpaged Bytes`` instance =
    { category = CategoryName; counter = "Pool Nonpaged Bytes"; instance = instance }
  /// Pool Paged Bytes: -
  let ``Pool Paged Bytes`` instance =
    { category = CategoryName; counter = "Pool Paged Bytes"; instance = instance }
  /// Priority Base: -
  let ``Priority Base`` instance =
    { category = CategoryName; counter = "Priority Base"; instance = instance }
  /// Private Bytes: -
  let ``Private Bytes`` instance =
    { category = CategoryName; counter = "Private Bytes"; instance = instance }
  /// Thread Count: -
  let ``Thread Count`` instance =
    { category = CategoryName; counter = "Thread Count"; instance = instance }
  /// Virtual Bytes: -
  let ``Virtual Bytes`` instance =
    { category = CategoryName; counter = "Virtual Bytes"; instance = instance }
  /// Virtual Bytes Peak: -
  let ``Virtual Bytes Peak`` instance =
    { category = CategoryName; counter = "Virtual Bytes Peak"; instance = instance }
  /// Working Set: -
  let ``Working Set`` instance =
    { category = CategoryName; counter = "Working Set"; instance = instance }
  /// Working Set Peak: -
  let ``Working Set Peak`` instance =
    { category = CategoryName; counter = "Working Set Peak"; instance = instance }

  let allCounters =
    [| ``% Privileged Time``
       ``% Processor Time``
       ``% User Time``
       ``Creating Process ID``
       ``Elapsed Time``
       ``Handle Count``
       ``ID Process``
       ``IO Data Bytes/sec``
       ``IO Data Operations/sec``
       ``IO Other Bytes/sec``
       ``IO Other Operations/sec``
       ``IO Read Bytes/sec``
       ``IO Read Operations/sec``
       ``IO Write Bytes/sec``
       ``IO Write Operations/sec``
       ``Page Faults/sec``
       ``Page File Bytes``
       ``Page File Bytes Peak``
       ``Pool Nonpaged Bytes``
       ``Pool Paged Bytes``
       ``Priority Base``
       ``Private Bytes``
       ``Thread Count``
       ``Virtual Bytes``
       ``Virtual Bytes Peak``
       ``Working Set``
       ``Working Set Peak``
    |]

/// LogicalDisk: The Logical Disk performance object consists of counters that monitor logical partitions of a hard or fixed disk drives.  Performance Monitor identifies logical disks by their a drive letter, such as C.
///
/// This performance counter does not have non-instance based counters
module ``LogicalDisk`` =

  [<Literal>]
  let CategoryName = "LogicalDisk"

  let PCC = Category.create CategoryName
  /// % Disk Read Time: % Disk Read Time is the percentage of elapsed time that the selected disk drive was busy servicing read requests.
  let ``% Disk Read Time`` instance =
    { category = CategoryName; counter = "% Disk Read Time"; instance = instance }
  /// % Disk Time: % Disk Time is the percentage of elapsed time that the selected disk drive was busy servicing read or write requests.
  let ``% Disk Time`` instance =
    { category = CategoryName; counter = "% Disk Time"; instance = instance }
  /// % Disk Write Time: % Disk Write Time is the percentage of elapsed time that the selected disk drive was busy servicing write requests.
  let ``% Disk Write Time`` instance =
    { category = CategoryName; counter = "% Disk Write Time"; instance = instance }
  /// % Free Space: % Free Space is the percentage of total usable space on the selected logical disk drive that was free.
  let ``% Free Space`` instance =
    { category = CategoryName; counter = "% Free Space"; instance = instance }
  /// % Idle Time: % Idle Time reports the percentage of time during the sample interval that the disk was idle.
  let ``% Idle Time`` instance =
    { category = CategoryName; counter = "% Idle Time"; instance = instance }
  /// Avg. Disk Bytes/Read: Avg. Disk Bytes/Read is the average number of bytes transferred from the disk during read operations.
  let ``Avg. Disk Bytes/Read`` instance =
    { category = CategoryName; counter = "Avg. Disk Bytes/Read"; instance = instance }
  /// Avg. Disk Bytes/Transfer: Avg. Disk Bytes/Transfer is the average number of bytes transferred to or from the disk during write or read operations.
  let ``Avg. Disk Bytes/Transfer`` instance =
    { category = CategoryName; counter = "Avg. Disk Bytes/Transfer"; instance = instance }
  /// Avg. Disk Bytes/Write: Avg. Disk Bytes/Write is the average number of bytes transferred to the disk during write operations.
  let ``Avg. Disk Bytes/Write`` instance =
    { category = CategoryName; counter = "Avg. Disk Bytes/Write"; instance = instance }
  /// Avg. Disk Queue Length: Avg. Disk Queue Length is the average number of both read and write requests that were queued for the selected disk during the sample interval.
  let ``Avg. Disk Queue Length`` instance =
    { category = CategoryName; counter = "Avg. Disk Queue Length"; instance = instance }
  /// Avg. Disk Read Queue Length: Avg. Disk Read Queue Length is the average number of read requests that were queued for the selected disk during the sample interval.
  let ``Avg. Disk Read Queue Length`` instance =
    { category = CategoryName; counter = "Avg. Disk Read Queue Length"; instance = instance }
  /// Avg. Disk Write Queue Length: Avg. Disk Write Queue Length is the average number of write requests that were queued for the selected disk during the sample interval.
  let ``Avg. Disk Write Queue Length`` instance =
    { category = CategoryName; counter = "Avg. Disk Write Queue Length"; instance = instance }
  /// Avg. Disk sec/Read: Avg. Disk sec/Read is the average time, in seconds, of a read of data from the disk.
  let ``Avg. Disk sec/Read`` instance =
    { category = CategoryName; counter = "Avg. Disk sec/Read"; instance = instance }
  /// Avg. Disk sec/Transfer: Avg. Disk sec/Transfer is the time, in seconds, of the average disk transfer.
  let ``Avg. Disk sec/Transfer`` instance =
    { category = CategoryName; counter = "Avg. Disk sec/Transfer"; instance = instance }
  /// Avg. Disk sec/Write: Avg. Disk sec/Write is the average time, in seconds, of a write of data to the disk.
  let ``Avg. Disk sec/Write`` instance =
    { category = CategoryName; counter = "Avg. Disk sec/Write"; instance = instance }
  /// Current Disk Queue Length: Current Disk Queue Length is the number of requests outstanding on the disk at the time the performance data is collected. It also includes requests in service at the time of the collection. This is a instantaneous snapshot, not an average over the time interval. Multi-spindle disk devices can have multiple requests that are active at one time, but other concurrent requests are awaiting service. This counter might reflect a transitory high or low queue length, but if there is a sustained load on the disk drive, it is likely that this will be consistently high. Requests experience delays proportional to the length of this queue minus the number of spindles on the disks. For good performance, this difference should average less than two.
  let ``Current Disk Queue Length`` instance =
    { category = CategoryName; counter = "Current Disk Queue Length"; instance = instance }
  /// Disk Bytes/sec: Disk Bytes/sec is the rate bytes are transferred to or from the disk during write or read operations.
  let ``Disk Bytes/sec`` instance =
    { category = CategoryName; counter = "Disk Bytes/sec"; instance = instance }
  /// Disk Read Bytes/sec: Disk Read Bytes/sec is the rate at which bytes are transferred from the disk during read operations.
  let ``Disk Read Bytes/sec`` instance =
    { category = CategoryName; counter = "Disk Read Bytes/sec"; instance = instance }
  /// Disk Reads/sec: Disk Reads/sec is the rate of read operations on the disk.
  let ``Disk Reads/sec`` instance =
    { category = CategoryName; counter = "Disk Reads/sec"; instance = instance }
  /// Disk Transfers/sec: Disk Transfers/sec is the rate of read and write operations on the disk.
  let ``Disk Transfers/sec`` instance =
    { category = CategoryName; counter = "Disk Transfers/sec"; instance = instance }
  /// Disk Write Bytes/sec: Disk Write Bytes/sec is rate at which bytes are transferred to the disk during write operations.
  let ``Disk Write Bytes/sec`` instance =
    { category = CategoryName; counter = "Disk Write Bytes/sec"; instance = instance }
  /// Disk Writes/sec: Disk Writes/sec is the rate of write operations on the disk.
  let ``Disk Writes/sec`` instance =
    { category = CategoryName; counter = "Disk Writes/sec"; instance = instance }
  /// Free Megabytes: Free Megabytes displays the unallocated space, in megabytes, on the disk drive in megabytes. One megabyte is equal to 1,048,576 bytes.
  let ``Free Megabytes`` instance =
    { category = CategoryName; counter = "Free Megabytes"; instance = instance }
  /// Split IO/Sec: Split IO/Sec reports the rate at which I/Os to the disk were split into multiple I/Os. A split I/O may result from requesting data of a size that is too large to fit into a single I/O or that the disk is fragmented.
  let ``Split IO/Sec`` instance =
    { category = CategoryName; counter = "Split IO/Sec"; instance = instance }

  let allCounters =
    [| ``% Disk Read Time``
       ``% Disk Time``
       ``% Disk Write Time``
       ``% Free Space``
       ``% Idle Time``
       ``Avg. Disk Bytes/Read``
       ``Avg. Disk Bytes/Transfer``
       ``Avg. Disk Bytes/Write``
       ``Avg. Disk Queue Length``
       ``Avg. Disk Read Queue Length``
       ``Avg. Disk Write Queue Length``
       ``Avg. Disk sec/Read``
       ``Avg. Disk sec/Transfer``
       ``Avg. Disk sec/Write``
       ``Current Disk Queue Length``
       ``Disk Bytes/sec``
       ``Disk Read Bytes/sec``
       ``Disk Reads/sec``
       ``Disk Transfers/sec``
       ``Disk Write Bytes/sec``
       ``Disk Writes/sec``
       ``Free Megabytes``
       ``Split IO/Sec``
    |]

/// MSAS12:Cache: Statistics related to Microsoft Analysis Services aggregation cache.
///
/// This performance counter does not have instance based counters
module ``MSAS12:Cache`` =

  [<Literal>]
  let CategoryName = "MSAS12:Cache"

  let PCC = Category.create CategoryName
  /// Current KB: Current memory used by the aggregation cache, in KB.
  let ``Current KB`` =
    { category = CategoryName; counter = "Current KB"; instance = None }
  /// Current entries: Current number of cache entries.
  let ``Current entries`` =
    { category = CategoryName; counter = "Current entries"; instance = None }
  /// Direct hit ratio: Ratio of cache direct hits to cache lookups, for the period between obtaining counter values.
  let ``Direct hit ratio`` =
    { category = CategoryName; counter = "Direct hit ratio"; instance = None }
  /// Direct hits/sec: Rate of cache direct hits.  Queries were answered from an existing cache entry.
  let ``Direct hits/sec`` =
    { category = CategoryName; counter = "Direct hits/sec"; instance = None }
  /// Evictions/sec: Rate of evictions from the cache.  This is per partition per cube per database.  Typically due to background cleaner.
  let ``Evictions/sec`` =
    { category = CategoryName; counter = "Evictions/sec"; instance = None }
  /// Inserts/sec: Rate of insertions into the cache.  This is per partition per cube per database.
  let ``Inserts/sec`` =
    { category = CategoryName; counter = "Inserts/sec"; instance = None }
  /// KB added/sec: Rate of memory added to the cache, KB/sec.
  let ``KB added/sec`` =
    { category = CategoryName; counter = "KB added/sec"; instance = None }
  /// Lookups/sec: Rate of cache lookups.
  let ``Lookups/sec`` =
    { category = CategoryName; counter = "Lookups/sec"; instance = None }
  /// Misses/sec: Rate of cache misses.
  let ``Misses/sec`` =
    { category = CategoryName; counter = "Misses/sec"; instance = None }
  /// Total direct hits: Total count of direct cache hits.  Queries were answered from existing cache entries.
  let ``Total direct hits`` =
    { category = CategoryName; counter = "Total direct hits"; instance = None }
  /// Total evictions: Evictions from the cache.  This is per partition per cube per database.  Typically due to background cleaner.
  let ``Total evictions`` =
    { category = CategoryName; counter = "Total evictions"; instance = None }
  /// Total filtered iterator cache hits: Total number of cache hits that returned an indexed iterator over the filtered results
  let ``Total filtered iterator cache hits`` =
    { category = CategoryName; counter = "Total filtered iterator cache hits"; instance = None }
  /// Total filtered iterator cache misses: Total number of cache hits that were unable to build an indexed iterator over the filtered results and had to build a new cache with the filtered results
  let ``Total filtered iterator cache misses`` =
    { category = CategoryName; counter = "Total filtered iterator cache misses"; instance = None }
  /// Total inserts: Insertions into the cache.  This is per partition per cube per database.
  let ``Total inserts`` =
    { category = CategoryName; counter = "Total inserts"; instance = None }
  /// Total lookups: Total number of lookups into the cache.
  let ``Total lookups`` =
    { category = CategoryName; counter = "Total lookups"; instance = None }
  /// Total misses: Total count of cache misses.
  let ``Total misses`` =
    { category = CategoryName; counter = "Total misses"; instance = None }

  let allCounters =
    [| ``Current KB``
       ``Current entries``
       ``Direct hit ratio``
       ``Direct hits/sec``
       ``Evictions/sec``
       ``Inserts/sec``
       ``KB added/sec``
       ``Lookups/sec``
       ``Misses/sec``
       ``Total direct hits``
       ``Total evictions``
       ``Total filtered iterator cache hits``
       ``Total filtered iterator cache misses``
       ``Total inserts``
       ``Total lookups``
       ``Total misses``
    |]

/// MSAS12:Connection: Statistics related to Microsoft Analysis Services connections.
///
/// This performance counter does not have instance based counters
module ``MSAS12:Connection`` =

  [<Literal>]
  let CategoryName = "MSAS12:Connection"

  let PCC = Category.create CategoryName
  /// Current connections: Current number of client connections established.
  let ``Current connections`` =
    { category = CategoryName; counter = "Current connections"; instance = None }
  /// Current user sessions: Current number of user sessions established.
  let ``Current user sessions`` =
    { category = CategoryName; counter = "Current user sessions"; instance = None }
  /// Failures/sec: Rate of connection failures.
  let ``Failures/sec`` =
    { category = CategoryName; counter = "Failures/sec"; instance = None }
  /// Requests/sec: Rate of connection requests.  These are arrivals.
  let ``Requests/sec`` =
    { category = CategoryName; counter = "Requests/sec"; instance = None }
  /// Successes/sec: Rate of successful connection completions.
  let ``Successes/sec`` =
    { category = CategoryName; counter = "Successes/sec"; instance = None }
  /// Total failures: Total failed connection attempts.
  let ``Total failures`` =
    { category = CategoryName; counter = "Total failures"; instance = None }
  /// Total requests: Total connection requests.  These are arrivals.
  let ``Total requests`` =
    { category = CategoryName; counter = "Total requests"; instance = None }
  /// Total successes: Total successful connections.
  let ``Total successes`` =
    { category = CategoryName; counter = "Total successes"; instance = None }

  let allCounters =
    [| ``Current connections``
       ``Current user sessions``
       ``Failures/sec``
       ``Requests/sec``
       ``Successes/sec``
       ``Total failures``
       ``Total requests``
       ``Total successes``
    |]

/// MSAS12:Data Mining Model Processing: Statistics related to Microsoft Analysis Services Data Mining model processing.
///
/// This performance counter does not have instance based counters
module ``MSAS12:Data Mining Model Processing`` =

  [<Literal>]
  let CategoryName = "MSAS12:Data Mining Model Processing"

  let PCC = Category.create CategoryName
  /// Cases/sec: Rate of processing cases.
  let ``Cases/sec`` =
    { category = CategoryName; counter = "Cases/sec"; instance = None }
  /// Current models processing: Current number of models being processed
  let ``Current models processing`` =
    { category = CategoryName; counter = "Current models processing"; instance = None }

  let allCounters =
    [| ``Cases/sec``
       ``Current models processing``
    |]

/// MSAS12:Data Mining Prediction: Statistics related to Microsoft Analysis Services Data Mining prediction.
///
/// This performance counter does not have instance based counters
module ``MSAS12:Data Mining Prediction`` =

  [<Literal>]
  let CategoryName = "MSAS12:Data Mining Prediction"

  let PCC = Category.create CategoryName
  /// Concurrent DM queries: Current number of Data Mining queries being actively worked on.
  let ``Concurrent DM queries`` =
    { category = CategoryName; counter = "Concurrent DM queries"; instance = None }
  /// Predictions/sec: Rate of Data Mining prediction queries
  let ``Predictions/sec`` =
    { category = CategoryName; counter = "Predictions/sec"; instance = None }
  /// Queries/sec: Rate of Data Mining queries
  let ``Queries/sec`` =
    { category = CategoryName; counter = "Queries/sec"; instance = None }
  /// Rows/sec: Rate of predicting rows
  let ``Rows/sec`` =
    { category = CategoryName; counter = "Rows/sec"; instance = None }
  /// Total Predictions: Total Data Mining Prediction Queries received by the server
  let ``Total Predictions`` =
    { category = CategoryName; counter = "Total Predictions"; instance = None }
  /// Total Queries: Total Data Mining Queries received by the server
  let ``Total Queries`` =
    { category = CategoryName; counter = "Total Queries"; instance = None }
  /// Total Rows: Total Rows returned by Data Mining queries
  let ``Total Rows`` =
    { category = CategoryName; counter = "Total Rows"; instance = None }

  let allCounters =
    [| ``Concurrent DM queries``
       ``Predictions/sec``
       ``Queries/sec``
       ``Rows/sec``
       ``Total Predictions``
       ``Total Queries``
       ``Total Rows``
    |]

/// MSAS12:Locks: Statistics related to Microsoft Analysis Services internal server locks.
///
/// This performance counter does not have instance based counters
module ``MSAS12:Locks`` =

  [<Literal>]
  let CategoryName = "MSAS12:Locks"

  let PCC = Category.create CategoryName
  /// Current latch waits: Current number of threads waiting for a latch.  These are latch requests that could not be given immediate grants and are in a wait state.
  let ``Current latch waits`` =
    { category = CategoryName; counter = "Current latch waits"; instance = None }
  /// Current lock waits: Current number of clients waiting for a lock.
  let ``Current lock waits`` =
    { category = CategoryName; counter = "Current lock waits"; instance = None }
  /// Current locks: Current number of locked objects.
  let ``Current locks`` =
    { category = CategoryName; counter = "Current locks"; instance = None }
  /// Latch waits/sec: Rate of latch requests that could not be granted immediately and had to wait before being granted.
  let ``Latch waits/sec`` =
    { category = CategoryName; counter = "Latch waits/sec"; instance = None }
  /// Lock denials/sec: Rate of lock denials.
  let ``Lock denials/sec`` =
    { category = CategoryName; counter = "Lock denials/sec"; instance = None }
  /// Lock grants/sec: Number of lock grants per second.
  let ``Lock grants/sec`` =
    { category = CategoryName; counter = "Lock grants/sec"; instance = None }
  /// Lock requests/sec: Number of lock requests per second.
  let ``Lock requests/sec`` =
    { category = CategoryName; counter = "Lock requests/sec"; instance = None }
  /// Lock waits/sec: Number of lock waits per second.  These are lock requests that could not be given immediate lock grants and were put in a wait state.
  let ``Lock waits/sec`` =
    { category = CategoryName; counter = "Lock waits/sec"; instance = None }
  /// Total deadlocks detected: Total number of deadlocks detected.
  let ``Total deadlocks detected`` =
    { category = CategoryName; counter = "Total deadlocks detected"; instance = None }
  /// Unlock requests/sec: Number of unlock requests per second.
  let ``Unlock requests/sec`` =
    { category = CategoryName; counter = "Unlock requests/sec"; instance = None }

  let allCounters =
    [| ``Current latch waits``
       ``Current lock waits``
       ``Current locks``
       ``Latch waits/sec``
       ``Lock denials/sec``
       ``Lock grants/sec``
       ``Lock requests/sec``
       ``Lock waits/sec``
       ``Total deadlocks detected``
       ``Unlock requests/sec``
    |]

/// MSAS12:MDX: Statistics related to Microsoft Analysis Services MDX Calculations.
///
/// This performance counter does not have instance based counters
module ``MSAS12:MDX`` =

  [<Literal>]
  let CategoryName = "MSAS12:MDX"

  let PCC = Category.create CategoryName
  /// Current number of cached evaluation nodes: Current (approximate) number of cached evaluation nodes built by MDX execution plans
  let ``Current number of cached evaluation nodes`` =
    { category = CategoryName; counter = "Current number of cached evaluation nodes"; instance = None }
  /// Current number of evaluation nodes: Current (approximate) number of evaluation nodes built by MDX execution plans including active and cached
  let ``Current number of evaluation nodes`` =
    { category = CategoryName; counter = "Current number of evaluation nodes"; instance = None }
  /// Number of Storage Engine evaluation nodes: Total number of Storage Engine evaluation nodes built by MDX execution plans
  let ``Number of Storage Engine evaluation nodes`` =
    { category = CategoryName; counter = "Number of Storage Engine evaluation nodes"; instance = None }
  /// Number of bulk-mode evaluation nodes: Total number of bulk-mode evaluation nodes built by MDX execution plans
  let ``Number of bulk-mode evaluation nodes`` =
    { category = CategoryName; counter = "Number of bulk-mode evaluation nodes"; instance = None }
  /// Number of cached 'other' evaluation nodes: Total number of cached evaluation nodes built by MDX execution plans that are neither Storage Engine nor Bulk-mode
  let ``Number of cached 'other' evaluation nodes`` =
    { category = CategoryName; counter = "Number of cached 'other' evaluation nodes"; instance = None }
  /// Number of cached Storage Engine evaluation nodes: Total number of cached Storage Engine evaluation nodes built by MDX execution plans
  let ``Number of cached Storage Engine evaluation nodes`` =
    { category = CategoryName; counter = "Number of cached Storage Engine evaluation nodes"; instance = None }
  /// Number of cached bulk-mode evaluation nodes: Total number of cached bulk-mode evaluation nodes built by MDX execution plans
  let ``Number of cached bulk-mode evaluation nodes`` =
    { category = CategoryName; counter = "Number of cached bulk-mode evaluation nodes"; instance = None }
  /// Number of calculation covers: Total number of evaluation nodes built by MDX execution plans including active and cached
  let ``Number of calculation covers`` =
    { category = CategoryName; counter = "Number of calculation covers"; instance = None }
  /// Number of cell-by-cell evaluation nodes: Total number of cell-by-cell evaluation nodes built by MDX execution plans
  let ``Number of cell-by-cell evaluation nodes`` =
    { category = CategoryName; counter = "Number of cell-by-cell evaluation nodes"; instance = None }
  /// Number of cell-by-cell hits in the cache of evaluation nodes: Total number of cell-by-cell hits in the cache of evaluation nodes
  let ``Number of cell-by-cell hits in the cache of evaluation nodes`` =
    { category = CategoryName; counter = "Number of cell-by-cell hits in the cache of evaluation nodes"; instance = None }
  /// Number of cell-by-cell misses in the cache of evaluation nodes: Total number of cell-by-cell misses in the cache of evaluation nodes
  let ``Number of cell-by-cell misses in the cache of evaluation nodes`` =
    { category = CategoryName; counter = "Number of cell-by-cell misses in the cache of evaluation nodes"; instance = None }
  /// Number of evaluation nodes that covered a single cell: Total number of evaluation nodes built by MDX execution plans that covered only one cell
  let ``Number of evaluation nodes that covered a single cell`` =
    { category = CategoryName; counter = "Number of evaluation nodes that covered a single cell"; instance = None }
  /// Number of evaluation nodes with calculations at the same granularity: Total number of evaluation nodes built by MDX execution plans for which the calculations were at the same granularity as the evaluation node
  let ``Number of evaluation nodes with calculations at the same granularity`` =
    { category = CategoryName; counter = "Number of evaluation nodes with calculations at the same granularity"; instance = None }
  /// Number of evictions of evaluation nodes: Total number of cache evictions of evaluation nodes due to collisions
  let ``Number of evictions of evaluation nodes`` =
    { category = CategoryName; counter = "Number of evictions of evaluation nodes"; instance = None }
  /// Number of hash index hits in the cache of evaluation nodes: Total number of hits in the cache of evaluation nodes that were satisfied by the hash index
  let ``Number of hash index hits in the cache of evaluation nodes`` =
    { category = CategoryName; counter = "Number of hash index hits in the cache of evaluation nodes"; instance = None }
  /// Number of subcube hits in the cache of evaluation nodes: Total number of subcube hits in the cache of evaluation nodes
  let ``Number of subcube hits in the cache of evaluation nodes`` =
    { category = CategoryName; counter = "Number of subcube hits in the cache of evaluation nodes"; instance = None }
  /// Number of subcube misses in the cache of evaluation nodes: Total number of subcube misses in the cache of evaluation nodes
  let ``Number of subcube misses in the cache of evaluation nodes`` =
    { category = CategoryName; counter = "Number of subcube misses in the cache of evaluation nodes"; instance = None }
  /// Total Autoexist: Total number of times autoexist performed
  let ``Total Autoexist`` =
    { category = CategoryName; counter = "Total Autoexist"; instance = None }
  /// Total EXISTING: Total number of times EXISTING set operator performed
  let ``Total EXISTING`` =
    { category = CategoryName; counter = "Total EXISTING"; instance = None }
  /// Total NON EMPTY: Total number of times NON EMPTY algorithms is used
  let ``Total NON EMPTY`` =
    { category = CategoryName; counter = "Total NON EMPTY"; instance = None }
  /// Total NON EMPTY for calculated members: Total number of times NON EMPTY algorithm was looping over calculated members
  let ``Total NON EMPTY for calculated members`` =
    { category = CategoryName; counter = "Total NON EMPTY for calculated members"; instance = None }
  /// Total NON EMPTY unoptimized: Total number of times unoptimized NON EMPTY algorithm is used
  let ``Total NON EMPTY unoptimized`` =
    { category = CategoryName; counter = "Total NON EMPTY unoptimized"; instance = None }
  /// Total Sonar subcubes: Total number of subcubes that query optimizer generated
  let ``Total Sonar subcubes`` =
    { category = CategoryName; counter = "Total Sonar subcubes"; instance = None }
  /// Total cells calculated: Total number of cell properties calculated
  let ``Total cells calculated`` =
    { category = CategoryName; counter = "Total cells calculated"; instance = None }
  /// Total flat cache inserts: Total number of cell values inserted into flat calculation cache
  let ``Total flat cache inserts`` =
    { category = CategoryName; counter = "Total flat cache inserts"; instance = None }
  /// Total recomputes: Total number of cells recomputed due to error
  let ``Total recomputes`` =
    { category = CategoryName; counter = "Total recomputes"; instance = None }

  let allCounters =
    [| ``Current number of cached evaluation nodes``
       ``Current number of evaluation nodes``
       ``Number of Storage Engine evaluation nodes``
       ``Number of bulk-mode evaluation nodes``
       ``Number of cached 'other' evaluation nodes``
       ``Number of cached Storage Engine evaluation nodes``
       ``Number of cached bulk-mode evaluation nodes``
       ``Number of calculation covers``
       ``Number of cell-by-cell evaluation nodes``
       ``Number of cell-by-cell hits in the cache of evaluation nodes``
       ``Number of cell-by-cell misses in the cache of evaluation nodes``
       ``Number of evaluation nodes that covered a single cell``
       ``Number of evaluation nodes with calculations at the same granularity``
       ``Number of evictions of evaluation nodes``
       ``Number of hash index hits in the cache of evaluation nodes``
       ``Number of subcube hits in the cache of evaluation nodes``
       ``Number of subcube misses in the cache of evaluation nodes``
       ``Total Autoexist``
       ``Total EXISTING``
       ``Total NON EMPTY``
       ``Total NON EMPTY for calculated members``
       ``Total NON EMPTY unoptimized``
       ``Total Sonar subcubes``
       ``Total cells calculated``
       ``Total flat cache inserts``
       ``Total recomputes``
    |]

/// MSAS12:Memory: Statistics related to Microsoft Analysis Services internal server memory.
///
/// This performance counter does not have instance based counters
module ``MSAS12:Memory`` =

  [<Literal>]
  let CategoryName = "MSAS12:Memory"

  let PCC = Category.create CategoryName
  /// AggCacheKB: Current memory allocated to aggregation cache, in KB.
  let ``AggCacheKB`` =
    { category = CategoryName; counter = "AggCacheKB"; instance = None }
  /// Aggregation Map Files: Number of aggregation map files.
  let ``Aggregation Map Files`` =
    { category = CategoryName; counter = "Aggregation Map Files"; instance = None }
  /// Cleaner Balance/sec: Rate of balance+shrink operations.
  let ``Cleaner Balance/sec`` =
    { category = CategoryName; counter = "Cleaner Balance/sec"; instance = None }
  /// Cleaner Current Price: Current price of memory, $/byte/time, normalized to 1000.
  let ``Cleaner Current Price`` =
    { category = CategoryName; counter = "Cleaner Current Price"; instance = None }
  /// Cleaner Memory KB: Amount of memory, in KB, known to the background cleaner.  (Cleaner memory shrinkable + Cleaner memory nonshrinkable.)
  let ``Cleaner Memory KB`` =
    { category = CategoryName; counter = "Cleaner Memory KB"; instance = None }
  /// Cleaner Memory nonshrinkable KB: Amount of memory, in KB, not subject to purging by the background cleaner.
  let ``Cleaner Memory nonshrinkable KB`` =
    { category = CategoryName; counter = "Cleaner Memory nonshrinkable KB"; instance = None }
  /// Cleaner Memory shrinkable KB: Amount of memory, in KB, subject to purging by the background cleaner.
  let ``Cleaner Memory shrinkable KB`` =
    { category = CategoryName; counter = "Cleaner Memory shrinkable KB"; instance = None }
  /// Cleaner Memory shrunk KB/sec: Rate of shrinking, in KB/sec.
  let ``Cleaner Memory shrunk KB/sec`` =
    { category = CategoryName; counter = "Cleaner Memory shrunk KB/sec"; instance = None }
  /// Dimension Index (Hash) Files: Number of dimension index (hash) files.
  let ``Dimension Index (Hash) Files`` =
    { category = CategoryName; counter = "Dimension Index (Hash) Files"; instance = None }
  /// Dimension Property Files: Number of dimension property files.
  let ``Dimension Property Files`` =
    { category = CategoryName; counter = "Dimension Property Files"; instance = None }
  /// Dimension String Files: Number of dimension string files.
  let ``Dimension String Files`` =
    { category = CategoryName; counter = "Dimension String Files"; instance = None }
  /// Fact Aggregation Files: Number of fact aggregation files.
  let ``Fact Aggregation Files`` =
    { category = CategoryName; counter = "Fact Aggregation Files"; instance = None }
  /// Fact Data Files: Number of fact data files.
  let ``Fact Data Files`` =
    { category = CategoryName; counter = "Fact Data Files"; instance = None }
  /// Fact String Files: Number of fact string files.
  let ``Fact String Files`` =
    { category = CategoryName; counter = "Fact String Files"; instance = None }
  /// Filestore Clock Pages Examined/sec: Rate of background cleaner examining pages for eviction consideration.
  let ``Filestore Clock Pages Examined/sec`` =
    { category = CategoryName; counter = "Filestore Clock Pages Examined/sec"; instance = None }
  /// Filestore Clock Pages HaveRef/sec: Rate of background cleaner examining pages that have a current reference count (are currently in use).
  let ``Filestore Clock Pages HaveRef/sec`` =
    { category = CategoryName; counter = "Filestore Clock Pages HaveRef/sec"; instance = None }
  /// Filestore Clock Pages Valid/sec: Rate of background cleaner examining pages that are valid candidates for eviction.
  let ``Filestore Clock Pages Valid/sec`` =
    { category = CategoryName; counter = "Filestore Clock Pages Valid/sec"; instance = None }
  /// Filestore IO Errors: Filestore IO Errors total.
  let ``Filestore IO Errors`` =
    { category = CategoryName; counter = "Filestore IO Errors"; instance = None }
  /// Filestore IO Errors/sec: Filestore IO Error rate.
  let ``Filestore IO Errors/sec`` =
    { category = CategoryName; counter = "Filestore IO Errors/sec"; instance = None }
  /// Filestore KB: Current memory allocated to filestore (file cache), in KB.
  let ``Filestore KB`` =
    { category = CategoryName; counter = "Filestore KB"; instance = None }
  /// Filestore KB Reads/sec: Filestore KB read/sec.
  let ``Filestore KB Reads/sec`` =
    { category = CategoryName; counter = "Filestore KB Reads/sec"; instance = None }
  /// Filestore KB Write/sec: Filestore KB written/sec.  The writes are asynchronous.
  let ``Filestore KB Write/sec`` =
    { category = CategoryName; counter = "Filestore KB Write/sec"; instance = None }
  /// Filestore Memory Pinned KB: Current filestore memory pinned KB.
  let ``Filestore Memory Pinned KB`` =
    { category = CategoryName; counter = "Filestore Memory Pinned KB"; instance = None }
  /// Filestore Page Faults/sec: Filestore page fault rate.
  let ``Filestore Page Faults/sec`` =
    { category = CategoryName; counter = "Filestore Page Faults/sec"; instance = None }
  /// Filestore Reads/sec: Filestore pages read/sec.
  let ``Filestore Reads/sec`` =
    { category = CategoryName; counter = "Filestore Reads/sec"; instance = None }
  /// Filestore Writes/sec: Filestore pages written/sec.  The writes are asynchronous.
  let ``Filestore Writes/sec`` =
    { category = CategoryName; counter = "Filestore Writes/sec"; instance = None }
  /// In-memory Aggregation Map File KB: Current in-memory aggregation map file KB.
  let ``In-memory Aggregation Map File KB`` =
    { category = CategoryName; counter = "In-memory Aggregation Map File KB"; instance = None }
  /// In-memory Aggregation Map File KB/sec: In-memory aggregation map file KB rate.
  let ``In-memory Aggregation Map File KB/sec`` =
    { category = CategoryName; counter = "In-memory Aggregation Map File KB/sec"; instance = None }
  /// In-memory Dimension Index (Hash) File KB: Current in-memory dimension index (hash) file KB.
  let ``In-memory Dimension Index (Hash) File KB`` =
    { category = CategoryName; counter = "In-memory Dimension Index (Hash) File KB"; instance = None }
  /// In-memory Dimension Index (Hash) File KB/sec: In-memory dimension index (hash) file KB rate.
  let ``In-memory Dimension Index (Hash) File KB/sec`` =
    { category = CategoryName; counter = "In-memory Dimension Index (Hash) File KB/sec"; instance = None }
  /// In-memory Dimension Property File KB: Current in-memory dimension property file KB.
  let ``In-memory Dimension Property File KB`` =
    { category = CategoryName; counter = "In-memory Dimension Property File KB"; instance = None }
  /// In-memory Dimension Property File KB/sec: In-memory dimension property file KB rate.
  let ``In-memory Dimension Property File KB/sec`` =
    { category = CategoryName; counter = "In-memory Dimension Property File KB/sec"; instance = None }
  /// In-memory Dimension String File KB: Current in-memory dimension string file KB.
  let ``In-memory Dimension String File KB`` =
    { category = CategoryName; counter = "In-memory Dimension String File KB"; instance = None }
  /// In-memory Dimension String File KB/sec: In-memory dimension string file KB rate.
  let ``In-memory Dimension String File KB/sec`` =
    { category = CategoryName; counter = "In-memory Dimension String File KB/sec"; instance = None }
  /// In-memory Fact Aggregation File KB: Current in-memory fact aggregation file KB.
  let ``In-memory Fact Aggregation File KB`` =
    { category = CategoryName; counter = "In-memory Fact Aggregation File KB"; instance = None }
  /// In-memory Fact Aggregation File KB/sec: In-memory fact aggregation file KB rate.
  let ``In-memory Fact Aggregation File KB/sec`` =
    { category = CategoryName; counter = "In-memory Fact Aggregation File KB/sec"; instance = None }
  /// In-memory Fact Data File KB: Current in-memory fact data file KB.
  let ``In-memory Fact Data File KB`` =
    { category = CategoryName; counter = "In-memory Fact Data File KB"; instance = None }
  /// In-memory Fact Data File KB/sec: In-memory fact data file KB rate.
  let ``In-memory Fact Data File KB/sec`` =
    { category = CategoryName; counter = "In-memory Fact Data File KB/sec"; instance = None }
  /// In-memory Fact String File KB: Current in-memory fact string file KB.
  let ``In-memory Fact String File KB`` =
    { category = CategoryName; counter = "In-memory Fact String File KB"; instance = None }
  /// In-memory Fact String File KB/sec: In-memory fact string file KB rate.
  let ``In-memory Fact String File KB/sec`` =
    { category = CategoryName; counter = "In-memory Fact String File KB/sec"; instance = None }
  /// In-memory Map File KB: Current in-memory map file KB.
  let ``In-memory Map File KB`` =
    { category = CategoryName; counter = "In-memory Map File KB"; instance = None }
  /// In-memory Map File KB/sec: In-memory map file KB rate.
  let ``In-memory Map File KB/sec`` =
    { category = CategoryName; counter = "In-memory Map File KB/sec"; instance = None }
  /// In-memory Other File KB: Current in-memory other file KB.
  let ``In-memory Other File KB`` =
    { category = CategoryName; counter = "In-memory Other File KB"; instance = None }
  /// In-memory Other File KB/sec: In-memory other file KB rate.
  let ``In-memory Other File KB/sec`` =
    { category = CategoryName; counter = "In-memory Other File KB/sec"; instance = None }
  /// Map Files: Number of map files.
  let ``Map Files`` =
    { category = CategoryName; counter = "Map Files"; instance = None }
  /// Memory Limit Hard KB: Hard memory limit, from configuration file.
  let ``Memory Limit Hard KB`` =
    { category = CategoryName; counter = "Memory Limit Hard KB"; instance = None }
  /// Memory Limit High KB: High memory limit, from configuration file.
  let ``Memory Limit High KB`` =
    { category = CategoryName; counter = "Memory Limit High KB"; instance = None }
  /// Memory Limit Low KB: Low memory limit, from configuration file.
  let ``Memory Limit Low KB`` =
    { category = CategoryName; counter = "Memory Limit Low KB"; instance = None }
  /// Memory Limit VertiPaq KB: VertiPaq memory limit, from configuration file.
  let ``Memory Limit VertiPaq KB`` =
    { category = CategoryName; counter = "Memory Limit VertiPaq KB"; instance = None }
  /// Memory Usage KB: Memory usage of the server process as used in calculating cleaner memory price.  Equal to counter Process\PrivateBytes plus the size of memory-mapped VertiPaq data, ignoring any memory which was mapped or allocated by VertiPaq in excess of the VertiPaq Memory Limit.
  let ``Memory Usage KB`` =
    { category = CategoryName; counter = "Memory Usage KB"; instance = None }
  /// Other Files: Number of other files.
  let ``Other Files`` =
    { category = CategoryName; counter = "Other Files"; instance = None }
  /// Page Pool 1 Alloc KB: Memory borrowed from 64KB page pool, in KB.  This memory is given away to other parts of the server.
  let ``Page Pool 1 Alloc KB`` =
    { category = CategoryName; counter = "Page Pool 1 Alloc KB"; instance = None }
  /// Page Pool 1 Lookaside KB: Current memory in 8KB lookaside list, in KB.  (Memory pages ready to be used.)
  let ``Page Pool 1 Lookaside KB`` =
    { category = CategoryName; counter = "Page Pool 1 Lookaside KB"; instance = None }
  /// Page Pool 64 Alloc KB: Memory borrowed from system, in KB.  This memory is given away to other parts of the server.
  let ``Page Pool 64 Alloc KB`` =
    { category = CategoryName; counter = "Page Pool 64 Alloc KB"; instance = None }
  /// Page Pool 64 Lookaside KB: Current memory in 64KB lookaside list, in KB.  (Memory pages ready to be used.)
  let ``Page Pool 64 Lookaside KB`` =
    { category = CategoryName; counter = "Page Pool 64 Lookaside KB"; instance = None }
  /// Page Pool 8 Alloc KB: Memory borrowed from 64KB page pool, in KB.  This memory is given away to other parts of the server.
  let ``Page Pool 8 Alloc KB`` =
    { category = CategoryName; counter = "Page Pool 8 Alloc KB"; instance = None }
  /// Page Pool 8 Lookaside KB: Current memory in 8KB lookaside list, in KB.  (Memory pages ready to be used.)
  let ``Page Pool 8 Lookaside KB`` =
    { category = CategoryName; counter = "Page Pool 8 Lookaside KB"; instance = None }
  /// Potential In-memory Aggregation Map File KB: Potential in-memory aggregation map file KB.
  let ``Potential In-memory Aggregation Map File KB`` =
    { category = CategoryName; counter = "Potential In-memory Aggregation Map File KB"; instance = None }
  /// Potential In-memory Dimension Index (Hash) File KB: Potential in-memory dimension index (hash) file KB.
  let ``Potential In-memory Dimension Index (Hash) File KB`` =
    { category = CategoryName; counter = "Potential In-memory Dimension Index (Hash) File KB"; instance = None }
  /// Potential In-memory Dimension Property File KB: Potential in-memory dimension property file KB.
  let ``Potential In-memory Dimension Property File KB`` =
    { category = CategoryName; counter = "Potential In-memory Dimension Property File KB"; instance = None }
  /// Potential In-memory Dimension String File KB: Potential in-memory dimension string file KB.
  let ``Potential In-memory Dimension String File KB`` =
    { category = CategoryName; counter = "Potential In-memory Dimension String File KB"; instance = None }
  /// Potential In-memory Fact Aggregation File KB: Potential in-memory fact aggregation file KB.
  let ``Potential In-memory Fact Aggregation File KB`` =
    { category = CategoryName; counter = "Potential In-memory Fact Aggregation File KB"; instance = None }
  /// Potential In-memory Fact Data File KB: Potential in-memory fact data file KB.
  let ``Potential In-memory Fact Data File KB`` =
    { category = CategoryName; counter = "Potential In-memory Fact Data File KB"; instance = None }
  /// Potential In-memory Fact String File KB: Potential in-memory fact string file KB.
  let ``Potential In-memory Fact String File KB`` =
    { category = CategoryName; counter = "Potential In-memory Fact String File KB"; instance = None }
  /// Potential In-memory Map File KB: Potential in-memory map file KB.
  let ``Potential In-memory Map File KB`` =
    { category = CategoryName; counter = "Potential In-memory Map File KB"; instance = None }
  /// Potential In-memory Other File KB: Potential in-memory other file KB.
  let ``Potential In-memory Other File KB`` =
    { category = CategoryName; counter = "Potential In-memory Other File KB"; instance = None }
  /// Quota Blocked: Current number of quota requests that are blocked until other memory quotas are freed.
  let ``Quota Blocked`` =
    { category = CategoryName; counter = "Quota Blocked"; instance = None }
  /// Quota KB: Current memory quota, in KB.  Memory quota is also known as a memory grant or memory reservation.
  let ``Quota KB`` =
    { category = CategoryName; counter = "Quota KB"; instance = None }
  /// VertiPaq Memory-Mapped KB: Kilobytes of pageable memory in use for VertiPaq data.
  let ``VertiPaq Memory-Mapped KB`` =
    { category = CategoryName; counter = "VertiPaq Memory-Mapped KB"; instance = None }
  /// VertiPaq Nonpaged KB: Kilobytes of memory locked in the working set for use by VertiPaq.
  let ``VertiPaq Nonpaged KB`` =
    { category = CategoryName; counter = "VertiPaq Nonpaged KB"; instance = None }
  /// VertiPaq Paged KB: Kilobytes of paged memory in use for VertiPaq data.
  let ``VertiPaq Paged KB`` =
    { category = CategoryName; counter = "VertiPaq Paged KB"; instance = None }

  let allCounters =
    [| ``AggCacheKB``
       ``Aggregation Map Files``
       ``Cleaner Balance/sec``
       ``Cleaner Current Price``
       ``Cleaner Memory KB``
       ``Cleaner Memory nonshrinkable KB``
       ``Cleaner Memory shrinkable KB``
       ``Cleaner Memory shrunk KB/sec``
       ``Dimension Index (Hash) Files``
       ``Dimension Property Files``
       ``Dimension String Files``
       ``Fact Aggregation Files``
       ``Fact Data Files``
       ``Fact String Files``
       ``Filestore Clock Pages Examined/sec``
       ``Filestore Clock Pages HaveRef/sec``
       ``Filestore Clock Pages Valid/sec``
       ``Filestore IO Errors``
       ``Filestore IO Errors/sec``
       ``Filestore KB``
       ``Filestore KB Reads/sec``
       ``Filestore KB Write/sec``
       ``Filestore Memory Pinned KB``
       ``Filestore Page Faults/sec``
       ``Filestore Reads/sec``
       ``Filestore Writes/sec``
       ``In-memory Aggregation Map File KB``
       ``In-memory Aggregation Map File KB/sec``
       ``In-memory Dimension Index (Hash) File KB``
       ``In-memory Dimension Index (Hash) File KB/sec``
       ``In-memory Dimension Property File KB``
       ``In-memory Dimension Property File KB/sec``
       ``In-memory Dimension String File KB``
       ``In-memory Dimension String File KB/sec``
       ``In-memory Fact Aggregation File KB``
       ``In-memory Fact Aggregation File KB/sec``
       ``In-memory Fact Data File KB``
       ``In-memory Fact Data File KB/sec``
       ``In-memory Fact String File KB``
       ``In-memory Fact String File KB/sec``
       ``In-memory Map File KB``
       ``In-memory Map File KB/sec``
       ``In-memory Other File KB``
       ``In-memory Other File KB/sec``
       ``Map Files``
       ``Memory Limit Hard KB``
       ``Memory Limit High KB``
       ``Memory Limit Low KB``
       ``Memory Limit VertiPaq KB``
       ``Memory Usage KB``
       ``Other Files``
       ``Page Pool 1 Alloc KB``
       ``Page Pool 1 Lookaside KB``
       ``Page Pool 64 Alloc KB``
       ``Page Pool 64 Lookaside KB``
       ``Page Pool 8 Alloc KB``
       ``Page Pool 8 Lookaside KB``
       ``Potential In-memory Aggregation Map File KB``
       ``Potential In-memory Dimension Index (Hash) File KB``
       ``Potential In-memory Dimension Property File KB``
       ``Potential In-memory Dimension String File KB``
       ``Potential In-memory Fact Aggregation File KB``
       ``Potential In-memory Fact Data File KB``
       ``Potential In-memory Fact String File KB``
       ``Potential In-memory Map File KB``
       ``Potential In-memory Other File KB``
       ``Quota Blocked``
       ``Quota KB``
       ``VertiPaq Memory-Mapped KB``
       ``VertiPaq Nonpaged KB``
       ``VertiPaq Paged KB``
    |]

/// MSAS12:Proactive Caching: Statistics related to Microsoft Analysis Services Proactive Caching.
///
/// This performance counter does not have instance based counters
module ``MSAS12:Proactive Caching`` =

  [<Literal>]
  let CategoryName = "MSAS12:Proactive Caching"

  let PCC = Category.create CategoryName
  /// Notifications/sec: Rate of notifications from relational database.
  let ``Notifications/sec`` =
    { category = CategoryName; counter = "Notifications/sec"; instance = None }
  /// Proactive Caching Begin/sec: Rate of proactive caching begin.
  let ``Proactive Caching Begin/sec`` =
    { category = CategoryName; counter = "Proactive Caching Begin/sec"; instance = None }
  /// Proactive Caching Completion/sec: Rate of proactive caching completion.
  let ``Proactive Caching Completion/sec`` =
    { category = CategoryName; counter = "Proactive Caching Completion/sec"; instance = None }
  /// Processing Cancellations/sec: Rate of processing cancellations caused by notifications.
  let ``Processing Cancellations/sec`` =
    { category = CategoryName; counter = "Processing Cancellations/sec"; instance = None }

  let allCounters =
    [| ``Notifications/sec``
       ``Proactive Caching Begin/sec``
       ``Proactive Caching Completion/sec``
       ``Processing Cancellations/sec``
    |]

/// MSAS12:Proc Aggregations: Statistics related to Microsoft Analysis Services processing of aggregations in MOLAP data files.
///
/// This performance counter does not have instance based counters
module ``MSAS12:Proc Aggregations`` =

  [<Literal>]
  let CategoryName = "MSAS12:Proc Aggregations"

  let PCC = Category.create CategoryName
  /// Current partitions: Current number of partitions being processed.
  let ``Current partitions`` =
    { category = CategoryName; counter = "Current partitions"; instance = None }
  /// Memory size bytes: Size of current aggregations in memory.  This count is an estimate.
  let ``Memory size bytes`` =
    { category = CategoryName; counter = "Memory size bytes"; instance = None }
  /// Memory size rows: Size of current aggregations in memory.  This count is an estimate.
  let ``Memory size rows`` =
    { category = CategoryName; counter = "Memory size rows"; instance = None }
  /// Rows created/sec: Rate of aggregation rows created.
  let ``Rows created/sec`` =
    { category = CategoryName; counter = "Rows created/sec"; instance = None }
  /// Rows merged/sec: Rate of rows merged or inserted into an aggregation.
  let ``Rows merged/sec`` =
    { category = CategoryName; counter = "Rows merged/sec"; instance = None }
  /// Temp file bytes written/sec: Rate of writing bytes to a temporary file.  Temporary files are written when aggregations exceed memory limits.
  let ``Temp file bytes written/sec`` =
    { category = CategoryName; counter = "Temp file bytes written/sec"; instance = None }
  /// Temp file rows written/sec: Rate of writing rows to a temporary file.  Temporary files are written when aggregations exceed memory limits.
  let ``Temp file rows written/sec`` =
    { category = CategoryName; counter = "Temp file rows written/sec"; instance = None }
  /// Total partitions: Total number of partitions processed (successfully or otherwise).
  let ``Total partitions`` =
    { category = CategoryName; counter = "Total partitions"; instance = None }

  let allCounters =
    [| ``Current partitions``
       ``Memory size bytes``
       ``Memory size rows``
       ``Rows created/sec``
       ``Rows merged/sec``
       ``Temp file bytes written/sec``
       ``Temp file rows written/sec``
       ``Total partitions``
    |]

/// MSAS12:Proc Indexes: Statistics related to Microsoft Analysis Services processing of indexes for MOLAP data files.
///
/// This performance counter does not have instance based counters
module ``MSAS12:Proc Indexes`` =

  [<Literal>]
  let CategoryName = "MSAS12:Proc Indexes"

  let PCC = Category.create CategoryName
  /// Current partitions: Current number of partitions being processed.
  let ``Current partitions`` =
    { category = CategoryName; counter = "Current partitions"; instance = None }
  /// Rows/sec: Rate of rows from MOLAP files used to create indexes.
  let ``Rows/sec`` =
    { category = CategoryName; counter = "Rows/sec"; instance = None }
  /// Total partitions: Total number of partitions processed (successfully or otherwise).
  let ``Total partitions`` =
    { category = CategoryName; counter = "Total partitions"; instance = None }
  /// Total rows: Total rows from MOLAP files used to create indexes.
  let ``Total rows`` =
    { category = CategoryName; counter = "Total rows"; instance = None }

  let allCounters =
    [| ``Current partitions``
       ``Rows/sec``
       ``Total partitions``
       ``Total rows``
    |]

/// MSAS12:Processing: Statistics related to Microsoft Analysis Services processing of data.
///
/// This performance counter does not have instance based counters
module ``MSAS12:Processing`` =

  [<Literal>]
  let CategoryName = "MSAS12:Processing"

  let PCC = Category.create CategoryName
  /// Rows converted/sec: Rate of rows converted during processing.
  let ``Rows converted/sec`` =
    { category = CategoryName; counter = "Rows converted/sec"; instance = None }
  /// Rows read/sec: Rate of rows read from all relational databases.
  let ``Rows read/sec`` =
    { category = CategoryName; counter = "Rows read/sec"; instance = None }
  /// Rows written/sec: Rate of rows written during processing.
  let ``Rows written/sec`` =
    { category = CategoryName; counter = "Rows written/sec"; instance = None }
  /// Total rows converted: Count of rows converted during processing.
  let ``Total rows converted`` =
    { category = CategoryName; counter = "Total rows converted"; instance = None }
  /// Total rows read: Count of rows read from all relational databases.
  let ``Total rows read`` =
    { category = CategoryName; counter = "Total rows read"; instance = None }
  /// Total rows written: Count of rows written during processing.
  let ``Total rows written`` =
    { category = CategoryName; counter = "Total rows written"; instance = None }

  let allCounters =
    [| ``Rows converted/sec``
       ``Rows read/sec``
       ``Rows written/sec``
       ``Total rows converted``
       ``Total rows read``
       ``Total rows written``
    |]

/// MSAS12:Storage Engine Query: Statistics related to Microsoft Analysis Services storage engine queries.
///
/// This performance counter does not have instance based counters
module ``MSAS12:Storage Engine Query`` =

  [<Literal>]
  let CategoryName = "MSAS12:Storage Engine Query"

  let PCC = Category.create CategoryName
  /// Aggregation hits/sec: Rate of aggregation hits.
  let ``Aggregation hits/sec`` =
    { category = CategoryName; counter = "Aggregation hits/sec"; instance = None }
  /// Aggregation lookups/sec: Rate of aggregation lookups.
  let ``Aggregation lookups/sec`` =
    { category = CategoryName; counter = "Aggregation lookups/sec"; instance = None }
  /// Avg time/query: Average time per query, in milliseconds.  Response time based on queries answered since the last counter measurement.
  let ``Avg time/query`` =
    { category = CategoryName; counter = "Avg time/query"; instance = None }
  /// Bytes sent/sec: Rate of bytes sent by server to clients, in response to queries.
  let ``Bytes sent/sec`` =
    { category = CategoryName; counter = "Bytes sent/sec"; instance = None }
  /// Calculation cache hits/sec: Rate of calculation cache hits.  This includes global, session, and query scope calculation caches.
  let ``Calculation cache hits/sec`` =
    { category = CategoryName; counter = "Calculation cache hits/sec"; instance = None }
  /// Calculation cache lookups/sec: Rate of calculation cache lookups.  This includes global, session, and query scope calculation caches.
  let ``Calculation cache lookups/sec`` =
    { category = CategoryName; counter = "Calculation cache lookups/sec"; instance = None }
  /// Current dimension queries: Current number of dimension queries being actively worked on.
  let ``Current dimension queries`` =
    { category = CategoryName; counter = "Current dimension queries"; instance = None }
  /// Current measure group queries: Current number of measure group queries being actively worked on.
  let ``Current measure group queries`` =
    { category = CategoryName; counter = "Current measure group queries"; instance = None }
  /// Data bytes/sec: Bytes read from the Data file.
  let ``Data bytes/sec`` =
    { category = CategoryName; counter = "Data bytes/sec"; instance = None }
  /// Data reads/sec: Number of logical read operations using the Data file.
  let ``Data reads/sec`` =
    { category = CategoryName; counter = "Data reads/sec"; instance = None }
  /// Dimension cache hits/sec: Rate of dimension cache hits.
  let ``Dimension cache hits/sec`` =
    { category = CategoryName; counter = "Dimension cache hits/sec"; instance = None }
  /// Dimension cache lookups/sec: Rate of dimension cache lookups.
  let ``Dimension cache lookups/sec`` =
    { category = CategoryName; counter = "Dimension cache lookups/sec"; instance = None }
  /// Dimension queries/sec: Rate of dimension queries
  let ``Dimension queries/sec`` =
    { category = CategoryName; counter = "Dimension queries/sec"; instance = None }
  /// Flat cache hits/sec: Rate of flat cache hits.  This includes global, session, and query scope flat caches.
  let ``Flat cache hits/sec`` =
    { category = CategoryName; counter = "Flat cache hits/sec"; instance = None }
  /// Flat cache lookups/sec: Rate of flat cache lookups.  This includes global, session, and query scope flat caches.
  let ``Flat cache lookups/sec`` =
    { category = CategoryName; counter = "Flat cache lookups/sec"; instance = None }
  /// Map bytes/sec: Bytes read from the Map file.
  let ``Map bytes/sec`` =
    { category = CategoryName; counter = "Map bytes/sec"; instance = None }
  /// Map reads/sec: Number of logical read operations using the Map file.
  let ``Map reads/sec`` =
    { category = CategoryName; counter = "Map reads/sec"; instance = None }
  /// Measure group cache hits/sec: Rate of measure group cache hits.
  let ``Measure group cache hits/sec`` =
    { category = CategoryName; counter = "Measure group cache hits/sec"; instance = None }
  /// Measure group cache lookups/sec: Rate of measure group cache lookups.
  let ``Measure group cache lookups/sec`` =
    { category = CategoryName; counter = "Measure group cache lookups/sec"; instance = None }
  /// Measure group queries/sec: Rate of measure group queries
  let ``Measure group queries/sec`` =
    { category = CategoryName; counter = "Measure group queries/sec"; instance = None }
  /// Network round trips/sec: Rate of network round trips.  This includes all client/server communication.
  let ``Network round trips/sec`` =
    { category = CategoryName; counter = "Network round trips/sec"; instance = None }
  /// Persisted cache hits/sec: Rate of persisted cache hits.  Persisted caches are created by the MDX script CACHE statement.
  let ``Persisted cache hits/sec`` =
    { category = CategoryName; counter = "Persisted cache hits/sec"; instance = None }
  /// Persisted cache lookups/sec: Rate of persisted cache lookups.  Persisted caches are created by the MDX script CACHE statement.
  let ``Persisted cache lookups/sec`` =
    { category = CategoryName; counter = "Persisted cache lookups/sec"; instance = None }
  /// Queries answered/sec: Rate of queries answered.
  let ``Queries answered/sec`` =
    { category = CategoryName; counter = "Queries answered/sec"; instance = None }
  /// Queries from cache direct/sec: Rate of queries answered from cache directly.
  let ``Queries from cache direct/sec`` =
    { category = CategoryName; counter = "Queries from cache direct/sec"; instance = None }
  /// Queries from cache filtered/sec: Rate of queries answered by filtering existing cache entry.
  let ``Queries from cache filtered/sec`` =
    { category = CategoryName; counter = "Queries from cache filtered/sec"; instance = None }
  /// Queries from file/sec: Rate of queries answered from files.
  let ``Queries from file/sec`` =
    { category = CategoryName; counter = "Queries from file/sec"; instance = None }
  /// Rows sent/sec: Rate of rows sent by server to clients.
  let ``Rows sent/sec`` =
    { category = CategoryName; counter = "Rows sent/sec"; instance = None }
  /// Total bytes sent: Total bytes sent by server to clients, in response to queries.
  let ``Total bytes sent`` =
    { category = CategoryName; counter = "Total bytes sent"; instance = None }
  /// Total dimension queries.: Total number of dimension queries.
  let ``Total dimension queries.`` =
    { category = CategoryName; counter = "Total dimension queries."; instance = None }
  /// Total measure group queries: Total number of queries to measure group.
  let ``Total measure group queries`` =
    { category = CategoryName; counter = "Total measure group queries"; instance = None }
  /// Total network round trips: Total network round trips.  This includes all client/server communication.
  let ``Total network round trips`` =
    { category = CategoryName; counter = "Total network round trips"; instance = None }
  /// Total queries answered: Total number of queries answered.
  let ``Total queries answered`` =
    { category = CategoryName; counter = "Total queries answered"; instance = None }
  /// Total queries from cache direct: Total number of queries derived directly from cache.  Note that this is per partition.
  let ``Total queries from cache direct`` =
    { category = CategoryName; counter = "Total queries from cache direct"; instance = None }
  /// Total queries from cache filtered: Total queries answered by filtering existing cache entries.
  let ``Total queries from cache filtered`` =
    { category = CategoryName; counter = "Total queries from cache filtered"; instance = None }
  /// Total queries from file: Total number of queries answered from files.
  let ``Total queries from file`` =
    { category = CategoryName; counter = "Total queries from file"; instance = None }
  /// Total rows sent: Total rows sent by server to clients.
  let ``Total rows sent`` =
    { category = CategoryName; counter = "Total rows sent"; instance = None }

  let allCounters =
    [| ``Aggregation hits/sec``
       ``Aggregation lookups/sec``
       ``Avg time/query``
       ``Bytes sent/sec``
       ``Calculation cache hits/sec``
       ``Calculation cache lookups/sec``
       ``Current dimension queries``
       ``Current measure group queries``
       ``Data bytes/sec``
       ``Data reads/sec``
       ``Dimension cache hits/sec``
       ``Dimension cache lookups/sec``
       ``Dimension queries/sec``
       ``Flat cache hits/sec``
       ``Flat cache lookups/sec``
       ``Map bytes/sec``
       ``Map reads/sec``
       ``Measure group cache hits/sec``
       ``Measure group cache lookups/sec``
       ``Measure group queries/sec``
       ``Network round trips/sec``
       ``Persisted cache hits/sec``
       ``Persisted cache lookups/sec``
       ``Queries answered/sec``
       ``Queries from cache direct/sec``
       ``Queries from cache filtered/sec``
       ``Queries from file/sec``
       ``Rows sent/sec``
       ``Total bytes sent``
       ``Total dimension queries.``
       ``Total measure group queries``
       ``Total network round trips``
       ``Total queries answered``
       ``Total queries from cache direct``
       ``Total queries from cache filtered``
       ``Total queries from file``
       ``Total rows sent``
    |]

/// MSAS12:Threads: Statistics related to Microsoft Analysis Services threads.
///
/// This performance counter does not have instance based counters
module ``MSAS12:Threads`` =

  [<Literal>]
  let CategoryName = "MSAS12:Threads"

  let PCC = Category.create CategoryName
  /// Long parsing busy threads: Number of busy threads in the long parsing thread pool.
  let ``Long parsing busy threads`` =
    { category = CategoryName; counter = "Long parsing busy threads"; instance = None }
  /// Long parsing idle threads: Number of idle threads in the long parsing thread pool.
  let ``Long parsing idle threads`` =
    { category = CategoryName; counter = "Long parsing idle threads"; instance = None }
  /// Long parsing job queue length: Number of jobs in the queue of the long parsing thread pool.
  let ``Long parsing job queue length`` =
    { category = CategoryName; counter = "Long parsing job queue length"; instance = None }
  /// Long parsing job rate: Rate of jobs through the long parsing thread pool.
  let ``Long parsing job rate`` =
    { category = CategoryName; counter = "Long parsing job rate"; instance = None }
  /// Processing pool I/O job completion rate: Rate of I/O jobs through the processing thread pool.
  let ``Processing pool I/O job completion rate`` =
    { category = CategoryName; counter = "Processing pool I/O job completion rate"; instance = None }
  /// Processing pool I/O job queue length: Number of I/O jobs in the queue of the processing thread pool.
  let ``Processing pool I/O job queue length`` =
    { category = CategoryName; counter = "Processing pool I/O job queue length"; instance = None }
  /// Processing pool busy I/O job threads: Number of threads running I/O jobs in the processing thread pool.
  let ``Processing pool busy I/O job threads`` =
    { category = CategoryName; counter = "Processing pool busy I/O job threads"; instance = None }
  /// Processing pool busy non-I/O threads: Number of threads running non-I/O jobs in the processing thread pool.
  let ``Processing pool busy non-I/O threads`` =
    { category = CategoryName; counter = "Processing pool busy non-I/O threads"; instance = None }
  /// Processing pool idle I/O job threads: Number of idle threads for I/O jobs in the processing thread pool.
  let ``Processing pool idle I/O job threads`` =
    { category = CategoryName; counter = "Processing pool idle I/O job threads"; instance = None }
  /// Processing pool idle non-I/O threads: Number of idle threads in the processing thread pool dedicated to non-I/O jobs.
  let ``Processing pool idle non-I/O threads`` =
    { category = CategoryName; counter = "Processing pool idle non-I/O threads"; instance = None }
  /// Processing pool job queue length: Number of non-I/O jobs in the queue of the processing thread pool.
  let ``Processing pool job queue length`` =
    { category = CategoryName; counter = "Processing pool job queue length"; instance = None }
  /// Processing pool job rate: Rate of non-I/O jobs through the processing thread pool.
  let ``Processing pool job rate`` =
    { category = CategoryName; counter = "Processing pool job rate"; instance = None }
  /// Query pool busy threads: Number of busy threads in the query thread pool.
  let ``Query pool busy threads`` =
    { category = CategoryName; counter = "Query pool busy threads"; instance = None }
  /// Query pool idle threads: Number of idle threads in the query thread pool.
  let ``Query pool idle threads`` =
    { category = CategoryName; counter = "Query pool idle threads"; instance = None }
  /// Query pool job queue length: Number of jobs in the queue of the query thread pool.
  let ``Query pool job queue length`` =
    { category = CategoryName; counter = "Query pool job queue length"; instance = None }
  /// Query pool job rate: Rate of jobs through the query thread pool.
  let ``Query pool job rate`` =
    { category = CategoryName; counter = "Query pool job rate"; instance = None }
  /// Short parsing busy threads: Number of busy threads in the short parsing thread pool.
  let ``Short parsing busy threads`` =
    { category = CategoryName; counter = "Short parsing busy threads"; instance = None }
  /// Short parsing idle threads: Number of idle threads in the short parsing thread pool.
  let ``Short parsing idle threads`` =
    { category = CategoryName; counter = "Short parsing idle threads"; instance = None }
  /// Short parsing job queue length: Number of jobs in the queue of the short parsing thread pool.
  let ``Short parsing job queue length`` =
    { category = CategoryName; counter = "Short parsing job queue length"; instance = None }
  /// Short parsing job rate: Rate of jobs through the short parsing thread pool.
  let ``Short parsing job rate`` =
    { category = CategoryName; counter = "Short parsing job rate"; instance = None }

  let allCounters =
    [| ``Long parsing busy threads``
       ``Long parsing idle threads``
       ``Long parsing job queue length``
       ``Long parsing job rate``
       ``Processing pool I/O job completion rate``
       ``Processing pool I/O job queue length``
       ``Processing pool busy I/O job threads``
       ``Processing pool busy non-I/O threads``
       ``Processing pool idle I/O job threads``
       ``Processing pool idle non-I/O threads``
       ``Processing pool job queue length``
       ``Processing pool job rate``
       ``Query pool busy threads``
       ``Query pool idle threads``
       ``Query pool job queue length``
       ``Query pool job rate``
       ``Short parsing busy threads``
       ``Short parsing idle threads``
       ``Short parsing job queue length``
       ``Short parsing job rate``
    |]

/// MSDTC Bridge 3.0.0.0: MSDTC Bridge 3.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``MSDTC Bridge 3_0_0_0`` =

  [<Literal>]
  let CategoryName = "MSDTC Bridge 3.0.0.0"

  let PCC = Category.create CategoryName
  /// Average participant commit response time: Average time in milliseconds for the WS-AT service to receive a Commit message response from a participant.
  let ``Average participant commit response time`` =
    { category = CategoryName; counter = "Average participant commit response time"; instance = None }
  /// Average participant commit response time Base: Base counter for the 'Average participant commit response time' counter.
  let ``Average participant commit response time Base`` =
    { category = CategoryName; counter = "Average participant commit response time Base"; instance = None }
  /// Average participant prepare response time: Average time in milliseconds for the WS-AT service to receive a Prepare message response from a participant.
  let ``Average participant prepare response time`` =
    { category = CategoryName; counter = "Average participant prepare response time"; instance = None }
  /// Average participant prepare response time Base: Base counter for the 'Average participant prepare response time' counter.
  let ``Average participant prepare response time Base`` =
    { category = CategoryName; counter = "Average participant prepare response time Base"; instance = None }
  /// Commit retry count/sec: The number of Commit retry messages that the WS-AT service has sent per second.
  let ``Commit retry count/sec`` =
    { category = CategoryName; counter = "Commit retry count/sec"; instance = None }
  /// Faults received count/sec: The number of Fault messages that the WS-AT service has received per second.
  let ``Faults received count/sec`` =
    { category = CategoryName; counter = "Faults received count/sec"; instance = None }
  /// Faults sent count/sec: The number of Fault messages that the WS-AT service has sent per second.
  let ``Faults sent count/sec`` =
    { category = CategoryName; counter = "Faults sent count/sec"; instance = None }
  /// Message send failures/sec: The number of WS-AT protocol messages that the WS-AT service failed to send per second.
  let ``Message send failures/sec`` =
    { category = CategoryName; counter = "Message send failures/sec"; instance = None }
  /// Prepare retry count/sec: The number of Prepare retry messages that the WS-AT service has sent per second.
  let ``Prepare retry count/sec`` =
    { category = CategoryName; counter = "Prepare retry count/sec"; instance = None }
  /// Prepared retry count/sec: The number of Prepared retry messages that the WS-AT service has sent per second.
  let ``Prepared retry count/sec`` =
    { category = CategoryName; counter = "Prepared retry count/sec"; instance = None }
  /// Replay retry count/sec: The number of Replay retry messages that the WS-AT service has sent per second.
  let ``Replay retry count/sec`` =
    { category = CategoryName; counter = "Replay retry count/sec"; instance = None }

  let allCounters =
    [| ``Average participant commit response time``
       ``Average participant commit response time Base``
       ``Average participant prepare response time``
       ``Average participant prepare response time Base``
       ``Commit retry count/sec``
       ``Faults received count/sec``
       ``Faults sent count/sec``
       ``Message send failures/sec``
       ``Prepare retry count/sec``
       ``Prepared retry count/sec``
       ``Replay retry count/sec``
    |]

/// MSDTC Bridge 4.0.0.0: MSDTC Bridge 4.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``MSDTC Bridge 4_0_0_0`` =

  [<Literal>]
  let CategoryName = "MSDTC Bridge 4.0.0.0"

  let PCC = Category.create CategoryName
  /// Average participant commit response time: Average time in milliseconds for the WS-AT service to receive a Commit message response from a participant.
  let ``Average participant commit response time`` =
    { category = CategoryName; counter = "Average participant commit response time"; instance = None }
  /// Average participant commit response time Base: Base counter for the 'Average participant commit response time' counter.
  let ``Average participant commit response time Base`` =
    { category = CategoryName; counter = "Average participant commit response time Base"; instance = None }
  /// Average participant prepare response time: Average time in milliseconds for the WS-AT service to receive a Prepare message response from a participant.
  let ``Average participant prepare response time`` =
    { category = CategoryName; counter = "Average participant prepare response time"; instance = None }
  /// Average participant prepare response time Base: Base counter for the 'Average participant prepare response time' counter.
  let ``Average participant prepare response time Base`` =
    { category = CategoryName; counter = "Average participant prepare response time Base"; instance = None }
  /// Commit retry count/sec: The number of Commit retry messages that the WS-AT service has sent per second.
  let ``Commit retry count/sec`` =
    { category = CategoryName; counter = "Commit retry count/sec"; instance = None }
  /// Faults received count/sec: The number of Fault messages that the WS-AT service has received per second.
  let ``Faults received count/sec`` =
    { category = CategoryName; counter = "Faults received count/sec"; instance = None }
  /// Faults sent count/sec: The number of Fault messages that the WS-AT service has sent per second.
  let ``Faults sent count/sec`` =
    { category = CategoryName; counter = "Faults sent count/sec"; instance = None }
  /// Message send failures/sec: The number of WS-AT protocol messages that the WS-AT service failed to send per second.
  let ``Message send failures/sec`` =
    { category = CategoryName; counter = "Message send failures/sec"; instance = None }
  /// Prepare retry count/sec: The number of Prepare retry messages that the WS-AT service has sent per second.
  let ``Prepare retry count/sec`` =
    { category = CategoryName; counter = "Prepare retry count/sec"; instance = None }
  /// Prepared retry count/sec: The number of Prepared retry messages that the WS-AT service has sent per second.
  let ``Prepared retry count/sec`` =
    { category = CategoryName; counter = "Prepared retry count/sec"; instance = None }
  /// Replay retry count/sec: The number of Replay retry messages that the WS-AT service has sent per second.
  let ``Replay retry count/sec`` =
    { category = CategoryName; counter = "Replay retry count/sec"; instance = None }

  let allCounters =
    [| ``Average participant commit response time``
       ``Average participant commit response time Base``
       ``Average participant prepare response time``
       ``Average participant prepare response time Base``
       ``Commit retry count/sec``
       ``Faults received count/sec``
       ``Faults sent count/sec``
       ``Message send failures/sec``
       ``Prepare retry count/sec``
       ``Prepared retry count/sec``
       ``Replay retry count/sec``
    |]

/// MSMQ Incoming Multicast Session: Statistics about active incoming multicast sessions.
///
/// This performance counter does not have instance based counters
module ``MSMQ Incoming Multicast Session`` =

  [<Literal>]
  let CategoryName = "MSMQ Incoming Multicast Session"

  let PCC = Category.create CategoryName
  /// Incoming Multicast Bytes: -
  let ``Incoming Multicast Bytes`` instance =
    { category = CategoryName; counter = "Incoming Multicast Bytes"; instance = instance }
  /// Incoming Multicast Bytes/sec: -
  let ``Incoming Multicast Bytes/sec`` instance =
    { category = CategoryName; counter = "Incoming Multicast Bytes/sec"; instance = instance }
  /// Incoming Multicast Messages: -
  let ``Incoming Multicast Messages`` instance =
    { category = CategoryName; counter = "Incoming Multicast Messages"; instance = instance }
  /// Incoming Multicast Messages/sec: -
  let ``Incoming Multicast Messages/sec`` instance =
    { category = CategoryName; counter = "Incoming Multicast Messages/sec"; instance = instance }

  let allCounters =
    [| ``Incoming Multicast Bytes``
       ``Incoming Multicast Bytes/sec``
       ``Incoming Multicast Messages``
       ``Incoming Multicast Messages/sec``
    |]

/// MSMQ Outgoing HTTP Session: Statistics about active HTTP sessions between this computer and other computers running Message Queuing.
///
/// This performance counter does not have instance based counters
module ``MSMQ Outgoing HTTP Session`` =

  [<Literal>]
  let CategoryName = "MSMQ Outgoing HTTP Session"

  let PCC = Category.create CategoryName
  /// Outgoing HTTP Bytes: -
  let ``Outgoing HTTP Bytes`` instance =
    { category = CategoryName; counter = "Outgoing HTTP Bytes"; instance = instance }
  /// Outgoing HTTP Bytes/sec: -
  let ``Outgoing HTTP Bytes/sec`` instance =
    { category = CategoryName; counter = "Outgoing HTTP Bytes/sec"; instance = instance }
  /// Outgoing HTTP Messages: -
  let ``Outgoing HTTP Messages`` instance =
    { category = CategoryName; counter = "Outgoing HTTP Messages"; instance = instance }
  /// Outgoing HTTP Messages/sec: -
  let ``Outgoing HTTP Messages/sec`` instance =
    { category = CategoryName; counter = "Outgoing HTTP Messages/sec"; instance = instance }

  let allCounters =
    [| ``Outgoing HTTP Bytes``
       ``Outgoing HTTP Bytes/sec``
       ``Outgoing HTTP Messages``
       ``Outgoing HTTP Messages/sec``
    |]

/// MSMQ Outgoing Multicast Session: Statistics about active outgoing multicast sessions.
///
/// This performance counter does not have instance based counters
module ``MSMQ Outgoing Multicast Session`` =

  [<Literal>]
  let CategoryName = "MSMQ Outgoing Multicast Session"

  let PCC = Category.create CategoryName
  /// Outgoing Multicast Bytes: -
  let ``Outgoing Multicast Bytes`` instance =
    { category = CategoryName; counter = "Outgoing Multicast Bytes"; instance = instance }
  /// Outgoing Multicast Bytes/sec: -
  let ``Outgoing Multicast Bytes/sec`` instance =
    { category = CategoryName; counter = "Outgoing Multicast Bytes/sec"; instance = instance }
  /// Outgoing Multicast Messages: -
  let ``Outgoing Multicast Messages`` instance =
    { category = CategoryName; counter = "Outgoing Multicast Messages"; instance = instance }
  /// Outgoing Multicast Messages/sec: -
  let ``Outgoing Multicast Messages/sec`` instance =
    { category = CategoryName; counter = "Outgoing Multicast Messages/sec"; instance = instance }

  let allCounters =
    [| ``Outgoing Multicast Bytes``
       ``Outgoing Multicast Bytes/sec``
       ``Outgoing Multicast Messages``
       ``Outgoing Multicast Messages/sec``
    |]

/// MSMQ Queue: Message statistics for the selected Message Queuing queue
///
/// This performance counter does not have non-instance based counters
module ``MSMQ Queue`` =

  [<Literal>]
  let CategoryName = "MSMQ Queue"

  let PCC = Category.create CategoryName
  /// Bytes in Journal Queue: The total number of bytes in all Message Queuing messages that currently reside in the selected journal. For the Computer Queues instance, this counter represents the computer journal.
  let ``Bytes in Journal Queue`` instance =
    { category = CategoryName; counter = "Bytes in Journal Queue"; instance = instance }
  /// Bytes in Queue: The total number of bytes in all Message Queuing messages that currently reside in the selected queue. For the Computer Queues instance, this counter represents the dead-letter queue.
  let ``Bytes in Queue`` instance =
    { category = CategoryName; counter = "Bytes in Queue"; instance = instance }
  /// Messages in Journal Queue: The total number of Message Queuing messages that currently reside in the selected journal. For the Computer Queues instance, this counter represents the computer journal.
  let ``Messages in Journal Queue`` instance =
    { category = CategoryName; counter = "Messages in Journal Queue"; instance = instance }
  /// Messages in Queue: The total number of Message Queuing messages that currently reside in the selected queue. For the Computer Queues instance, this counter represents the dead-letter queue.
  let ``Messages in Queue`` instance =
    { category = CategoryName; counter = "Messages in Queue"; instance = instance }

  let allCounters =
    [| ``Bytes in Journal Queue``
       ``Bytes in Queue``
       ``Messages in Journal Queue``
       ``Messages in Queue``
    |]

/// MSMQ Service: Statistics for the Message Queuing service on the selected computer.
///
/// This performance counter does not have instance based counters
module ``MSMQ Service`` =

  [<Literal>]
  let CategoryName = "MSMQ Service"

  let PCC = Category.create CategoryName
  /// IP Sessions: The number of open IP sessions involving the selected computer.
  let ``IP Sessions`` =
    { category = CategoryName; counter = "IP Sessions"; instance = None }
  /// Incoming Messages/sec: The rate at which incoming Message Queuing messages are placed in queues on the selected computer by the Message Queuing service.
  let ``Incoming Messages/sec`` =
    { category = CategoryName; counter = "Incoming Messages/sec"; instance = None }
  /// Incoming Multicast Sessions: The number of open incoming multicast sessions involving the selected computer.
  let ``Incoming Multicast Sessions`` =
    { category = CategoryName; counter = "Incoming Multicast Sessions"; instance = None }
  /// MSMQ Incoming Messages: The total number of incoming Message Queuing messages placed in queues on the selected computer by the Message Queuing service.
  let ``MSMQ Incoming Messages`` =
    { category = CategoryName; counter = "MSMQ Incoming Messages"; instance = None }
  /// MSMQ Outgoing Messages: The total number of outgoing Message Queuing messages sent from the selected computer by the Message Queuing service.
  let ``MSMQ Outgoing Messages`` =
    { category = CategoryName; counter = "MSMQ Outgoing Messages"; instance = None }
  /// Outgoing HTTP Sessions: The number of open outgoing HTTP sessions involving the selected computer.
  let ``Outgoing HTTP Sessions`` =
    { category = CategoryName; counter = "Outgoing HTTP Sessions"; instance = None }
  /// Outgoing Messages/sec: The rate at which outgoing Message Queuing messages are sent from the selected computer by the Message Queuing service.
  let ``Outgoing Messages/sec`` =
    { category = CategoryName; counter = "Outgoing Messages/sec"; instance = None }
  /// Outgoing Multicast Sessions: The number of open outgoing multicast sessions involving the selected computer.
  let ``Outgoing Multicast Sessions`` =
    { category = CategoryName; counter = "Outgoing Multicast Sessions"; instance = None }
  /// Sessions: The total number of open network sessions involving the selected computer.
  let ``Sessions`` =
    { category = CategoryName; counter = "Sessions"; instance = None }
  /// Total bytes in all queues: The total number of bytes in all Message Queuing messages residing in active queues on the selected computer.
  let ``Total bytes in all queues`` =
    { category = CategoryName; counter = "Total bytes in all queues"; instance = None }
  /// Total messages in all queues: The total number of Message Queuing messages residing in active queues on the selected computer.
  let ``Total messages in all queues`` =
    { category = CategoryName; counter = "Total messages in all queues"; instance = None }

  let allCounters =
    [| ``IP Sessions``
       ``Incoming Messages/sec``
       ``Incoming Multicast Sessions``
       ``MSMQ Incoming Messages``
       ``MSMQ Outgoing Messages``
       ``Outgoing HTTP Sessions``
       ``Outgoing Messages/sec``
       ``Outgoing Multicast Sessions``
       ``Sessions``
       ``Total bytes in all queues``
       ``Total messages in all queues``
    |]

/// MSMQ Session: Statistics about active sessions between computers running Message Queuing
///
/// This performance counter does not have instance based counters
module ``MSMQ Session`` =

  [<Literal>]
  let CategoryName = "MSMQ Session"

  let PCC = Category.create CategoryName
  /// Incoming Bytes: -
  let ``Incoming Bytes`` instance =
    { category = CategoryName; counter = "Incoming Bytes"; instance = instance }
  /// Incoming Bytes/sec: -
  let ``Incoming Bytes/sec`` instance =
    { category = CategoryName; counter = "Incoming Bytes/sec"; instance = instance }
  /// Incoming Messages: -
  let ``Incoming Messages`` instance =
    { category = CategoryName; counter = "Incoming Messages"; instance = instance }
  /// Incoming Messages/sec: -
  let ``Incoming Messages/sec`` instance =
    { category = CategoryName; counter = "Incoming Messages/sec"; instance = instance }
  /// Outgoing Bytes: -
  let ``Outgoing Bytes`` instance =
    { category = CategoryName; counter = "Outgoing Bytes"; instance = instance }
  /// Outgoing Bytes/sec: -
  let ``Outgoing Bytes/sec`` instance =
    { category = CategoryName; counter = "Outgoing Bytes/sec"; instance = instance }
  /// Outgoing Messages: -
  let ``Outgoing Messages`` instance =
    { category = CategoryName; counter = "Outgoing Messages"; instance = instance }
  /// Outgoing Messages/sec: -
  let ``Outgoing Messages/sec`` instance =
    { category = CategoryName; counter = "Outgoing Messages/sec"; instance = instance }

  let allCounters =
    [| ``Incoming Bytes``
       ``Incoming Bytes/sec``
       ``Incoming Messages``
       ``Incoming Messages/sec``
       ``Outgoing Bytes``
       ``Outgoing Bytes/sec``
       ``Outgoing Messages``
       ``Outgoing Messages/sec``
    |]

/// MSRS 2014 Web Service: MSRS 2011 Web Service
///
/// This performance counter does not have instance based counters
module ``MSRS 2014 Web Service`` =

  [<Literal>]
  let CategoryName = "MSRS 2014 Web Service"

  let PCC = Category.create CategoryName
  /// Active Sessions: -
  let ``Active Sessions`` instance =
    { category = CategoryName; counter = "Active Sessions"; instance = instance }
  /// Cache Hits/Sec: -
  let ``Cache Hits/Sec`` instance =
    { category = CategoryName; counter = "Cache Hits/Sec"; instance = instance }
  /// Cache Hits/Sec (Semantic Models): -
  let ``Cache Hits/Sec (Semantic Models)`` instance =
    { category = CategoryName; counter = "Cache Hits/Sec (Semantic Models)"; instance = instance }
  /// Cache Misses/Sec: -
  let ``Cache Misses/Sec`` instance =
    { category = CategoryName; counter = "Cache Misses/Sec"; instance = instance }
  /// Cache Misses/Sec (Semantic Models): -
  let ``Cache Misses/Sec (Semantic Models)`` instance =
    { category = CategoryName; counter = "Cache Misses/Sec (Semantic Models)"; instance = instance }
  /// First Session Requests/Sec: -
  let ``First Session Requests/Sec`` instance =
    { category = CategoryName; counter = "First Session Requests/Sec"; instance = instance }
  /// Memory Cache Hits/Sec: -
  let ``Memory Cache Hits/Sec`` instance =
    { category = CategoryName; counter = "Memory Cache Hits/Sec"; instance = instance }
  /// Memory Cache Miss/Sec: -
  let ``Memory Cache Miss/Sec`` instance =
    { category = CategoryName; counter = "Memory Cache Miss/Sec"; instance = instance }
  /// Next Session Requests/Sec: -
  let ``Next Session Requests/Sec`` instance =
    { category = CategoryName; counter = "Next Session Requests/Sec"; instance = instance }
  /// Report Requests: -
  let ``Report Requests`` instance =
    { category = CategoryName; counter = "Report Requests"; instance = instance }
  /// Reports Executed/Sec: -
  let ``Reports Executed/Sec`` instance =
    { category = CategoryName; counter = "Reports Executed/Sec"; instance = instance }
  /// Requests/Sec: -
  let ``Requests/Sec`` instance =
    { category = CategoryName; counter = "Requests/Sec"; instance = instance }
  /// Total Cache Hits: -
  let ``Total Cache Hits`` instance =
    { category = CategoryName; counter = "Total Cache Hits"; instance = instance }
  /// Total Cache Hits (Semantic Models): -
  let ``Total Cache Hits (Semantic Models)`` instance =
    { category = CategoryName; counter = "Total Cache Hits (Semantic Models)"; instance = instance }
  /// Total Cache Misses: -
  let ``Total Cache Misses`` instance =
    { category = CategoryName; counter = "Total Cache Misses"; instance = instance }
  /// Total Cache Misses (Semantic Models): -
  let ``Total Cache Misses (Semantic Models)`` instance =
    { category = CategoryName; counter = "Total Cache Misses (Semantic Models)"; instance = instance }
  /// Total Memory Cache Hits: -
  let ``Total Memory Cache Hits`` instance =
    { category = CategoryName; counter = "Total Memory Cache Hits"; instance = instance }
  /// Total Memory Cache Misses: -
  let ``Total Memory Cache Misses`` instance =
    { category = CategoryName; counter = "Total Memory Cache Misses"; instance = instance }
  /// Total Processing Failures: -
  let ``Total Processing Failures`` instance =
    { category = CategoryName; counter = "Total Processing Failures"; instance = instance }
  /// Total Rejected Threads: -
  let ``Total Rejected Threads`` instance =
    { category = CategoryName; counter = "Total Rejected Threads"; instance = instance }
  /// Total Reports Executed: -
  let ``Total Reports Executed`` instance =
    { category = CategoryName; counter = "Total Reports Executed"; instance = instance }
  /// Total Requests: -
  let ``Total Requests`` instance =
    { category = CategoryName; counter = "Total Requests"; instance = instance }

  let allCounters =
    [| ``Active Sessions``
       ``Cache Hits/Sec``
       ``Cache Hits/Sec (Semantic Models)``
       ``Cache Misses/Sec``
       ``Cache Misses/Sec (Semantic Models)``
       ``First Session Requests/Sec``
       ``Memory Cache Hits/Sec``
       ``Memory Cache Miss/Sec``
       ``Next Session Requests/Sec``
       ``Report Requests``
       ``Reports Executed/Sec``
       ``Requests/Sec``
       ``Total Cache Hits``
       ``Total Cache Hits (Semantic Models)``
       ``Total Cache Misses``
       ``Total Cache Misses (Semantic Models)``
       ``Total Memory Cache Hits``
       ``Total Memory Cache Misses``
       ``Total Processing Failures``
       ``Total Rejected Threads``
       ``Total Reports Executed``
       ``Total Requests``
    |]

/// MSRS 2014 Web Service SharePoint Mode: MSRS 2011 Web Service
///
/// This performance counter does not have instance based counters
module ``MSRS 2014 Web Service SharePoint Mode`` =

  [<Literal>]
  let CategoryName = "MSRS 2014 Web Service SharePoint Mode"

  let PCC = Category.create CategoryName
  /// Active Sessions: -
  let ``Active Sessions`` instance =
    { category = CategoryName; counter = "Active Sessions"; instance = instance }
  /// Cache Hits/Sec: -
  let ``Cache Hits/Sec`` instance =
    { category = CategoryName; counter = "Cache Hits/Sec"; instance = instance }
  /// Cache Hits/Sec (Semantic Models): -
  let ``Cache Hits/Sec (Semantic Models)`` instance =
    { category = CategoryName; counter = "Cache Hits/Sec (Semantic Models)"; instance = instance }
  /// Cache Misses/Sec: -
  let ``Cache Misses/Sec`` instance =
    { category = CategoryName; counter = "Cache Misses/Sec"; instance = instance }
  /// Cache Misses/Sec (Semantic Models): -
  let ``Cache Misses/Sec (Semantic Models)`` instance =
    { category = CategoryName; counter = "Cache Misses/Sec (Semantic Models)"; instance = instance }
  /// First Session Requests/Sec: -
  let ``First Session Requests/Sec`` instance =
    { category = CategoryName; counter = "First Session Requests/Sec"; instance = instance }
  /// Memory Cache Hits/Sec: -
  let ``Memory Cache Hits/Sec`` instance =
    { category = CategoryName; counter = "Memory Cache Hits/Sec"; instance = instance }
  /// Memory Cache Miss/Sec: -
  let ``Memory Cache Miss/Sec`` instance =
    { category = CategoryName; counter = "Memory Cache Miss/Sec"; instance = instance }
  /// Next Session Requests/Sec: -
  let ``Next Session Requests/Sec`` instance =
    { category = CategoryName; counter = "Next Session Requests/Sec"; instance = instance }
  /// Report Requests: -
  let ``Report Requests`` instance =
    { category = CategoryName; counter = "Report Requests"; instance = instance }
  /// Reports Executed/Sec: -
  let ``Reports Executed/Sec`` instance =
    { category = CategoryName; counter = "Reports Executed/Sec"; instance = instance }
  /// Requests/Sec: -
  let ``Requests/Sec`` instance =
    { category = CategoryName; counter = "Requests/Sec"; instance = instance }
  /// Total Cache Hits: -
  let ``Total Cache Hits`` instance =
    { category = CategoryName; counter = "Total Cache Hits"; instance = instance }
  /// Total Cache Hits (Semantic Models): -
  let ``Total Cache Hits (Semantic Models)`` instance =
    { category = CategoryName; counter = "Total Cache Hits (Semantic Models)"; instance = instance }
  /// Total Cache Misses: -
  let ``Total Cache Misses`` instance =
    { category = CategoryName; counter = "Total Cache Misses"; instance = instance }
  /// Total Cache Misses (Semantic Models): -
  let ``Total Cache Misses (Semantic Models)`` instance =
    { category = CategoryName; counter = "Total Cache Misses (Semantic Models)"; instance = instance }
  /// Total Memory Cache Hits: -
  let ``Total Memory Cache Hits`` instance =
    { category = CategoryName; counter = "Total Memory Cache Hits"; instance = instance }
  /// Total Memory Cache Misses: -
  let ``Total Memory Cache Misses`` instance =
    { category = CategoryName; counter = "Total Memory Cache Misses"; instance = instance }
  /// Total Processing Failures: -
  let ``Total Processing Failures`` instance =
    { category = CategoryName; counter = "Total Processing Failures"; instance = instance }
  /// Total Rejected Threads: -
  let ``Total Rejected Threads`` instance =
    { category = CategoryName; counter = "Total Rejected Threads"; instance = instance }
  /// Total Reports Executed: -
  let ``Total Reports Executed`` instance =
    { category = CategoryName; counter = "Total Reports Executed"; instance = instance }
  /// Total Requests: -
  let ``Total Requests`` instance =
    { category = CategoryName; counter = "Total Requests"; instance = instance }

  let allCounters =
    [| ``Active Sessions``
       ``Cache Hits/Sec``
       ``Cache Hits/Sec (Semantic Models)``
       ``Cache Misses/Sec``
       ``Cache Misses/Sec (Semantic Models)``
       ``First Session Requests/Sec``
       ``Memory Cache Hits/Sec``
       ``Memory Cache Miss/Sec``
       ``Next Session Requests/Sec``
       ``Report Requests``
       ``Reports Executed/Sec``
       ``Requests/Sec``
       ``Total Cache Hits``
       ``Total Cache Hits (Semantic Models)``
       ``Total Cache Misses``
       ``Total Cache Misses (Semantic Models)``
       ``Total Memory Cache Hits``
       ``Total Memory Cache Misses``
       ``Total Processing Failures``
       ``Total Rejected Threads``
       ``Total Reports Executed``
       ``Total Requests``
    |]

/// MSRS 2014 Windows Service: MSRS 2011 Windows Service
///
/// This performance counter does not have non-instance based counters
module ``MSRS 2014 Windows Service`` =

  [<Literal>]
  let CategoryName = "MSRS 2014 Windows Service"

  let PCC = Category.create CategoryName
  /// Active Sessions: Number of active sessions.
  let ``Active Sessions`` instance =
    { category = CategoryName; counter = "Active Sessions"; instance = instance }
  /// Cache Flushes/Sec: Number of cache flushes per second.
  let ``Cache Flushes/Sec`` instance =
    { category = CategoryName; counter = "Cache Flushes/Sec"; instance = instance }
  /// Cache Hits/Sec: Number of report server cache hits per second.
  let ``Cache Hits/Sec`` instance =
    { category = CategoryName; counter = "Cache Hits/Sec"; instance = instance }
  /// Cache Hits/Sec (Semantic Models): Number of times per second that models can be retrieved from the cache.
  let ``Cache Hits/Sec (Semantic Models)`` instance =
    { category = CategoryName; counter = "Cache Hits/Sec (Semantic Models)"; instance = instance }
  /// Cache Misses/Sec: Number of times per second that reports cannot be retrieved from cache.
  let ``Cache Misses/Sec`` instance =
    { category = CategoryName; counter = "Cache Misses/Sec"; instance = instance }
  /// Cache Misses/Sec (Semantic Models): Number of times per second that models cannot be retrieved from the cache.
  let ``Cache Misses/Sec (Semantic Models)`` instance =
    { category = CategoryName; counter = "Cache Misses/Sec (Semantic Models)"; instance = instance }
  /// Delivers/Sec: Number of delivers deliveries per second.
  let ``Delivers/Sec`` instance =
    { category = CategoryName; counter = "Delivers/Sec"; instance = instance }
  /// Events/Sec: Number of events per second.
  let ``Events/Sec`` instance =
    { category = CategoryName; counter = "Events/Sec"; instance = instance }
  /// First Session Requests/Sec: Number of new user sessions that are started per second.
  let ``First Session Requests/Sec`` instance =
    { category = CategoryName; counter = "First Session Requests/Sec"; instance = instance }
  /// Memory Cache Hits/Sec: Number of times per second that reports can be retrieved from the in memory cache.
  let ``Memory Cache Hits/Sec`` instance =
    { category = CategoryName; counter = "Memory Cache Hits/Sec"; instance = instance }
  /// Memory Cache Miss/Sec: Number of times per second that reports cannot be retrieved from the in memory cache.
  let ``Memory Cache Miss/Sec`` instance =
    { category = CategoryName; counter = "Memory Cache Miss/Sec"; instance = instance }
  /// Next Session Requests/Sec: Number of requests per second for reports that are open in an existing session.
  let ``Next Session Requests/Sec`` instance =
    { category = CategoryName; counter = "Next Session Requests/Sec"; instance = instance }
  /// Report Requests: Number of active report requests.
  let ``Report Requests`` instance =
    { category = CategoryName; counter = "Report Requests"; instance = instance }
  /// Reports Executed/Sec: Number of reports executed per second.
  let ``Reports Executed/Sec`` instance =
    { category = CategoryName; counter = "Reports Executed/Sec"; instance = instance }
  /// Requests/Sec: Number of requests per second.
  let ``Requests/Sec`` instance =
    { category = CategoryName; counter = "Requests/Sec"; instance = instance }
  /// Snapshot Updates/Sec: Number of snapshot updates per second.
  let ``Snapshot Updates/Sec`` instance =
    { category = CategoryName; counter = "Snapshot Updates/Sec"; instance = instance }
  /// Total App Domain Recycles: Total number of application domain recycles.
  let ``Total App Domain Recycles`` instance =
    { category = CategoryName; counter = "Total App Domain Recycles"; instance = instance }
  /// Total Cache Flushes: Total number of report execution server cache updates.
  let ``Total Cache Flushes`` instance =
    { category = CategoryName; counter = "Total Cache Flushes"; instance = instance }
  /// Total Cache Hits: Total number of report server cache hits.
  let ``Total Cache Hits`` instance =
    { category = CategoryName; counter = "Total Cache Hits"; instance = instance }
  /// Total Cache Hits (Semantic Models): Total number of cache hits made in the model cache.
  let ``Total Cache Hits (Semantic Models)`` instance =
    { category = CategoryName; counter = "Total Cache Hits (Semantic Models)"; instance = instance }
  /// Total Cache Misses: Total number of cache misses.
  let ``Total Cache Misses`` instance =
    { category = CategoryName; counter = "Total Cache Misses"; instance = instance }
  /// Total Cache Misses (Semantic Models): Total number of cache misses made in the model cache.
  let ``Total Cache Misses (Semantic Models)`` instance =
    { category = CategoryName; counter = "Total Cache Misses (Semantic Models)"; instance = instance }
  /// Total Deliveries: Total number of deliveries.
  let ``Total Deliveries`` instance =
    { category = CategoryName; counter = "Total Deliveries"; instance = instance }
  /// Total Events: Total number of events.
  let ``Total Events`` instance =
    { category = CategoryName; counter = "Total Events"; instance = instance }
  /// Total Memory Cache Hits: Total number of cache hits made in the in memory cache.
  let ``Total Memory Cache Hits`` instance =
    { category = CategoryName; counter = "Total Memory Cache Hits"; instance = instance }
  /// Total Memory Cache Misses: Total number of cache misses made in the in memory cache.
  let ``Total Memory Cache Misses`` instance =
    { category = CategoryName; counter = "Total Memory Cache Misses"; instance = instance }
  /// Total Processing Failures: Total number of processing failures.
  let ``Total Processing Failures`` instance =
    { category = CategoryName; counter = "Total Processing Failures"; instance = instance }
  /// Total Rejected Threads: Total number of rejected threads as a result of thread pressure.
  let ``Total Rejected Threads`` instance =
    { category = CategoryName; counter = "Total Rejected Threads"; instance = instance }
  /// Total Reports Executed: Total number of reports executed.
  let ``Total Reports Executed`` instance =
    { category = CategoryName; counter = "Total Reports Executed"; instance = instance }
  /// Total Requests: Total number of requests being processed.
  let ``Total Requests`` instance =
    { category = CategoryName; counter = "Total Requests"; instance = instance }
  /// Total Snapshot Updates: Total number of report execution snapshot updates.
  let ``Total Snapshot Updates`` instance =
    { category = CategoryName; counter = "Total Snapshot Updates"; instance = instance }

  let allCounters =
    [| ``Active Sessions``
       ``Cache Flushes/Sec``
       ``Cache Hits/Sec``
       ``Cache Hits/Sec (Semantic Models)``
       ``Cache Misses/Sec``
       ``Cache Misses/Sec (Semantic Models)``
       ``Delivers/Sec``
       ``Events/Sec``
       ``First Session Requests/Sec``
       ``Memory Cache Hits/Sec``
       ``Memory Cache Miss/Sec``
       ``Next Session Requests/Sec``
       ``Report Requests``
       ``Reports Executed/Sec``
       ``Requests/Sec``
       ``Snapshot Updates/Sec``
       ``Total App Domain Recycles``
       ``Total Cache Flushes``
       ``Total Cache Hits``
       ``Total Cache Hits (Semantic Models)``
       ``Total Cache Misses``
       ``Total Cache Misses (Semantic Models)``
       ``Total Deliveries``
       ``Total Events``
       ``Total Memory Cache Hits``
       ``Total Memory Cache Misses``
       ``Total Processing Failures``
       ``Total Rejected Threads``
       ``Total Reports Executed``
       ``Total Requests``
       ``Total Snapshot Updates``
    |]

/// MSRS 2014 Windows Service SharePoint Mode: MSRS 2011 Windows Service
///
/// This performance counter does not have instance based counters
module ``MSRS 2014 Windows Service SharePoint Mode`` =

  [<Literal>]
  let CategoryName = "MSRS 2014 Windows Service SharePoint Mode"

  let PCC = Category.create CategoryName
  /// Active Sessions: -
  let ``Active Sessions`` instance =
    { category = CategoryName; counter = "Active Sessions"; instance = instance }
  /// Alerting: event queue length: -
  let ``Alerting: event queue length`` instance =
    { category = CategoryName; counter = "Alerting: event queue length"; instance = instance }
  /// Alerting: events processed - CreateSchedule: -
  let ``Alerting: events processed - CreateSchedule`` instance =
    { category = CategoryName; counter = "Alerting: events processed - CreateSchedule"; instance = instance }
  /// Alerting: events processed - DeleteSchedule: -
  let ``Alerting: events processed - DeleteSchedule`` instance =
    { category = CategoryName; counter = "Alerting: events processed - DeleteSchedule"; instance = instance }
  /// Alerting: events processed - DeliverAlert: -
  let ``Alerting: events processed - DeliverAlert`` instance =
    { category = CategoryName; counter = "Alerting: events processed - DeliverAlert"; instance = instance }
  /// Alerting: events processed - FireAlert: -
  let ``Alerting: events processed - FireAlert`` instance =
    { category = CategoryName; counter = "Alerting: events processed - FireAlert"; instance = instance }
  /// Alerting: events processed - FireSchedule: -
  let ``Alerting: events processed - FireSchedule`` instance =
    { category = CategoryName; counter = "Alerting: events processed - FireSchedule"; instance = instance }
  /// Alerting: events processed - GenerateAlert: -
  let ``Alerting: events processed - GenerateAlert`` instance =
    { category = CategoryName; counter = "Alerting: events processed - GenerateAlert"; instance = instance }
  /// Alerting: events processed - UpdateSchedule: -
  let ``Alerting: events processed - UpdateSchedule`` instance =
    { category = CategoryName; counter = "Alerting: events processed - UpdateSchedule"; instance = instance }
  /// Cache Flushes/Sec: -
  let ``Cache Flushes/Sec`` instance =
    { category = CategoryName; counter = "Cache Flushes/Sec"; instance = instance }
  /// Cache Hits/Sec: -
  let ``Cache Hits/Sec`` instance =
    { category = CategoryName; counter = "Cache Hits/Sec"; instance = instance }
  /// Cache Hits/Sec (Semantic Models): -
  let ``Cache Hits/Sec (Semantic Models)`` instance =
    { category = CategoryName; counter = "Cache Hits/Sec (Semantic Models)"; instance = instance }
  /// Cache Misses/Sec: -
  let ``Cache Misses/Sec`` instance =
    { category = CategoryName; counter = "Cache Misses/Sec"; instance = instance }
  /// Cache Misses/Sec (Semantic Models): -
  let ``Cache Misses/Sec (Semantic Models)`` instance =
    { category = CategoryName; counter = "Cache Misses/Sec (Semantic Models)"; instance = instance }
  /// Delivers/Sec: -
  let ``Delivers/Sec`` instance =
    { category = CategoryName; counter = "Delivers/Sec"; instance = instance }
  /// Events/Sec: -
  let ``Events/Sec`` instance =
    { category = CategoryName; counter = "Events/Sec"; instance = instance }
  /// First Session Requests/Sec: -
  let ``First Session Requests/Sec`` instance =
    { category = CategoryName; counter = "First Session Requests/Sec"; instance = instance }
  /// Memory Cache Hits/Sec: -
  let ``Memory Cache Hits/Sec`` instance =
    { category = CategoryName; counter = "Memory Cache Hits/Sec"; instance = instance }
  /// Memory Cache Miss/Sec: -
  let ``Memory Cache Miss/Sec`` instance =
    { category = CategoryName; counter = "Memory Cache Miss/Sec"; instance = instance }
  /// Next Session Requests/Sec: -
  let ``Next Session Requests/Sec`` instance =
    { category = CategoryName; counter = "Next Session Requests/Sec"; instance = instance }
  /// Report Requests: -
  let ``Report Requests`` instance =
    { category = CategoryName; counter = "Report Requests"; instance = instance }
  /// Reports Executed/Sec: -
  let ``Reports Executed/Sec`` instance =
    { category = CategoryName; counter = "Reports Executed/Sec"; instance = instance }
  /// Requests/Sec: -
  let ``Requests/Sec`` instance =
    { category = CategoryName; counter = "Requests/Sec"; instance = instance }
  /// Snapshot Updates/Sec: -
  let ``Snapshot Updates/Sec`` instance =
    { category = CategoryName; counter = "Snapshot Updates/Sec"; instance = instance }
  /// Total App Domain Recycles: -
  let ``Total App Domain Recycles`` instance =
    { category = CategoryName; counter = "Total App Domain Recycles"; instance = instance }
  /// Total Cache Flushes: -
  let ``Total Cache Flushes`` instance =
    { category = CategoryName; counter = "Total Cache Flushes"; instance = instance }
  /// Total Cache Hits: -
  let ``Total Cache Hits`` instance =
    { category = CategoryName; counter = "Total Cache Hits"; instance = instance }
  /// Total Cache Hits (Semantic Models): -
  let ``Total Cache Hits (Semantic Models)`` instance =
    { category = CategoryName; counter = "Total Cache Hits (Semantic Models)"; instance = instance }
  /// Total Cache Misses: -
  let ``Total Cache Misses`` instance =
    { category = CategoryName; counter = "Total Cache Misses"; instance = instance }
  /// Total Cache Misses (Semantic Models): -
  let ``Total Cache Misses (Semantic Models)`` instance =
    { category = CategoryName; counter = "Total Cache Misses (Semantic Models)"; instance = instance }
  /// Total Deliveries: -
  let ``Total Deliveries`` instance =
    { category = CategoryName; counter = "Total Deliveries"; instance = instance }
  /// Total Events: -
  let ``Total Events`` instance =
    { category = CategoryName; counter = "Total Events"; instance = instance }
  /// Total Memory Cache Hits: -
  let ``Total Memory Cache Hits`` instance =
    { category = CategoryName; counter = "Total Memory Cache Hits"; instance = instance }
  /// Total Memory Cache Misses: -
  let ``Total Memory Cache Misses`` instance =
    { category = CategoryName; counter = "Total Memory Cache Misses"; instance = instance }
  /// Total Processing Failures: -
  let ``Total Processing Failures`` instance =
    { category = CategoryName; counter = "Total Processing Failures"; instance = instance }
  /// Total Rejected Threads: -
  let ``Total Rejected Threads`` instance =
    { category = CategoryName; counter = "Total Rejected Threads"; instance = instance }
  /// Total Reports Executed: -
  let ``Total Reports Executed`` instance =
    { category = CategoryName; counter = "Total Reports Executed"; instance = instance }
  /// Total Requests: -
  let ``Total Requests`` instance =
    { category = CategoryName; counter = "Total Requests"; instance = instance }
  /// Total Snapshot Updates: -
  let ``Total Snapshot Updates`` instance =
    { category = CategoryName; counter = "Total Snapshot Updates"; instance = instance }

  let allCounters =
    [| ``Active Sessions``
       ``Alerting: event queue length``
       ``Alerting: events processed - CreateSchedule``
       ``Alerting: events processed - DeleteSchedule``
       ``Alerting: events processed - DeliverAlert``
       ``Alerting: events processed - FireAlert``
       ``Alerting: events processed - FireSchedule``
       ``Alerting: events processed - GenerateAlert``
       ``Alerting: events processed - UpdateSchedule``
       ``Cache Flushes/Sec``
       ``Cache Hits/Sec``
       ``Cache Hits/Sec (Semantic Models)``
       ``Cache Misses/Sec``
       ``Cache Misses/Sec (Semantic Models)``
       ``Delivers/Sec``
       ``Events/Sec``
       ``First Session Requests/Sec``
       ``Memory Cache Hits/Sec``
       ``Memory Cache Miss/Sec``
       ``Next Session Requests/Sec``
       ``Report Requests``
       ``Reports Executed/Sec``
       ``Requests/Sec``
       ``Snapshot Updates/Sec``
       ``Total App Domain Recycles``
       ``Total Cache Flushes``
       ``Total Cache Hits``
       ``Total Cache Hits (Semantic Models)``
       ``Total Cache Misses``
       ``Total Cache Misses (Semantic Models)``
       ``Total Deliveries``
       ``Total Events``
       ``Total Memory Cache Hits``
       ``Total Memory Cache Misses``
       ``Total Processing Failures``
       ``Total Rejected Threads``
       ``Total Reports Executed``
       ``Total Requests``
       ``Total Snapshot Updates``
    |]

/// Memory: The Memory performance object  consists of counters that describe the behavior of physical and virtual memory on the computer.  Physical memory is the amount of random access memory on the computer.  Virtual memory consists of the space in physical memory and on disk.  Many of the memory counters monitor paging, which is the movement of pages of code and data between disk and physical memory.  Excessive paging, a symptom of a memory shortage, can cause delays which interfere with all system processes.
///
/// This performance counter does not have instance based counters
module ``Memory`` =

  [<Literal>]
  let CategoryName = "Memory"

  let PCC = Category.create CategoryName
  /// % Committed Bytes In Use: % Committed Bytes In Use is the ratio of Memory\\Committed Bytes to the Memory\\Commit Limit. Committed memory is the physical memory in use for which space has been reserved in the paging file should it need to be written to disk. The commit limit is determined by the size of the paging file.  If the paging file is enlarged, the commit limit increases, and the ratio is reduced). This counter displays the current percentage value only; it is not an average.
  let ``% Committed Bytes In Use`` =
    { category = CategoryName; counter = "% Committed Bytes In Use"; instance = None }
  /// Available Bytes: Available Bytes is the amount of physical memory, in bytes, immediately available for allocation to a process or for system use. It is equal to the sum of memory assigned to the standby (cached), free and zero page lists.
  let ``Available Bytes`` =
    { category = CategoryName; counter = "Available Bytes"; instance = None }
  /// Available KBytes: Available KBytes is the amount of physical memory, in Kilobytes, immediately available for allocation to a process or for system use. It is equal to the sum of memory assigned to the standby (cached), free and zero page lists.
  let ``Available KBytes`` =
    { category = CategoryName; counter = "Available KBytes"; instance = None }
  /// Available MBytes: Available MBytes is the amount of physical memory, in Megabytes, immediately available for allocation to a process or for system use. It is equal to the sum of memory assigned to the standby (cached), free and zero page lists.
  let ``Available MBytes`` =
    { category = CategoryName; counter = "Available MBytes"; instance = None }
  /// Cache Bytes: Cache Bytes the size, in bytes, of the portion of the system file cache which is currently resident and active in physical memory. The Cache Bytes and Memory\\System Cache Resident Bytes counters are equivalent.  This counter displays the last observed value only; it is not an average.
  let ``Cache Bytes`` =
    { category = CategoryName; counter = "Cache Bytes"; instance = None }
  /// Cache Bytes Peak: Cache Bytes Peak is the maximum number of bytes used by the system file cache since the system was last restarted. This might be larger than the current size of the cache. This counter displays the last observed value only; it is not an average.
  let ``Cache Bytes Peak`` =
    { category = CategoryName; counter = "Cache Bytes Peak"; instance = None }
  /// Cache Faults/sec: Cache Faults/sec is the rate at which faults occur when a page sought in the file system cache is not found and must be retrieved from elsewhere in memory (a soft fault) or from disk (a hard fault). The file system cache is an area of physical memory that stores recently used pages of data for applications. Cache activity is a reliable indicator of most application I/O operations. This counter shows the number of faults, without regard for the number of pages faulted in each operation.
  let ``Cache Faults/sec`` =
    { category = CategoryName; counter = "Cache Faults/sec"; instance = None }
  /// Commit Limit: Commit Limit is the amount of virtual memory that can be committed without having to extend the paging file(s).  It is measured in bytes. Committed memory is the physical memory which has space reserved on the disk paging files. There can be one paging file on each logical drive). If the paging file(s) are be expanded, this limit increases accordingly.  This counter displays the last observed value only; it is not an average.
  let ``Commit Limit`` =
    { category = CategoryName; counter = "Commit Limit"; instance = None }
  /// Committed Bytes: Committed Bytes is the amount of committed virtual memory, in bytes. Committed memory is the physical memory which has space reserved on the disk paging file(s). There can be one or more paging files on each physical drive. This counter displays the last observed value only; it is not an average.
  let ``Committed Bytes`` =
    { category = CategoryName; counter = "Committed Bytes"; instance = None }
  /// Demand Zero Faults/sec: Demand Zero Faults/sec is the rate at which a zeroed page is required to satisfy the fault.  Zeroed pages, pages emptied of previously stored data and filled with zeros, are a security feature of Windows that prevent processes from seeing data stored by earlier processes that used the memory space. Windows maintains a list of zeroed pages to accelerate this process. This counter shows the number of faults, without regard to the number of pages retrieved to satisfy the fault. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Demand Zero Faults/sec`` =
    { category = CategoryName; counter = "Demand Zero Faults/sec"; instance = None }
  /// Free & Zero Page List Bytes: Free & Zero Page List Bytes is the amount of physical memory, in bytes, that is assigned to the free and zero page lists. This memory does not contain cached data. It is immediately available for allocation to a process or for system use.
  let ``Free & Zero Page List Bytes`` =
    { category = CategoryName; counter = "Free & Zero Page List Bytes"; instance = None }
  /// Free System Page Table Entries: Free System Page Table Entries is the number of page table entries not currently in used by the system.  This counter displays the last observed value only; it is not an average.
  let ``Free System Page Table Entries`` =
    { category = CategoryName; counter = "Free System Page Table Entries"; instance = None }
  /// Long-Term Average Standby Cache Lifetime (s): Long-Term Average Standby Cache Lifetime, in seconds. The average lifetime of data in the standby cache over a long interval is measured.
  let ``Long-Term Average Standby Cache Lifetime (s)`` =
    { category = CategoryName; counter = "Long-Term Average Standby Cache Lifetime (s)"; instance = None }
  /// Modified Page List Bytes: Modified Page List Bytes is the amount of physical memory, in bytes, that is assigned to the modified page list. This memory contains cached data and code that is not actively in use by processes, the system and the system cache. This memory needs to be written out before it will be available for allocation to a process or for system use.
  let ``Modified Page List Bytes`` =
    { category = CategoryName; counter = "Modified Page List Bytes"; instance = None }
  /// Page Faults/sec: Page Faults/sec is the average number of pages faulted per second. It is measured in number of pages faulted per second because only one page is faulted in each fault operation, hence this is also equal to the number of page fault operations. This counter includes both hard faults (those that require disk access) and soft faults (where the faulted page is found elsewhere in physical memory.) Most processors can handle large numbers of soft faults without significant consequence. However, hard faults, which require disk access, can cause significant delays.
  let ``Page Faults/sec`` =
    { category = CategoryName; counter = "Page Faults/sec"; instance = None }
  /// Page Reads/sec: Page Reads/sec is the rate at which the disk was read to resolve hard page faults. It shows the number of reads operations, without regard to the number of pages retrieved in each operation. Hard page faults occur when a process references a page in virtual memory that is not in working set or elsewhere in physical memory, and must be retrieved from disk. This counter is a primary indicator of the kinds of faults that cause system-wide delays. It includes read operations to satisfy faults in the file system cache (usually requested by applications) and in non-cached mapped memory files. Compare the value of Memory\\Pages Reads/sec to the value of Memory\\Pages Input/sec to determine the average number of pages read during each operation.
  let ``Page Reads/sec`` =
    { category = CategoryName; counter = "Page Reads/sec"; instance = None }
  /// Page Writes/sec: Page Writes/sec is the rate at which pages are written to disk to free up space in physical memory. Pages are written to disk only if they are changed while in physical memory, so they are likely to hold data, not code.  This counter shows write operations, without regard to the number of pages written in each operation.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Page Writes/sec`` =
    { category = CategoryName; counter = "Page Writes/sec"; instance = None }
  /// Pages Input/sec: Pages Input/sec is the rate at which pages are read from disk to resolve hard page faults. Hard page faults occur when a process refers to a page in virtual memory that is not in its working set or elsewhere in physical memory, and must be retrieved from disk. When a page is faulted, the system tries to read multiple contiguous pages into memory to maximize the benefit of the read operation. Compare the value of Memory\\Pages Input/sec to the value of  Memory\\Page Reads/sec to determine the average number of pages read into memory during each read operation.
  let ``Pages Input/sec`` =
    { category = CategoryName; counter = "Pages Input/sec"; instance = None }
  /// Pages Output/sec: Pages Output/sec is the rate at which pages are written to disk to free up space in physical memory. Pages are written back to disk only if they are changed in physical memory, so they are likely to hold data, not code. A high rate of pages output might indicate a memory shortage. Windows writes more pages back to disk to free up space when physical memory is in short supply.  This counter shows the number of pages, and can be compared to other counts of pages, without conversion.
  let ``Pages Output/sec`` =
    { category = CategoryName; counter = "Pages Output/sec"; instance = None }
  /// Pages/sec: Pages/sec is the rate at which pages are read from or written to disk to resolve hard page faults. This counter is a primary indicator of the kinds of faults that cause system-wide delays.  It is the sum of Memory\\Pages Input/sec and Memory\\Pages Output/sec.  It is counted in numbers of pages, so it can be compared to other counts of pages, such as Memory\\Page Faults/sec, without conversion. It includes pages retrieved to satisfy faults in the file system cache (usually requested by applications) non-cached mapped memory files.
  let ``Pages/sec`` =
    { category = CategoryName; counter = "Pages/sec"; instance = None }
  /// Pool Nonpaged Allocs: Pool Nonpaged Allocs is the number of calls to allocate space in the nonpaged pool. The nonpaged pool is an area of system memory area for objects that cannot be written to disk, and must remain in physical memory as long as they are allocated.  It is measured in numbers of calls to allocate space, regardless of the amount of space allocated in each call.  This counter displays the last observed value only; it is not an average.
  let ``Pool Nonpaged Allocs`` =
    { category = CategoryName; counter = "Pool Nonpaged Allocs"; instance = None }
  /// Pool Nonpaged Bytes: Pool Nonpaged Bytes is the size, in bytes, of the nonpaged pool, an area of the system virtual memory that is used for objects that cannot be written to disk, but must remain in physical memory as long as they are allocated.  Memory\\Pool Nonpaged Bytes is calculated differently than Process\\Pool Nonpaged Bytes, so it might not equal Process(_Total)\\Pool Nonpaged Bytes.  This counter displays the last observed value only; it is not an average.
  let ``Pool Nonpaged Bytes`` =
    { category = CategoryName; counter = "Pool Nonpaged Bytes"; instance = None }
  /// Pool Paged Allocs: Pool Paged Allocs is the number of calls to allocate space in the paged pool. The paged pool is an area of the system virtual memory that is used for objects that can be written to disk when they are not being used. It is measured in numbers of calls to allocate space, regardless of the amount of space allocated in each call.  This counter displays the last observed value only; it is not an average.
  let ``Pool Paged Allocs`` =
    { category = CategoryName; counter = "Pool Paged Allocs"; instance = None }
  /// Pool Paged Bytes: Pool Paged Bytes is the size, in bytes, of the paged pool, an area of the system virtual memory that is used for objects that can be written to disk when they are not being used.  Memory\\Pool Paged Bytes is calculated differently than Process\\Pool Paged Bytes, so it might not equal Process(_Total)\\Pool Paged Bytes. This counter displays the last observed value only; it is not an average.
  let ``Pool Paged Bytes`` =
    { category = CategoryName; counter = "Pool Paged Bytes"; instance = None }
  /// Pool Paged Resident Bytes: Pool Paged Resident Bytes is the size, in bytes, of the portion of the paged pool that is currently resident and active in physical memory. The paged pool is an area of the system virtual memory that is used for objects that can be written to disk when they are not being used. This counter displays the last observed value only; it is not an average.
  let ``Pool Paged Resident Bytes`` =
    { category = CategoryName; counter = "Pool Paged Resident Bytes"; instance = None }
  /// Standby Cache Core Bytes: Standby Cache Core Bytes is the amount of physical memory, in bytes, that is assigned to the core standby cache page lists. This memory contains cached data and code that is not actively in use by processes, the system and the system cache. It is immediately available for allocation to a process or for system use. If the system runs out of available free and zero memory, memory on lower priority standby cache page lists will be repurposed before memory on higher priority standby cache page lists.
  let ``Standby Cache Core Bytes`` =
    { category = CategoryName; counter = "Standby Cache Core Bytes"; instance = None }
  /// Standby Cache Normal Priority Bytes: Standby Cache Normal Priority Bytes is the amount of physical memory, in bytes, that is assigned to the normal priority standby cache page lists. This memory contains cached data and code that is not actively in use by processes, the system and the system cache. It is immediately available for allocation to a process or for system use. If the system runs out of available free and zero memory, memory on lower priority standby cache page lists will be repurposed before memory on higher priority standby cache page lists.
  let ``Standby Cache Normal Priority Bytes`` =
    { category = CategoryName; counter = "Standby Cache Normal Priority Bytes"; instance = None }
  /// Standby Cache Reserve Bytes: Standby Cache Reserve Bytes is the amount of physical memory, in bytes, that is assigned to the reserve standby cache page lists. This memory contains cached data and code that is not actively in use by processes, the system and the system cache. It is immediately available for allocation to a process or for system use. If the system runs out of available free and zero memory, memory on lower priority standby cache page lists will be repurposed before memory on higher priority standby cache page lists.
  let ``Standby Cache Reserve Bytes`` =
    { category = CategoryName; counter = "Standby Cache Reserve Bytes"; instance = None }
  /// System Cache Resident Bytes: System Cache Resident Bytes is the size, in bytes, of the portion of the system file cache which is currently resident and active in physical memory. The System Cache Resident Bytes and Memory\\Cache Bytes counters are equivalent.  This counter displays the last observed value only; it is not an average.
  let ``System Cache Resident Bytes`` =
    { category = CategoryName; counter = "System Cache Resident Bytes"; instance = None }
  /// System Code Resident Bytes: System Code Resident Bytes is the size, in bytes, of the pageable operating system code that is currently resident and active in physical memory. This value is a component of Memory\\System Code Total Bytes. Memory\\System Code Resident Bytes (and Memory\\System Code Total Bytes) does not include code that must remain in physical memory and cannot be written to disk. This counter displays the last observed value only; it is not an average.
  let ``System Code Resident Bytes`` =
    { category = CategoryName; counter = "System Code Resident Bytes"; instance = None }
  /// System Code Total Bytes: System Code Total Bytes is the size, in bytes, of the pageable operating system code currently mapped into the system virtual address space. This value is calculated by summing the bytes in Ntoskrnl.exe, Hal.dll, the boot drivers, and file systems loaded by Ntldr/osloader.  This counter does not include code that must remain in physical memory and cannot be written to disk. This counter displays the last observed value only; it is not an average.
  let ``System Code Total Bytes`` =
    { category = CategoryName; counter = "System Code Total Bytes"; instance = None }
  /// System Driver Resident Bytes: System Driver Resident Bytes is the size, in bytes, of the pageable physical memory being used by device drivers. It is the working set (physical memory area) of the drivers. This value is a component of Memory\\System Driver Total Bytes, which also includes driver memory that has been written to disk. Neither Memory\\System Driver Resident Bytes nor Memory\\System Driver Total Bytes includes memory that cannot be written to disk.
  let ``System Driver Resident Bytes`` =
    { category = CategoryName; counter = "System Driver Resident Bytes"; instance = None }
  /// System Driver Total Bytes: System Driver Total Bytes is the size, in bytes, of the pageable virtual memory currently being used by device drivers. Pageable memory can be written to disk when it is not being used. It includes both physical memory (Memory\\System Driver Resident Bytes) and code and data paged to disk. It is a component of Memory\\System Code Total Bytes. This counter displays the last observed value only; it is not an average.
  let ``System Driver Total Bytes`` =
    { category = CategoryName; counter = "System Driver Total Bytes"; instance = None }
  /// Transition Faults/sec: Transition Faults/sec is the rate at which page faults are resolved by recovering pages that were being used by another process sharing the page, or were on the modified page list or the standby list, or were being written to disk at the time of the page fault. The pages were recovered without additional disk activity. Transition faults are counted in numbers of faults; because only one page is faulted in each operation, it is also equal to the number of pages faulted.
  let ``Transition Faults/sec`` =
    { category = CategoryName; counter = "Transition Faults/sec"; instance = None }
  /// Transition Pages RePurposed/sec: Transition Pages RePurposed is the rate at which the number of transition cache pages were reused for a different purpose.  These pages would have otherwise remained in the page cache to provide a (fast) soft fault (instead of retrieving it from backing store) in the event the page was accessed in the future.  Note these pages can contain private or sharable memory.
  let ``Transition Pages RePurposed/sec`` =
    { category = CategoryName; counter = "Transition Pages RePurposed/sec"; instance = None }
  /// Write Copies/sec: Write Copies/sec is the rate at which page faults are caused by attempts to write that have been satisfied by coping of the page from elsewhere in physical memory. This is an economical way of sharing data since pages are only copied when they are written to; otherwise, the page is shared. This counter shows the number of copies, without regard for the number of pages copied in each operation.
  let ``Write Copies/sec`` =
    { category = CategoryName; counter = "Write Copies/sec"; instance = None }

  let allCounters =
    [| ``% Committed Bytes In Use``
       ``Available Bytes``
       ``Available KBytes``
       ``Available MBytes``
       ``Cache Bytes``
       ``Cache Bytes Peak``
       ``Cache Faults/sec``
       ``Commit Limit``
       ``Committed Bytes``
       ``Demand Zero Faults/sec``
       ``Free & Zero Page List Bytes``
       ``Free System Page Table Entries``
       ``Long-Term Average Standby Cache Lifetime (s)``
       ``Modified Page List Bytes``
       ``Page Faults/sec``
       ``Page Reads/sec``
       ``Page Writes/sec``
       ``Pages Input/sec``
       ``Pages Output/sec``
       ``Pages/sec``
       ``Pool Nonpaged Allocs``
       ``Pool Nonpaged Bytes``
       ``Pool Paged Allocs``
       ``Pool Paged Bytes``
       ``Pool Paged Resident Bytes``
       ``Standby Cache Core Bytes``
       ``Standby Cache Normal Priority Bytes``
       ``Standby Cache Reserve Bytes``
       ``System Cache Resident Bytes``
       ``System Code Resident Bytes``
       ``System Code Total Bytes``
       ``System Driver Resident Bytes``
       ``System Driver Total Bytes``
       ``Transition Faults/sec``
       ``Transition Pages RePurposed/sec``
       ``Write Copies/sec``
    |]

/// Microsoft Winsock BSP: Global performance counters for Microsoft Winsock Base Service Provider
///
/// This performance counter does not have instance based counters
module ``Microsoft Winsock BSP`` =

  [<Literal>]
  let CategoryName = "Microsoft Winsock BSP"

  let PCC = Category.create CategoryName
  /// Dropped Datagrams: Dropped Datagrams due to receive buffer limit on any datagram socket
  let ``Dropped Datagrams`` =
    { category = CategoryName; counter = "Dropped Datagrams"; instance = None }
  /// Dropped Datagrams/sec: Dropped Datagrams/sec due to receive buffer limit on any datagram socket
  let ``Dropped Datagrams/sec`` =
    { category = CategoryName; counter = "Dropped Datagrams/sec"; instance = None }
  /// Rejected Connections: Rejected Connections due to backlog limit on any TCP listening socket
  let ``Rejected Connections`` =
    { category = CategoryName; counter = "Rejected Connections"; instance = None }
  /// Rejected Connections/sec: Rejected Connections/sec due to backlog limit on any TCP listening socket
  let ``Rejected Connections/sec`` =
    { category = CategoryName; counter = "Rejected Connections/sec"; instance = None }

  let allCounters =
    [| ``Dropped Datagrams``
       ``Dropped Datagrams/sec``
       ``Rejected Connections``
       ``Rejected Connections/sec``
    |]

/// NBT Connection: The NBT Connection performance object consists of counters that measure the rates at which bytes are sent and received over the NBT connection between the local computer and a remote computer.  The connection is identified by the name of the remote computer.
///
/// This performance counter does not have non-instance based counters
module ``NBT Connection`` =

  [<Literal>]
  let CategoryName = "NBT Connection"

  let PCC = Category.create CategoryName
  /// Bytes Received/sec: Bytes Received/sec is the rate at which bytes are received by the local computer over an NBT connection to some remote computer.  All the bytes received by the local computer over the particular NBT connection are counted.
  let ``Bytes Received/sec`` instance =
    { category = CategoryName; counter = "Bytes Received/sec"; instance = instance }
  /// Bytes Sent/sec: Bytes Sent/sec is the rate at which bytes are sent by the local computer over an NBT connection to some remote computer.  All the bytes sent by the local computer over the particular NBT connection are counted.
  let ``Bytes Sent/sec`` instance =
    { category = CategoryName; counter = "Bytes Sent/sec"; instance = instance }
  /// Bytes Total/sec: Bytes Total/sec is the rate at which bytes are sent or received by the local computer over an NBT connection to some remote computer.  All the bytes sent or received by the local computer over the particular NBT connection are counted.
  let ``Bytes Total/sec`` instance =
    { category = CategoryName; counter = "Bytes Total/sec"; instance = instance }

  let allCounters =
    [| ``Bytes Received/sec``
       ``Bytes Sent/sec``
       ``Bytes Total/sec``
    |]

/// NUMA Node Memory: Counters that report approximate memory utilization statistics per node on NUMA systems.
///
/// This performance counter does not have non-instance based counters
module ``NUMA Node Memory`` =

  [<Literal>]
  let CategoryName = "NUMA Node Memory"

  let PCC = Category.create CategoryName
  /// Available MBytes: Approximate amount of physical memory available for allocation for a NUMA node, in megabytes. Computed as the sum of memory on the zeroed, free, and standby lists for a NUMA node. This counter is available only on 64-bit systems.
  let ``Available MBytes`` instance =
    { category = CategoryName; counter = "Available MBytes"; instance = instance }
  /// Free & Zero Page List MBytes: Approximate amount of physical memory on the free and zero page lists for a NUMA node, in megabytes.
  let ``Free & Zero Page List MBytes`` instance =
    { category = CategoryName; counter = "Free & Zero Page List MBytes"; instance = instance }
  /// Standby List MBytes: Approximate amount of physical memory on the standby page list for a NUMA node, in megabytes. This counter is available only on 64-bit systems.
  let ``Standby List MBytes`` instance =
    { category = CategoryName; counter = "Standby List MBytes"; instance = instance }
  /// Total MBytes: Total amount of physical memory associated with a NUMA node in megabytes.
  let ``Total MBytes`` instance =
    { category = CategoryName; counter = "Total MBytes"; instance = instance }

  let allCounters =
    [| ``Available MBytes``
       ``Free & Zero Page List MBytes``
       ``Standby List MBytes``
       ``Total MBytes``
    |]

/// NVIDIA GPU: NVIDIA GPU performance counters
///
/// This performance counter does not have non-instance based counters
module ``NVIDIA GPU`` =

  [<Literal>]
  let CategoryName = "NVIDIA GPU"

  let PCC = Category.create CategoryName
  /// % Bus Usage: Bus Usage in percents
  let ``% Bus Usage`` instance =
    { category = CategoryName; counter = "% Bus Usage"; instance = instance }
  /// % Cooler rate: GPU Cooler rate in percents
  let ``% Cooler rate`` instance =
    { category = CategoryName; counter = "% Cooler rate"; instance = instance }
  /// % FB Usage: Frame Buffer usage in percents
  let ``% FB Usage`` instance =
    { category = CategoryName; counter = "% FB Usage"; instance = instance }
  /// % GPU Memory Usage: GPU Memory Usage in percents
  let ``% GPU Memory Usage`` instance =
    { category = CategoryName; counter = "% GPU Memory Usage"; instance = instance }
  /// % GPU Usage: GPU Usage in percents
  let ``% GPU Usage`` instance =
    { category = CategoryName; counter = "% GPU Usage"; instance = instance }
  /// % Video Decoder Usage: Video Decoder usage in percents
  let ``% Video Decoder Usage`` instance =
    { category = CategoryName; counter = "% Video Decoder Usage"; instance = instance }
  /// % Video Encoder Usage: Video Encoder usage in percents
  let ``% Video Encoder Usage`` instance =
    { category = CategoryName; counter = "% Video Encoder Usage"; instance = instance }
  /// % Video Usage: Video Usage in percents
  let ``% Video Usage`` instance =
    { category = CategoryName; counter = "% Video Usage"; instance = instance }
  /// Available Memory MB: GPU Available Memory in megabytes (MB)
  let ``Available Memory MB`` instance =
    { category = CategoryName; counter = "Available Memory MB"; instance = instance }
  /// Core Clock MHz: GPU core clock  frequency (MHz)
  let ``Core Clock MHz`` instance =
    { category = CategoryName; counter = "Core Clock MHz"; instance = instance }
  /// Fan Speed: GPU Fan speed rotations per minute (RPM)
  let ``Fan Speed`` instance =
    { category = CategoryName; counter = "Fan Speed"; instance = instance }
  /// Memory Clock MHz: GPU memory clock frequency in megahertz (MHz)
  let ``Memory Clock MHz`` instance =
    { category = CategoryName; counter = "Memory Clock MHz"; instance = instance }
  /// PCI-E current speed to GPU Mbps: Current speed of the PCI-E link to GPU (Mbps)
  let ``PCI-E current speed to GPU Mbps`` instance =
    { category = CategoryName; counter = "PCI-E current speed to GPU Mbps"; instance = instance }
  /// PCI-E current width to GPU: Number of PCI-E lanes in current link to GPU
  let ``PCI-E current width to GPU`` instance =
    { category = CategoryName; counter = "PCI-E current width to GPU"; instance = instance }
  /// PCI-E downstream width to GPU: Number of PCI-E lanes in downstream link to GPU
  let ``PCI-E downstream width to GPU`` instance =
    { category = CategoryName; counter = "PCI-E downstream width to GPU"; instance = instance }
  /// Power Consumption mW: GPU Power consumption per measurement interval in milliWatts (mW)
  let ``Power Consumption mW`` instance =
    { category = CategoryName; counter = "Power Consumption mW"; instance = instance }
  /// Temperature C: GPU Temperature in degrees of Celsius
  let ``Temperature C`` instance =
    { category = CategoryName; counter = "Temperature C"; instance = instance }
  /// Total Memory MB: GPU Total Memory in megabytes (MB)
  let ``Total Memory MB`` instance =
    { category = CategoryName; counter = "Total Memory MB"; instance = instance }
  /// Virtual Memory MB: GPU Virtual Memory in megabytes (MB)
  let ``Virtual Memory MB`` instance =
    { category = CategoryName; counter = "Virtual Memory MB"; instance = instance }

  let allCounters =
    [| ``% Bus Usage``
       ``% Cooler rate``
       ``% FB Usage``
       ``% GPU Memory Usage``
       ``% GPU Usage``
       ``% Video Decoder Usage``
       ``% Video Encoder Usage``
       ``% Video Usage``
       ``Available Memory MB``
       ``Core Clock MHz``
       ``Fan Speed``
       ``Memory Clock MHz``
       ``PCI-E current speed to GPU Mbps``
       ``PCI-E current width to GPU``
       ``PCI-E downstream width to GPU``
       ``Power Consumption mW``
       ``Temperature C``
       ``Total Memory MB``
       ``Virtual Memory MB``
    |]

/// Netlogon: Counters for measuring the performance of Netlogon.
///
/// This performance counter does not have non-instance based counters
module ``Netlogon`` =

  [<Literal>]
  let CategoryName = "Netlogon"

  let PCC = Category.create CategoryName
  /// Average Semaphore Hold Time: The average amount of time the semaphore is held over the last sample.
  let ``Average Semaphore Hold Time`` instance =
    { category = CategoryName; counter = "Average Semaphore Hold Time"; instance = instance }
  /// Semaphore Acquires: The total number of times the semaphore has been acquired over the lifetime of the Secure Channel connection (or since system boot for _Total).
  let ``Semaphore Acquires`` instance =
    { category = CategoryName; counter = "Semaphore Acquires"; instance = instance }
  /// Semaphore Holders: Number of thread currently holding the semaphore.
  let ``Semaphore Holders`` instance =
    { category = CategoryName; counter = "Semaphore Holders"; instance = instance }
  /// Semaphore Timeouts: The total number of times a thread has timed out waiting for the semaphore over the lifetime of the Secure Channel connection (or since system boot for _Total).
  let ``Semaphore Timeouts`` instance =
    { category = CategoryName; counter = "Semaphore Timeouts"; instance = instance }
  /// Semaphore Waiters: Number of thread currently waiting to acquire the semaphore.
  let ``Semaphore Waiters`` instance =
    { category = CategoryName; counter = "Semaphore Waiters"; instance = instance }

  let allCounters =
    [| ``Average Semaphore Hold Time``
       ``Semaphore Acquires``
       ``Semaphore Holders``
       ``Semaphore Timeouts``
       ``Semaphore Waiters``
    |]

/// Network Adapter: The Network Adapter performance object consists of counters that measure the rates at which bytes and packets are sent and received over a physical or virtual network connection.  It includes counters that monitor connection errors.
///
/// This performance counter does not have non-instance based counters
module ``Network Adapter`` =

  [<Literal>]
  let CategoryName = "Network Adapter"

  let PCC = Category.create CategoryName
  /// Bytes Received/sec: Bytes Received/sec is the rate at which bytes are received over each network adapter, including framing characters. Network Interface\Bytes Received/sec is a subset of Network Interface\Bytes Total/sec.
  let ``Bytes Received/sec`` instance =
    { category = CategoryName; counter = "Bytes Received/sec"; instance = instance }
  /// Bytes Sent/sec: Bytes Sent/sec is the rate at which bytes are sent over each network adapter, including framing characters. Network Interface\Bytes Sent/sec is a subset of Network Interface\Bytes Total/sec.
  let ``Bytes Sent/sec`` instance =
    { category = CategoryName; counter = "Bytes Sent/sec"; instance = instance }
  /// Bytes Total/sec: Bytes Total/sec is the rate at which bytes are sent and received over each network adapter, including framing characters. Network Interface\Bytes Total/sec is a sum of Network Interface\Bytes Received/sec and Network Interface\Bytes Sent/sec.
  let ``Bytes Total/sec`` instance =
    { category = CategoryName; counter = "Bytes Total/sec"; instance = instance }
  /// Current Bandwidth: Current Bandwidth is an estimate of the current bandwidth of the network interface in bits per second (BPS).  For interfaces that do not vary in bandwidth or for those where no accurate estimation can be made, this value is the nominal bandwidth.
  let ``Current Bandwidth`` instance =
    { category = CategoryName; counter = "Current Bandwidth"; instance = instance }
  /// Offloaded Connections: Offloaded Connections is the number of TCP connections (over both IPv4 and IPv6) that are currently handled by the TCP chimney offload capable network adapter.
  let ``Offloaded Connections`` instance =
    { category = CategoryName; counter = "Offloaded Connections"; instance = instance }
  /// Output Queue Length: Output Queue Length is the length of the output packet queue (in packets). If this is longer than two, there are delays and the bottleneck should be found and eliminated, if possible. Since the requests are queued by the Network Driver Interface Specification (NDIS) in this implementation, this will always be 0.
  let ``Output Queue Length`` instance =
    { category = CategoryName; counter = "Output Queue Length"; instance = instance }
  /// Packets Outbound Discarded: Packets Outbound Discarded is the number of outbound packets that were chosen to be discarded even though no errors had been detected to prevent transmission. One possible reason for discarding packets could be to free up buffer space.
  let ``Packets Outbound Discarded`` instance =
    { category = CategoryName; counter = "Packets Outbound Discarded"; instance = instance }
  /// Packets Outbound Errors: Packets Outbound Errors is the number of outbound packets that could not be transmitted because of errors.
  let ``Packets Outbound Errors`` instance =
    { category = CategoryName; counter = "Packets Outbound Errors"; instance = instance }
  /// Packets Received Discarded: Packets Received Discarded is the number of inbound packets that were chosen to be discarded even though no errors had been detected to prevent their delivery to a higher-layer protocol.  One possible reason for discarding packets could be to free up buffer space.
  let ``Packets Received Discarded`` instance =
    { category = CategoryName; counter = "Packets Received Discarded"; instance = instance }
  /// Packets Received Errors: Packets Received Errors is the number of inbound packets that contained errors preventing them from being deliverable to a higher-layer protocol.
  let ``Packets Received Errors`` instance =
    { category = CategoryName; counter = "Packets Received Errors"; instance = instance }
  /// Packets Received Non-Unicast/sec: Packets Received Non-Unicast/sec is the rate at which non-unicast (subnet broadcast or subnet multicast) packets are delivered to a higher-layer protocol.
  let ``Packets Received Non-Unicast/sec`` instance =
    { category = CategoryName; counter = "Packets Received Non-Unicast/sec"; instance = instance }
  /// Packets Received Unicast/sec: Packets Received Unicast/sec is the rate at which (subnet) unicast packets are delivered to a higher-layer protocol.
  let ``Packets Received Unicast/sec`` instance =
    { category = CategoryName; counter = "Packets Received Unicast/sec"; instance = instance }
  /// Packets Received Unknown: Packets Received Unknown is the number of packets received through the interface that were discarded because of an unknown or unsupported protocol.
  let ``Packets Received Unknown`` instance =
    { category = CategoryName; counter = "Packets Received Unknown"; instance = instance }
  /// Packets Received/sec: Packets Received/sec is the rate at which packets are received on the network interface.
  let ``Packets Received/sec`` instance =
    { category = CategoryName; counter = "Packets Received/sec"; instance = instance }
  /// Packets Sent Non-Unicast/sec: Packets Sent Non-Unicast/sec is the rate at which packets are requested to be transmitted to non-unicast (subnet broadcast or subnet multicast) addresses by higher-level protocols.  The rate includes the packets that were discarded or not sent.
  let ``Packets Sent Non-Unicast/sec`` instance =
    { category = CategoryName; counter = "Packets Sent Non-Unicast/sec"; instance = instance }
  /// Packets Sent Unicast/sec: Packets Sent Unicast/sec is the rate at which packets are requested to be transmitted to subnet-unicast addresses by higher-level protocols.  The rate includes the packets that were discarded or not sent.
  let ``Packets Sent Unicast/sec`` instance =
    { category = CategoryName; counter = "Packets Sent Unicast/sec"; instance = instance }
  /// Packets Sent/sec: Packets Sent/sec is the rate at which packets are sent on the network interface.
  let ``Packets Sent/sec`` instance =
    { category = CategoryName; counter = "Packets Sent/sec"; instance = instance }
  /// Packets/sec: Packets/sec is the rate at which packets are sent and received on the network interface.
  let ``Packets/sec`` instance =
    { category = CategoryName; counter = "Packets/sec"; instance = instance }
  /// TCP Active RSC Connections: TCP Active RSC Connections is the number of TCP connections (over both IPv4 and IPv6) that are currently receiving large packets from the RSC capable network adapter on this network interface.
  let ``TCP Active RSC Connections`` instance =
    { category = CategoryName; counter = "TCP Active RSC Connections"; instance = instance }
  /// TCP RSC Average Packet Size: TCP RSC Average Packet Size is the average size in bytes of received packets across all TCP connections on this network interface.
  let ``TCP RSC Average Packet Size`` instance =
    { category = CategoryName; counter = "TCP RSC Average Packet Size"; instance = instance }
  /// TCP RSC Coalesced Packets/sec: TCP RSC Coalesced Packets/sec shows the large packet receive rate across all TCP connections on this network interface.
  let ``TCP RSC Coalesced Packets/sec`` instance =
    { category = CategoryName; counter = "TCP RSC Coalesced Packets/sec"; instance = instance }
  /// TCP RSC Exceptions/sec: TCP RSC Exceptions/sec shows the RSC exception rate for receive packets across all TCP connections on this network interface.
  let ``TCP RSC Exceptions/sec`` instance =
    { category = CategoryName; counter = "TCP RSC Exceptions/sec"; instance = instance }

  let allCounters =
    [| ``Bytes Received/sec``
       ``Bytes Sent/sec``
       ``Bytes Total/sec``
       ``Current Bandwidth``
       ``Offloaded Connections``
       ``Output Queue Length``
       ``Packets Outbound Discarded``
       ``Packets Outbound Errors``
       ``Packets Received Discarded``
       ``Packets Received Errors``
       ``Packets Received Non-Unicast/sec``
       ``Packets Received Unicast/sec``
       ``Packets Received Unknown``
       ``Packets Received/sec``
       ``Packets Sent Non-Unicast/sec``
       ``Packets Sent Unicast/sec``
       ``Packets Sent/sec``
       ``Packets/sec``
       ``TCP Active RSC Connections``
       ``TCP RSC Average Packet Size``
       ``TCP RSC Coalesced Packets/sec``
       ``TCP RSC Exceptions/sec``
    |]

/// Network Interface: The Network Interface performance object consists of counters that measure the rates at which bytes and packets are sent and received over a network connection.  It includes counters that monitor connection errors.
///
/// This performance counter does not have non-instance based counters
module ``Network Interface`` =

  [<Literal>]
  let CategoryName = "Network Interface"

  let PCC = Category.create CategoryName
  /// Bytes Received/sec: Bytes Received/sec is the rate at which bytes are received over each network adapter, including framing characters. Network Interface\Bytes Received/sec is a subset of Network Interface\Bytes Total/sec.
  let ``Bytes Received/sec`` instance =
    { category = CategoryName; counter = "Bytes Received/sec"; instance = instance }
  /// Bytes Sent/sec: Bytes Sent/sec is the rate at which bytes are sent over each network adapter, including framing characters. Network Interface\Bytes Sent/sec is a subset of Network Interface\Bytes Total/sec.
  let ``Bytes Sent/sec`` instance =
    { category = CategoryName; counter = "Bytes Sent/sec"; instance = instance }
  /// Bytes Total/sec: Bytes Total/sec is the rate at which bytes are sent and received over each network adapter, including framing characters. Network Interface\Bytes Total/sec is a sum of Network Interface\Bytes Received/sec and Network Interface\Bytes Sent/sec.
  let ``Bytes Total/sec`` instance =
    { category = CategoryName; counter = "Bytes Total/sec"; instance = instance }
  /// Current Bandwidth: Current Bandwidth is an estimate of the current bandwidth of the network interface in bits per second (BPS).  For interfaces that do not vary in bandwidth or for those where no accurate estimation can be made, this value is the nominal bandwidth.
  let ``Current Bandwidth`` instance =
    { category = CategoryName; counter = "Current Bandwidth"; instance = instance }
  /// Offloaded Connections: Offloaded Connections is the number of TCP connections (over both IPv4 and IPv6) that are currently handled by the TCP chimney offload capable network adapter.
  let ``Offloaded Connections`` instance =
    { category = CategoryName; counter = "Offloaded Connections"; instance = instance }
  /// Output Queue Length: Output Queue Length is the length of the output packet queue (in packets). If this is longer than two, there are delays and the bottleneck should be found and eliminated, if possible. Since the requests are queued by the Network Driver Interface Specification (NDIS) in this implementation, this will always be 0.
  let ``Output Queue Length`` instance =
    { category = CategoryName; counter = "Output Queue Length"; instance = instance }
  /// Packets Outbound Discarded: Packets Outbound Discarded is the number of outbound packets that were chosen to be discarded even though no errors had been detected to prevent transmission. One possible reason for discarding packets could be to free up buffer space.
  let ``Packets Outbound Discarded`` instance =
    { category = CategoryName; counter = "Packets Outbound Discarded"; instance = instance }
  /// Packets Outbound Errors: Packets Outbound Errors is the number of outbound packets that could not be transmitted because of errors.
  let ``Packets Outbound Errors`` instance =
    { category = CategoryName; counter = "Packets Outbound Errors"; instance = instance }
  /// Packets Received Discarded: Packets Received Discarded is the number of inbound packets that were chosen to be discarded even though no errors had been detected to prevent their delivery to a higher-layer protocol.  One possible reason for discarding packets could be to free up buffer space.
  let ``Packets Received Discarded`` instance =
    { category = CategoryName; counter = "Packets Received Discarded"; instance = instance }
  /// Packets Received Errors: Packets Received Errors is the number of inbound packets that contained errors preventing them from being deliverable to a higher-layer protocol.
  let ``Packets Received Errors`` instance =
    { category = CategoryName; counter = "Packets Received Errors"; instance = instance }
  /// Packets Received Non-Unicast/sec: Packets Received Non-Unicast/sec is the rate at which non-unicast (subnet broadcast or subnet multicast) packets are delivered to a higher-layer protocol.
  let ``Packets Received Non-Unicast/sec`` instance =
    { category = CategoryName; counter = "Packets Received Non-Unicast/sec"; instance = instance }
  /// Packets Received Unicast/sec: Packets Received Unicast/sec is the rate at which (subnet) unicast packets are delivered to a higher-layer protocol.
  let ``Packets Received Unicast/sec`` instance =
    { category = CategoryName; counter = "Packets Received Unicast/sec"; instance = instance }
  /// Packets Received Unknown: Packets Received Unknown is the number of packets received through the interface that were discarded because of an unknown or unsupported protocol.
  let ``Packets Received Unknown`` instance =
    { category = CategoryName; counter = "Packets Received Unknown"; instance = instance }
  /// Packets Received/sec: Packets Received/sec is the rate at which packets are received on the network interface.
  let ``Packets Received/sec`` instance =
    { category = CategoryName; counter = "Packets Received/sec"; instance = instance }
  /// Packets Sent Non-Unicast/sec: Packets Sent Non-Unicast/sec is the rate at which packets are requested to be transmitted to non-unicast (subnet broadcast or subnet multicast) addresses by higher-level protocols.  The rate includes the packets that were discarded or not sent.
  let ``Packets Sent Non-Unicast/sec`` instance =
    { category = CategoryName; counter = "Packets Sent Non-Unicast/sec"; instance = instance }
  /// Packets Sent Unicast/sec: Packets Sent Unicast/sec is the rate at which packets are requested to be transmitted to subnet-unicast addresses by higher-level protocols.  The rate includes the packets that were discarded or not sent.
  let ``Packets Sent Unicast/sec`` instance =
    { category = CategoryName; counter = "Packets Sent Unicast/sec"; instance = instance }
  /// Packets Sent/sec: Packets Sent/sec is the rate at which packets are sent on the network interface.
  let ``Packets Sent/sec`` instance =
    { category = CategoryName; counter = "Packets Sent/sec"; instance = instance }
  /// Packets/sec: Packets/sec is the rate at which packets are sent and received on the network interface.
  let ``Packets/sec`` instance =
    { category = CategoryName; counter = "Packets/sec"; instance = instance }
  /// TCP Active RSC Connections: TCP Active RSC Connections is the number of TCP connections (over both IPv4 and IPv6) that are currently receiving large packets from the RSC capable network adapter on this network interface.
  let ``TCP Active RSC Connections`` instance =
    { category = CategoryName; counter = "TCP Active RSC Connections"; instance = instance }
  /// TCP RSC Average Packet Size: TCP RSC Average Packet Size is the average size in bytes of received packets across all TCP connections on this network interface.
  let ``TCP RSC Average Packet Size`` instance =
    { category = CategoryName; counter = "TCP RSC Average Packet Size"; instance = instance }
  /// TCP RSC Coalesced Packets/sec: TCP RSC Coalesced Packets/sec shows the large packet receive rate across all TCP connections on this network interface.
  let ``TCP RSC Coalesced Packets/sec`` instance =
    { category = CategoryName; counter = "TCP RSC Coalesced Packets/sec"; instance = instance }
  /// TCP RSC Exceptions/sec: TCP RSC Exceptions/sec shows the RSC exception rate for receive packets across all TCP connections on this network interface.
  let ``TCP RSC Exceptions/sec`` instance =
    { category = CategoryName; counter = "TCP RSC Exceptions/sec"; instance = instance }

  let allCounters =
    [| ``Bytes Received/sec``
       ``Bytes Sent/sec``
       ``Bytes Total/sec``
       ``Current Bandwidth``
       ``Offloaded Connections``
       ``Output Queue Length``
       ``Packets Outbound Discarded``
       ``Packets Outbound Errors``
       ``Packets Received Discarded``
       ``Packets Received Errors``
       ``Packets Received Non-Unicast/sec``
       ``Packets Received Unicast/sec``
       ``Packets Received Unknown``
       ``Packets Received/sec``
       ``Packets Sent Non-Unicast/sec``
       ``Packets Sent Unicast/sec``
       ``Packets Sent/sec``
       ``Packets/sec``
       ``TCP Active RSC Connections``
       ``TCP RSC Average Packet Size``
       ``TCP RSC Coalesced Packets/sec``
       ``TCP RSC Exceptions/sec``
    |]

/// Network QoS Policy: This counter set consists of flow statistics specific to a network QoS policy.
///
/// This performance counter does not have instance based counters
module ``Network QoS Policy`` =

  [<Literal>]
  let CategoryName = "Network QoS Policy"

  let PCC = Category.create CategoryName
  /// Bytes transmitted: -
  let ``Bytes transmitted`` instance =
    { category = CategoryName; counter = "Bytes transmitted"; instance = instance }
  /// Bytes transmitted/sec: -
  let ``Bytes transmitted/sec`` instance =
    { category = CategoryName; counter = "Bytes transmitted/sec"; instance = instance }
  /// Packets dropped: -
  let ``Packets dropped`` instance =
    { category = CategoryName; counter = "Packets dropped"; instance = instance }
  /// Packets dropped/sec: -
  let ``Packets dropped/sec`` instance =
    { category = CategoryName; counter = "Packets dropped/sec"; instance = instance }
  /// Packets transmitted: -
  let ``Packets transmitted`` instance =
    { category = CategoryName; counter = "Packets transmitted"; instance = instance }
  /// Packets transmitted/sec: -
  let ``Packets transmitted/sec`` instance =
    { category = CategoryName; counter = "Packets transmitted/sec"; instance = instance }

  let allCounters =
    [| ``Bytes transmitted``
       ``Bytes transmitted/sec``
       ``Packets dropped``
       ``Packets dropped/sec``
       ``Packets transmitted``
       ``Packets transmitted/sec``
    |]

/// Network Virtualization: Network Virtualization counter set measures network activity for packets matching network virtualization policies.
///
/// This performance counter does not have non-instance based counters
module ``Network Virtualization`` =

  [<Literal>]
  let CategoryName = "Network Virtualization"

  let PCC = Category.create CategoryName
  /// Broadcast packets received: Number of broadcast packets received.
  let ``Broadcast packets received`` instance =
    { category = CategoryName; counter = "Broadcast packets received"; instance = instance }
  /// Broadcast packets sent: Number of broadcast packets sent.
  let ``Broadcast packets sent`` instance =
    { category = CategoryName; counter = "Broadcast packets sent"; instance = instance }
  /// Inbound Packets dropped: Number of Inbound packets dropped.
  let ``Inbound Packets dropped`` instance =
    { category = CategoryName; counter = "Inbound Packets dropped"; instance = instance }
  /// Missing policy icmp errors received: Number of missing policy ICMP errors received.
  let ``Missing policy icmp errors received`` instance =
    { category = CategoryName; counter = "Missing policy icmp errors received"; instance = instance }
  /// Missing policy icmp errors sent: Number of missing policy ICMP errors sent.
  let ``Missing policy icmp errors sent`` instance =
    { category = CategoryName; counter = "Missing policy icmp errors sent"; instance = instance }
  /// Missing policy notifications dropped: Number of missing policy notifications dropped.
  let ``Missing policy notifications dropped`` instance =
    { category = CategoryName; counter = "Missing policy notifications dropped"; instance = instance }
  /// Missing policy notifications indicated: Number of missing policy notifications indicated.
  let ``Missing policy notifications indicated`` instance =
    { category = CategoryName; counter = "Missing policy notifications indicated"; instance = instance }
  /// Multicast packets received: Number of multicast packets received.
  let ``Multicast packets received`` instance =
    { category = CategoryName; counter = "Multicast packets received"; instance = instance }
  /// Multicast packets sent: Number of multicast packets sent.
  let ``Multicast packets sent`` instance =
    { category = CategoryName; counter = "Multicast packets sent"; instance = instance }
  /// Outbound Packets dropped: Number of outbound packets dropped.
  let ``Outbound Packets dropped`` instance =
    { category = CategoryName; counter = "Outbound Packets dropped"; instance = instance }
  /// Packets buffered: Number of packets buffered waiting for missing lookup records.
  let ``Packets buffered`` instance =
    { category = CategoryName; counter = "Packets buffered"; instance = instance }
  /// Packets forwarded: Number of packets forwarded between virtual subnets on different hosts.
  let ``Packets forwarded`` instance =
    { category = CategoryName; counter = "Packets forwarded"; instance = instance }
  /// Packets looped back: Number of packets forwarded between virtual subnets on the local host.
  let ``Packets looped back`` instance =
    { category = CategoryName; counter = "Packets looped back"; instance = instance }
  /// Policy cache hits: Number of cache hits during policy lookup.
  let ``Policy cache hits`` instance =
    { category = CategoryName; counter = "Policy cache hits"; instance = instance }
  /// Policy cache misses: Number of cache misses during policy lookup.
  let ``Policy cache misses`` instance =
    { category = CategoryName; counter = "Policy cache misses"; instance = instance }
  /// Policy lookup failures: Number of failures during policy lookup.
  let ``Policy lookup failures`` instance =
    { category = CategoryName; counter = "Policy lookup failures"; instance = instance }
  /// Provider address duplicate detection failures: Number of provider address duplicate detection failures.
  let ``Provider address duplicate detection failures`` instance =
    { category = CategoryName; counter = "Provider address duplicate detection failures"; instance = instance }
  /// Unicast Replicated Packets out: Number of Unicast Replicated packets sent.
  let ``Unicast Replicated Packets out`` instance =
    { category = CategoryName; counter = "Unicast Replicated Packets out"; instance = instance }
  /// Unicast packets received (GRE): Number of unicast packets received with GRE encapsulation.
  let ``Unicast packets received (GRE)`` instance =
    { category = CategoryName; counter = "Unicast packets received (GRE)"; instance = instance }
  /// Unicast packets sent (GRE): Number of unicast packets sent with GRE encapsulation.
  let ``Unicast packets sent (GRE)`` instance =
    { category = CategoryName; counter = "Unicast packets sent (GRE)"; instance = instance }

  let allCounters =
    [| ``Broadcast packets received``
       ``Broadcast packets sent``
       ``Inbound Packets dropped``
       ``Missing policy icmp errors received``
       ``Missing policy icmp errors sent``
       ``Missing policy notifications dropped``
       ``Missing policy notifications indicated``
       ``Multicast packets received``
       ``Multicast packets sent``
       ``Outbound Packets dropped``
       ``Packets buffered``
       ``Packets forwarded``
       ``Packets looped back``
       ``Policy cache hits``
       ``Policy cache misses``
       ``Policy lookup failures``
       ``Provider address duplicate detection failures``
       ``Unicast Replicated Packets out``
       ``Unicast packets received (GRE)``
       ``Unicast packets sent (GRE)``
    |]

/// Objects: The Object performance object consists of counters that monitor  logical objects in the system, such as processes, threads, mutexes, and semaphores.  This information can be used to detect the unnecessary consumption of computer resources.  Each object requires memory to store basic information about the object.
///
/// This performance counter does not have instance based counters
module ``Objects`` =

  [<Literal>]
  let CategoryName = "Objects"

  let PCC = Category.create CategoryName
  /// Events: Events is the number of events in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  An event is used when two or more threads try to synchronize execution.
  let ``Events`` =
    { category = CategoryName; counter = "Events"; instance = None }
  /// Mutexes: Mutexes counts the number of mutexes in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  Mutexes are used by threads to assure only one thread is executing a particular section of code.
  let ``Mutexes`` =
    { category = CategoryName; counter = "Mutexes"; instance = None }
  /// Processes: Processes is the number of processes in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  Each process represents the running of a program.
  let ``Processes`` =
    { category = CategoryName; counter = "Processes"; instance = None }
  /// Sections: Sections is the number of sections in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  A section is a portion of virtual memory created by a process for storing data. A process can share sections with other processes.
  let ``Sections`` =
    { category = CategoryName; counter = "Sections"; instance = None }
  /// Semaphores: Semaphores is the number of semaphores in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  Threads use semaphores to obtain exclusive access to data structures that they share with other threads.
  let ``Semaphores`` =
    { category = CategoryName; counter = "Semaphores"; instance = None }
  /// Threads: Threads is the number of threads in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  A thread is the basic executable entity that can execute instructions in a processor.
  let ``Threads`` =
    { category = CategoryName; counter = "Threads"; instance = None }

  let allCounters =
    [| ``Events``
       ``Mutexes``
       ``Processes``
       ``Sections``
       ``Semaphores``
       ``Threads``
    |]

/// Offline Files: Performance counters for Offline Files
///
/// This performance counter does not have instance based counters
module ``Offline Files`` =

  [<Literal>]
  let CategoryName = "Offline Files"

  let PCC = Category.create CategoryName
  /// Bytes Received: Bytes synchronized from server to client
  let ``Bytes Received`` =
    { category = CategoryName; counter = "Bytes Received"; instance = None }
  /// Bytes Received/sec: Bytes synchronized per second, server to client
  let ``Bytes Received/sec`` =
    { category = CategoryName; counter = "Bytes Received/sec"; instance = None }
  /// Bytes Transmitted: Bytes synchronized from client to server
  let ``Bytes Transmitted`` =
    { category = CategoryName; counter = "Bytes Transmitted"; instance = None }
  /// Bytes Transmitted/sec: Bytes synchronized per second, client to server
  let ``Bytes Transmitted/sec`` =
    { category = CategoryName; counter = "Bytes Transmitted/sec"; instance = None }

  let allCounters =
    [| ``Bytes Received``
       ``Bytes Received/sec``
       ``Bytes Transmitted``
       ``Bytes Transmitted/sec``
    |]

/// Pacer Flow: The Pacer Flow performance counter set consists of flow statistics from the packet scheduler.
///
/// This performance counter does not have instance based counters
module ``Pacer Flow`` =

  [<Literal>]
  let CategoryName = "Pacer Flow"

  let PCC = Category.create CategoryName
  /// Average packets in netcard: -
  let ``Average packets in netcard`` instance =
    { category = CategoryName; counter = "Average packets in netcard"; instance = instance }
  /// Average packets in sequencer: -
  let ``Average packets in sequencer`` instance =
    { category = CategoryName; counter = "Average packets in sequencer"; instance = instance }
  /// Average packets in shaper: -
  let ``Average packets in shaper`` instance =
    { category = CategoryName; counter = "Average packets in shaper"; instance = instance }
  /// Bytes scheduled: -
  let ``Bytes scheduled`` instance =
    { category = CategoryName; counter = "Bytes scheduled"; instance = instance }
  /// Bytes scheduled/sec: -
  let ``Bytes scheduled/sec`` instance =
    { category = CategoryName; counter = "Bytes scheduled/sec"; instance = instance }
  /// Bytes transmitted: -
  let ``Bytes transmitted`` instance =
    { category = CategoryName; counter = "Bytes transmitted"; instance = instance }
  /// Bytes transmitted/sec: -
  let ``Bytes transmitted/sec`` instance =
    { category = CategoryName; counter = "Bytes transmitted/sec"; instance = instance }
  /// Max packets in sequencer: -
  let ``Max packets in sequencer`` instance =
    { category = CategoryName; counter = "Max packets in sequencer"; instance = instance }
  /// Max packets in shaper: -
  let ``Max packets in shaper`` instance =
    { category = CategoryName; counter = "Max packets in shaper"; instance = instance }
  /// Maximum packets in netcard: -
  let ``Maximum packets in netcard`` instance =
    { category = CategoryName; counter = "Maximum packets in netcard"; instance = instance }
  /// Nonconforming packets scheduled: -
  let ``Nonconforming packets scheduled`` instance =
    { category = CategoryName; counter = "Nonconforming packets scheduled"; instance = instance }
  /// Nonconforming packets scheduled/sec: -
  let ``Nonconforming packets scheduled/sec`` instance =
    { category = CategoryName; counter = "Nonconforming packets scheduled/sec"; instance = instance }
  /// Nonconforming packets transmitted: -
  let ``Nonconforming packets transmitted`` instance =
    { category = CategoryName; counter = "Nonconforming packets transmitted"; instance = instance }
  /// Nonconforming packets transmitted/sec: -
  let ``Nonconforming packets transmitted/sec`` instance =
    { category = CategoryName; counter = "Nonconforming packets transmitted/sec"; instance = instance }
  /// Packets dropped: -
  let ``Packets dropped`` instance =
    { category = CategoryName; counter = "Packets dropped"; instance = instance }
  /// Packets dropped/sec: -
  let ``Packets dropped/sec`` instance =
    { category = CategoryName; counter = "Packets dropped/sec"; instance = instance }
  /// Packets scheduled: -
  let ``Packets scheduled`` instance =
    { category = CategoryName; counter = "Packets scheduled"; instance = instance }
  /// Packets scheduled/sec: -
  let ``Packets scheduled/sec`` instance =
    { category = CategoryName; counter = "Packets scheduled/sec"; instance = instance }
  /// Packets transmitted: -
  let ``Packets transmitted`` instance =
    { category = CategoryName; counter = "Packets transmitted"; instance = instance }
  /// Packets transmitted/sec: -
  let ``Packets transmitted/sec`` instance =
    { category = CategoryName; counter = "Packets transmitted/sec"; instance = instance }

  let allCounters =
    [| ``Average packets in netcard``
       ``Average packets in sequencer``
       ``Average packets in shaper``
       ``Bytes scheduled``
       ``Bytes scheduled/sec``
       ``Bytes transmitted``
       ``Bytes transmitted/sec``
       ``Max packets in sequencer``
       ``Max packets in shaper``
       ``Maximum packets in netcard``
       ``Nonconforming packets scheduled``
       ``Nonconforming packets scheduled/sec``
       ``Nonconforming packets transmitted``
       ``Nonconforming packets transmitted/sec``
       ``Packets dropped``
       ``Packets dropped/sec``
       ``Packets scheduled``
       ``Packets scheduled/sec``
       ``Packets transmitted``
       ``Packets transmitted/sec``
    |]

/// Pacer Pipe: The Pacer Pipe performance counter set consists of pipe statistics from the packet scheduler.
///
/// This performance counter does not have non-instance based counters
module ``Pacer Pipe`` =

  [<Literal>]
  let CategoryName = "Pacer Pipe"

  let PCC = Category.create CategoryName
  /// Average packets in netcard: The average number of packets in the network card over the last sampling period.
  let ``Average packets in netcard`` instance =
    { category = CategoryName; counter = "Average packets in netcard"; instance = instance }
  /// Average packets in sequencer: The average number of packets in the sequencer over the last sampling period.
  let ``Average packets in sequencer`` instance =
    { category = CategoryName; counter = "Average packets in sequencer"; instance = instance }
  /// Average packets in shaper: The average number of packets in the shaper over the last sampling period.
  let ``Average packets in shaper`` instance =
    { category = CategoryName; counter = "Average packets in shaper"; instance = instance }
  /// Flow mods rejected: The number of times a flow modification has been rejected.
  let ``Flow mods rejected`` instance =
    { category = CategoryName; counter = "Flow mods rejected"; instance = instance }
  /// Flows closed: The number of flows that have been closed.
  let ``Flows closed`` instance =
    { category = CategoryName; counter = "Flows closed"; instance = instance }
  /// Flows modified: The number of times a flow has been modified.
  let ``Flows modified`` instance =
    { category = CategoryName; counter = "Flows modified"; instance = instance }
  /// Flows opened: The number of flows opened on this pipe (some of which may now be closed).
  let ``Flows opened`` instance =
    { category = CategoryName; counter = "Flows opened"; instance = instance }
  /// Flows rejected: The number of flow creations that were rejected.
  let ``Flows rejected`` instance =
    { category = CategoryName; counter = "Flows rejected"; instance = instance }
  /// Max packets in netcard: The maximum number of packets ever simultaneously in the network card.
  let ``Max packets in netcard`` instance =
    { category = CategoryName; counter = "Max packets in netcard"; instance = instance }
  /// Max packets in sequencer: The maximum number of packets that have ever simultaneously been in the sequencer.
  let ``Max packets in sequencer`` instance =
    { category = CategoryName; counter = "Max packets in sequencer"; instance = instance }
  /// Max packets in shaper: The maximum number of packets that have ever simultaneously been in the shaper.
  let ``Max packets in shaper`` instance =
    { category = CategoryName; counter = "Max packets in shaper"; instance = instance }
  /// Max simultaneous flows: The maximum number of flows that have been simultaneously open on this pipe.
  let ``Max simultaneous flows`` instance =
    { category = CategoryName; counter = "Max simultaneous flows"; instance = instance }
  /// Nonconforming packets scheduled: The number of packets that have entered the packet scheduler at a rate which exceeded that packet's flow parameters.
  let ``Nonconforming packets scheduled`` instance =
    { category = CategoryName; counter = "Nonconforming packets scheduled"; instance = instance }
  /// Nonconforming packets scheduled/sec: The rate at which nonconforming packets have entered the packet scheduler.
  let ``Nonconforming packets scheduled/sec`` instance =
    { category = CategoryName; counter = "Nonconforming packets scheduled/sec"; instance = instance }
  /// Nonconforming packets transmitted: The number of packets that have been sent by the packet scheduler at a rate which exceeded that packet's flow parameters.
  let ``Nonconforming packets transmitted`` instance =
    { category = CategoryName; counter = "Nonconforming packets transmitted"; instance = instance }
  /// Nonconforming packets transmitted/sec: The rate at which nonconforming packets have been sent by the packet scheduler.
  let ``Nonconforming packets transmitted/sec`` instance =
    { category = CategoryName; counter = "Nonconforming packets transmitted/sec"; instance = instance }
  /// Out of packets: The number of times Pacer has been unable to allocate a packet.
  let ``Out of packets`` instance =
    { category = CategoryName; counter = "Out of packets"; instance = instance }

  let allCounters =
    [| ``Average packets in netcard``
       ``Average packets in sequencer``
       ``Average packets in shaper``
       ``Flow mods rejected``
       ``Flows closed``
       ``Flows modified``
       ``Flows opened``
       ``Flows rejected``
       ``Max packets in netcard``
       ``Max packets in sequencer``
       ``Max packets in shaper``
       ``Max simultaneous flows``
       ``Nonconforming packets scheduled``
       ``Nonconforming packets scheduled/sec``
       ``Nonconforming packets transmitted``
       ``Nonconforming packets transmitted/sec``
       ``Out of packets``
    |]

/// PacketDirect EC Utilization: NDIS PacketDirect execution context utilization counter set.
///
/// This performance counter does not have instance based counters
module ``PacketDirect EC Utilization`` =

  [<Literal>]
  let CategoryName = "PacketDirect EC Utilization"

  let PCC = Category.create CategoryName
  /// % Busy Wait Iterations: -
  let ``% Busy Wait Iterations`` instance =
    { category = CategoryName; counter = "% Busy Wait Iterations"; instance = instance }
  /// % Busy Waiting Time: -
  let ``% Busy Waiting Time`` instance =
    { category = CategoryName; counter = "% Busy Waiting Time"; instance = instance }
  /// % Idle Time: -
  let ``% Idle Time`` instance =
    { category = CategoryName; counter = "% Idle Time"; instance = instance }
  /// % Processing Time: -
  let ``% Processing Time`` instance =
    { category = CategoryName; counter = "% Processing Time"; instance = instance }
  /// Busy Wait Iterations/sec: -
  let ``Busy Wait Iterations/sec`` instance =
    { category = CategoryName; counter = "Busy Wait Iterations/sec"; instance = instance }
  /// Iterations/sec: -
  let ``Iterations/sec`` instance =
    { category = CategoryName; counter = "Iterations/sec"; instance = instance }
  /// Processor Number: -
  let ``Processor Number`` instance =
    { category = CategoryName; counter = "Processor Number"; instance = instance }
  /// RX Queue Count: -
  let ``RX Queue Count`` instance =
    { category = CategoryName; counter = "RX Queue Count"; instance = instance }
  /// TX Queue Count: -
  let ``TX Queue Count`` instance =
    { category = CategoryName; counter = "TX Queue Count"; instance = instance }
  /// Total Busy Wait Iterations: -
  let ``Total Busy Wait Iterations`` instance =
    { category = CategoryName; counter = "Total Busy Wait Iterations"; instance = instance }
  /// Total Iterations: -
  let ``Total Iterations`` instance =
    { category = CategoryName; counter = "Total Iterations"; instance = instance }

  let allCounters =
    [| ``% Busy Wait Iterations``
       ``% Busy Waiting Time``
       ``% Idle Time``
       ``% Processing Time``
       ``Busy Wait Iterations/sec``
       ``Iterations/sec``
       ``Processor Number``
       ``RX Queue Count``
       ``TX Queue Count``
       ``Total Busy Wait Iterations``
       ``Total Iterations``
    |]

/// PacketDirect Queue Depth: NDIS PacketDirect queue depth counter set.
///
/// This performance counter does not have instance based counters
module ``PacketDirect Queue Depth`` =

  [<Literal>]
  let CategoryName = "PacketDirect Queue Depth"

  let PCC = Category.create CategoryName
  /// % Average Queue Utilization: -
  let ``% Average Queue Utilization`` instance =
    { category = CategoryName; counter = "% Average Queue Utilization"; instance = instance }
  /// Average Queue Depth: -
  let ``Average Queue Depth`` instance =
    { category = CategoryName; counter = "Average Queue Depth"; instance = instance }

  let allCounters =
    [| ``% Average Queue Utilization``
       ``Average Queue Depth``
    |]

/// PacketDirect Receive Counters: NDIS PacketDirect receive counter set.
///
/// This performance counter does not have instance based counters
module ``PacketDirect Receive Counters`` =

  [<Literal>]
  let CategoryName = "PacketDirect Receive Counters"

  let PCC = Category.create CategoryName
  /// Bytes Received: -
  let ``Bytes Received`` instance =
    { category = CategoryName; counter = "Bytes Received"; instance = instance }
  /// Bytes Received/sec: -
  let ``Bytes Received/sec`` instance =
    { category = CategoryName; counter = "Bytes Received/sec"; instance = instance }
  /// Packets Dropped: -
  let ``Packets Dropped`` instance =
    { category = CategoryName; counter = "Packets Dropped"; instance = instance }
  /// Packets Dropped/sec: -
  let ``Packets Dropped/sec`` instance =
    { category = CategoryName; counter = "Packets Dropped/sec"; instance = instance }
  /// Packets Received: -
  let ``Packets Received`` instance =
    { category = CategoryName; counter = "Packets Received"; instance = instance }
  /// Packets Received/sec: -
  let ``Packets Received/sec`` instance =
    { category = CategoryName; counter = "Packets Received/sec"; instance = instance }

  let allCounters =
    [| ``Bytes Received``
       ``Bytes Received/sec``
       ``Packets Dropped``
       ``Packets Dropped/sec``
       ``Packets Received``
       ``Packets Received/sec``
    |]

/// PacketDirect Receive Filters: NDIS PacketDirect receive filter counter set.
///
/// This performance counter does not have instance based counters
module ``PacketDirect Receive Filters`` =

  [<Literal>]
  let CategoryName = "PacketDirect Receive Filters"

  let PCC = Category.create CategoryName
  /// Bytes Matched: -
  let ``Bytes Matched`` instance =
    { category = CategoryName; counter = "Bytes Matched"; instance = instance }
  /// Bytes Matched/sec: -
  let ``Bytes Matched/sec`` instance =
    { category = CategoryName; counter = "Bytes Matched/sec"; instance = instance }
  /// Packets Matched: -
  let ``Packets Matched`` instance =
    { category = CategoryName; counter = "Packets Matched"; instance = instance }
  /// Packets Matched/sec: -
  let ``Packets Matched/sec`` instance =
    { category = CategoryName; counter = "Packets Matched/sec"; instance = instance }

  let allCounters =
    [| ``Bytes Matched``
       ``Bytes Matched/sec``
       ``Packets Matched``
       ``Packets Matched/sec``
    |]

/// PacketDirect Transmit Counters: NDIS PacketDirect transmit counter set.
///
/// This performance counter does not have instance based counters
module ``PacketDirect Transmit Counters`` =

  [<Literal>]
  let CategoryName = "PacketDirect Transmit Counters"

  let PCC = Category.create CategoryName
  /// Bytes Transmitted: -
  let ``Bytes Transmitted`` instance =
    { category = CategoryName; counter = "Bytes Transmitted"; instance = instance }
  /// Bytes Transmitted/sec: -
  let ``Bytes Transmitted/sec`` instance =
    { category = CategoryName; counter = "Bytes Transmitted/sec"; instance = instance }
  /// Packets Transmitted: -
  let ``Packets Transmitted`` instance =
    { category = CategoryName; counter = "Packets Transmitted"; instance = instance }
  /// Packets Transmitted/sec: -
  let ``Packets Transmitted/sec`` instance =
    { category = CategoryName; counter = "Packets Transmitted/sec"; instance = instance }

  let allCounters =
    [| ``Bytes Transmitted``
       ``Bytes Transmitted/sec``
       ``Packets Transmitted``
       ``Packets Transmitted/sec``
    |]

/// Paging File: The Paging File performance object consists of counters that monitor the paging file(s) on the computer.  The paging file is a reserved space on disk that backs up committed physical memory on the computer.
///
/// This performance counter does not have non-instance based counters
module ``Paging File`` =

  [<Literal>]
  let CategoryName = "Paging File"

  let PCC = Category.create CategoryName
  /// % Usage: The amount of the Page File instance in use in percent.  See also Process\\Page File Bytes.
  let ``% Usage`` instance =
    { category = CategoryName; counter = "% Usage"; instance = instance }
  /// % Usage Peak: The peak usage of the Page File instance in percent.  See also Process\\Page File Bytes Peak.
  let ``% Usage Peak`` instance =
    { category = CategoryName; counter = "% Usage Peak"; instance = instance }

  let allCounters =
    [| ``% Usage``
       ``% Usage Peak``
    |]

/// Peer Name Resolution Protocol: The Peer Name Resolution Protocol (PNRP) performance object consists of counters that monitor each of available PNRP clouds.  These counters monitor the local PNRP cache and measure the rates at which PNRP protocol messages are sent and received.
///
/// This performance counter does not have instance based counters
module ``Peer Name Resolution Protocol`` =

  [<Literal>]
  let CategoryName = "Peer Name Resolution Protocol"

  let PCC = Category.create CategoryName
  /// Ack received per second: -
  let ``Ack received per second`` instance =
    { category = CategoryName; counter = "Ack received per second"; instance = instance }
  /// Ack sent per second: -
  let ``Ack sent per second`` instance =
    { category = CategoryName; counter = "Ack sent per second"; instance = instance }
  /// Advertise received per second: -
  let ``Advertise received per second`` instance =
    { category = CategoryName; counter = "Advertise received per second"; instance = instance }
  /// Advertise sent per second: -
  let ``Advertise sent per second`` instance =
    { category = CategoryName; counter = "Advertise sent per second"; instance = instance }
  /// Authority received per second: -
  let ``Authority received per second`` instance =
    { category = CategoryName; counter = "Authority received per second"; instance = instance }
  /// Authority sent per second: -
  let ``Authority sent per second`` instance =
    { category = CategoryName; counter = "Authority sent per second"; instance = instance }
  /// Average bytes received: -
  let ``Average bytes received`` instance =
    { category = CategoryName; counter = "Average bytes received"; instance = instance }
  /// Average bytes sent: -
  let ``Average bytes sent`` instance =
    { category = CategoryName; counter = "Average bytes sent"; instance = instance }
  /// Cache Entry: -
  let ``Cache Entry`` instance =
    { category = CategoryName; counter = "Cache Entry"; instance = instance }
  /// Estimated cloud size: -
  let ``Estimated cloud size`` instance =
    { category = CategoryName; counter = "Estimated cloud size"; instance = instance }
  /// Flood received per second: -
  let ``Flood received per second`` instance =
    { category = CategoryName; counter = "Flood received per second"; instance = instance }
  /// Flood sent per second: -
  let ``Flood sent per second`` instance =
    { category = CategoryName; counter = "Flood sent per second"; instance = instance }
  /// Inquire received per second: -
  let ``Inquire received per second`` instance =
    { category = CategoryName; counter = "Inquire received per second"; instance = instance }
  /// Inquire sent per second: -
  let ``Inquire sent per second`` instance =
    { category = CategoryName; counter = "Inquire sent per second"; instance = instance }
  /// Lookup received per second: -
  let ``Lookup received per second`` instance =
    { category = CategoryName; counter = "Lookup received per second"; instance = instance }
  /// Lookup sent per second: -
  let ``Lookup sent per second`` instance =
    { category = CategoryName; counter = "Lookup sent per second"; instance = instance }
  /// Receive failures: -
  let ``Receive failures`` instance =
    { category = CategoryName; counter = "Receive failures"; instance = instance }
  /// Registration: -
  let ``Registration`` instance =
    { category = CategoryName; counter = "Registration"; instance = instance }
  /// Request received per second: -
  let ``Request received per second`` instance =
    { category = CategoryName; counter = "Request received per second"; instance = instance }
  /// Request sent per second: -
  let ``Request sent per second`` instance =
    { category = CategoryName; counter = "Request sent per second"; instance = instance }
  /// Resolve: -
  let ``Resolve`` instance =
    { category = CategoryName; counter = "Resolve"; instance = instance }
  /// Send failures: -
  let ``Send failures`` instance =
    { category = CategoryName; counter = "Send failures"; instance = instance }
  /// Solicit received per second: -
  let ``Solicit received per second`` instance =
    { category = CategoryName; counter = "Solicit received per second"; instance = instance }
  /// Solicit sent per second: -
  let ``Solicit sent per second`` instance =
    { category = CategoryName; counter = "Solicit sent per second"; instance = instance }
  /// Stale cache entry: -
  let ``Stale cache entry`` instance =
    { category = CategoryName; counter = "Stale cache entry"; instance = instance }
  /// Unknown message type received: -
  let ``Unknown message type received`` instance =
    { category = CategoryName; counter = "Unknown message type received"; instance = instance }

  let allCounters =
    [| ``Ack received per second``
       ``Ack sent per second``
       ``Advertise received per second``
       ``Advertise sent per second``
       ``Authority received per second``
       ``Authority sent per second``
       ``Average bytes received``
       ``Average bytes sent``
       ``Cache Entry``
       ``Estimated cloud size``
       ``Flood received per second``
       ``Flood sent per second``
       ``Inquire received per second``
       ``Inquire sent per second``
       ``Lookup received per second``
       ``Lookup sent per second``
       ``Receive failures``
       ``Registration``
       ``Request received per second``
       ``Request sent per second``
       ``Resolve``
       ``Send failures``
       ``Solicit received per second``
       ``Solicit sent per second``
       ``Stale cache entry``
       ``Unknown message type received``
    |]

/// Per Processor Network Activity Cycles: The Per Processor Network Activity Cycles counter set measures processor cycles due to network activity of an interface on each processor.
///
/// This performance counter does not have non-instance based counters
module ``Per Processor Network Activity Cycles`` =

  [<Literal>]
  let CategoryName = "Per Processor Network Activity Cycles"

  let PCC = Category.create CategoryName
  /// Build Scatter Gather Cycles/sec: Build Scatter Gather Cycles/sec is the average rate, in cycles per second, at which NDIS processed building Scatter Gather DMA lists for an interface.
  let ``Build Scatter Gather Cycles/sec`` instance =
    { category = CategoryName; counter = "Build Scatter Gather Cycles/sec"; instance = instance }
  /// Interrupt Cycles/sec: Interrupt Cycles/sec is the average rate, in cycles per second, at which NDIS processed hardware interrupts for an interface.
  let ``Interrupt Cycles/sec`` instance =
    { category = CategoryName; counter = "Interrupt Cycles/sec"; instance = instance }
  /// Interrupt DPC Cycles/sec: Interrupt DPC Cycles/sec is the average rate, in cycles per second, at which NDIS processed a Deferred Procedure Call (DPC) for an interface.
  let ``Interrupt DPC Cycles/sec`` instance =
    { category = CategoryName; counter = "Interrupt DPC Cycles/sec"; instance = instance }
  /// Interrupt DPC Latency Cycles/sec: Interrupt DPC Latency Cycles/sec is the amount of time, in cycles per second, between an interrupt and its DPC.
  let ``Interrupt DPC Latency Cycles/sec`` instance =
    { category = CategoryName; counter = "Interrupt DPC Latency Cycles/sec"; instance = instance }
  /// Miniport RSS Indirection Table Change Cycles: Miniport RSS Indirection Table Change Cycles is the average rate, in cycles per second, at which an interface processed changing the RSS indirection table.
  let ``Miniport RSS Indirection Table Change Cycles`` instance =
    { category = CategoryName; counter = "Miniport RSS Indirection Table Change Cycles"; instance = instance }
  /// Miniport Return Packet Cycles/sec: Miniport Return Packet Cycles/sec is the average rate, in cycles per second, at which an interface processed returning received packets.
  let ``Miniport Return Packet Cycles/sec`` instance =
    { category = CategoryName; counter = "Miniport Return Packet Cycles/sec"; instance = instance }
  /// Miniport Send Cycles/sec: Miniport Send Cycles/sec is the average rate, in cycles per second, at which an interface processed transmitting packets.
  let ``Miniport Send Cycles/sec`` instance =
    { category = CategoryName; counter = "Miniport Send Cycles/sec"; instance = instance }
  /// NDIS Receive Indication Cycles/sec: NDIS Receive Indication Cycles/sec is the average rate, in cycles per second, at which NDIS processed a receive indication call from an interface.
  let ``NDIS Receive Indication Cycles/sec`` instance =
    { category = CategoryName; counter = "NDIS Receive Indication Cycles/sec"; instance = instance }
  /// NDIS Return Packet Cycles/sec: NDIS Return Packet Cycles/sec is the average rate, in cycles per second, at which NDIS processed returning received packets to an interface.
  let ``NDIS Return Packet Cycles/sec`` instance =
    { category = CategoryName; counter = "NDIS Return Packet Cycles/sec"; instance = instance }
  /// NDIS Send Complete Cycles/sec: NDIS Send Complete Cycles/sec is the average rate, in cycles per second, at which NDIS processed transmit-complete notifications from an interface.
  let ``NDIS Send Complete Cycles/sec`` instance =
    { category = CategoryName; counter = "NDIS Send Complete Cycles/sec"; instance = instance }
  /// NDIS Send Cycles/sec: NDIS Send Cycles/sec is the average rate, in cycles per second, at which NDIS processed transmit requests from the stack for an interface.
  let ``NDIS Send Cycles/sec`` instance =
    { category = CategoryName; counter = "NDIS Send Cycles/sec"; instance = instance }
  /// Stack Receive Indication Cycles/sec: Stack Receive Indication Cycles/sec is the average rate, in cycles per second, at which the stack processed a receive indication call from an interface.
  let ``Stack Receive Indication Cycles/sec`` instance =
    { category = CategoryName; counter = "Stack Receive Indication Cycles/sec"; instance = instance }
  /// Stack Send Complete Cycles/sec: Stack Send Complete Cycles/sec is the average rate, in cycles per second, at which the stack processed transmit-complete notifications from an interface.
  let ``Stack Send Complete Cycles/sec`` instance =
    { category = CategoryName; counter = "Stack Send Complete Cycles/sec"; instance = instance }

  let allCounters =
    [| ``Build Scatter Gather Cycles/sec``
       ``Interrupt Cycles/sec``
       ``Interrupt DPC Cycles/sec``
       ``Interrupt DPC Latency Cycles/sec``
       ``Miniport RSS Indirection Table Change Cycles``
       ``Miniport Return Packet Cycles/sec``
       ``Miniport Send Cycles/sec``
       ``NDIS Receive Indication Cycles/sec``
       ``NDIS Return Packet Cycles/sec``
       ``NDIS Send Complete Cycles/sec``
       ``NDIS Send Cycles/sec``
       ``Stack Receive Indication Cycles/sec``
       ``Stack Send Complete Cycles/sec``
    |]

/// Per Processor Network Interface Card Activity: The Per Processor Network Interface Card Activity counter set measures network activity of a network interface card per processor.
///
/// This performance counter does not have non-instance based counters
module ``Per Processor Network Interface Card Activity`` =

  [<Literal>]
  let CategoryName = "Per Processor Network Interface Card Activity"

  let PCC = Category.create CategoryName
  /// Build Scatter Gather List Calls/sec: Build Scatter Gather List Calls/sec is the average rate, in incidents per second, at which NDIS received a request from an interface to build a scatter gather DMA list.
  let ``Build Scatter Gather List Calls/sec`` instance =
    { category = CategoryName; counter = "Build Scatter Gather List Calls/sec"; instance = instance }
  /// DPCs Deferred/sec: DPCs Deferred/sec is the average rate, in incidents per second, at which DPCs are deferred from executing immediately to avoid starving usermode threads.
  let ``DPCs Deferred/sec`` instance =
    { category = CategoryName; counter = "DPCs Deferred/sec"; instance = instance }
  /// DPCs Queued on Other CPUs/sec: DPCs Queued on Other CPUs/sec is the average rate, in incidents per second, at which the miniport queued a DPC on one CPU from a different CPU.
  let ``DPCs Queued on Other CPUs/sec`` instance =
    { category = CategoryName; counter = "DPCs Queued on Other CPUs/sec"; instance = instance }
  /// DPCs Queued/sec: DPCs Queued/sec is the average rate, in incidents per second, at which NDIS queued a Deferred Procedure Call (DPC) for an interface.
  let ``DPCs Queued/sec`` instance =
    { category = CategoryName; counter = "DPCs Queued/sec"; instance = instance }
  /// Interrupts/sec: Interrupts/sec is the average rate, in incidents per second, at which NDIS received and serviced hardware interrupts for an interface.
  let ``Interrupts/sec`` instance =
    { category = CategoryName; counter = "Interrupts/sec"; instance = instance }
  /// Low Resource Receive Indications/sec: Low Resource Receive Indications/sec is the average rate, in incidents per second, at which NDIS received a receive indication call from an interface with low receive resources.
  let ``Low Resource Receive Indications/sec`` instance =
    { category = CategoryName; counter = "Low Resource Receive Indications/sec"; instance = instance }
  /// Low Resource Received Packets/sec: Low Resource Received Packets/sec is the average rate, in packets per second, at which NDIS received packets from an interface with low receive resources.
  let ``Low Resource Received Packets/sec`` instance =
    { category = CategoryName; counter = "Low Resource Received Packets/sec"; instance = instance }
  /// Packets Coalesced/sec: Packets Coalesced/sec is the average rate, in packets per second, at which NDIS received packets that were subjected to coalescing by a network interface before interrupting the host CPU.
  let ``Packets Coalesced/sec`` instance =
    { category = CategoryName; counter = "Packets Coalesced/sec"; instance = instance }
  /// RSS Indirection Table Change Calls/sec: RSS Indirection Table Change Calls/sec is the average rate, in incidents per second, at which the stack submitted a request to change the RSS indirection table of an interface.
  let ``RSS Indirection Table Change Calls/sec`` instance =
    { category = CategoryName; counter = "RSS Indirection Table Change Calls/sec"; instance = instance }
  /// Receive Indications/sec: Receive Indications/sec is the average rate, in incidents per second, at which NDIS received a receive indication call from an interface.
  let ``Receive Indications/sec`` instance =
    { category = CategoryName; counter = "Receive Indications/sec"; instance = instance }
  /// Received Packets/sec: Received Packets/sec is the average rate, in packets per second, at which NDIS received packets from an interface.
  let ``Received Packets/sec`` instance =
    { category = CategoryName; counter = "Received Packets/sec"; instance = instance }
  /// Return Packet Calls/sec: Return Packet Calls/sec is the average rate, in incidents per second, at which the stack returned received packets to an interface.
  let ``Return Packet Calls/sec`` instance =
    { category = CategoryName; counter = "Return Packet Calls/sec"; instance = instance }
  /// Returned Packets/sec: Returned Packets/sec is the average rate, in packets per second, at which the stack returned received packets to an interface.
  let ``Returned Packets/sec`` instance =
    { category = CategoryName; counter = "Returned Packets/sec"; instance = instance }
  /// Send Complete Calls/sec: Send Complete Calls/sec is the average rate, in incidents per second, at which NDIS received a transmit-complete notification from an interface.
  let ``Send Complete Calls/sec`` instance =
    { category = CategoryName; counter = "Send Complete Calls/sec"; instance = instance }
  /// Send Request Calls/sec: Send Request Calls/sec is the average rate, in incidents per second, at which the stack requested a transmit on an interface.
  let ``Send Request Calls/sec`` instance =
    { category = CategoryName; counter = "Send Request Calls/sec"; instance = instance }
  /// Sent Complete Packets/sec: Sent Complete Packets/sec is the average rate, in packets per second, at which NDIS received a transmit-complete notification from an interface.
  let ``Sent Complete Packets/sec`` instance =
    { category = CategoryName; counter = "Sent Complete Packets/sec"; instance = instance }
  /// Sent Packets/sec: Sent Packets/sec is the average rate, in packets per second, at which the stack requested a transmit on an interface.
  let ``Sent Packets/sec`` instance =
    { category = CategoryName; counter = "Sent Packets/sec"; instance = instance }
  /// Tcp Offload Receive Indications/sec: Tcp Offload Receive Indications/sec is the average rate, in incidents per second, at which NDIS received a TCP offload receive indication call from a network interface.
  let ``Tcp Offload Receive Indications/sec`` instance =
    { category = CategoryName; counter = "Tcp Offload Receive Indications/sec"; instance = instance }
  /// Tcp Offload Receive bytes/sec: Tcp Offload Receive bytes/sec is the average rate, in bytes per second, at which data was delivered by a network interface using the TCP offload receive indication call.
  let ``Tcp Offload Receive bytes/sec`` instance =
    { category = CategoryName; counter = "Tcp Offload Receive bytes/sec"; instance = instance }
  /// Tcp Offload Send Request Calls/sec: Tcp Offload Send Request Calls/sec is the average rate, in incidents per second, at which the TCP/IP protocol requested a TCP offload transmission on a network interface.
  let ``Tcp Offload Send Request Calls/sec`` instance =
    { category = CategoryName; counter = "Tcp Offload Send Request Calls/sec"; instance = instance }
  /// Tcp Offload Send bytes/sec: Tcp Offload Send bytes/sec is the average rate, in bytes per second, at which data was delivered to a network interface using the TCP offload send request call.
  let ``Tcp Offload Send bytes/sec`` instance =
    { category = CategoryName; counter = "Tcp Offload Send bytes/sec"; instance = instance }

  let allCounters =
    [| ``Build Scatter Gather List Calls/sec``
       ``DPCs Deferred/sec``
       ``DPCs Queued on Other CPUs/sec``
       ``DPCs Queued/sec``
       ``Interrupts/sec``
       ``Low Resource Receive Indications/sec``
       ``Low Resource Received Packets/sec``
       ``Packets Coalesced/sec``
       ``RSS Indirection Table Change Calls/sec``
       ``Receive Indications/sec``
       ``Received Packets/sec``
       ``Return Packet Calls/sec``
       ``Returned Packets/sec``
       ``Send Complete Calls/sec``
       ``Send Request Calls/sec``
       ``Sent Complete Packets/sec``
       ``Sent Packets/sec``
       ``Tcp Offload Receive Indications/sec``
       ``Tcp Offload Receive bytes/sec``
       ``Tcp Offload Send Request Calls/sec``
       ``Tcp Offload Send bytes/sec``
    |]

/// Physical Network Interface Card Activity: The Physical Network Interface Card Activity counter set measures events on a physical network card.
///
/// This performance counter does not have non-instance based counters
module ``Physical Network Interface Card Activity`` =

  [<Literal>]
  let CategoryName = "Physical Network Interface Card Activity"

  let PCC = Category.create CategoryName
  /// % Time Suspended (Instantaneous): % Time Suspended (Instantaneous) measures the amount of time that the network interface card is in a low-power suspended state.  The percentage is calculated over the duration of the sample interval.
  let ``% Time Suspended (Instantaneous)`` instance =
    { category = CategoryName; counter = "% Time Suspended (Instantaneous)"; instance = instance }
  /// % Time Suspended (Lifetime): % Time Suspended (Lifetime) measures the amount of time that the network interface card is in a low-power suspended state.  The percentage is calculated over the entire lifetime of the network card.
  let ``% Time Suspended (Lifetime)`` instance =
    { category = CategoryName; counter = "% Time Suspended (Lifetime)"; instance = instance }
  /// Device Power State: Device Power State is the current power state of the network interface card.  Power state 0 is the active operating state, while power state 3 is the device's lowest power state.  Intermediate states 1 and 2 are device-specific sleep states.  For example, a USB NIC uses power state 2 to allow remote-wakeup.
  let ``Device Power State`` instance =
    { category = CategoryName; counter = "Device Power State"; instance = instance }
  /// Low Power Transitions (Lifetime): Low Power Transitions (Lifetime) measures the number of successful low-power transitions over the lifetime of the network interface card.  The counter includes only transitions from the active high-power state to a low-power state.
  let ``Low Power Transitions (Lifetime)`` instance =
    { category = CategoryName; counter = "Low Power Transitions (Lifetime)"; instance = instance }

  let allCounters =
    [| ``% Time Suspended (Instantaneous)``
       ``% Time Suspended (Lifetime)``
       ``Device Power State``
       ``Low Power Transitions (Lifetime)``
    |]

/// PhysicalDisk: The Physical Disk performance object consists of counters that monitor hard or fixed disk drive on a computer.  Disks are used to store file, program, and paging data and are read to retrieve these items, and written to record changes to them.  The values of physical disk counters are sums of the values of the logical disks (or partitions) into which they are divided.
///
/// This performance counter does not have non-instance based counters
module ``PhysicalDisk`` =

  [<Literal>]
  let CategoryName = "PhysicalDisk"

  let PCC = Category.create CategoryName
  /// % Disk Read Time: % Disk Read Time is the percentage of elapsed time that the selected disk drive was busy servicing read requests.
  let ``% Disk Read Time`` instance =
    { category = CategoryName; counter = "% Disk Read Time"; instance = instance }
  /// % Disk Time: % Disk Time is the percentage of elapsed time that the selected disk drive was busy servicing read or write requests.
  let ``% Disk Time`` instance =
    { category = CategoryName; counter = "% Disk Time"; instance = instance }
  /// % Disk Write Time: % Disk Write Time is the percentage of elapsed time that the selected disk drive was busy servicing write requests.
  let ``% Disk Write Time`` instance =
    { category = CategoryName; counter = "% Disk Write Time"; instance = instance }
  /// % Idle Time: % Idle Time reports the percentage of time during the sample interval that the disk was idle.
  let ``% Idle Time`` instance =
    { category = CategoryName; counter = "% Idle Time"; instance = instance }
  /// Avg. Disk Bytes/Read: Avg. Disk Bytes/Read is the average number of bytes transferred from the disk during read operations.
  let ``Avg. Disk Bytes/Read`` instance =
    { category = CategoryName; counter = "Avg. Disk Bytes/Read"; instance = instance }
  /// Avg. Disk Bytes/Transfer: Avg. Disk Bytes/Transfer is the average number of bytes transferred to or from the disk during write or read operations.
  let ``Avg. Disk Bytes/Transfer`` instance =
    { category = CategoryName; counter = "Avg. Disk Bytes/Transfer"; instance = instance }
  /// Avg. Disk Bytes/Write: Avg. Disk Bytes/Write is the average number of bytes transferred to the disk during write operations.
  let ``Avg. Disk Bytes/Write`` instance =
    { category = CategoryName; counter = "Avg. Disk Bytes/Write"; instance = instance }
  /// Avg. Disk Queue Length: Avg. Disk Queue Length is the average number of both read and write requests that were queued for the selected disk during the sample interval.
  let ``Avg. Disk Queue Length`` instance =
    { category = CategoryName; counter = "Avg. Disk Queue Length"; instance = instance }
  /// Avg. Disk Read Queue Length: Avg. Disk Read Queue Length is the average number of read requests that were queued for the selected disk during the sample interval.
  let ``Avg. Disk Read Queue Length`` instance =
    { category = CategoryName; counter = "Avg. Disk Read Queue Length"; instance = instance }
  /// Avg. Disk Write Queue Length: Avg. Disk Write Queue Length is the average number of write requests that were queued for the selected disk during the sample interval.
  let ``Avg. Disk Write Queue Length`` instance =
    { category = CategoryName; counter = "Avg. Disk Write Queue Length"; instance = instance }
  /// Avg. Disk sec/Read: Avg. Disk sec/Read is the average time, in seconds, of a read of data from the disk.
  let ``Avg. Disk sec/Read`` instance =
    { category = CategoryName; counter = "Avg. Disk sec/Read"; instance = instance }
  /// Avg. Disk sec/Transfer: Avg. Disk sec/Transfer is the time, in seconds, of the average disk transfer.
  let ``Avg. Disk sec/Transfer`` instance =
    { category = CategoryName; counter = "Avg. Disk sec/Transfer"; instance = instance }
  /// Avg. Disk sec/Write: Avg. Disk sec/Write is the average time, in seconds, of a write of data to the disk.
  let ``Avg. Disk sec/Write`` instance =
    { category = CategoryName; counter = "Avg. Disk sec/Write"; instance = instance }
  /// Current Disk Queue Length: Current Disk Queue Length is the number of requests outstanding on the disk at the time the performance data is collected. It also includes requests in service at the time of the collection. This is a instantaneous snapshot, not an average over the time interval. Multi-spindle disk devices can have multiple requests that are active at one time, but other concurrent requests are awaiting service. This counter might reflect a transitory high or low queue length, but if there is a sustained load on the disk drive, it is likely that this will be consistently high. Requests experience delays proportional to the length of this queue minus the number of spindles on the disks. For good performance, this difference should average less than two.
  let ``Current Disk Queue Length`` instance =
    { category = CategoryName; counter = "Current Disk Queue Length"; instance = instance }
  /// Disk Bytes/sec: Disk Bytes/sec is the rate bytes are transferred to or from the disk during write or read operations.
  let ``Disk Bytes/sec`` instance =
    { category = CategoryName; counter = "Disk Bytes/sec"; instance = instance }
  /// Disk Read Bytes/sec: Disk Read Bytes/sec is the rate at which bytes are transferred from the disk during read operations.
  let ``Disk Read Bytes/sec`` instance =
    { category = CategoryName; counter = "Disk Read Bytes/sec"; instance = instance }
  /// Disk Reads/sec: Disk Reads/sec is the rate of read operations on the disk.
  let ``Disk Reads/sec`` instance =
    { category = CategoryName; counter = "Disk Reads/sec"; instance = instance }
  /// Disk Transfers/sec: Disk Transfers/sec is the rate of read and write operations on the disk.
  let ``Disk Transfers/sec`` instance =
    { category = CategoryName; counter = "Disk Transfers/sec"; instance = instance }
  /// Disk Write Bytes/sec: Disk Write Bytes/sec is rate at which bytes are transferred to the disk during write operations.
  let ``Disk Write Bytes/sec`` instance =
    { category = CategoryName; counter = "Disk Write Bytes/sec"; instance = instance }
  /// Disk Writes/sec: Disk Writes/sec is the rate of write operations on the disk.
  let ``Disk Writes/sec`` instance =
    { category = CategoryName; counter = "Disk Writes/sec"; instance = instance }
  /// Split IO/Sec: Split IO/Sec reports the rate at which I/Os to the disk were split into multiple I/Os. A split I/O may result from requesting data of a size that is too large to fit into a single I/O or that the disk is fragmented.
  let ``Split IO/Sec`` instance =
    { category = CategoryName; counter = "Split IO/Sec"; instance = instance }

  let allCounters =
    [| ``% Disk Read Time``
       ``% Disk Time``
       ``% Disk Write Time``
       ``% Idle Time``
       ``Avg. Disk Bytes/Read``
       ``Avg. Disk Bytes/Transfer``
       ``Avg. Disk Bytes/Write``
       ``Avg. Disk Queue Length``
       ``Avg. Disk Read Queue Length``
       ``Avg. Disk Write Queue Length``
       ``Avg. Disk sec/Read``
       ``Avg. Disk sec/Transfer``
       ``Avg. Disk sec/Write``
       ``Current Disk Queue Length``
       ``Disk Bytes/sec``
       ``Disk Read Bytes/sec``
       ``Disk Reads/sec``
       ``Disk Transfers/sec``
       ``Disk Write Bytes/sec``
       ``Disk Writes/sec``
       ``Split IO/Sec``
    |]

/// Power Meter: This counter set displays power metering and budgeting information
///
/// This performance counter does not have instance based counters
module ``Power Meter`` =

  [<Literal>]
  let CategoryName = "Power Meter"

  let PCC = Category.create CategoryName
  /// Power: -
  let ``Power`` instance =
    { category = CategoryName; counter = "Power"; instance = instance }
  /// Power Budget: -
  let ``Power Budget`` instance =
    { category = CategoryName; counter = "Power Budget"; instance = instance }

  let allCounters =
    [| ``Power``
       ``Power Budget``
    |]

/// PowerShell Workflow: Displays performance counters for PowerShell Workflow engine.
///
/// This performance counter does not have instance based counters
module ``PowerShell Workflow`` =

  [<Literal>]
  let CategoryName = "PowerShell Workflow"

  let PCC = Category.create CategoryName
  /// # of failed workflow jobs: -
  let ``# of failed workflow jobs`` instance =
    { category = CategoryName; counter = "# of failed workflow jobs"; instance = instance }
  /// # of failed workflow jobs/sec: -
  let ``# of failed workflow jobs/sec`` instance =
    { category = CategoryName; counter = "# of failed workflow jobs/sec"; instance = instance }
  /// # of resumed workflow jobs: -
  let ``# of resumed workflow jobs`` instance =
    { category = CategoryName; counter = "# of resumed workflow jobs"; instance = instance }
  /// # of resumed workflow jobs/sec: -
  let ``# of resumed workflow jobs/sec`` instance =
    { category = CategoryName; counter = "# of resumed workflow jobs/sec"; instance = instance }
  /// # of running workflow jobs: -
  let ``# of running workflow jobs`` instance =
    { category = CategoryName; counter = "# of running workflow jobs"; instance = instance }
  /// # of running workflow jobs / sec: -
  let ``# of running workflow jobs / sec`` instance =
    { category = CategoryName; counter = "# of running workflow jobs / sec"; instance = instance }
  /// # of stopped workflow jobs: -
  let ``# of stopped workflow jobs`` instance =
    { category = CategoryName; counter = "# of stopped workflow jobs"; instance = instance }
  /// # of stopped workflow jobs / sec: -
  let ``# of stopped workflow jobs / sec`` instance =
    { category = CategoryName; counter = "# of stopped workflow jobs / sec"; instance = instance }
  /// # of succeeded workflow jobs: -
  let ``# of succeeded workflow jobs`` instance =
    { category = CategoryName; counter = "# of succeeded workflow jobs"; instance = instance }
  /// # of succeeded workflow jobs/sec: -
  let ``# of succeeded workflow jobs/sec`` instance =
    { category = CategoryName; counter = "# of succeeded workflow jobs/sec"; instance = instance }
  /// # of suspended workflow jobs: -
  let ``# of suspended workflow jobs`` instance =
    { category = CategoryName; counter = "# of suspended workflow jobs"; instance = instance }
  /// # of suspended workflow jobs/sec: -
  let ``# of suspended workflow jobs/sec`` instance =
    { category = CategoryName; counter = "# of suspended workflow jobs/sec"; instance = instance }
  /// # of terminated workflow jobs: -
  let ``# of terminated workflow jobs`` instance =
    { category = CategoryName; counter = "# of terminated workflow jobs"; instance = instance }
  /// # of terminated workflow jobs / sec: -
  let ``# of terminated workflow jobs / sec`` instance =
    { category = CategoryName; counter = "# of terminated workflow jobs / sec"; instance = instance }
  /// # of waiting workflow jobs: -
  let ``# of waiting workflow jobs`` instance =
    { category = CategoryName; counter = "# of waiting workflow jobs"; instance = instance }
  /// Activity Host Manager: # of busy host processes: -
  let ``Activity Host Manager: # of busy host processes`` instance =
    { category = CategoryName; counter = "Activity Host Manager: # of busy host processes"; instance = instance }
  /// Activity Host Manager: # of created host processes: -
  let ``Activity Host Manager: # of created host processes`` instance =
    { category = CategoryName; counter = "Activity Host Manager: # of created host processes"; instance = instance }
  /// Activity Host Manager: # of disposed host processes: -
  let ``Activity Host Manager: # of disposed host processes`` instance =
    { category = CategoryName; counter = "Activity Host Manager: # of disposed host processes"; instance = instance }
  /// Activity Host Manager: # of failed requests in queue: -
  let ``Activity Host Manager: # of failed requests in queue`` instance =
    { category = CategoryName; counter = "Activity Host Manager: # of failed requests in queue"; instance = instance }
  /// Activity Host Manager: # of failed requests/sec: -
  let ``Activity Host Manager: # of failed requests/sec`` instance =
    { category = CategoryName; counter = "Activity Host Manager: # of failed requests/sec"; instance = instance }
  /// Activity Host Manager: # of incoming requests/sec: -
  let ``Activity Host Manager: # of incoming requests/sec`` instance =
    { category = CategoryName; counter = "Activity Host Manager: # of incoming requests/sec"; instance = instance }
  /// Activity Host Manager: # of pending requests in queue: -
  let ``Activity Host Manager: # of pending requests in queue`` instance =
    { category = CategoryName; counter = "Activity Host Manager: # of pending requests in queue"; instance = instance }
  /// Activity Host Manager: host processes pool size: -
  let ``Activity Host Manager: host processes pool size`` instance =
    { category = CategoryName; counter = "Activity Host Manager: host processes pool size"; instance = instance }
  /// PowerShell Remoting: # of connections closed-reopened: -
  let ``PowerShell Remoting: # of connections closed-reopened`` instance =
    { category = CategoryName; counter = "PowerShell Remoting: # of connections closed-reopened"; instance = instance }
  /// PowerShell Remoting: # of created connections: -
  let ``PowerShell Remoting: # of created connections`` instance =
    { category = CategoryName; counter = "PowerShell Remoting: # of created connections"; instance = instance }
  /// PowerShell Remoting: # of disposed connections: -
  let ``PowerShell Remoting: # of disposed connections`` instance =
    { category = CategoryName; counter = "PowerShell Remoting: # of disposed connections"; instance = instance }
  /// PowerShell Remoting: # of forced to wait requests in queue: -
  let ``PowerShell Remoting: # of forced to wait requests in queue`` instance =
    { category = CategoryName; counter = "PowerShell Remoting: # of forced to wait requests in queue"; instance = instance }
  /// PowerShell Remoting: # of pending requests in queue: -
  let ``PowerShell Remoting: # of pending requests in queue`` instance =
    { category = CategoryName; counter = "PowerShell Remoting: # of pending requests in queue"; instance = instance }
  /// PowerShell Remoting: # of requests being serviced: -
  let ``PowerShell Remoting: # of requests being serviced`` instance =
    { category = CategoryName; counter = "PowerShell Remoting: # of requests being serviced"; instance = instance }

  let allCounters =
    [| ``# of failed workflow jobs``
       ``# of failed workflow jobs/sec``
       ``# of resumed workflow jobs``
       ``# of resumed workflow jobs/sec``
       ``# of running workflow jobs``
       ``# of running workflow jobs / sec``
       ``# of stopped workflow jobs``
       ``# of stopped workflow jobs / sec``
       ``# of succeeded workflow jobs``
       ``# of succeeded workflow jobs/sec``
       ``# of suspended workflow jobs``
       ``# of suspended workflow jobs/sec``
       ``# of terminated workflow jobs``
       ``# of terminated workflow jobs / sec``
       ``# of waiting workflow jobs``
       ``Activity Host Manager: # of busy host processes``
       ``Activity Host Manager: # of created host processes``
       ``Activity Host Manager: # of disposed host processes``
       ``Activity Host Manager: # of failed requests in queue``
       ``Activity Host Manager: # of failed requests/sec``
       ``Activity Host Manager: # of incoming requests/sec``
       ``Activity Host Manager: # of pending requests in queue``
       ``Activity Host Manager: host processes pool size``
       ``PowerShell Remoting: # of connections closed-reopened``
       ``PowerShell Remoting: # of created connections``
       ``PowerShell Remoting: # of disposed connections``
       ``PowerShell Remoting: # of forced to wait requests in queue``
       ``PowerShell Remoting: # of pending requests in queue``
       ``PowerShell Remoting: # of requests being serviced``
    |]

/// Print Queue: Displays performance statistics about a Print Queue.
///
/// This performance counter does not have non-instance based counters
module ``Print Queue`` =

  [<Literal>]
  let CategoryName = "Print Queue"

  let PCC = Category.create CategoryName
  /// Add Network Printer Calls: Total number of calls from other print servers to add shared network printers to this server since last restart.
  let ``Add Network Printer Calls`` instance =
    { category = CategoryName; counter = "Add Network Printer Calls"; instance = instance }
  /// Bytes Printed/sec: Number of bytes per second printed on a print queue.
  let ``Bytes Printed/sec`` instance =
    { category = CategoryName; counter = "Bytes Printed/sec"; instance = instance }
  /// Enumerate Network Printer Calls: Total number of calls from browse clients to this print server to request network browse lists since last restart.
  let ``Enumerate Network Printer Calls`` instance =
    { category = CategoryName; counter = "Enumerate Network Printer Calls"; instance = instance }
  /// Job Errors: Total number of job errors in a print queue since last restart.
  let ``Job Errors`` instance =
    { category = CategoryName; counter = "Job Errors"; instance = instance }
  /// Jobs: Current number of jobs in a print queue.
  let ``Jobs`` instance =
    { category = CategoryName; counter = "Jobs"; instance = instance }
  /// Jobs Spooling: Current number of spooling jobs in a print queue.
  let ``Jobs Spooling`` instance =
    { category = CategoryName; counter = "Jobs Spooling"; instance = instance }
  /// Max Jobs Spooling: Maximum number of spooling jobs in a print queue since last restart.
  let ``Max Jobs Spooling`` instance =
    { category = CategoryName; counter = "Max Jobs Spooling"; instance = instance }
  /// Max References: Peak number of references (open handles) to this printer.
  let ``Max References`` instance =
    { category = CategoryName; counter = "Max References"; instance = instance }
  /// Not Ready Errors: Total number of printer not ready errors in a print queue since the last restart.
  let ``Not Ready Errors`` instance =
    { category = CategoryName; counter = "Not Ready Errors"; instance = instance }
  /// Out of Paper Errors: Total number of out of paper errors in a print queue since the last restart.
  let ``Out of Paper Errors`` instance =
    { category = CategoryName; counter = "Out of Paper Errors"; instance = instance }
  /// References: Current number of references (open handles) to this printer.
  let ``References`` instance =
    { category = CategoryName; counter = "References"; instance = instance }
  /// Total Jobs Printed: Total number of jobs printed on a print queue since the last restart.
  let ``Total Jobs Printed`` instance =
    { category = CategoryName; counter = "Total Jobs Printed"; instance = instance }
  /// Total Pages Printed: Total number of pages printed through GDI on a print queue since the last restart.
  let ``Total Pages Printed`` instance =
    { category = CategoryName; counter = "Total Pages Printed"; instance = instance }

  let allCounters =
    [| ``Add Network Printer Calls``
       ``Bytes Printed/sec``
       ``Enumerate Network Printer Calls``
       ``Job Errors``
       ``Jobs``
       ``Jobs Spooling``
       ``Max Jobs Spooling``
       ``Max References``
       ``Not Ready Errors``
       ``Out of Paper Errors``
       ``References``
       ``Total Jobs Printed``
       ``Total Pages Printed``
    |]

/// Process: The Process performance object consists of counters that monitor running application program and system processes.  All the threads in a process share the same address space and have access to the same data.
///
/// This performance counter does not have non-instance based counters
module ``Process`` =

  [<Literal>]
  let CategoryName = "Process"

  let PCC = Category.create CategoryName
  /// % Privileged Time: % Privileged Time is the percentage of elapsed time that the process threads spent executing code in privileged mode. When a Windows system service is called, the service will often run in privileged mode to gain access to system-private data. Such data is protected from access by threads executing in user mode. Calls to the system can be explicit or implicit, such as page faults or interrupts. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.
  let ``% Privileged Time`` instance =
    { category = CategoryName; counter = "% Privileged Time"; instance = instance }
  /// % Processor Time: % Processor Time is the percentage of elapsed time that all of process threads used the processor to execution instructions. An instruction is the basic unit of execution in a computer, a thread is the object that executes instructions, and a process is the object created when a program is run. Code executed to handle some hardware interrupts and trap conditions are included in this count.
  let ``% Processor Time`` instance =
    { category = CategoryName; counter = "% Processor Time"; instance = instance }
  /// % User Time: % User Time is the percentage of elapsed time that the process threads spent executing code in user mode. Applications, environment subsystems, and integral subsystems execute in user mode. Code executing in user mode cannot damage the integrity of the Windows executive, kernel, and device drivers. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.
  let ``% User Time`` instance =
    { category = CategoryName; counter = "% User Time"; instance = instance }
  /// Creating Process ID: The Creating Process ID value is the Process ID of the process that created the process. The creating process may have terminated, so this value may no longer identify a running process.
  let ``Creating Process ID`` instance =
    { category = CategoryName; counter = "Creating Process ID"; instance = instance }
  /// Elapsed Time: The total elapsed time, in seconds, that this process has been running.
  let ``Elapsed Time`` instance =
    { category = CategoryName; counter = "Elapsed Time"; instance = instance }
  /// Handle Count: The total number of handles currently open by this process. This number is equal to the sum of the handles currently open by each thread in this process.
  let ``Handle Count`` instance =
    { category = CategoryName; counter = "Handle Count"; instance = instance }
  /// ID Process: ID Process is the unique identifier of this process. ID Process numbers are reused, so they only identify a process for the lifetime of that process.
  let ``ID Process`` instance =
    { category = CategoryName; counter = "ID Process"; instance = instance }
  /// IO Data Bytes/sec: The rate at which the process is reading and writing bytes in I/O operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Data Bytes/sec`` instance =
    { category = CategoryName; counter = "IO Data Bytes/sec"; instance = instance }
  /// IO Data Operations/sec: The rate at which the process is issuing read and write I/O operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Data Operations/sec`` instance =
    { category = CategoryName; counter = "IO Data Operations/sec"; instance = instance }
  /// IO Other Bytes/sec: The rate at which the process is issuing bytes to I/O operations that do not involve data such as control operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Other Bytes/sec`` instance =
    { category = CategoryName; counter = "IO Other Bytes/sec"; instance = instance }
  /// IO Other Operations/sec: The rate at which the process is issuing I/O operations that are neither read nor write operations (for example, a control function). This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Other Operations/sec`` instance =
    { category = CategoryName; counter = "IO Other Operations/sec"; instance = instance }
  /// IO Read Bytes/sec: The rate at which the process is reading bytes from I/O operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Read Bytes/sec`` instance =
    { category = CategoryName; counter = "IO Read Bytes/sec"; instance = instance }
  /// IO Read Operations/sec: The rate at which the process is issuing read I/O operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Read Operations/sec`` instance =
    { category = CategoryName; counter = "IO Read Operations/sec"; instance = instance }
  /// IO Write Bytes/sec: The rate at which the process is writing bytes to I/O operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Write Bytes/sec`` instance =
    { category = CategoryName; counter = "IO Write Bytes/sec"; instance = instance }
  /// IO Write Operations/sec: The rate at which the process is issuing write I/O operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Write Operations/sec`` instance =
    { category = CategoryName; counter = "IO Write Operations/sec"; instance = instance }
  /// Page Faults/sec: Page Faults/sec is the rate at which page faults by the threads executing in this process are occurring.  A page fault occurs when a thread refers to a virtual memory page that is not in its working set in main memory. This may not cause the page to be fetched from disk if it is on the standby list and hence already in main memory, or if it is in use by another process with whom the page is shared.
  let ``Page Faults/sec`` instance =
    { category = CategoryName; counter = "Page Faults/sec"; instance = instance }
  /// Page File Bytes: Page File Bytes is the current amount of virtual memory, in bytes, that this process has reserved for use in the paging file(s). Paging files are used to store pages of memory used by the process that are not contained in other files. Paging files are shared by all processes, and the lack of space in paging files can prevent other processes from allocating memory. If there is no paging file, this counter reflects the current amount of virtual memory that the process has reserved for use in physical memory.
  let ``Page File Bytes`` instance =
    { category = CategoryName; counter = "Page File Bytes"; instance = instance }
  /// Page File Bytes Peak: Page File Bytes Peak is the maximum amount of virtual memory, in bytes, that this process has reserved for use in the paging file(s). Paging files are used to store pages of memory used by the process that are not contained in other files.  Paging files are shared by all processes, and the lack of space in paging files can prevent other processes from allocating memory. If there is no paging file, this counter reflects the maximum amount of virtual memory that the process has reserved for use in physical memory.
  let ``Page File Bytes Peak`` instance =
    { category = CategoryName; counter = "Page File Bytes Peak"; instance = instance }
  /// Pool Nonpaged Bytes: Pool Nonpaged Bytes is the size, in bytes, of the nonpaged pool, an area of the system virtual memory that is used for objects that cannot be written to disk, but must remain in physical memory as long as they are allocated.  Memory\\Pool Nonpaged Bytes is calculated differently than Process\\Pool Nonpaged Bytes, so it might not equal Process(_Total)\\Pool Nonpaged Bytes.  This counter displays the last observed value only; it is not an average.
  let ``Pool Nonpaged Bytes`` instance =
    { category = CategoryName; counter = "Pool Nonpaged Bytes"; instance = instance }
  /// Pool Paged Bytes: Pool Paged Bytes is the size, in bytes, of the paged pool, an area of the system virtual memory that is used for objects that can be written to disk when they are not being used.  Memory\\Pool Paged Bytes is calculated differently than Process\\Pool Paged Bytes, so it might not equal Process(_Total)\\Pool Paged Bytes. This counter displays the last observed value only; it is not an average.
  let ``Pool Paged Bytes`` instance =
    { category = CategoryName; counter = "Pool Paged Bytes"; instance = instance }
  /// Priority Base: The current base priority of this process. Threads within a process can raise and lower their own base priority relative to the process' base priority.
  let ``Priority Base`` instance =
    { category = CategoryName; counter = "Priority Base"; instance = instance }
  /// Private Bytes: Private Bytes is the current size, in bytes, of memory that this process has allocated that cannot be shared with other processes.
  let ``Private Bytes`` instance =
    { category = CategoryName; counter = "Private Bytes"; instance = instance }
  /// Thread Count: The number of threads currently active in this process. An instruction is the basic unit of execution in a processor, and a thread is the object that executes instructions. Every running process has at least one thread.
  let ``Thread Count`` instance =
    { category = CategoryName; counter = "Thread Count"; instance = instance }
  /// Virtual Bytes: Virtual Bytes is the current size, in bytes, of the virtual address space the process is using. Use of virtual address space does not necessarily imply corresponding use of either disk or main memory pages. Virtual space is finite, and the process can limit its ability to load libraries.
  let ``Virtual Bytes`` instance =
    { category = CategoryName; counter = "Virtual Bytes"; instance = instance }
  /// Virtual Bytes Peak: Virtual Bytes Peak is the maximum size, in bytes, of virtual address space the process has used at any one time. Use of virtual address space does not necessarily imply corresponding use of either disk or main memory pages. However, virtual space is finite, and the process might limit its ability to load libraries.
  let ``Virtual Bytes Peak`` instance =
    { category = CategoryName; counter = "Virtual Bytes Peak"; instance = instance }
  /// Working Set: Working Set is the current size, in bytes, of the Working Set of this process. The Working Set is the set of memory pages touched recently by the threads in the process. If free memory in the computer is above a threshold, pages are left in the Working Set of a process even if they are not in use.  When free memory falls below a threshold, pages are trimmed from Working Sets. If they are needed they will then be soft-faulted back into the Working Set before leaving main memory.
  let ``Working Set`` instance =
    { category = CategoryName; counter = "Working Set"; instance = instance }
  /// Working Set - Private: Working Set - Private displays the size of the working set, in bytes, that is use for this process only and not shared nor sharable by other processes.
  let ``Working Set - Private`` instance =
    { category = CategoryName; counter = "Working Set - Private"; instance = instance }
  /// Working Set Peak: Working Set Peak is the maximum size, in bytes, of the Working Set of this process at any point in time. The Working Set is the set of memory pages touched recently by the threads in the process. If free memory in the computer is above a threshold, pages are left in the Working Set of a process even if they are not in use. When free memory falls below a threshold, pages are trimmed from Working Sets. If they are needed they will then be soft-faulted back into the Working Set before they leave main memory.
  let ``Working Set Peak`` instance =
    { category = CategoryName; counter = "Working Set Peak"; instance = instance }

  let allCounters =
    [| ``% Privileged Time``
       ``% Processor Time``
       ``% User Time``
       ``Creating Process ID``
       ``Elapsed Time``
       ``Handle Count``
       ``ID Process``
       ``IO Data Bytes/sec``
       ``IO Data Operations/sec``
       ``IO Other Bytes/sec``
       ``IO Other Operations/sec``
       ``IO Read Bytes/sec``
       ``IO Read Operations/sec``
       ``IO Write Bytes/sec``
       ``IO Write Operations/sec``
       ``Page Faults/sec``
       ``Page File Bytes``
       ``Page File Bytes Peak``
       ``Pool Nonpaged Bytes``
       ``Pool Paged Bytes``
       ``Priority Base``
       ``Private Bytes``
       ``Thread Count``
       ``Virtual Bytes``
       ``Virtual Bytes Peak``
       ``Working Set``
       ``Working Set - Private``
       ``Working Set Peak``
    |]

/// Processor: The Processor performance object consists of counters that measure aspects of processor activity. The processor is the part of the computer that performs arithmetic and logical computations, initiates operations on peripherals, and runs the threads of processes.  A computer can have multiple processors.  The processor object represents each processor as an instance of the object.
///
/// This performance counter does not have non-instance based counters
module ``Processor`` =

  [<Literal>]
  let CategoryName = "Processor"

  let PCC = Category.create CategoryName
  /// % C1 Time: % C1 Time is the percentage of time the processor spends in the C1 low-power idle state. % C1 Time is a subset of the total processor idle time. C1 low-power idle state enables the processor to maintain its entire context and quickly return to the running state. Not all systems support the % C1 state.
  let ``% C1 Time`` instance =
    { category = CategoryName; counter = "% C1 Time"; instance = instance }
  /// % C2 Time: % C2 Time is the percentage of time the processor spends in the C2 low-power idle state. % C2 Time is a subset of the total processor idle time. C2 low-power idle state enables the processor to maintain the context of the system caches. The C2 power state is a lower power and higher exit latency state than C1. Not all systems support the C2 state.
  let ``% C2 Time`` instance =
    { category = CategoryName; counter = "% C2 Time"; instance = instance }
  /// % C3 Time: % C3 Time is the percentage of time the processor spends in the C3 low-power idle state. % C3 Time is a subset of the total processor idle time. When the processor is in the C3 low-power idle state it is unable to maintain the coherency of its caches. The C3 power state is a lower power and higher exit latency state than C2. Not all systems support the C3 state.
  let ``% C3 Time`` instance =
    { category = CategoryName; counter = "% C3 Time"; instance = instance }
  /// % DPC Time: % DPC Time is the percentage of time that the processor spent receiving and servicing deferred procedure calls (DPCs) during the sample interval. DPCs are interrupts that run at a lower priority than standard interrupts. % DPC Time is a component of % Privileged Time because DPCs are executed in privileged mode. They are counted separately and are not a component of the interrupt counters. This counter displays the average busy time as a percentage of the sample time.
  let ``% DPC Time`` instance =
    { category = CategoryName; counter = "% DPC Time"; instance = instance }
  /// % Idle Time: % Idle Time is the percentage of time the processor is idle during the sample interval
  let ``% Idle Time`` instance =
    { category = CategoryName; counter = "% Idle Time"; instance = instance }
  /// % Interrupt Time: % Interrupt Time is the time the processor spends receiving and servicing hardware interrupts during sample intervals. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention. Normal thread execution is suspended during interrupts. Most system clocks interrupt the processor every 10 milliseconds, creating a background of interrupt activity. suspends normal thread execution during interrupts. This counter displays the average busy time as a percentage of the sample time.
  let ``% Interrupt Time`` instance =
    { category = CategoryName; counter = "% Interrupt Time"; instance = instance }
  /// % Privileged Time: % Privileged Time is the percentage of elapsed time that the process threads spent executing code in privileged mode.  When a Windows system service in called, the service will often run in privileged mode to gain access to system-private data. Such data is protected from access by threads executing in user mode. Calls to the system can be explicit or implicit, such as page faults or interrupts. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.
  let ``% Privileged Time`` instance =
    { category = CategoryName; counter = "% Privileged Time"; instance = instance }
  /// % Processor Time: % Processor Time is the percentage of elapsed time that the processor spends to execute a non-Idle thread. It is calculated by measuring the percentage of time that the processor spends executing the idle thread and then subtracting that value from 100%. (Each processor has an idle thread that consumes cycles when no other threads are ready to run). This counter is the primary indicator of processor activity, and displays the average percentage of busy time observed during the sample interval. It should be noted that the accounting calculation of whether the processor is idle is performed at an internal sampling interval of the system clock (10ms). On todays fast processors, % Processor Time can therefore underestimate the processor utilization as the processor may be spending a lot of time servicing threads between the system clock sampling interval. Workload based timer applications are one example  of applications  which are more likely to be measured inaccurately as timers are signaled just after the sample is taken.
  let ``% Processor Time`` instance =
    { category = CategoryName; counter = "% Processor Time"; instance = instance }
  /// % User Time: % User Time is the percentage of elapsed time the processor spends in the user mode. User mode is a restricted processing mode designed for applications, environment subsystems, and integral subsystems.  The alternative, privileged mode, is designed for operating system components and allows direct access to hardware and all memory.  The operating system switches application threads to privileged mode to access operating system services. This counter displays the average busy time as a percentage of the sample time.
  let ``% User Time`` instance =
    { category = CategoryName; counter = "% User Time"; instance = instance }
  /// C1 Transitions/sec: C1 Transitions/sec is the rate that the CPU enters the C1 low-power idle state. The CPU enters the C1 state when it is sufficiently idle and exits this state on any interrupt. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``C1 Transitions/sec`` instance =
    { category = CategoryName; counter = "C1 Transitions/sec"; instance = instance }
  /// C2 Transitions/sec: C2 Transitions/sec is the rate that the CPU enters the C2 low-power idle state. The CPU enters the C2 state when it is sufficiently idle and exits this state on any interrupt. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``C2 Transitions/sec`` instance =
    { category = CategoryName; counter = "C2 Transitions/sec"; instance = instance }
  /// C3 Transitions/sec: C3 Transitions/sec is the rate that the CPU enters the C3 low-power idle state. The CPU enters the C3 state when it is sufficiently idle and exits this state on any interrupt. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``C3 Transitions/sec`` instance =
    { category = CategoryName; counter = "C3 Transitions/sec"; instance = instance }
  /// DPC Rate: DPC Rate is the rate at which deferred procedure calls (DPCs) were added to the processors DPC queues between the timer ticks of the processor clock. DPCs are interrupts that run at alower priority than standard interrupts.  Each processor has its own DPC queue. This counter measures the rate that DPCs were added to the queue, not the number of DPCs in the queue. This counter displays the last observed value only; it is not an average.
  let ``DPC Rate`` instance =
    { category = CategoryName; counter = "DPC Rate"; instance = instance }
  /// DPCs Queued/sec: DPCs Queued/sec is the average rate, in incidents per second, at which deferred procedure calls (DPCs) were added to the processor's DPC queue. DPCs are interrupts that run at a lower priority than standard interrupts.  Each processor has its own DPC queue. This counter measures the rate that DPCs are added to the queue, not the number of DPCs in the queue.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``DPCs Queued/sec`` instance =
    { category = CategoryName; counter = "DPCs Queued/sec"; instance = instance }
  /// Interrupts/sec: Interrupts/sec is the average rate, in incidents per second, at which the processor received and serviced hardware interrupts. It does not include deferred procedure calls (DPCs), which are counted separately. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards, and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention. Normal thread execution is suspended. The system clock typically interrupts the processor every 10 milliseconds, creating a background of interrupt activity. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Interrupts/sec`` instance =
    { category = CategoryName; counter = "Interrupts/sec"; instance = instance }

  let allCounters =
    [| ``% C1 Time``
       ``% C2 Time``
       ``% C3 Time``
       ``% DPC Time``
       ``% Idle Time``
       ``% Interrupt Time``
       ``% Privileged Time``
       ``% Processor Time``
       ``% User Time``
       ``C1 Transitions/sec``
       ``C2 Transitions/sec``
       ``C3 Transitions/sec``
       ``DPC Rate``
       ``DPCs Queued/sec``
       ``Interrupts/sec``
    |]

/// Processor Information: The Processor Information performance counter set consists of counters that measure aspects of processor activity. The processor is the part of the computer that performs arithmetic and logical computations, initiates operations on peripherals, and runs the threads of processes. A computer can have multiple processors. On some computers, processors are organized in NUMA nodes that share hardware resources such as physical memory. The Processor Information counter set represents each processor as a pair of numbers, where the first number is the NUMA node number and the second number is the zero-based index of the processor within that NUMA node. If the computer does not use NUMA nodes, the first number is zero.
///
/// This performance counter does not have non-instance based counters
module ``Processor Information`` =

  [<Literal>]
  let CategoryName = "Processor Information"

  let PCC = Category.create CategoryName
  /// % C1 Time: % C1 Time is the percentage of time the processor spends in the C1 low-power idle state. % C1 Time is a subset of the total processor idle time. C1 low-power idle state enables the processor to maintain its entire context and quickly return to the running state. Not all systems support the % C1 state.
  let ``% C1 Time`` instance =
    { category = CategoryName; counter = "% C1 Time"; instance = instance }
  /// % C2 Time: % C2 Time is the percentage of time the processor spends in the C2 low-power idle state. % C2 Time is a subset of the total processor idle time. C2 low-power idle state enables the processor to maintain the context of the system caches. The C2 power state is a lower power and higher exit latency state than C1. Not all systems support the C2 state.
  let ``% C2 Time`` instance =
    { category = CategoryName; counter = "% C2 Time"; instance = instance }
  /// % C3 Time: % C3 Time is the percentage of time the processor spends in the C3 low-power idle state. % C3 Time is a subset of the total processor idle time. When the processor is in the C3 low-power idle state it is unable to maintain the coherency of its caches. The C3 power state is a lower power and higher exit latency state than C2. Not all systems support the C3 state.
  let ``% C3 Time`` instance =
    { category = CategoryName; counter = "% C3 Time"; instance = instance }
  /// % DPC Time: % DPC Time is the percentage of time that the processor spent receiving and servicing deferred procedure calls (DPCs) during the sample interval. DPCs are interrupts that run at a lower priority than standard interrupts. % DPC Time is a component of % Privileged Time because DPCs are executed in privileged mode. They are counted separately and are not a component of the interrupt counters. This counter displays the average busy time as a percentage of the sample time.
  let ``% DPC Time`` instance =
    { category = CategoryName; counter = "% DPC Time"; instance = instance }
  /// % Idle Time: % Idle Time is the percentage of time the processor is idle during the sample interval
  let ``% Idle Time`` instance =
    { category = CategoryName; counter = "% Idle Time"; instance = instance }
  /// % Interrupt Time: % Interrupt Time is the time the processor spends receiving and servicing hardware interrupts during sample intervals. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention. Normal thread execution is suspended during interrupts. Most system clocks interrupt the processor every 10 milliseconds, creating a background of interrupt activity. suspends normal thread execution during interrupts. This counter displays the average busy time as a percentage of the sample time.
  let ``% Interrupt Time`` instance =
    { category = CategoryName; counter = "% Interrupt Time"; instance = instance }
  /// % Performance Limit: % Performance Limit is the performance the processor guarantees it can provide, as a percentage of the nominal performance of the processor. Performance can be limited by Windows power policy, or by the platform as a result of a power budget, overheating, or other hardware issues.
  let ``% Performance Limit`` instance =
    { category = CategoryName; counter = "% Performance Limit"; instance = instance }
  /// % Priority Time: % Priority Time is the percentage of elapsed time that the processor spends executing threads that are not low priority. It is calculated by measuring the percentage of time that the processor spends executing low priority threads or the idle thread and then subtracting that value from 100%. (Each processor has an idle thread to which time is accumulated when no other threads are ready to run). This counter displays the average percentage of busy time observed during the sample interval excluding low priority background work. It should be noted that the accounting calculation of whether the processor is idle is performed at an internal sampling interval of the system clock tick. % Priority Time can therefore underestimate the processor utilization as the processor may be spending a lot of time servicing threads between the system clock sampling interval. Workload based timer applications are one example  of applications  which are more likely to be measured inaccurately as timers are signaled just after the sample is taken.
  let ``% Priority Time`` instance =
    { category = CategoryName; counter = "% Priority Time"; instance = instance }
  /// % Privileged Time: % Privileged Time is the percentage of elapsed time that the process threads spent executing code in privileged mode.  When a Windows system service in called, the service will often run in privileged mode to gain access to system-private data. Such data is protected from access by threads executing in user mode. Calls to the system can be explicit or implicit, such as page faults or interrupts. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.
  let ``% Privileged Time`` instance =
    { category = CategoryName; counter = "% Privileged Time"; instance = instance }
  /// % Privileged Utility: Privileged Utility is the amount of work a processor is completing while executing in privileged mode, as a percentage of the amount of work the processor could complete if it were running at its nominal performance and never idle. On some processors, Privileged Utility may exceed 100%.
  let ``% Privileged Utility`` instance =
    { category = CategoryName; counter = "% Privileged Utility"; instance = instance }
  /// % Processor Performance: Processor Performance is the average performance of the processor while it is executing instructions, as a percentage of the nominal performance of the processor. On some processors, Processor Performance may exceed 100%. Some processors are capable of regulating their frequency outside of the control of Windows. Processor Performance will accurately reflect the performance of these processors.
  let ``% Processor Performance`` instance =
    { category = CategoryName; counter = "% Processor Performance"; instance = instance }
  /// % Processor Time: % Processor Time is the percentage of elapsed time that the processor spends to execute a non-Idle thread. It is calculated by measuring the percentage of time that the processor spends executing the idle thread and then subtracting that value from 100%. (Each processor has an idle thread to which time is accumulated when no other threads are ready to run). This counter is the primary indicator of processor activity, and displays the average percentage of busy time observed during the sample interval. It should be noted that the accounting calculation of whether the processor is idle is performed at an internal sampling interval of the system clock tick. On todays fast processors, % Processor Time can therefore underestimate the processor utilization as the processor may be spending a lot of time servicing threads between the system clock sampling interval. Workload based timer applications are one example  of applications  which are more likely to be measured inaccurately as timers are signaled just after the sample is taken.
  let ``% Processor Time`` instance =
    { category = CategoryName; counter = "% Processor Time"; instance = instance }
  /// % Processor Utility: Processor Utility is the amount of work a processor is completing, as a percentage of the amount of work the processor could complete if it were running at its nominal performance and never idle. On some processors, Processor Utility may exceed 100%.
  let ``% Processor Utility`` instance =
    { category = CategoryName; counter = "% Processor Utility"; instance = instance }
  /// % User Time: % User Time is the percentage of elapsed time the processor spends in the user mode. User mode is a restricted processing mode designed for applications, environment subsystems, and integral subsystems.  The alternative, privileged mode, is designed for operating system components and allows direct access to hardware and all memory.  The operating system switches application threads to privileged mode to access operating system services. This counter displays the average busy time as a percentage of the sample time.
  let ``% User Time`` instance =
    { category = CategoryName; counter = "% User Time"; instance = instance }
  /// % of Maximum Frequency: % of Maximum Frequency is the percentage of the current processor's maximum frequency. Some processors are capable of regulating their frequency outside of the control of Windows. % of Maximum Frequency will not accurately reflect actual processor frequency on these systems. Use % Processor Performance instead.
  let ``% of Maximum Frequency`` instance =
    { category = CategoryName; counter = "% of Maximum Frequency"; instance = instance }
  /// Average Idle Time: Average Idle Time is the average idle duration in 100ns units observed between the last two samples.
  let ``Average Idle Time`` instance =
    { category = CategoryName; counter = "Average Idle Time"; instance = instance }
  /// C1 Transitions/sec: C1 Transitions/sec is the rate that the CPU enters the C1 low-power idle state. The CPU enters the C1 state when it is sufficiently idle and exits this state on any interrupt. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``C1 Transitions/sec`` instance =
    { category = CategoryName; counter = "C1 Transitions/sec"; instance = instance }
  /// C2 Transitions/sec: C2 Transitions/sec is the rate that the CPU enters the C2 low-power idle state. The CPU enters the C2 state when it is sufficiently idle and exits this state on any interrupt. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``C2 Transitions/sec`` instance =
    { category = CategoryName; counter = "C2 Transitions/sec"; instance = instance }
  /// C3 Transitions/sec: C3 Transitions/sec is the rate that the CPU enters the C3 low-power idle state. The CPU enters the C3 state when it is sufficiently idle and exits this state on any interrupt. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``C3 Transitions/sec`` instance =
    { category = CategoryName; counter = "C3 Transitions/sec"; instance = instance }
  /// Clock Interrupts/sec: Clock Interrupts/sec is the average rate, in incidents per second, at which the processor received and serviced clock tick interrupts. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Clock Interrupts/sec`` instance =
    { category = CategoryName; counter = "Clock Interrupts/sec"; instance = instance }
  /// DPC Rate: DPC Rate is the rate at which deferred procedure calls (DPCs) were added to the processors DPC queues between the timer ticks of the processor clock. DPCs are interrupts that run at alower priority than standard interrupts.  Each processor has its own DPC queue. This counter measures the rate that DPCs were added to the queue, not the number of DPCs in the queue. This counter displays the last observed value only; it is not an average.
  let ``DPC Rate`` instance =
    { category = CategoryName; counter = "DPC Rate"; instance = instance }
  /// DPCs Queued/sec: DPCs Queued/sec is the average rate, in incidents per second, at which deferred procedure calls (DPCs) were added to the processor's DPC queue. DPCs are interrupts that run at a lower priority than standard interrupts.  Each processor has its own DPC queue. This counter measures the rate that DPCs are added to the queue, not the number of DPCs in the queue.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``DPCs Queued/sec`` instance =
    { category = CategoryName; counter = "DPCs Queued/sec"; instance = instance }
  /// Idle Break Events/sec: Idle Break Events/sec is the average rate, in incidents per second, at which the processor wakes from idle.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Idle Break Events/sec`` instance =
    { category = CategoryName; counter = "Idle Break Events/sec"; instance = instance }
  /// Interrupts/sec: Interrupts/sec is the average rate, in incidents per second, at which the processor received and serviced hardware interrupts. It does not include deferred procedure calls (DPCs), which are counted separately. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards, and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention. Normal thread execution is suspended. The system clock typically interrupts the processor every 10 milliseconds, creating a background of interrupt activity. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Interrupts/sec`` instance =
    { category = CategoryName; counter = "Interrupts/sec"; instance = instance }
  /// Parking Status: Parking Status represents whether a processor is parked or not.
  let ``Parking Status`` instance =
    { category = CategoryName; counter = "Parking Status"; instance = instance }
  /// Performance Limit Flags: Performance Limit Flags indicate reasons why the processor performance was limited.
  let ``Performance Limit Flags`` instance =
    { category = CategoryName; counter = "Performance Limit Flags"; instance = instance }
  /// Processor Frequency: Processor Frequency is the frequency of the current processor in megahertz. Some processors are capable of regulating their frequency outside of the control of Windows. Processor Frequency will not accurately reflect actual processor frequency on these systems.
  let ``Processor Frequency`` instance =
    { category = CategoryName; counter = "Processor Frequency"; instance = instance }
  /// Processor State Flags: Processor State Flags
  let ``Processor State Flags`` instance =
    { category = CategoryName; counter = "Processor State Flags"; instance = instance }

  let allCounters =
    [| ``% C1 Time``
       ``% C2 Time``
       ``% C3 Time``
       ``% DPC Time``
       ``% Idle Time``
       ``% Interrupt Time``
       ``% Performance Limit``
       ``% Priority Time``
       ``% Privileged Time``
       ``% Privileged Utility``
       ``% Processor Performance``
       ``% Processor Time``
       ``% Processor Utility``
       ``% User Time``
       ``% of Maximum Frequency``
       ``Average Idle Time``
       ``C1 Transitions/sec``
       ``C2 Transitions/sec``
       ``C3 Transitions/sec``
       ``Clock Interrupts/sec``
       ``DPC Rate``
       ``DPCs Queued/sec``
       ``Idle Break Events/sec``
       ``Interrupts/sec``
       ``Parking Status``
       ``Performance Limit Flags``
       ``Processor Frequency``
       ``Processor State Flags``
    |]

/// RAS: VPN counters which keep track of their values since service start
///
/// This performance counter does not have instance based counters
module ``RAS`` =

  [<Literal>]
  let CategoryName = "RAS"

  let PCC = Category.create CategoryName
  /// Bytes Received By Disconnected Clients: Total number of bytes received by all the disconnected clients since service start
  let ``Bytes Received By Disconnected Clients`` =
    { category = CategoryName; counter = "Bytes Received By Disconnected Clients"; instance = None }
  /// Bytes Transmitted By Disconnected Clients: Total number of bytes transmitted by all the disconnected clients since service start
  let ``Bytes Transmitted By Disconnected Clients`` =
    { category = CategoryName; counter = "Bytes Transmitted By Disconnected Clients"; instance = None }
  /// Failed Authentications: Number of failed authentications since service start
  let ``Failed Authentications`` =
    { category = CategoryName; counter = "Failed Authentications"; instance = None }
  /// Max Clients: Maximum number of remote clients connected to server since service start
  let ``Max Clients`` =
    { category = CategoryName; counter = "Max Clients"; instance = None }
  /// Total Clients: Total number of cumulative remote clients connected to server since service start
  let ``Total Clients`` =
    { category = CategoryName; counter = "Total Clients"; instance = None }

  let allCounters =
    [| ``Bytes Received By Disconnected Clients``
       ``Bytes Transmitted By Disconnected Clients``
       ``Failed Authentications``
       ``Max Clients``
       ``Total Clients``
    |]

/// RAS Port: The RAS Object Type handles individual ports of the RAS device on your system.
///
/// This performance counter does not have instance based counters
module ``RAS Port`` =

  [<Literal>]
  let CategoryName = "RAS Port"

  let PCC = Category.create CategoryName
  /// Alignment Errors: -
  let ``Alignment Errors`` instance =
    { category = CategoryName; counter = "Alignment Errors"; instance = instance }
  /// Buffer Overrun Errors: -
  let ``Buffer Overrun Errors`` instance =
    { category = CategoryName; counter = "Buffer Overrun Errors"; instance = instance }
  /// Bytes Received: -
  let ``Bytes Received`` instance =
    { category = CategoryName; counter = "Bytes Received"; instance = instance }
  /// Bytes Received/Sec: -
  let ``Bytes Received/Sec`` instance =
    { category = CategoryName; counter = "Bytes Received/Sec"; instance = instance }
  /// Bytes Transmitted: -
  let ``Bytes Transmitted`` instance =
    { category = CategoryName; counter = "Bytes Transmitted"; instance = instance }
  /// Bytes Transmitted/Sec: -
  let ``Bytes Transmitted/Sec`` instance =
    { category = CategoryName; counter = "Bytes Transmitted/Sec"; instance = instance }
  /// CRC Errors: -
  let ``CRC Errors`` instance =
    { category = CategoryName; counter = "CRC Errors"; instance = instance }
  /// Frames Received: -
  let ``Frames Received`` instance =
    { category = CategoryName; counter = "Frames Received"; instance = instance }
  /// Frames Received/Sec: -
  let ``Frames Received/Sec`` instance =
    { category = CategoryName; counter = "Frames Received/Sec"; instance = instance }
  /// Frames Transmitted: -
  let ``Frames Transmitted`` instance =
    { category = CategoryName; counter = "Frames Transmitted"; instance = instance }
  /// Frames Transmitted/Sec: -
  let ``Frames Transmitted/Sec`` instance =
    { category = CategoryName; counter = "Frames Transmitted/Sec"; instance = instance }
  /// Percent Compression In: -
  let ``Percent Compression In`` instance =
    { category = CategoryName; counter = "Percent Compression In"; instance = instance }
  /// Percent Compression Out: -
  let ``Percent Compression Out`` instance =
    { category = CategoryName; counter = "Percent Compression Out"; instance = instance }
  /// Serial Overrun Errors: -
  let ``Serial Overrun Errors`` instance =
    { category = CategoryName; counter = "Serial Overrun Errors"; instance = instance }
  /// Timeout Errors: -
  let ``Timeout Errors`` instance =
    { category = CategoryName; counter = "Timeout Errors"; instance = instance }
  /// Total Errors: -
  let ``Total Errors`` instance =
    { category = CategoryName; counter = "Total Errors"; instance = instance }
  /// Total Errors/Sec: -
  let ``Total Errors/Sec`` instance =
    { category = CategoryName; counter = "Total Errors/Sec"; instance = instance }

  let allCounters =
    [| ``Alignment Errors``
       ``Buffer Overrun Errors``
       ``Bytes Received``
       ``Bytes Received/Sec``
       ``Bytes Transmitted``
       ``Bytes Transmitted/Sec``
       ``CRC Errors``
       ``Frames Received``
       ``Frames Received/Sec``
       ``Frames Transmitted``
       ``Frames Transmitted/Sec``
       ``Percent Compression In``
       ``Percent Compression Out``
       ``Serial Overrun Errors``
       ``Timeout Errors``
       ``Total Errors``
       ``Total Errors/Sec``
    |]

/// RAS Total: The RAS Object Type handles all combined ports of the RAS device on your system.
///
/// This performance counter does not have instance based counters
module ``RAS Total`` =

  [<Literal>]
  let CategoryName = "RAS Total"

  let PCC = Category.create CategoryName
  /// Alignment Errors: The total number of Alignment Errors for this connection.  Alignment Errors occur when a byte received is different from the byte expected.
  let ``Alignment Errors`` =
    { category = CategoryName; counter = "Alignment Errors"; instance = None }
  /// Buffer Overrun Errors: The total number of Buffer Overrun Errors for this connection.  Buffer Overrun Errors when the software cannot handle the rate at which data is received.
  let ``Buffer Overrun Errors`` =
    { category = CategoryName; counter = "Buffer Overrun Errors"; instance = None }
  /// Bytes Received: The number of bytes received total for this connection.
  let ``Bytes Received`` =
    { category = CategoryName; counter = "Bytes Received"; instance = None }
  /// Bytes Received/Sec: The number of bytes received per second.
  let ``Bytes Received/Sec`` =
    { category = CategoryName; counter = "Bytes Received/Sec"; instance = None }
  /// Bytes Transmitted: The number of bytes transmitted total for this connection.
  let ``Bytes Transmitted`` =
    { category = CategoryName; counter = "Bytes Transmitted"; instance = None }
  /// Bytes Transmitted/Sec: The number of bytes transmitted per second.
  let ``Bytes Transmitted/Sec`` =
    { category = CategoryName; counter = "Bytes Transmitted/Sec"; instance = None }
  /// CRC Errors: The total number of CRC Errors for this connection.  CRC Errors occur when the frame received contains erroneous data.
  let ``CRC Errors`` =
    { category = CategoryName; counter = "CRC Errors"; instance = None }
  /// Frames Received: The number of data frames received total for this connection.
  let ``Frames Received`` =
    { category = CategoryName; counter = "Frames Received"; instance = None }
  /// Frames Received/Sec: The number of frames received per second.
  let ``Frames Received/Sec`` =
    { category = CategoryName; counter = "Frames Received/Sec"; instance = None }
  /// Frames Transmitted: The number of data frames transmitted total for this connection.
  let ``Frames Transmitted`` =
    { category = CategoryName; counter = "Frames Transmitted"; instance = None }
  /// Frames Transmitted/Sec: The number of frames transmitted per second.
  let ``Frames Transmitted/Sec`` =
    { category = CategoryName; counter = "Frames Transmitted/Sec"; instance = None }
  /// Percent Compression In: The compression ratio for bytes being received.
  let ``Percent Compression In`` =
    { category = CategoryName; counter = "Percent Compression In"; instance = None }
  /// Percent Compression Out: The compression ratio for bytes being transmitted.
  let ``Percent Compression Out`` =
    { category = CategoryName; counter = "Percent Compression Out"; instance = None }
  /// Serial Overrun Errors: The total number of Serial Overrun Errors for this connection.  Serial Overrun Errors occur when the hardware cannot handle the rate at which data is received.
  let ``Serial Overrun Errors`` =
    { category = CategoryName; counter = "Serial Overrun Errors"; instance = None }
  /// Timeout Errors: The total number of Timeout Errors for this connection.  Timeout Errors occur when an expected is not received in time.
  let ``Timeout Errors`` =
    { category = CategoryName; counter = "Timeout Errors"; instance = None }
  /// Total Connections: The total number of Remote Access connections.
  let ``Total Connections`` =
    { category = CategoryName; counter = "Total Connections"; instance = None }
  /// Total Errors: The total number of CRC, Timeout, Serial Overrun, Alignment, and Buffer Overrun Errors for this connection.
  let ``Total Errors`` =
    { category = CategoryName; counter = "Total Errors"; instance = None }
  /// Total Errors/Sec: The total number of CRC, Timeout, Serial Overrun, Alignment, and Buffer Overrun Errors per second.
  let ``Total Errors/Sec`` =
    { category = CategoryName; counter = "Total Errors/Sec"; instance = None }

  let allCounters =
    [| ``Alignment Errors``
       ``Buffer Overrun Errors``
       ``Bytes Received``
       ``Bytes Received/Sec``
       ``Bytes Transmitted``
       ``Bytes Transmitted/Sec``
       ``CRC Errors``
       ``Frames Received``
       ``Frames Received/Sec``
       ``Frames Transmitted``
       ``Frames Transmitted/Sec``
       ``Percent Compression In``
       ``Percent Compression Out``
       ``Serial Overrun Errors``
       ``Timeout Errors``
       ``Total Connections``
       ``Total Errors``
       ``Total Errors/Sec``
    |]

/// ReadyBoost Cache: Displays performance statistics about ReadyBoost Caches.
///
/// This performance counter does not have instance based counters
module ``ReadyBoost Cache`` =

  [<Literal>]
  let CategoryName = "ReadyBoost Cache"

  let PCC = Category.create CategoryName
  /// Bytes cached: The total (uncompressed) amount of data currently stored in ReadyBoost caches.
  let ``Bytes cached`` =
    { category = CategoryName; counter = "Bytes cached"; instance = None }
  /// Cache read bytes/sec: Bytes of I/Os satisfied from ReadyBoost caches per second.
  let ``Cache read bytes/sec`` =
    { category = CategoryName; counter = "Cache read bytes/sec"; instance = None }
  /// Cache reads/sec: Number of I/Os satisfied from ReadyBoost caches per second.
  let ``Cache reads/sec`` =
    { category = CategoryName; counter = "Cache reads/sec"; instance = None }
  /// Cache space used: Amount of space in bytes taken by data cached in ReadyBoost caches.
  let ``Cache space used`` =
    { category = CategoryName; counter = "Cache space used"; instance = None }
  /// Compression Ratio: (Cache space used) / (Bytes cached)
  let ``Compression Ratio`` =
    { category = CategoryName; counter = "Compression Ratio"; instance = None }
  /// Skipped read bytes/sec: Bytes of read I/Os ignored by ReadyBoost due to policy.
  let ``Skipped read bytes/sec`` =
    { category = CategoryName; counter = "Skipped read bytes/sec"; instance = None }
  /// Skipped reads/sec: Number of read I/Os ignored by ReadyBoost due to policy.
  let ``Skipped reads/sec`` =
    { category = CategoryName; counter = "Skipped reads/sec"; instance = None }
  /// Total cache size bytes: Total size, in bytes, of all caches regardless of how much data they contain.
  let ``Total cache size bytes`` =
    { category = CategoryName; counter = "Total cache size bytes"; instance = None }
  /// Total read bytes/sec: Bytes of read I/Os that are received by ReadyBoost. This counter includes all reads whether or not they were satisfied by ReadyBoost caches.
  let ``Total read bytes/sec`` =
    { category = CategoryName; counter = "Total read bytes/sec"; instance = None }
  /// Total reads/sec: Number of read I/Os that are received by ReadyBoost. This counter includes all reads whether or not they were satisfied by ReadyBoost caches.
  let ``Total reads/sec`` =
    { category = CategoryName; counter = "Total reads/sec"; instance = None }

  let allCounters =
    [| ``Bytes cached``
       ``Cache read bytes/sec``
       ``Cache reads/sec``
       ``Cache space used``
       ``Compression Ratio``
       ``Skipped read bytes/sec``
       ``Skipped reads/sec``
       ``Total cache size bytes``
       ``Total read bytes/sec``
       ``Total reads/sec``
    |]

/// Redirector: The Redirector performance object consists of counter that monitor network connections originating at the local computer.
///
/// This performance counter does not have instance based counters
module ``Redirector`` =

  [<Literal>]
  let CategoryName = "Redirector"

  let PCC = Category.create CategoryName
  /// Bytes Received/sec: Bytes Received/sec is the rate of bytes coming in to the Redirector from the network.  It includes all application data as well as network protocol information (such as packet headers).
  let ``Bytes Received/sec`` =
    { category = CategoryName; counter = "Bytes Received/sec"; instance = None }
  /// Bytes Total/sec: Bytes Total/sec is the rate the Redirector is processing data bytes.  This includes all application and file data in addition to protocol information such as packet headers.
  let ``Bytes Total/sec`` =
    { category = CategoryName; counter = "Bytes Total/sec"; instance = None }
  /// Bytes Transmitted/sec: Bytes Transmitted/sec is the rate at which bytes are leaving the Redirector to the network.  It includes all application data as well as network protocol information (such as packet headers and the like).
  let ``Bytes Transmitted/sec`` =
    { category = CategoryName; counter = "Bytes Transmitted/sec"; instance = None }
  /// Connects Core: Connects Core counts the number of connections you have to servers running the original MS-Net SMB protocol, including MS-Net itself and Xenix and VAX's.
  let ``Connects Core`` =
    { category = CategoryName; counter = "Connects Core"; instance = None }
  /// Connects Lan Manager 2.0: Connects LAN Manager 2.0 counts connections to LAN Manager 2.0 servers, including LMX servers.
  let ``Connects Lan Manager 2.0`` =
    { category = CategoryName; counter = "Connects Lan Manager 2.0"; instance = None }
  /// Connects Lan Manager 2.1: Connects LAN Manager 2.1 counts connections to LAN Manager 2.1 servers, including LMX servers.
  let ``Connects Lan Manager 2.1`` =
    { category = CategoryName; counter = "Connects Lan Manager 2.1"; instance = None }
  /// Connects Windows NT: Connects Windows NT counts the connections to Windows 2000 or earlier computers.
  let ``Connects Windows NT`` =
    { category = CategoryName; counter = "Connects Windows NT"; instance = None }
  /// Current Commands: Current Commands counter indicates the number of pending commands from the local computer to all destination servers.  If the Current Commands counter shows a high number and the local computer is idle, this may indicate a network-related problem or a redirector bottleneck on the local computer.
  let ``Current Commands`` =
    { category = CategoryName; counter = "Current Commands"; instance = None }
  /// File Data Operations/sec: File Data Operations/sec is the rate at which the Redirector is processing data operations. One operation should include many bytes, since each operation has overhead. The efficiency of this path can be determined by dividing the Bytes/sec by this counter to obtain the average number of bytes transferred per operation.
  let ``File Data Operations/sec`` =
    { category = CategoryName; counter = "File Data Operations/sec"; instance = None }
  /// File Read Operations/sec: File Read Operations/sec is the rate at which applications are asking the Redirector for data. Each call to a file system or similar Application Program Interface (API) call counts as one operation.
  let ``File Read Operations/sec`` =
    { category = CategoryName; counter = "File Read Operations/sec"; instance = None }
  /// File Write Operations/sec: File Write Operations/sec is the rate at which applications are sending data to the Redirector. Each call to a file system or similar Application Program Interface (API) call counts as one operation.
  let ``File Write Operations/sec`` =
    { category = CategoryName; counter = "File Write Operations/sec"; instance = None }
  /// Network Errors/sec: Network Errors/sec is the rate at which serious unexpected errors are occurring. Such errors generally indicate that the Redirector and one or more Servers are having serious communication difficulties. For example an SMB (Server Message Block) protocol error is a Network Error. An entry is written to the System Event Log and provide details.
  let ``Network Errors/sec`` =
    { category = CategoryName; counter = "Network Errors/sec"; instance = None }
  /// Packets Received/sec: Packets Received/sec is the rate at which the Redirector is receiving packets (also called SMBs or Server Message Blocks).  Network transmissions are divided into packets.  The average number of bytes received in a packet can be obtained by dividing Bytes Received/sec by this counter.  Some packets received might not contain incoming data (for example an acknowledgment to a write made by the Redirector would count as an incoming packet).
  let ``Packets Received/sec`` =
    { category = CategoryName; counter = "Packets Received/sec"; instance = None }
  /// Packets Transmitted/sec: Packets Transmitted/sec is the rate at which the Redirector is sending packets (also called SMBs or Server Message Blocks).  Network transmissions are divided into packets.  The average number of bytes transmitted in a packet can be obtained by dividing Bytes Transmitted/sec by this counter.
  let ``Packets Transmitted/sec`` =
    { category = CategoryName; counter = "Packets Transmitted/sec"; instance = None }
  /// Packets/sec: Packets/sec is the rate the Redirector is processing data packets.  One packet includes (hopefully) many bytes.  We say hopefully here because each packet has protocol overhead.  You can determine the efficiency of this path by dividing the Bytes/sec by this counter to determine the average number of bytes transferred/packet.  You can also divide this counter by Operations/sec to determine the average number of packets per operation, another measure of efficiency.
  let ``Packets/sec`` =
    { category = CategoryName; counter = "Packets/sec"; instance = None }
  /// Read Bytes Cache/sec: Read Bytes Cache/sec is the rate at which applications are accessing the file system cache by using the Redirector.  Some of these data requests are satisfied by retrieving the data from the cache.  Requests that miss the Cache cause a page fault (see Read Bytes Paging/sec).
  let ``Read Bytes Cache/sec`` =
    { category = CategoryName; counter = "Read Bytes Cache/sec"; instance = None }
  /// Read Bytes Network/sec: Read Bytes Network/sec is the rate at which applications are reading data across the network. This occurs when data sought in the file system cache is not found there and must be retrieved from the network.  Dividing this value by Bytes Received/sec indicates the proportion of application data traveling across the network. (see Bytes Received/sec).
  let ``Read Bytes Network/sec`` =
    { category = CategoryName; counter = "Read Bytes Network/sec"; instance = None }
  /// Read Bytes Non-Paging/sec: Read Bytes Non-Paging/sec are those bytes read by the Redirector in response to normal file requests by an application when they are redirected to come from another computer.  In addition to file requests, this counter includes other methods of reading across the network such as Named Pipes and Transactions.  This counter does not count network protocol information, just application data.
  let ``Read Bytes Non-Paging/sec`` =
    { category = CategoryName; counter = "Read Bytes Non-Paging/sec"; instance = None }
  /// Read Bytes Paging/sec: Read Bytes Paging/sec is the rate at which the Redirector is attempting to read bytes in response to page faults.  Page faults are caused by loading of modules (such as programs and libraries), by a miss in the Cache (see Read Bytes Cache/sec), or by files directly mapped into the address space of applications (a high-performance feature of Windows NT).
  let ``Read Bytes Paging/sec`` =
    { category = CategoryName; counter = "Read Bytes Paging/sec"; instance = None }
  /// Read Operations Random/sec: Read Operations Random/sec counts the rate at which, on a file-by-file basis, reads are made that are not sequential.  If a read is made using a particular file handle, and then is followed by another read that is not immediately the contiguous next byte, this counter is incremented by one.
  let ``Read Operations Random/sec`` =
    { category = CategoryName; counter = "Read Operations Random/sec"; instance = None }
  /// Read Packets Small/sec: Read Packets Small/sec is the rate at which reads less than one-fourth of the server's negotiated buffer size are made by applications.  Too many of these could indicate a waste of buffers on the server.  This counter is incremented once for each read. It does not count packets.
  let ``Read Packets Small/sec`` =
    { category = CategoryName; counter = "Read Packets Small/sec"; instance = None }
  /// Read Packets/sec: Read Packets/sec is the rate at which read packets are being placed on the network.  Each time a single packet is sent with a request to read data remotely, this counter is incremented by one.
  let ``Read Packets/sec`` =
    { category = CategoryName; counter = "Read Packets/sec"; instance = None }
  /// Reads Denied/sec: Reads Denied/sec is the rate at which the server is unable to accommodate requests for Raw Reads.  When a read is much larger than the server's negotiated buffer size, the Redirector requests a Raw Read which, if granted, would permit the transfer of the data without lots of protocol overhead on each packet.  To accomplish this the server must lock out other requests, so the request is denied if the server is really busy.
  let ``Reads Denied/sec`` =
    { category = CategoryName; counter = "Reads Denied/sec"; instance = None }
  /// Reads Large/sec: Reads Large/sec is the rate at which reads over 2 times the server's negotiated buffer size are made by applications.  Too many of these could place a strain on server resources.  This counter is incremented once for each read. It does not count packets.
  let ``Reads Large/sec`` =
    { category = CategoryName; counter = "Reads Large/sec"; instance = None }
  /// Server Disconnects: Server Disconnects counts the number of times a Server has disconnected your Redirector.  See also Server Reconnects.
  let ``Server Disconnects`` =
    { category = CategoryName; counter = "Server Disconnects"; instance = None }
  /// Server Reconnects: Server Reconnects counts the number of times your Redirector has had to reconnect to a server in order to complete a new active request.  You can be disconnected by the Server if you remain inactive for too long.  Locally even if all your remote files are closed, the Redirector will keep your connections intact for (nominally) ten minutes.  Such inactive connections are called Dormant Connections.  Reconnecting is expensive in time.
  let ``Server Reconnects`` =
    { category = CategoryName; counter = "Server Reconnects"; instance = None }
  /// Server Sessions: Server Sessions counts the total number of security objects the Redirector has managed.  For example, a logon to a server followed by a network access to the same server will establish one connection, but two sessions.
  let ``Server Sessions`` =
    { category = CategoryName; counter = "Server Sessions"; instance = None }
  /// Server Sessions Hung: Server Sessions Hung counts the number of active sessions that are timed out and unable to proceed due to a lack of response from the remote server.
  let ``Server Sessions Hung`` =
    { category = CategoryName; counter = "Server Sessions Hung"; instance = None }
  /// Write Bytes Cache/sec: Write Bytes Cache/sec is the rate at which applications on your computer are writing to the file system cache by using the Redirector.  The data might not leave your computer immediately; it can be retained in the cache for further modification before being written to the network.  This saves network traffic.  Each write of a byte into the cache is counted here.
  let ``Write Bytes Cache/sec`` =
    { category = CategoryName; counter = "Write Bytes Cache/sec"; instance = None }
  /// Write Bytes Network/sec: Write Bytes Network/sec is the rate at which applications are writing data across the network. This occurs when the file system cache is bypassed, such as for Named Pipes or Transactions, or when the cache writes the bytes to disk to make room for other data.  Dividing this counter by Bytes Transmitted/sec will indicate the proportion of application data being to the network (see Transmitted Bytes/sec).
  let ``Write Bytes Network/sec`` =
    { category = CategoryName; counter = "Write Bytes Network/sec"; instance = None }
  /// Write Bytes Non-Paging/sec: Write Bytes Non-Paging/sec is the rate at which bytes are written by the Redirector in response to normal file outputs by an application when they are redirected to another computer.  In addition to file requests, this count includes other methods of writing across the network, such as Named Pipes and Transactions.  This counter does not count network protocol information, just application data.
  let ``Write Bytes Non-Paging/sec`` =
    { category = CategoryName; counter = "Write Bytes Non-Paging/sec"; instance = None }
  /// Write Bytes Paging/sec: Write Bytes Paging/sec is the rate at which the Redirector is attempting to write bytes changed in the pages being used by applications.  The program data changed by modules (such as programs and libraries) that were loaded over the network are 'paged out' when no longer needed.  Other output pages come from the file system cache (see Write Bytes Cache/sec).
  let ``Write Bytes Paging/sec`` =
    { category = CategoryName; counter = "Write Bytes Paging/sec"; instance = None }
  /// Write Operations Random/sec: Write Operations Random/sec is the rate at which, on a file-by-file basis, writes are made that are not sequential.  If a write is made using a particular file handle, and then is followed by another write that is not immediately the next contiguous byte, this counter is incremented by one.
  let ``Write Operations Random/sec`` =
    { category = CategoryName; counter = "Write Operations Random/sec"; instance = None }
  /// Write Packets Small/sec: Write Packets Small/sec is the rate at which writes are made by applications that are less than one-fourth of the server's negotiated buffer size.  Too many of these could indicate a waste of buffers on the server.  This counter is incremented once for each write: it counts writes, not packets.
  let ``Write Packets Small/sec`` =
    { category = CategoryName; counter = "Write Packets Small/sec"; instance = None }
  /// Write Packets/sec: Write Packets/sec is the rate at which writes are being sent to the network.  Each time a single packet is sent with a request to write remote data, this counter is incremented by one.
  let ``Write Packets/sec`` =
    { category = CategoryName; counter = "Write Packets/sec"; instance = None }
  /// Writes Denied/sec: Writes Denied/sec is the rate at which the server is unable to accommodate requests for Raw Writes.  When a write is much larger than the server's negotiated buffer size, the Redirector requests a Raw Write which, if granted, would permit the transfer of the data without lots of protocol overhead on each packet.  To accomplish this the server must lock out other requests, so the request is denied if the server is really busy.
  let ``Writes Denied/sec`` =
    { category = CategoryName; counter = "Writes Denied/sec"; instance = None }
  /// Writes Large/sec: Writes Large/sec is the rate at which writes are made by applications that are over 2 times the server's negotiated buffer size.  Too many of these could place a strain on server resources.  This counter is incremented once for each write: it counts writes, not packets.
  let ``Writes Large/sec`` =
    { category = CategoryName; counter = "Writes Large/sec"; instance = None }

  let allCounters =
    [| ``Bytes Received/sec``
       ``Bytes Total/sec``
       ``Bytes Transmitted/sec``
       ``Connects Core``
       ``Connects Lan Manager 2.0``
       ``Connects Lan Manager 2.1``
       ``Connects Windows NT``
       ``Current Commands``
       ``File Data Operations/sec``
       ``File Read Operations/sec``
       ``File Write Operations/sec``
       ``Network Errors/sec``
       ``Packets Received/sec``
       ``Packets Transmitted/sec``
       ``Packets/sec``
       ``Read Bytes Cache/sec``
       ``Read Bytes Network/sec``
       ``Read Bytes Non-Paging/sec``
       ``Read Bytes Paging/sec``
       ``Read Operations Random/sec``
       ``Read Packets Small/sec``
       ``Read Packets/sec``
       ``Reads Denied/sec``
       ``Reads Large/sec``
       ``Server Disconnects``
       ``Server Reconnects``
       ``Server Sessions``
       ``Server Sessions Hung``
       ``Write Bytes Cache/sec``
       ``Write Bytes Network/sec``
       ``Write Bytes Non-Paging/sec``
       ``Write Bytes Paging/sec``
       ``Write Operations Random/sec``
       ``Write Packets Small/sec``
       ``Write Packets/sec``
       ``Writes Denied/sec``
       ``Writes Large/sec``
    |]

/// RemoteFX Graphics: The RemoteFX encoding performance object consists of counters that measure the performance of RemoteFX graphics encoding
///
/// This performance counter does not have instance based counters
module ``RemoteFX Graphics`` =

  [<Literal>]
  let CategoryName = "RemoteFX Graphics"

  let PCC = Category.create CategoryName
  /// Average Encoding Time: -
  let ``Average Encoding Time`` instance =
    { category = CategoryName; counter = "Average Encoding Time"; instance = instance }
  /// Frame Quality: -
  let ``Frame Quality`` instance =
    { category = CategoryName; counter = "Frame Quality"; instance = instance }
  /// Frames Skipped/Second - Insufficient Client Resources: -
  let ``Frames Skipped/Second - Insufficient Client Resources`` instance =
    { category = CategoryName; counter = "Frames Skipped/Second - Insufficient Client Resources"; instance = instance }
  /// Frames Skipped/Second - Insufficient Network Resources: -
  let ``Frames Skipped/Second - Insufficient Network Resources`` instance =
    { category = CategoryName; counter = "Frames Skipped/Second - Insufficient Network Resources"; instance = instance }
  /// Frames Skipped/Second - Insufficient Server Resources: -
  let ``Frames Skipped/Second - Insufficient Server Resources`` instance =
    { category = CategoryName; counter = "Frames Skipped/Second - Insufficient Server Resources"; instance = instance }
  /// Graphics Compression ratio: -
  let ``Graphics Compression ratio`` instance =
    { category = CategoryName; counter = "Graphics Compression ratio"; instance = instance }
  /// Input Frames/Second: -
  let ``Input Frames/Second`` instance =
    { category = CategoryName; counter = "Input Frames/Second"; instance = instance }
  /// Output Frames/Second: -
  let ``Output Frames/Second`` instance =
    { category = CategoryName; counter = "Output Frames/Second"; instance = instance }
  /// Source Frames/Second: -
  let ``Source Frames/Second`` instance =
    { category = CategoryName; counter = "Source Frames/Second"; instance = instance }

  let allCounters =
    [| ``Average Encoding Time``
       ``Frame Quality``
       ``Frames Skipped/Second - Insufficient Client Resources``
       ``Frames Skipped/Second - Insufficient Network Resources``
       ``Frames Skipped/Second - Insufficient Server Resources``
       ``Graphics Compression ratio``
       ``Input Frames/Second``
       ``Output Frames/Second``
       ``Source Frames/Second``
    |]

/// RemoteFX Network: This is counter set for the per session RemoteFX network counters
///
/// This performance counter does not have instance based counters
module ``RemoteFX Network`` =

  [<Literal>]
  let CategoryName = "RemoteFX Network"

  let PCC = Category.create CategoryName
  /// Base TCP RTT: -
  let ``Base TCP RTT`` instance =
    { category = CategoryName; counter = "Base TCP RTT"; instance = instance }
  /// Base UDP RTT: -
  let ``Base UDP RTT`` instance =
    { category = CategoryName; counter = "Base UDP RTT"; instance = instance }
  /// Current TCP Bandwidth: -
  let ``Current TCP Bandwidth`` instance =
    { category = CategoryName; counter = "Current TCP Bandwidth"; instance = instance }
  /// Current TCP RTT: -
  let ``Current TCP RTT`` instance =
    { category = CategoryName; counter = "Current TCP RTT"; instance = instance }
  /// Current UDP Bandwidth: -
  let ``Current UDP Bandwidth`` instance =
    { category = CategoryName; counter = "Current UDP Bandwidth"; instance = instance }
  /// Current UDP RTT: -
  let ``Current UDP RTT`` instance =
    { category = CategoryName; counter = "Current UDP RTT"; instance = instance }
  /// FEC Rate: -
  let ``FEC Rate`` instance =
    { category = CategoryName; counter = "FEC Rate"; instance = instance }
  /// Loss Rate: -
  let ``Loss Rate`` instance =
    { category = CategoryName; counter = "Loss Rate"; instance = instance }
  /// Retransmission Rate: -
  let ``Retransmission Rate`` instance =
    { category = CategoryName; counter = "Retransmission Rate"; instance = instance }
  /// Sent Rate P0: -
  let ``Sent Rate P0`` instance =
    { category = CategoryName; counter = "Sent Rate P0"; instance = instance }
  /// Sent Rate P1: -
  let ``Sent Rate P1`` instance =
    { category = CategoryName; counter = "Sent Rate P1"; instance = instance }
  /// Sent Rate P2: -
  let ``Sent Rate P2`` instance =
    { category = CategoryName; counter = "Sent Rate P2"; instance = instance }
  /// Sent Rate P3: -
  let ``Sent Rate P3`` instance =
    { category = CategoryName; counter = "Sent Rate P3"; instance = instance }
  /// TCP Received Rate: -
  let ``TCP Received Rate`` instance =
    { category = CategoryName; counter = "TCP Received Rate"; instance = instance }
  /// TCP Sent Rate: -
  let ``TCP Sent Rate`` instance =
    { category = CategoryName; counter = "TCP Sent Rate"; instance = instance }
  /// Total Received Bytes: -
  let ``Total Received Bytes`` instance =
    { category = CategoryName; counter = "Total Received Bytes"; instance = instance }
  /// Total Received Rate: -
  let ``Total Received Rate`` instance =
    { category = CategoryName; counter = "Total Received Rate"; instance = instance }
  /// Total Sent Bytes: -
  let ``Total Sent Bytes`` instance =
    { category = CategoryName; counter = "Total Sent Bytes"; instance = instance }
  /// Total Sent Rate: -
  let ``Total Sent Rate`` instance =
    { category = CategoryName; counter = "Total Sent Rate"; instance = instance }
  /// UDP Packets Received/sec: -
  let ``UDP Packets Received/sec`` instance =
    { category = CategoryName; counter = "UDP Packets Received/sec"; instance = instance }
  /// UDP Packets Sent/sec: -
  let ``UDP Packets Sent/sec`` instance =
    { category = CategoryName; counter = "UDP Packets Sent/sec"; instance = instance }
  /// UDP Received Rate: -
  let ``UDP Received Rate`` instance =
    { category = CategoryName; counter = "UDP Received Rate"; instance = instance }
  /// UDP Sent Rate: -
  let ``UDP Sent Rate`` instance =
    { category = CategoryName; counter = "UDP Sent Rate"; instance = instance }

  let allCounters =
    [| ``Base TCP RTT``
       ``Base UDP RTT``
       ``Current TCP Bandwidth``
       ``Current TCP RTT``
       ``Current UDP Bandwidth``
       ``Current UDP RTT``
       ``FEC Rate``
       ``Loss Rate``
       ``Retransmission Rate``
       ``Sent Rate P0``
       ``Sent Rate P1``
       ``Sent Rate P2``
       ``Sent Rate P3``
       ``TCP Received Rate``
       ``TCP Sent Rate``
       ``Total Received Bytes``
       ``Total Received Rate``
       ``Total Sent Bytes``
       ``Total Sent Rate``
       ``UDP Packets Received/sec``
       ``UDP Packets Sent/sec``
       ``UDP Received Rate``
       ``UDP Sent Rate``
    |]

/// RemoteFX Root GPU Management: Displays RemoteFX Root GPU Management Counters
///
/// This performance counter does not have non-instance based counters
module ``RemoteFX Root GPU Management`` =

  [<Literal>]
  let CategoryName = "RemoteFX Root GPU Management"

  let PCC = Category.create CategoryName
  /// Resources: VMs running RemoteFX: Count of virtual machines that have the RemoteFX 3D adapter installed.
  let ``Resources: VMs running RemoteFX`` instance =
    { category = CategoryName; counter = "Resources: VMs running RemoteFX"; instance = instance }
  /// VRAM: Available MB per GPU: Amount of dedicated VRAM that is unused.
  let ``VRAM: Available MB per GPU`` instance =
    { category = CategoryName; counter = "VRAM: Available MB per GPU"; instance = instance }
  /// VRAM: Reserved  % per GPU: Percent of dedicated VRAM that has been reserved for RemoteFX.
  let ``VRAM: Reserved  % per GPU`` instance =
    { category = CategoryName; counter = "VRAM: Reserved  % per GPU"; instance = instance }

  let allCounters =
    [| ``Resources: VMs running RemoteFX``
       ``VRAM: Available MB per GPU``
       ``VRAM: Reserved  % per GPU``
    |]

/// RemoteFX Software: Displays RemoteFX software per-session counters
///
/// This performance counter does not have instance based counters
module ``RemoteFX Software`` =

  [<Literal>]
  let CategoryName = "RemoteFX Software"

  let PCC = Category.create CategoryName
  /// Capture Rate for monitor 1: -
  let ``Capture Rate for monitor 1`` instance =
    { category = CategoryName; counter = "Capture Rate for monitor 1"; instance = instance }
  /// Capture Rate for monitor 2: -
  let ``Capture Rate for monitor 2`` instance =
    { category = CategoryName; counter = "Capture Rate for monitor 2"; instance = instance }
  /// Capture Rate for monitor 3: -
  let ``Capture Rate for monitor 3`` instance =
    { category = CategoryName; counter = "Capture Rate for monitor 3"; instance = instance }
  /// Capture Rate for monitor 4: -
  let ``Capture Rate for monitor 4`` instance =
    { category = CategoryName; counter = "Capture Rate for monitor 4"; instance = instance }
  /// Capture Rate for monitor 5: -
  let ``Capture Rate for monitor 5`` instance =
    { category = CategoryName; counter = "Capture Rate for monitor 5"; instance = instance }
  /// Capture Rate for monitor 6: -
  let ``Capture Rate for monitor 6`` instance =
    { category = CategoryName; counter = "Capture Rate for monitor 6"; instance = instance }
  /// Capture Rate for monitor 7: -
  let ``Capture Rate for monitor 7`` instance =
    { category = CategoryName; counter = "Capture Rate for monitor 7"; instance = instance }
  /// Capture Rate for monitor 8: -
  let ``Capture Rate for monitor 8`` instance =
    { category = CategoryName; counter = "Capture Rate for monitor 8"; instance = instance }
  /// Compression Ratio: -
  let ``Compression Ratio`` instance =
    { category = CategoryName; counter = "Compression Ratio"; instance = instance }
  /// Delayed Frames / sec: -
  let ``Delayed Frames / sec`` instance =
    { category = CategoryName; counter = "Delayed Frames / sec"; instance = instance }
  /// GPU response time from Capture: -
  let ``GPU response time from Capture`` instance =
    { category = CategoryName; counter = "GPU response time from Capture"; instance = instance }
  /// GPU response time from Render: -
  let ``GPU response time from Render`` instance =
    { category = CategoryName; counter = "GPU response time from Render"; instance = instance }
  /// Output Bytes: -
  let ``Output Bytes`` instance =
    { category = CategoryName; counter = "Output Bytes"; instance = instance }
  /// Render rate for monitor 1: -
  let ``Render rate for monitor 1`` instance =
    { category = CategoryName; counter = "Render rate for monitor 1"; instance = instance }
  /// Render rate for monitor 2: -
  let ``Render rate for monitor 2`` instance =
    { category = CategoryName; counter = "Render rate for monitor 2"; instance = instance }
  /// Render rate for monitor 3: -
  let ``Render rate for monitor 3`` instance =
    { category = CategoryName; counter = "Render rate for monitor 3"; instance = instance }
  /// Render rate for monitor 4: -
  let ``Render rate for monitor 4`` instance =
    { category = CategoryName; counter = "Render rate for monitor 4"; instance = instance }
  /// Render rate for monitor 5: -
  let ``Render rate for monitor 5`` instance =
    { category = CategoryName; counter = "Render rate for monitor 5"; instance = instance }
  /// Render rate for monitor 6: -
  let ``Render rate for monitor 6`` instance =
    { category = CategoryName; counter = "Render rate for monitor 6"; instance = instance }
  /// Render rate for monitor 7: -
  let ``Render rate for monitor 7`` instance =
    { category = CategoryName; counter = "Render rate for monitor 7"; instance = instance }
  /// Render rate for monitor 8: -
  let ``Render rate for monitor 8`` instance =
    { category = CategoryName; counter = "Render rate for monitor 8"; instance = instance }
  /// Waiting for client count / sec: -
  let ``Waiting for client count / sec`` instance =
    { category = CategoryName; counter = "Waiting for client count / sec"; instance = instance }

  let allCounters =
    [| ``Capture Rate for monitor 1``
       ``Capture Rate for monitor 2``
       ``Capture Rate for monitor 3``
       ``Capture Rate for monitor 4``
       ``Capture Rate for monitor 5``
       ``Capture Rate for monitor 6``
       ``Capture Rate for monitor 7``
       ``Capture Rate for monitor 8``
       ``Compression Ratio``
       ``Delayed Frames / sec``
       ``GPU response time from Capture``
       ``GPU response time from Render``
       ``Output Bytes``
       ``Render rate for monitor 1``
       ``Render rate for monitor 2``
       ``Render rate for monitor 3``
       ``Render rate for monitor 4``
       ``Render rate for monitor 5``
       ``Render rate for monitor 6``
       ``Render rate for monitor 7``
       ``Render rate for monitor 8``
       ``Waiting for client count / sec``
    |]

/// RemoteFX Synth3D VSC VM Device: Microsoft RemoteFX Synth3D VSC VM Device
///
/// This performance counter does not have instance based counters
module ``RemoteFX Synth3D VSC VM Device`` =

  [<Literal>]
  let CategoryName = "RemoteFX Synth3D VSC VM Device"

  let PCC = Category.create CategoryName
  /// Number of RDVGM restarted notifications: Number of RDVGM restarted notifications
  let ``Number of RDVGM restarted notifications`` =
    { category = CategoryName; counter = "Number of RDVGM restarted notifications"; instance = None }
  /// Number of connected VMT channels: Number of connected VMT channels
  let ``Number of connected VMT channels`` =
    { category = CategoryName; counter = "Number of connected VMT channels"; instance = None }
  /// Number of created VMT channels: Number of created VMT channels
  let ``Number of created VMT channels`` =
    { category = CategoryName; counter = "Number of created VMT channels"; instance = None }
  /// Number of disconnected VMT channels: Number of disconnected VMT channels
  let ``Number of disconnected VMT channels`` =
    { category = CategoryName; counter = "Number of disconnected VMT channels"; instance = None }
  /// Number of waiting VMT channels: Number of waiting VMT channels
  let ``Number of waiting VMT channels`` =
    { category = CategoryName; counter = "Number of waiting VMT channels"; instance = None }
  /// Total number of created VMT channels: Total number of created VMT channels
  let ``Total number of created VMT channels`` =
    { category = CategoryName; counter = "Total number of created VMT channels"; instance = None }

  let allCounters =
    [| ``Number of RDVGM restarted notifications``
       ``Number of connected VMT channels``
       ``Number of created VMT channels``
       ``Number of disconnected VMT channels``
       ``Number of waiting VMT channels``
       ``Total number of created VMT channels``
    |]

/// RemoteFX Synth3D VSC VM Transport Channel: Microsoft RemoteFX Synth3D VSC VM Transport Channel
///
/// This performance counter does not have instance based counters
module ``RemoteFX Synth3D VSC VM Transport Channel`` =

  [<Literal>]
  let CategoryName = "RemoteFX Synth3D VSC VM Transport Channel"

  let PCC = Category.create CategoryName
  /// Number of data available event was reset: -
  let ``Number of data available event was reset`` instance =
    { category = CategoryName; counter = "Number of data available event was reset"; instance = instance }
  /// Number of data available event was reset per second: -
  let ``Number of data available event was reset per second`` instance =
    { category = CategoryName; counter = "Number of data available event was reset per second"; instance = instance }
  /// Number of data available signals received: -
  let ``Number of data available signals received`` instance =
    { category = CategoryName; counter = "Number of data available signals received"; instance = instance }
  /// Number of data available signals received per second: -
  let ``Number of data available signals received per second`` instance =
    { category = CategoryName; counter = "Number of data available signals received per second"; instance = instance }
  /// Number of data available signals sent: -
  let ``Number of data available signals sent`` instance =
    { category = CategoryName; counter = "Number of data available signals sent"; instance = instance }
  /// Number of data available signals sent per second: -
  let ``Number of data available signals sent per second`` instance =
    { category = CategoryName; counter = "Number of data available signals sent per second"; instance = instance }
  /// Number of space available event was reset: -
  let ``Number of space available event was reset`` instance =
    { category = CategoryName; counter = "Number of space available event was reset"; instance = instance }
  /// Number of space available event was reset per second: -
  let ``Number of space available event was reset per second`` instance =
    { category = CategoryName; counter = "Number of space available event was reset per second"; instance = instance }
  /// Number of space available signals received: -
  let ``Number of space available signals received`` instance =
    { category = CategoryName; counter = "Number of space available signals received"; instance = instance }
  /// Number of space available signals received per second: -
  let ``Number of space available signals received per second`` instance =
    { category = CategoryName; counter = "Number of space available signals received per second"; instance = instance }
  /// Number of space available signals sent: -
  let ``Number of space available signals sent`` instance =
    { category = CategoryName; counter = "Number of space available signals sent"; instance = instance }
  /// Number of space available signals sent per second: -
  let ``Number of space available signals sent per second`` instance =
    { category = CategoryName; counter = "Number of space available signals sent per second"; instance = instance }

  let allCounters =
    [| ``Number of data available event was reset``
       ``Number of data available event was reset per second``
       ``Number of data available signals received``
       ``Number of data available signals received per second``
       ``Number of data available signals sent``
       ``Number of data available signals sent per second``
       ``Number of space available event was reset``
       ``Number of space available event was reset per second``
       ``Number of space available signals received``
       ``Number of space available signals received per second``
       ``Number of space available signals sent``
       ``Number of space available signals sent per second``
    |]

/// RemoteFX Synth3D VSP: Microsoft RemoteFX Synth3D VSP
///
/// This performance counter does not have instance based counters
module ``RemoteFX Synth3D VSP`` =

  [<Literal>]
  let CategoryName = "RemoteFX Synth3D VSP"

  let PCC = Category.create CategoryName
  /// Number of created VM devices: Number of created VM devices
  let ``Number of created VM devices`` =
    { category = CategoryName; counter = "Number of created VM devices"; instance = None }

  let allCounters =
    [| ``Number of created VM devices``

    |]

/// RemoteFX Synth3D VSP VM Device: Microsoft RemoteFX Synth3D VSP VM Device
///
/// This performance counter does not have instance based counters
module ``RemoteFX Synth3D VSP VM Device`` =

  [<Literal>]
  let CategoryName = "RemoteFX Synth3D VSP VM Device"

  let PCC = Category.create CategoryName
  /// Number of RDVGM restarted notifications: -
  let ``Number of RDVGM restarted notifications`` instance =
    { category = CategoryName; counter = "Number of RDVGM restarted notifications"; instance = instance }
  /// Number of connected VMT channels: -
  let ``Number of connected VMT channels`` instance =
    { category = CategoryName; counter = "Number of connected VMT channels"; instance = instance }
  /// Number of created VMT channels: -
  let ``Number of created VMT channels`` instance =
    { category = CategoryName; counter = "Number of created VMT channels"; instance = instance }
  /// Number of disconnected VMT channels: -
  let ``Number of disconnected VMT channels`` instance =
    { category = CategoryName; counter = "Number of disconnected VMT channels"; instance = instance }
  /// Number of waiting VMT channels: -
  let ``Number of waiting VMT channels`` instance =
    { category = CategoryName; counter = "Number of waiting VMT channels"; instance = instance }
  /// Total number of created VMT channels: -
  let ``Total number of created VMT channels`` instance =
    { category = CategoryName; counter = "Total number of created VMT channels"; instance = instance }

  let allCounters =
    [| ``Number of RDVGM restarted notifications``
       ``Number of connected VMT channels``
       ``Number of created VMT channels``
       ``Number of disconnected VMT channels``
       ``Number of waiting VMT channels``
       ``Total number of created VMT channels``
    |]

/// RemoteFX Synth3D VSP VM Transport Channel: Microsoft RemoteFX Synth3D VSP VM Transport Channel
///
/// This performance counter does not have instance based counters
module ``RemoteFX Synth3D VSP VM Transport Channel`` =

  [<Literal>]
  let CategoryName = "RemoteFX Synth3D VSP VM Transport Channel"

  let PCC = Category.create CategoryName
  /// Number of data available event was reset: -
  let ``Number of data available event was reset`` instance =
    { category = CategoryName; counter = "Number of data available event was reset"; instance = instance }
  /// Number of data available event was reset per second: -
  let ``Number of data available event was reset per second`` instance =
    { category = CategoryName; counter = "Number of data available event was reset per second"; instance = instance }
  /// Number of data available signals received: -
  let ``Number of data available signals received`` instance =
    { category = CategoryName; counter = "Number of data available signals received"; instance = instance }
  /// Number of data available signals received per second: -
  let ``Number of data available signals received per second`` instance =
    { category = CategoryName; counter = "Number of data available signals received per second"; instance = instance }
  /// Number of data available signals sent: -
  let ``Number of data available signals sent`` instance =
    { category = CategoryName; counter = "Number of data available signals sent"; instance = instance }
  /// Number of data available signals sent per second: -
  let ``Number of data available signals sent per second`` instance =
    { category = CategoryName; counter = "Number of data available signals sent per second"; instance = instance }
  /// Number of space available event was reset: -
  let ``Number of space available event was reset`` instance =
    { category = CategoryName; counter = "Number of space available event was reset"; instance = instance }
  /// Number of space available event was reset per second: -
  let ``Number of space available event was reset per second`` instance =
    { category = CategoryName; counter = "Number of space available event was reset per second"; instance = instance }
  /// Number of space available signals received: -
  let ``Number of space available signals received`` instance =
    { category = CategoryName; counter = "Number of space available signals received"; instance = instance }
  /// Number of space available signals received per second: -
  let ``Number of space available signals received per second`` instance =
    { category = CategoryName; counter = "Number of space available signals received per second"; instance = instance }
  /// Number of space available signals sent: -
  let ``Number of space available signals sent`` instance =
    { category = CategoryName; counter = "Number of space available signals sent"; instance = instance }
  /// Number of space available signals sent per second: -
  let ``Number of space available signals sent per second`` instance =
    { category = CategoryName; counter = "Number of space available signals sent per second"; instance = instance }

  let allCounters =
    [| ``Number of data available event was reset``
       ``Number of data available event was reset per second``
       ``Number of data available signals received``
       ``Number of data available signals received per second``
       ``Number of data available signals sent``
       ``Number of data available signals sent per second``
       ``Number of space available event was reset``
       ``Number of space available event was reset per second``
       ``Number of space available signals received``
       ``Number of space available signals received per second``
       ``Number of space available signals sent``
       ``Number of space available signals sent per second``
    |]

/// ReportServer:Service: Statistics related to SQL Report Server Service
///
/// This performance counter does not have instance based counters
module ``ReportServer:Service`` =

  [<Literal>]
  let CategoryName = "ReportServer:Service"

  let PCC = Category.create CategoryName
  /// Active Connections: Number of connections active against server.
  let ``Active Connections`` =
    { category = CategoryName; counter = "Active Connections"; instance = None }
  /// Bytes Received Total: Number of bytes received.
  let ``Bytes Received Total`` =
    { category = CategoryName; counter = "Bytes Received Total"; instance = None }
  /// Bytes Received/sec: Rate of bytes received per second.
  let ``Bytes Received/sec`` =
    { category = CategoryName; counter = "Bytes Received/sec"; instance = None }
  /// Bytes Sent Total: Number of bytes sent.
  let ``Bytes Sent Total`` =
    { category = CategoryName; counter = "Bytes Sent Total"; instance = None }
  /// Bytes Sent/sec: Rate of bytes sent per second.
  let ``Bytes Sent/sec`` =
    { category = CategoryName; counter = "Bytes Sent/sec"; instance = None }
  /// Errors Total: The total number of errors that occur during the execution of HTTP requests (error codes 400s and 500s).
  let ``Errors Total`` =
    { category = CategoryName; counter = "Errors Total"; instance = None }
  /// Errors/sec: Number of errors that occur during the execution of HTTP requests (error codes 400s and 500s) per second.
  let ``Errors/sec`` =
    { category = CategoryName; counter = "Errors/sec"; instance = None }
  /// Logon Attempts Total: Number of logon attempts for RSWindows* authentication types. Returns 0 for Custom authentication
  let ``Logon Attempts Total`` =
    { category = CategoryName; counter = "Logon Attempts Total"; instance = None }
  /// Logon Attempts/sec: Rate of logon attempts.
  let ``Logon Attempts/sec`` =
    { category = CategoryName; counter = "Logon Attempts/sec"; instance = None }
  /// Logon Successes Total: Number of successful logons for RSWindows* authuentication types. Returns 0 for Custom authentication.
  let ``Logon Successes Total`` =
    { category = CategoryName; counter = "Logon Successes Total"; instance = None }
  /// Logon Successes/sec: Rate of successful logons.
  let ``Logon Successes/sec`` =
    { category = CategoryName; counter = "Logon Successes/sec"; instance = None }
  /// Memory Pressure State: A number from 1-5 indicating the current memory state of the server. 1:No pressure, 2:Low Pressure,3:Medium Pressure,4:High Pressure,5:Exceeded Pressure.
  let ``Memory Pressure State`` =
    { category = CategoryName; counter = "Memory Pressure State"; instance = None }
  /// Memory Shrink Amount: Number of bytes the server requested to shrink.
  let ``Memory Shrink Amount`` =
    { category = CategoryName; counter = "Memory Shrink Amount"; instance = None }
  /// Memory Shrink Notifications/sec: Number of shrink notifications the server issued in the last second. Indicates how often the server believes it is under memory pressure.
  let ``Memory Shrink Notifications/sec`` =
    { category = CategoryName; counter = "Memory Shrink Notifications/sec"; instance = None }
  /// Requests Disconnected: Number of requests that have been disconnected due to a communication failure.
  let ``Requests Disconnected`` =
    { category = CategoryName; counter = "Requests Disconnected"; instance = None }
  /// Requests Executing: Number of requests currently executing.
  let ``Requests Executing`` =
    { category = CategoryName; counter = "Requests Executing"; instance = None }
  /// Requests Not Authorized: Number of requests failing with HTTP 401 error code.
  let ``Requests Not Authorized`` =
    { category = CategoryName; counter = "Requests Not Authorized"; instance = None }
  /// Requests Rejected: Total number of requests not executed because of insufficient server resources. This counter represents the number of requests that return a 503 HTTP status code, indicating that the server is too busy.
  let ``Requests Rejected`` =
    { category = CategoryName; counter = "Requests Rejected"; instance = None }
  /// Requests Total: The total number of requests received by the report server service since service start up.
  let ``Requests Total`` =
    { category = CategoryName; counter = "Requests Total"; instance = None }
  /// Requests/sec: Number of requests executed per second. This represents the current throughput of the application.
  let ``Requests/sec`` =
    { category = CategoryName; counter = "Requests/sec"; instance = None }
  /// Tasks Queued: Tasks Queued represents the number of tasks that are waiting for a thread to become available for processing. Each request made to the report server corresponds to one or more tasks. This counter represents only the number of tasks that are ready for processing; it does not include the number of tasks that are currently running.
  let ``Tasks Queued`` =
    { category = CategoryName; counter = "Tasks Queued"; instance = None }

  let allCounters =
    [| ``Active Connections``
       ``Bytes Received Total``
       ``Bytes Received/sec``
       ``Bytes Sent Total``
       ``Bytes Sent/sec``
       ``Errors Total``
       ``Errors/sec``
       ``Logon Attempts Total``
       ``Logon Attempts/sec``
       ``Logon Successes Total``
       ``Logon Successes/sec``
       ``Memory Pressure State``
       ``Memory Shrink Amount``
       ``Memory Shrink Notifications/sec``
       ``Requests Disconnected``
       ``Requests Executing``
       ``Requests Not Authorized``
       ``Requests Rejected``
       ``Requests Total``
       ``Requests/sec``
       ``Tasks Queued``
    |]

/// ReportServerSharePoint:Service: Statistics related to SQL Report Server Service
///
/// This performance counter does not have instance based counters
module ``ReportServerSharePoint:Service`` =

  [<Literal>]
  let CategoryName = "ReportServerSharePoint:Service"

  let PCC = Category.create CategoryName
  /// Memory Pressure State: -
  let ``Memory Pressure State`` instance =
    { category = CategoryName; counter = "Memory Pressure State"; instance = instance }
  /// Memory Shrink Amount: -
  let ``Memory Shrink Amount`` instance =
    { category = CategoryName; counter = "Memory Shrink Amount"; instance = instance }
  /// Memory Shrink Notifications/Sec: -
  let ``Memory Shrink Notifications/Sec`` instance =
    { category = CategoryName; counter = "Memory Shrink Notifications/Sec"; instance = instance }

  let allCounters =
    [| ``Memory Pressure State``
       ``Memory Shrink Amount``
       ``Memory Shrink Notifications/Sec``
    |]

/// SMB Client Shares: This counter set displays information about server shares that are being accessed by the client using SMB protocol version 2 or higher.
///
/// This performance counter does not have non-instance based counters
module ``SMB Client Shares`` =

  [<Literal>]
  let CategoryName = "SMB Client Shares"

  let PCC = Category.create CategoryName
  /// Avg. Bytes/Read: The average number of bytes per read request.
  let ``Avg. Bytes/Read`` instance =
    { category = CategoryName; counter = "Avg. Bytes/Read"; instance = instance }
  /// Avg. Bytes/Write: The average number of bytes per write request.
  let ``Avg. Bytes/Write`` instance =
    { category = CategoryName; counter = "Avg. Bytes/Write"; instance = instance }
  /// Avg. Data Bytes/Request: The average number of bytes per read or write request.
  let ``Avg. Data Bytes/Request`` instance =
    { category = CategoryName; counter = "Avg. Data Bytes/Request"; instance = instance }
  /// Avg. Data Queue Length: The average number of both read and write requests that were queued for this share.
  let ``Avg. Data Queue Length`` instance =
    { category = CategoryName; counter = "Avg. Data Queue Length"; instance = instance }
  /// Avg. Read Queue Length: The average number of read requests that were queued for this share.
  let ``Avg. Read Queue Length`` instance =
    { category = CategoryName; counter = "Avg. Read Queue Length"; instance = instance }
  /// Avg. Write Queue Length: The average number of write requests that were queued for this share.
  let ``Avg. Write Queue Length`` instance =
    { category = CategoryName; counter = "Avg. Write Queue Length"; instance = instance }
  /// Avg. sec/Data Request: The average latency between the time a read or write request is sent and when its response is received.
  let ``Avg. sec/Data Request`` instance =
    { category = CategoryName; counter = "Avg. sec/Data Request"; instance = instance }
  /// Avg. sec/Read: The average latency between the time a read request is sent and when its response is received.
  let ``Avg. sec/Read`` instance =
    { category = CategoryName; counter = "Avg. sec/Read"; instance = instance }
  /// Avg. sec/Write: The average latency between the time a write request is sent and when its response is received.
  let ``Avg. sec/Write`` instance =
    { category = CategoryName; counter = "Avg. sec/Write"; instance = instance }
  /// Credit Stalls/sec: The number of requests per second delayed based on insufficient credits for this share.
  let ``Credit Stalls/sec`` instance =
    { category = CategoryName; counter = "Credit Stalls/sec"; instance = instance }
  /// Current Data Queue Length: The current number of read or write requests outstanding on this share.
  let ``Current Data Queue Length`` instance =
    { category = CategoryName; counter = "Current Data Queue Length"; instance = instance }
  /// Data Bytes/sec: The rate at which bytes are being read or written to this share.
  let ``Data Bytes/sec`` instance =
    { category = CategoryName; counter = "Data Bytes/sec"; instance = instance }
  /// Data Requests/sec: The rate at which read or write requests are being sent to this share.
  let ``Data Requests/sec`` instance =
    { category = CategoryName; counter = "Data Requests/sec"; instance = instance }
  /// Metadata Requests/sec: The rate at which metadata requests are being sent to this share.
  let ``Metadata Requests/sec`` instance =
    { category = CategoryName; counter = "Metadata Requests/sec"; instance = instance }
  /// Read Bytes/sec: The rate at which bytes are being read from this share.
  let ``Read Bytes/sec`` instance =
    { category = CategoryName; counter = "Read Bytes/sec"; instance = instance }
  /// Read Requests/sec: The rate at which read requests are being sent to this share.
  let ``Read Requests/sec`` instance =
    { category = CategoryName; counter = "Read Requests/sec"; instance = instance }
  /// Write Bytes/sec: The rate at which bytes are being written to this share.
  let ``Write Bytes/sec`` instance =
    { category = CategoryName; counter = "Write Bytes/sec"; instance = instance }
  /// Write Requests/sec: The rate at which write requests are being sent to this share.
  let ``Write Requests/sec`` instance =
    { category = CategoryName; counter = "Write Requests/sec"; instance = instance }

  let allCounters =
    [| ``Avg. Bytes/Read``
       ``Avg. Bytes/Write``
       ``Avg. Data Bytes/Request``
       ``Avg. Data Queue Length``
       ``Avg. Read Queue Length``
       ``Avg. Write Queue Length``
       ``Avg. sec/Data Request``
       ``Avg. sec/Read``
       ``Avg. sec/Write``
       ``Credit Stalls/sec``
       ``Current Data Queue Length``
       ``Data Bytes/sec``
       ``Data Requests/sec``
       ``Metadata Requests/sec``
       ``Read Bytes/sec``
       ``Read Requests/sec``
       ``Write Bytes/sec``
       ``Write Requests/sec``
    |]

/// SMB Server: The SMB Server performance counters measure file server activity for SMB protocol versions 2 and higher
///
/// This performance counter does not have instance based counters
module ``SMB Server`` =

  [<Literal>]
  let CategoryName = "SMB Server"

  let PCC = Category.create CategoryName
  /// Read Bytes/sec: Read Bytes/sec is the rate at which data is being read to satisfy SMB read requests.
  let ``Read Bytes/sec`` =
    { category = CategoryName; counter = "Read Bytes/sec"; instance = None }
  /// Read Requests/sec: Read Requests/sec is the rate at which SMB read requests are being received.
  let ``Read Requests/sec`` =
    { category = CategoryName; counter = "Read Requests/sec"; instance = None }
  /// Receive Bytes/sec: Receive Bytes/sec is the rate at which data is being received from the network. This value includes application data as well as SMB protocol data (such as packet headers).
  let ``Receive Bytes/sec`` =
    { category = CategoryName; counter = "Receive Bytes/sec"; instance = None }
  /// Send Bytes/sec: Send Bytes/sec is the rate at which data is being transmitted on the network. This value includes application data as well as SMB protocol data (such as packet headers).
  let ``Send Bytes/sec`` =
    { category = CategoryName; counter = "Send Bytes/sec"; instance = None }
  /// Write Bytes/sec: Write Bytes/sec is the rate at which data is being written to satisfy SMB write requests.
  let ``Write Bytes/sec`` =
    { category = CategoryName; counter = "Write Bytes/sec"; instance = None }
  /// Write Requests/sec: Write Requests/sec is the rate at which SMB write requests are being received.
  let ``Write Requests/sec`` =
    { category = CategoryName; counter = "Write Requests/sec"; instance = None }

  let allCounters =
    [| ``Read Bytes/sec``
       ``Read Requests/sec``
       ``Receive Bytes/sec``
       ``Send Bytes/sec``
       ``Write Bytes/sec``
       ``Write Requests/sec``
    |]

/// SMB Server Sessions: This counter set displays information about SMB server sessions using SMB protocol version 2 or higher
///
/// This performance counter does not have instance based counters
module ``SMB Server Sessions`` =

  [<Literal>]
  let CategoryName = "SMB Server Sessions"

  let PCC = Category.create CategoryName
  /// % Persistent Handles: -
  let ``% Persistent Handles`` instance =
    { category = CategoryName; counter = "% Persistent Handles"; instance = instance }
  /// % Resilient Handles: -
  let ``% Resilient Handles`` instance =
    { category = CategoryName; counter = "% Resilient Handles"; instance = instance }
  /// Avg. Bytes/Read: -
  let ``Avg. Bytes/Read`` instance =
    { category = CategoryName; counter = "Avg. Bytes/Read"; instance = instance }
  /// Avg. Bytes/Write: -
  let ``Avg. Bytes/Write`` instance =
    { category = CategoryName; counter = "Avg. Bytes/Write"; instance = instance }
  /// Avg. Data Bytes/Request: -
  let ``Avg. Data Bytes/Request`` instance =
    { category = CategoryName; counter = "Avg. Data Bytes/Request"; instance = instance }
  /// Avg. Data Queue Length: -
  let ``Avg. Data Queue Length`` instance =
    { category = CategoryName; counter = "Avg. Data Queue Length"; instance = instance }
  /// Avg. Read Queue Length: -
  let ``Avg. Read Queue Length`` instance =
    { category = CategoryName; counter = "Avg. Read Queue Length"; instance = instance }
  /// Avg. Write Queue Length: -
  let ``Avg. Write Queue Length`` instance =
    { category = CategoryName; counter = "Avg. Write Queue Length"; instance = instance }
  /// Avg. sec/Data Request: -
  let ``Avg. sec/Data Request`` instance =
    { category = CategoryName; counter = "Avg. sec/Data Request"; instance = instance }
  /// Avg. sec/Read: -
  let ``Avg. sec/Read`` instance =
    { category = CategoryName; counter = "Avg. sec/Read"; instance = instance }
  /// Avg. sec/Request: -
  let ``Avg. sec/Request`` instance =
    { category = CategoryName; counter = "Avg. sec/Request"; instance = instance }
  /// Avg. sec/Write: -
  let ``Avg. sec/Write`` instance =
    { category = CategoryName; counter = "Avg. sec/Write"; instance = instance }
  /// Current Data Queue Length: -
  let ``Current Data Queue Length`` instance =
    { category = CategoryName; counter = "Current Data Queue Length"; instance = instance }
  /// Current Durable Open File Count: -
  let ``Current Durable Open File Count`` instance =
    { category = CategoryName; counter = "Current Durable Open File Count"; instance = instance }
  /// Current Open File Count: -
  let ``Current Open File Count`` instance =
    { category = CategoryName; counter = "Current Open File Count"; instance = instance }
  /// Current Pending Requests: -
  let ``Current Pending Requests`` instance =
    { category = CategoryName; counter = "Current Pending Requests"; instance = instance }
  /// Data Bytes/sec: -
  let ``Data Bytes/sec`` instance =
    { category = CategoryName; counter = "Data Bytes/sec"; instance = instance }
  /// Data Requests/sec: -
  let ``Data Requests/sec`` instance =
    { category = CategoryName; counter = "Data Requests/sec"; instance = instance }
  /// Files Opened/sec: -
  let ``Files Opened/sec`` instance =
    { category = CategoryName; counter = "Files Opened/sec"; instance = instance }
  /// Metadata Requests/sec: -
  let ``Metadata Requests/sec`` instance =
    { category = CategoryName; counter = "Metadata Requests/sec"; instance = instance }
  /// Read Bytes/sec: -
  let ``Read Bytes/sec`` instance =
    { category = CategoryName; counter = "Read Bytes/sec"; instance = instance }
  /// Read Requests/sec: -
  let ``Read Requests/sec`` instance =
    { category = CategoryName; counter = "Read Requests/sec"; instance = instance }
  /// Received Bytes/sec: -
  let ``Received Bytes/sec`` instance =
    { category = CategoryName; counter = "Received Bytes/sec"; instance = instance }
  /// Requests/sec: -
  let ``Requests/sec`` instance =
    { category = CategoryName; counter = "Requests/sec"; instance = instance }
  /// Sent Bytes/sec: -
  let ``Sent Bytes/sec`` instance =
    { category = CategoryName; counter = "Sent Bytes/sec"; instance = instance }
  /// Total Durable Handle Reopen Count: -
  let ``Total Durable Handle Reopen Count`` instance =
    { category = CategoryName; counter = "Total Durable Handle Reopen Count"; instance = instance }
  /// Total Failed Durable Handle Reopen Count: -
  let ``Total Failed Durable Handle Reopen Count`` instance =
    { category = CategoryName; counter = "Total Failed Durable Handle Reopen Count"; instance = instance }
  /// Total Failed Persistent Handle Reopen Count: -
  let ``Total Failed Persistent Handle Reopen Count`` instance =
    { category = CategoryName; counter = "Total Failed Persistent Handle Reopen Count"; instance = instance }
  /// Total Failed Resilient Handle Reopen Count: -
  let ``Total Failed Resilient Handle Reopen Count`` instance =
    { category = CategoryName; counter = "Total Failed Resilient Handle Reopen Count"; instance = instance }
  /// Total File Open Count: -
  let ``Total File Open Count`` instance =
    { category = CategoryName; counter = "Total File Open Count"; instance = instance }
  /// Total Persistent Handle Reopen Count: -
  let ``Total Persistent Handle Reopen Count`` instance =
    { category = CategoryName; counter = "Total Persistent Handle Reopen Count"; instance = instance }
  /// Total Resilient Handle Reopen Count: -
  let ``Total Resilient Handle Reopen Count`` instance =
    { category = CategoryName; counter = "Total Resilient Handle Reopen Count"; instance = instance }
  /// Transferred Bytes/sec: -
  let ``Transferred Bytes/sec`` instance =
    { category = CategoryName; counter = "Transferred Bytes/sec"; instance = instance }
  /// Tree Connect Count: -
  let ``Tree Connect Count`` instance =
    { category = CategoryName; counter = "Tree Connect Count"; instance = instance }
  /// Write Bytes/sec: -
  let ``Write Bytes/sec`` instance =
    { category = CategoryName; counter = "Write Bytes/sec"; instance = instance }
  /// Write Requests/sec: -
  let ``Write Requests/sec`` instance =
    { category = CategoryName; counter = "Write Requests/sec"; instance = instance }

  let allCounters =
    [| ``% Persistent Handles``
       ``% Resilient Handles``
       ``Avg. Bytes/Read``
       ``Avg. Bytes/Write``
       ``Avg. Data Bytes/Request``
       ``Avg. Data Queue Length``
       ``Avg. Read Queue Length``
       ``Avg. Write Queue Length``
       ``Avg. sec/Data Request``
       ``Avg. sec/Read``
       ``Avg. sec/Request``
       ``Avg. sec/Write``
       ``Current Data Queue Length``
       ``Current Durable Open File Count``
       ``Current Open File Count``
       ``Current Pending Requests``
       ``Data Bytes/sec``
       ``Data Requests/sec``
       ``Files Opened/sec``
       ``Metadata Requests/sec``
       ``Read Bytes/sec``
       ``Read Requests/sec``
       ``Received Bytes/sec``
       ``Requests/sec``
       ``Sent Bytes/sec``
       ``Total Durable Handle Reopen Count``
       ``Total Failed Durable Handle Reopen Count``
       ``Total Failed Persistent Handle Reopen Count``
       ``Total Failed Resilient Handle Reopen Count``
       ``Total File Open Count``
       ``Total Persistent Handle Reopen Count``
       ``Total Resilient Handle Reopen Count``
       ``Transferred Bytes/sec``
       ``Tree Connect Count``
       ``Write Bytes/sec``
       ``Write Requests/sec``
    |]

/// SMB Server Shares: This counter set displays information about SMB server shares that are shared using SMB protocol version 2 or higher.
///
/// This performance counter does not have non-instance based counters
module ``SMB Server Shares`` =

  [<Literal>]
  let CategoryName = "SMB Server Shares"

  let PCC = Category.create CategoryName
  /// % Persistent Handles: The percentage of total handles for which clients requested persistency.
  let ``% Persistent Handles`` instance =
    { category = CategoryName; counter = "% Persistent Handles"; instance = instance }
  /// % Resilient Handles: The percentage of total opens for which clients requested resiliency.
  let ``% Resilient Handles`` instance =
    { category = CategoryName; counter = "% Resilient Handles"; instance = instance }
  /// Avg. Bytes/Read: The average number of bytes per read request.
  let ``Avg. Bytes/Read`` instance =
    { category = CategoryName; counter = "Avg. Bytes/Read"; instance = instance }
  /// Avg. Bytes/Write: The average number of bytes per write request.
  let ``Avg. Bytes/Write`` instance =
    { category = CategoryName; counter = "Avg. Bytes/Write"; instance = instance }
  /// Avg. Data Bytes/Request: The average number of bytes per read or write request.
  let ``Avg. Data Bytes/Request`` instance =
    { category = CategoryName; counter = "Avg. Data Bytes/Request"; instance = instance }
  /// Avg. Data Queue Length: The average number of read and write requests that were queued for this share.
  let ``Avg. Data Queue Length`` instance =
    { category = CategoryName; counter = "Avg. Data Queue Length"; instance = instance }
  /// Avg. Read Queue Length: The average number of read requests that were queued for this share.
  let ``Avg. Read Queue Length`` instance =
    { category = CategoryName; counter = "Avg. Read Queue Length"; instance = instance }
  /// Avg. Write Queue Length: The average number of write requests that were queued for this share.
  let ``Avg. Write Queue Length`` instance =
    { category = CategoryName; counter = "Avg. Write Queue Length"; instance = instance }
  /// Avg. sec/Data Request: The average number of seconds that elapse between the time at which a read or write request to this share is received and the time at which the SMB File Server processes the request.
  let ``Avg. sec/Data Request`` instance =
    { category = CategoryName; counter = "Avg. sec/Data Request"; instance = instance }
  /// Avg. sec/Read: The average number of seconds that elapse between the time at which a read request to this share is received and the time at which the SMB File Server sends the corresponding response.
  let ``Avg. sec/Read`` instance =
    { category = CategoryName; counter = "Avg. sec/Read"; instance = instance }
  /// Avg. sec/Request: The average number of seconds that elapse between the time at which the SMB File Server receives a request for this share and the time at which the SMB File Server sends the corresponding response.
  let ``Avg. sec/Request`` instance =
    { category = CategoryName; counter = "Avg. sec/Request"; instance = instance }
  /// Avg. sec/Write: The average number of seconds that elapse between the time at which a write request to this share is received and the time at which the SMB File Server sends the corresponding response.
  let ``Avg. sec/Write`` instance =
    { category = CategoryName; counter = "Avg. sec/Write"; instance = instance }
  /// Current Data Queue Length: The current number of read or write requests outstanding on this share.
  let ``Current Data Queue Length`` instance =
    { category = CategoryName; counter = "Current Data Queue Length"; instance = instance }
  /// Current Durable Open File Count: The number of durable file handles that are currently open on this share
  let ``Current Durable Open File Count`` instance =
    { category = CategoryName; counter = "Current Durable Open File Count"; instance = instance }
  /// Current Open File Count: The number of file handles that are currently open in this share
  let ``Current Open File Count`` instance =
    { category = CategoryName; counter = "Current Open File Count"; instance = instance }
  /// Current Pending Requests: The number of requests related to this share that are waiting to be processed by the SMB File Server.
  let ``Current Pending Requests`` instance =
    { category = CategoryName; counter = "Current Pending Requests"; instance = instance }
  /// Data Bytes/sec: The rate, in seconds, at which data is being written to or read from this share.
  let ``Data Bytes/sec`` instance =
    { category = CategoryName; counter = "Data Bytes/sec"; instance = instance }
  /// Data Requests/sec: The rate, in seconds, at which read or write requests are received for this share.
  let ``Data Requests/sec`` instance =
    { category = CategoryName; counter = "Data Requests/sec"; instance = instance }
  /// Files Opened/sec: The rate, in seconds, at which files are being opened for the SMB File Server’s clients on this share.
  let ``Files Opened/sec`` instance =
    { category = CategoryName; counter = "Files Opened/sec"; instance = instance }
  /// Metadata Requests/sec: The rate, in seconds, at which metadata requests are being sent to this share.
  let ``Metadata Requests/sec`` instance =
    { category = CategoryName; counter = "Metadata Requests/sec"; instance = instance }
  /// Read Bytes/sec: The rate, in seconds, at which data is being read from this share.
  let ``Read Bytes/sec`` instance =
    { category = CategoryName; counter = "Read Bytes/sec"; instance = instance }
  /// Read Requests/sec: Read requests processed/sec related to this share.
  let ``Read Requests/sec`` instance =
    { category = CategoryName; counter = "Read Requests/sec"; instance = instance }
  /// Received Bytes/sec: The rate at which bytes are being received for requests related to this share. This value includes application data as well as SMB protocol data (such as packet headers).
  let ``Received Bytes/sec`` instance =
    { category = CategoryName; counter = "Received Bytes/sec"; instance = instance }
  /// Requests/sec: The rate at which requests are being received for this share
  let ``Requests/sec`` instance =
    { category = CategoryName; counter = "Requests/sec"; instance = instance }
  /// Sent Bytes/sec: The rate, in seconds, at which bytes are being sent from the SMB File Server related to this share to its clients. This value includes both data bytes and protocol bytes.
  let ``Sent Bytes/sec`` instance =
    { category = CategoryName; counter = "Sent Bytes/sec"; instance = instance }
  /// Total Durable Handle Reopen Count: The number of durable opens on this share that have been recovered after a temporary network disconnect since the SMB File Server started.
  let ``Total Durable Handle Reopen Count`` instance =
    { category = CategoryName; counter = "Total Durable Handle Reopen Count"; instance = instance }
  /// Total Failed Durable Handle Reopen Count: The number of durable opens on this share that could not be recovered after a temporary network disconnect since the SMB File Server Started.
  let ``Total Failed Durable Handle Reopen Count`` instance =
    { category = CategoryName; counter = "Total Failed Durable Handle Reopen Count"; instance = instance }
  /// Total Failed Persistent Handle Reopen Count: The number of persistent opens on this share that could not be recovered after a temporary network disconnect since the SMB File Server Started.
  let ``Total Failed Persistent Handle Reopen Count`` instance =
    { category = CategoryName; counter = "Total Failed Persistent Handle Reopen Count"; instance = instance }
  /// Total Failed Resilient Handle Reopen Count: The number of resilient opens on this share that could not be recovered after a temporary network disconnect since the SMB File Server Started.
  let ``Total Failed Resilient Handle Reopen Count`` instance =
    { category = CategoryName; counter = "Total Failed Resilient Handle Reopen Count"; instance = instance }
  /// Total File Open Count: The number of files that have been opened by the SMB File Server on behalf of its clients on this share since the server started.
  let ``Total File Open Count`` instance =
    { category = CategoryName; counter = "Total File Open Count"; instance = instance }
  /// Total Persistent Handle Reopen Count: The number of persistent opens on this share that have been recovered after a temporary network disconnect since the SMB File Server started.
  let ``Total Persistent Handle Reopen Count`` instance =
    { category = CategoryName; counter = "Total Persistent Handle Reopen Count"; instance = instance }
  /// Total Resilient Handle Reopen Count: The number of resilient opens on this share that have been recovered after a temporary network disconnect since the SMB File Server started.
  let ``Total Resilient Handle Reopen Count`` instance =
    { category = CategoryName; counter = "Total Resilient Handle Reopen Count"; instance = instance }
  /// Transferred Bytes/sec: The sum of Sent Bytes/sec and Received Bytes/sec for this share.
  let ``Transferred Bytes/sec`` instance =
    { category = CategoryName; counter = "Transferred Bytes/sec"; instance = instance }
  /// Tree Connect Count: The current number of tree connects to this share
  let ``Tree Connect Count`` instance =
    { category = CategoryName; counter = "Tree Connect Count"; instance = instance }
  /// Write Bytes/sec: The rate, in seconds, at which data is being written to this share.
  let ``Write Bytes/sec`` instance =
    { category = CategoryName; counter = "Write Bytes/sec"; instance = instance }
  /// Write Requests/sec: Write requests processed/sec related to this share.
  let ``Write Requests/sec`` instance =
    { category = CategoryName; counter = "Write Requests/sec"; instance = instance }

  let allCounters =
    [| ``% Persistent Handles``
       ``% Resilient Handles``
       ``Avg. Bytes/Read``
       ``Avg. Bytes/Write``
       ``Avg. Data Bytes/Request``
       ``Avg. Data Queue Length``
       ``Avg. Read Queue Length``
       ``Avg. Write Queue Length``
       ``Avg. sec/Data Request``
       ``Avg. sec/Read``
       ``Avg. sec/Request``
       ``Avg. sec/Write``
       ``Current Data Queue Length``
       ``Current Durable Open File Count``
       ``Current Open File Count``
       ``Current Pending Requests``
       ``Data Bytes/sec``
       ``Data Requests/sec``
       ``Files Opened/sec``
       ``Metadata Requests/sec``
       ``Read Bytes/sec``
       ``Read Requests/sec``
       ``Received Bytes/sec``
       ``Requests/sec``
       ``Sent Bytes/sec``
       ``Total Durable Handle Reopen Count``
       ``Total Failed Durable Handle Reopen Count``
       ``Total Failed Persistent Handle Reopen Count``
       ``Total Failed Resilient Handle Reopen Count``
       ``Total File Open Count``
       ``Total Persistent Handle Reopen Count``
       ``Total Resilient Handle Reopen Count``
       ``Transferred Bytes/sec``
       ``Tree Connect Count``
       ``Write Bytes/sec``
       ``Write Requests/sec``
    |]

/// SMSvcHost 3.0.0.0: SMSvcHost 3.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``SMSvcHost 3_0_0_0`` =

  [<Literal>]
  let CategoryName = "SMSvcHost 3.0.0.0"

  let PCC = Category.create CategoryName
  /// Connections Accepted over net.pipe: The total number of named pipe connections accepted over net.pipe.
  let ``Connections Accepted over net.pipe`` =
    { category = CategoryName; counter = "Connections Accepted over net.pipe"; instance = None }
  /// Connections Accepted over net.tcp: The total number of TCP connections accepted over net.tcp.
  let ``Connections Accepted over net.tcp`` =
    { category = CategoryName; counter = "Connections Accepted over net.tcp"; instance = None }
  /// Connections Dispatched over net.pipe: The total number of connections dispatched over net.pipe.
  let ``Connections Dispatched over net.pipe`` =
    { category = CategoryName; counter = "Connections Dispatched over net.pipe"; instance = None }
  /// Connections Dispatched over net.tcp: The total number of connections dispatched over net.tcp.
  let ``Connections Dispatched over net.tcp`` =
    { category = CategoryName; counter = "Connections Dispatched over net.tcp"; instance = None }
  /// Dispatch Failures over net.pipe: The total number of failures dispatching messages received over net.pipe.
  let ``Dispatch Failures over net.pipe`` =
    { category = CategoryName; counter = "Dispatch Failures over net.pipe"; instance = None }
  /// Dispatch Failures over net.tcp: The total number of failures dispatching messages received over net.tcp.
  let ``Dispatch Failures over net.tcp`` =
    { category = CategoryName; counter = "Dispatch Failures over net.tcp"; instance = None }
  /// Protocol Failures over net.pipe: The total number of failures at the protocol layer of net.pipe.
  let ``Protocol Failures over net.pipe`` =
    { category = CategoryName; counter = "Protocol Failures over net.pipe"; instance = None }
  /// Protocol Failures over net.tcp: The total number of failures at the protocol layer of net.tcp.
  let ``Protocol Failures over net.tcp`` =
    { category = CategoryName; counter = "Protocol Failures over net.tcp"; instance = None }
  /// Registrations Active for net.pipe: The number of uri registrations currently active for net.pipe.
  let ``Registrations Active for net.pipe`` =
    { category = CategoryName; counter = "Registrations Active for net.pipe"; instance = None }
  /// Registrations Active for net.tcp: The number of uri registrations currently active for net.tcp.
  let ``Registrations Active for net.tcp`` =
    { category = CategoryName; counter = "Registrations Active for net.tcp"; instance = None }
  /// Uris Registered for net.pipe: The total number of uris that were succesfully registered for net.pipe.
  let ``Uris Registered for net.pipe`` =
    { category = CategoryName; counter = "Uris Registered for net.pipe"; instance = None }
  /// Uris Registered for net.tcp: The total number of uris that were succesfully registered for net.tcp.
  let ``Uris Registered for net.tcp`` =
    { category = CategoryName; counter = "Uris Registered for net.tcp"; instance = None }
  /// Uris Unregistered for net.pipe: The total number of uris that were succesfully unregistered for net.pipe.
  let ``Uris Unregistered for net.pipe`` =
    { category = CategoryName; counter = "Uris Unregistered for net.pipe"; instance = None }
  /// Uris Unregistered for net.tcp: The total number of uris that were succesfully unregistered for net.tcp.
  let ``Uris Unregistered for net.tcp`` =
    { category = CategoryName; counter = "Uris Unregistered for net.tcp"; instance = None }

  let allCounters =
    [| ``Connections Accepted over net.pipe``
       ``Connections Accepted over net.tcp``
       ``Connections Dispatched over net.pipe``
       ``Connections Dispatched over net.tcp``
       ``Dispatch Failures over net.pipe``
       ``Dispatch Failures over net.tcp``
       ``Protocol Failures over net.pipe``
       ``Protocol Failures over net.tcp``
       ``Registrations Active for net.pipe``
       ``Registrations Active for net.tcp``
       ``Uris Registered for net.pipe``
       ``Uris Registered for net.tcp``
       ``Uris Unregistered for net.pipe``
       ``Uris Unregistered for net.tcp``
    |]

/// SMSvcHost 4.0.0.0: SMSvcHost 4.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``SMSvcHost 4_0_0_0`` =

  [<Literal>]
  let CategoryName = "SMSvcHost 4.0.0.0"

  let PCC = Category.create CategoryName
  /// Connections Accepted over net.pipe: The total number of named pipe connections accepted over net.pipe.
  let ``Connections Accepted over net.pipe`` =
    { category = CategoryName; counter = "Connections Accepted over net.pipe"; instance = None }
  /// Connections Accepted over net.tcp: The total number of TCP connections accepted over net.tcp.
  let ``Connections Accepted over net.tcp`` =
    { category = CategoryName; counter = "Connections Accepted over net.tcp"; instance = None }
  /// Connections Dispatched over net.pipe: The total number of connections dispatched over net.pipe.
  let ``Connections Dispatched over net.pipe`` =
    { category = CategoryName; counter = "Connections Dispatched over net.pipe"; instance = None }
  /// Connections Dispatched over net.tcp: The total number of connections dispatched over net.tcp.
  let ``Connections Dispatched over net.tcp`` =
    { category = CategoryName; counter = "Connections Dispatched over net.tcp"; instance = None }
  /// Dispatch Failures over net.pipe: The total number of failures dispatching messages received over net.pipe.
  let ``Dispatch Failures over net.pipe`` =
    { category = CategoryName; counter = "Dispatch Failures over net.pipe"; instance = None }
  /// Dispatch Failures over net.tcp: The total number of failures dispatching messages received over net.tcp.
  let ``Dispatch Failures over net.tcp`` =
    { category = CategoryName; counter = "Dispatch Failures over net.tcp"; instance = None }
  /// Protocol Failures over net.pipe: The total number of failures at the protocol layer of net.pipe.
  let ``Protocol Failures over net.pipe`` =
    { category = CategoryName; counter = "Protocol Failures over net.pipe"; instance = None }
  /// Protocol Failures over net.tcp: The total number of failures at the protocol layer of net.tcp.
  let ``Protocol Failures over net.tcp`` =
    { category = CategoryName; counter = "Protocol Failures over net.tcp"; instance = None }
  /// Registrations Active for net.pipe: The number of uri registrations currently active for net.pipe.
  let ``Registrations Active for net.pipe`` =
    { category = CategoryName; counter = "Registrations Active for net.pipe"; instance = None }
  /// Registrations Active for net.tcp: The number of uri registrations currently active for net.tcp.
  let ``Registrations Active for net.tcp`` =
    { category = CategoryName; counter = "Registrations Active for net.tcp"; instance = None }
  /// Uris Registered for net.pipe: The total number of uris that were succesfully registered for net.pipe.
  let ``Uris Registered for net.pipe`` =
    { category = CategoryName; counter = "Uris Registered for net.pipe"; instance = None }
  /// Uris Registered for net.tcp: The total number of uris that were succesfully registered for net.tcp.
  let ``Uris Registered for net.tcp`` =
    { category = CategoryName; counter = "Uris Registered for net.tcp"; instance = None }
  /// Uris Unregistered for net.pipe: The total number of uris that were succesfully unregistered for net.pipe.
  let ``Uris Unregistered for net.pipe`` =
    { category = CategoryName; counter = "Uris Unregistered for net.pipe"; instance = None }
  /// Uris Unregistered for net.tcp: The total number of uris that were succesfully unregistered for net.tcp.
  let ``Uris Unregistered for net.tcp`` =
    { category = CategoryName; counter = "Uris Unregistered for net.tcp"; instance = None }

  let allCounters =
    [| ``Connections Accepted over net.pipe``
       ``Connections Accepted over net.tcp``
       ``Connections Dispatched over net.pipe``
       ``Connections Dispatched over net.tcp``
       ``Dispatch Failures over net.pipe``
       ``Dispatch Failures over net.tcp``
       ``Protocol Failures over net.pipe``
       ``Protocol Failures over net.tcp``
       ``Registrations Active for net.pipe``
       ``Registrations Active for net.tcp``
       ``Uris Registered for net.pipe``
       ``Uris Registered for net.tcp``
       ``Uris Unregistered for net.pipe``
       ``Uris Unregistered for net.tcp``
    |]

/// SQLAgent:Alerts: SQLAgent statistics about alerts
///
/// This performance counter does not have instance based counters
module ``SQLAgent:Alerts`` =

  [<Literal>]
  let CategoryName = "SQLAgent:Alerts"

  let PCC = Category.create CategoryName
  /// Activated alerts: The number of Alerts that have activated since the last SQL Server restart.
  let ``Activated alerts`` =
    { category = CategoryName; counter = "Activated alerts"; instance = None }
  /// Alerts activated/minute: The number of Alerts that have activated within the last minute.
  let ``Alerts activated/minute`` =
    { category = CategoryName; counter = "Alerts activated/minute"; instance = None }

  let allCounters =
    [| ``Activated alerts``
       ``Alerts activated/minute``
    |]

/// SQLAgent:JobSteps: Statistics for job steps
///
/// This performance counter does not have instance based counters
module ``SQLAgent:JobSteps`` =

  [<Literal>]
  let CategoryName = "SQLAgent:JobSteps"

  let PCC = Category.create CategoryName
  /// Active steps: -
  let ``Active steps`` instance =
    { category = CategoryName; counter = "Active steps"; instance = instance }
  /// Queued steps: -
  let ``Queued steps`` instance =
    { category = CategoryName; counter = "Queued steps"; instance = instance }
  /// Total step retries: -
  let ``Total step retries`` instance =
    { category = CategoryName; counter = "Total step retries"; instance = instance }

  let allCounters =
    [| ``Active steps``
       ``Queued steps``
       ``Total step retries``
    |]

/// SQLAgent:Jobs: SQLAgent General Statistics about jobs
///
/// This performance counter does not have instance based counters
module ``SQLAgent:Jobs`` =

  [<Literal>]
  let CategoryName = "SQLAgent:Jobs"

  let PCC = Category.create CategoryName
  /// Active jobs: -
  let ``Active jobs`` instance =
    { category = CategoryName; counter = "Active jobs"; instance = instance }
  /// Failed jobs: -
  let ``Failed jobs`` instance =
    { category = CategoryName; counter = "Failed jobs"; instance = instance }
  /// Job success rate: -
  let ``Job success rate`` instance =
    { category = CategoryName; counter = "Job success rate"; instance = instance }
  /// Jobs activated/minute: -
  let ``Jobs activated/minute`` instance =
    { category = CategoryName; counter = "Jobs activated/minute"; instance = instance }
  /// Queued jobs: -
  let ``Queued jobs`` instance =
    { category = CategoryName; counter = "Queued jobs"; instance = instance }
  /// Successful jobs: -
  let ``Successful jobs`` instance =
    { category = CategoryName; counter = "Successful jobs"; instance = instance }
  /// Successful jobs base: -
  let ``Successful jobs base`` instance =
    { category = CategoryName; counter = "Successful jobs base"; instance = instance }

  let allCounters =
    [| ``Active jobs``
       ``Failed jobs``
       ``Job success rate``
       ``Jobs activated/minute``
       ``Queued jobs``
       ``Successful jobs``
       ``Successful jobs base``
    |]

/// SQLAgent:Statistics: SQLAgent general statistics
///
/// This performance counter does not have instance based counters
module ``SQLAgent:Statistics`` =

  [<Literal>]
  let CategoryName = "SQLAgent:Statistics"

  let PCC = Category.create CategoryName
  /// SQL Server restarted: The number of times the SQL Server has been successfully restarted by SQL Server Agent, since the last SQL Server Agent restart.
  let ``SQL Server restarted`` =
    { category = CategoryName; counter = "SQL Server restarted"; instance = None }

  let allCounters =
    [| ``SQL Server restarted``

    |]

/// SQLAgent:SystemJobs: SQLAgent General Statistics about system jobs
///
/// This performance counter does not have instance based counters
module ``SQLAgent:SystemJobs`` =

  [<Literal>]
  let CategoryName = "SQLAgent:SystemJobs"

  let PCC = Category.create CategoryName
  /// Active system jobs: -
  let ``Active system jobs`` instance =
    { category = CategoryName; counter = "Active system jobs"; instance = instance }
  /// Failed system jobs: -
  let ``Failed system jobs`` instance =
    { category = CategoryName; counter = "Failed system jobs"; instance = instance }
  /// Queued system jobs: -
  let ``Queued system jobs`` instance =
    { category = CategoryName; counter = "Queued system jobs"; instance = instance }
  /// Successful system jobs: -
  let ``Successful system jobs`` instance =
    { category = CategoryName; counter = "Successful system jobs"; instance = instance }
  /// System Jobs activated/minute: -
  let ``System Jobs activated/minute`` instance =
    { category = CategoryName; counter = "System Jobs activated/minute"; instance = instance }

  let allCounters =
    [| ``Active system jobs``
       ``Failed system jobs``
       ``Queued system jobs``
       ``Successful system jobs``
       ``System Jobs activated/minute``
    |]

/// SQLServer:Access Methods: Collects statistics associated with the database server access methods
///
/// This performance counter does not have instance based counters
module ``SQLServer:Access Methods`` =

  [<Literal>]
  let CategoryName = "SQLServer:Access Methods"

  let PCC = Category.create CategoryName
  /// AU cleanup batches/sec: The number of batches that completed successfully per second by the background task that cleans up deferred dropped allocation units.
  let ``AU cleanup batches/sec`` =
    { category = CategoryName; counter = "AU cleanup batches/sec"; instance = None }
  /// AU cleanups/sec: The number of allocation units per second that were successfully dropped by the background task that cleans up deferred dropped allocation units. Each allocation unit drop requires multiple batches.
  let ``AU cleanups/sec`` =
    { category = CategoryName; counter = "AU cleanups/sec"; instance = None }
  /// By-reference Lob Create Count: Count of large object (LOB) values that were passed by reference. By-reference lobs are used in certain bulk operations to avoid the cost of passing them by value.
  let ``By-reference Lob Create Count`` =
    { category = CategoryName; counter = "By-reference Lob Create Count"; instance = None }
  /// By-reference Lob Use Count: Count of by-reference lob values that were used. By-reference lobs are used in certain bulk operations to avoid the cost of passing them by value.
  let ``By-reference Lob Use Count`` =
    { category = CategoryName; counter = "By-reference Lob Use Count"; instance = None }
  /// Count Lob Readahead: Count of lob pages on which readahead was issued.
  let ``Count Lob Readahead`` =
    { category = CategoryName; counter = "Count Lob Readahead"; instance = None }
  /// Count Pull In Row: Count of values that were pulled in-row from off-row.
  let ``Count Pull In Row`` =
    { category = CategoryName; counter = "Count Pull In Row"; instance = None }
  /// Count Push Off Row: Count of values that were pushed from in-row to off-row.
  let ``Count Push Off Row`` =
    { category = CategoryName; counter = "Count Push Off Row"; instance = None }
  /// Deferred Dropped rowsets: The number of rowsets created as a result of aborted online index build operations that are waiting to be dropped by the background task that cleans up deferred dropped rowsets.
  let ``Deferred Dropped rowsets`` =
    { category = CategoryName; counter = "Deferred Dropped rowsets"; instance = None }
  /// Deferred dropped AUs: The number of allocation units waiting to be dropped by the background task that cleans up deferred dropped allocation units.
  let ``Deferred dropped AUs`` =
    { category = CategoryName; counter = "Deferred dropped AUs"; instance = None }
  /// Dropped rowset cleanups/sec: The number of rowsets per second created as a result of aborted online index build operations that were successfully dropped by the background task that cleans up deferred dropped rowsets.
  let ``Dropped rowset cleanups/sec`` =
    { category = CategoryName; counter = "Dropped rowset cleanups/sec"; instance = None }
  /// Dropped rowsets skipped/sec: The number of rowsets per second created as a result of aborted online index build operations that were skipped by the background task that cleans up deferred dropped rowsets created.
  let ``Dropped rowsets skipped/sec`` =
    { category = CategoryName; counter = "Dropped rowsets skipped/sec"; instance = None }
  /// Extent Deallocations/sec: Number of extents deallocated per second in all databases in this SQL Server instance.
  let ``Extent Deallocations/sec`` =
    { category = CategoryName; counter = "Extent Deallocations/sec"; instance = None }
  /// Extents Allocated/sec: Number of extents allocated per second in all databases in this SQL Server instance.
  let ``Extents Allocated/sec`` =
    { category = CategoryName; counter = "Extents Allocated/sec"; instance = None }
  /// Failed AU cleanup batches/sec: The number of batches per second that failed and required retry, by the background task that cleans up deferred dropped allocation units. Failure could be due to lack of memory or disk space, hardware failure and other reasons.
  let ``Failed AU cleanup batches/sec`` =
    { category = CategoryName; counter = "Failed AU cleanup batches/sec"; instance = None }
  /// Failed leaf page cookie: The number of times that a leaf page cookie could not be used during an index search since changes happened on the leaf page. The cookie is used to speed up index search.
  let ``Failed leaf page cookie`` =
    { category = CategoryName; counter = "Failed leaf page cookie"; instance = None }
  /// Failed tree page cookie: The number of times that a tree page cookie could not be used during an index search since changes happened on the parent pages of those tree pages. The cookie is used to speed up index search.
  let ``Failed tree page cookie`` =
    { category = CategoryName; counter = "Failed tree page cookie"; instance = None }
  /// Forwarded Records/sec: Number of records fetched through forwarded record pointers.
  let ``Forwarded Records/sec`` =
    { category = CategoryName; counter = "Forwarded Records/sec"; instance = None }
  /// FreeSpace Page Fetches/sec: Number of pages fetched per second by free space scans. These scans search for free space within pages already allocated to an allocation unit, to satisfy requests to insert or modify record fragments.
  let ``FreeSpace Page Fetches/sec`` =
    { category = CategoryName; counter = "FreeSpace Page Fetches/sec"; instance = None }
  /// FreeSpace Scans/sec: Number of scans per second that were initiated to search for free space within pages already allocated to an allocation unit to insert or modify record fragments. Each scan may find multiple pages.
  let ``FreeSpace Scans/sec`` =
    { category = CategoryName; counter = "FreeSpace Scans/sec"; instance = None }
  /// Full Scans/sec: Number of unrestricted full scans. These can either be base table or full index scans.
  let ``Full Scans/sec`` =
    { category = CategoryName; counter = "Full Scans/sec"; instance = None }
  /// InSysXact waits/sec: Number of times a reader needs to wait for a page because the InSysXact bit is set
  let ``InSysXact waits/sec`` =
    { category = CategoryName; counter = "InSysXact waits/sec"; instance = None }
  /// Index Searches/sec: Number of index searches. Index searches are used to start range scans, single index record fetches, and to reposition within an index.
  let ``Index Searches/sec`` =
    { category = CategoryName; counter = "Index Searches/sec"; instance = None }
  /// LobHandle Create Count: Count of temporary LOBs created.
  let ``LobHandle Create Count`` =
    { category = CategoryName; counter = "LobHandle Create Count"; instance = None }
  /// LobHandle Destroy Count: Count of temporary LOBs destroyed.
  let ``LobHandle Destroy Count`` =
    { category = CategoryName; counter = "LobHandle Destroy Count"; instance = None }
  /// LobSS Provider Create Count: Count of LOB Storage Service Providers created. One worktable created per LOB Storage Service Provider.
  let ``LobSS Provider Create Count`` =
    { category = CategoryName; counter = "LobSS Provider Create Count"; instance = None }
  /// LobSS Provider Destroy Count: Count of LOB Storage Service Providers destroyed.
  let ``LobSS Provider Destroy Count`` =
    { category = CategoryName; counter = "LobSS Provider Destroy Count"; instance = None }
  /// LobSS Provider Truncation Count: Count of LOB Storage Service Providers truncated.
  let ``LobSS Provider Truncation Count`` =
    { category = CategoryName; counter = "LobSS Provider Truncation Count"; instance = None }
  /// Mixed page allocations/sec: Number of pages allocated per second from mixed extents. These could be used for storing the IAM pages and the first eight pages that are allocated to an allocation unit.
  let ``Mixed page allocations/sec`` =
    { category = CategoryName; counter = "Mixed page allocations/sec"; instance = None }
  /// Page Deallocations/sec: Number of pages deallocated per second in all databases in this SQL Server instance. These include pages from mixed extents and uniform extents.
  let ``Page Deallocations/sec`` =
    { category = CategoryName; counter = "Page Deallocations/sec"; instance = None }
  /// Page Splits/sec: Number of page splits per second that occur as a result of overflowing index pages.
  let ``Page Splits/sec`` =
    { category = CategoryName; counter = "Page Splits/sec"; instance = None }
  /// Page compression attempts/sec: Number of attempts to compress a database page per second
  let ``Page compression attempts/sec`` =
    { category = CategoryName; counter = "Page compression attempts/sec"; instance = None }
  /// Pages Allocated/sec: Number of pages allocated per second in all databases in this SQL Server instance. These include pages allocations from both mixed extents and uniform extents.
  let ``Pages Allocated/sec`` =
    { category = CategoryName; counter = "Pages Allocated/sec"; instance = None }
  /// Pages compressed/sec: Number of times a database page was compressed
  let ``Pages compressed/sec`` =
    { category = CategoryName; counter = "Pages compressed/sec"; instance = None }
  /// Probe Scans/sec: Number of probe scans per second that are used to find at most one single qualified row in an index or base table directly.
  let ``Probe Scans/sec`` =
    { category = CategoryName; counter = "Probe Scans/sec"; instance = None }
  /// Range Scans/sec: Number of qualified range scans through indexes per second.
  let ``Range Scans/sec`` =
    { category = CategoryName; counter = "Range Scans/sec"; instance = None }
  /// Scan Point Revalidations/sec: Number of times the scan point had to be revalidated to continue the scan.
  let ``Scan Point Revalidations/sec`` =
    { category = CategoryName; counter = "Scan Point Revalidations/sec"; instance = None }
  /// Skipped Ghosted Records/sec: Number of ghosted records per second skipped during scans.
  let ``Skipped Ghosted Records/sec`` =
    { category = CategoryName; counter = "Skipped Ghosted Records/sec"; instance = None }
  /// Table Lock Escalations/sec: The number of times locks on a table were escalated.
  let ``Table Lock Escalations/sec`` =
    { category = CategoryName; counter = "Table Lock Escalations/sec"; instance = None }
  /// Used leaf page cookie: Number of times a leaf page cookie was used successfully during an index search since no change happened on the leaf page. The cookie is used to speed up index search.
  let ``Used leaf page cookie`` =
    { category = CategoryName; counter = "Used leaf page cookie"; instance = None }
  /// Used tree page cookie: Number of times a tree page cookie was used successfully during an index search since no change happened on the parent page of the tree page. The cookie is used to speed up index search.
  let ``Used tree page cookie`` =
    { category = CategoryName; counter = "Used tree page cookie"; instance = None }
  /// Workfiles Created/sec: Number of work files created per second. For example, work files could be used to store temporary results for hash joins and hash aggregates.
  let ``Workfiles Created/sec`` =
    { category = CategoryName; counter = "Workfiles Created/sec"; instance = None }
  /// Worktables Created/sec: Number of work tables created per second. For example, work tables could be used to store temporary results for query spool, LOB variables, XML variables, and cursors.
  let ``Worktables Created/sec`` =
    { category = CategoryName; counter = "Worktables Created/sec"; instance = None }
  /// Worktables From Cache Base: Percent of worktables from cache base.
  let ``Worktables From Cache Base`` =
    { category = CategoryName; counter = "Worktables From Cache Base"; instance = None }
  /// Worktables From Cache Ratio: Percentage of work tables created where the initial two pages of the work table were not allocated but were immediately available from the work table cache.
  let ``Worktables From Cache Ratio`` =
    { category = CategoryName; counter = "Worktables From Cache Ratio"; instance = None }

  let allCounters =
    [| ``AU cleanup batches/sec``
       ``AU cleanups/sec``
       ``By-reference Lob Create Count``
       ``By-reference Lob Use Count``
       ``Count Lob Readahead``
       ``Count Pull In Row``
       ``Count Push Off Row``
       ``Deferred Dropped rowsets``
       ``Deferred dropped AUs``
       ``Dropped rowset cleanups/sec``
       ``Dropped rowsets skipped/sec``
       ``Extent Deallocations/sec``
       ``Extents Allocated/sec``
       ``Failed AU cleanup batches/sec``
       ``Failed leaf page cookie``
       ``Failed tree page cookie``
       ``Forwarded Records/sec``
       ``FreeSpace Page Fetches/sec``
       ``FreeSpace Scans/sec``
       ``Full Scans/sec``
       ``InSysXact waits/sec``
       ``Index Searches/sec``
       ``LobHandle Create Count``
       ``LobHandle Destroy Count``
       ``LobSS Provider Create Count``
       ``LobSS Provider Destroy Count``
       ``LobSS Provider Truncation Count``
       ``Mixed page allocations/sec``
       ``Page Deallocations/sec``
       ``Page Splits/sec``
       ``Page compression attempts/sec``
       ``Pages Allocated/sec``
       ``Pages compressed/sec``
       ``Probe Scans/sec``
       ``Range Scans/sec``
       ``Scan Point Revalidations/sec``
       ``Skipped Ghosted Records/sec``
       ``Table Lock Escalations/sec``
       ``Used leaf page cookie``
       ``Used tree page cookie``
       ``Workfiles Created/sec``
       ``Worktables Created/sec``
       ``Worktables From Cache Base``
       ``Worktables From Cache Ratio``
    |]

/// SQLServer:Availability Replica: This defines a HADR availability replica object for SQL Server
///
/// This performance counter does not have instance based counters
module ``SQLServer:Availability Replica`` =

  [<Literal>]
  let CategoryName = "SQLServer:Availability Replica"

  let PCC = Category.create CategoryName
  /// Bytes Received from Replica/sec: -
  let ``Bytes Received from Replica/sec`` instance =
    { category = CategoryName; counter = "Bytes Received from Replica/sec"; instance = instance }
  /// Bytes Sent to Replica/sec: -
  let ``Bytes Sent to Replica/sec`` instance =
    { category = CategoryName; counter = "Bytes Sent to Replica/sec"; instance = instance }
  /// Bytes Sent to Transport/sec: -
  let ``Bytes Sent to Transport/sec`` instance =
    { category = CategoryName; counter = "Bytes Sent to Transport/sec"; instance = instance }
  /// Flow Control Time (ms/sec): -
  let ``Flow Control Time (ms/sec)`` instance =
    { category = CategoryName; counter = "Flow Control Time (ms/sec)"; instance = instance }
  /// Flow Control/sec: -
  let ``Flow Control/sec`` instance =
    { category = CategoryName; counter = "Flow Control/sec"; instance = instance }
  /// Receives from Replica/sec: -
  let ``Receives from Replica/sec`` instance =
    { category = CategoryName; counter = "Receives from Replica/sec"; instance = instance }
  /// Resent Messages/sec: -
  let ``Resent Messages/sec`` instance =
    { category = CategoryName; counter = "Resent Messages/sec"; instance = instance }
  /// Sends to Replica/sec: -
  let ``Sends to Replica/sec`` instance =
    { category = CategoryName; counter = "Sends to Replica/sec"; instance = instance }
  /// Sends to Transport/sec: -
  let ``Sends to Transport/sec`` instance =
    { category = CategoryName; counter = "Sends to Transport/sec"; instance = instance }

  let allCounters =
    [| ``Bytes Received from Replica/sec``
       ``Bytes Sent to Replica/sec``
       ``Bytes Sent to Transport/sec``
       ``Flow Control Time (ms/sec)``
       ``Flow Control/sec``
       ``Receives from Replica/sec``
       ``Resent Messages/sec``
       ``Sends to Replica/sec``
       ``Sends to Transport/sec``
    |]

/// SQLServer:Backup Device: This defines a backup device object for SQL Server
///
/// This performance counter does not have instance based counters
module ``SQLServer:Backup Device`` =

  [<Literal>]
  let CategoryName = "SQLServer:Backup Device"

  let PCC = Category.create CategoryName
  /// Device Throughput Bytes/sec: -
  let ``Device Throughput Bytes/sec`` instance =
    { category = CategoryName; counter = "Device Throughput Bytes/sec"; instance = instance }

  let allCounters =
    [| ``Device Throughput Bytes/sec``

    |]

/// SQLServer:Batch Resp Statistics: Counters to track SQL Batch Response times
///
/// This performance counter does not have instance based counters
module ``SQLServer:Batch Resp Statistics`` =

  [<Literal>]
  let CategoryName = "SQLServer:Batch Resp Statistics"

  let PCC = Category.create CategoryName
  /// Batches >=000000ms & <000001ms: -
  let ``Batches >=000000ms & <000001ms`` instance =
    { category = CategoryName; counter = "Batches >=000000ms & <000001ms"; instance = instance }
  /// Batches >=000001ms & <000002ms: -
  let ``Batches >=000001ms & <000002ms`` instance =
    { category = CategoryName; counter = "Batches >=000001ms & <000002ms"; instance = instance }
  /// Batches >=000002ms & <000005ms: -
  let ``Batches >=000002ms & <000005ms`` instance =
    { category = CategoryName; counter = "Batches >=000002ms & <000005ms"; instance = instance }
  /// Batches >=000005ms & <000010ms: -
  let ``Batches >=000005ms & <000010ms`` instance =
    { category = CategoryName; counter = "Batches >=000005ms & <000010ms"; instance = instance }
  /// Batches >=000010ms & <000020ms: -
  let ``Batches >=000010ms & <000020ms`` instance =
    { category = CategoryName; counter = "Batches >=000010ms & <000020ms"; instance = instance }
  /// Batches >=000020ms & <000050ms: -
  let ``Batches >=000020ms & <000050ms`` instance =
    { category = CategoryName; counter = "Batches >=000020ms & <000050ms"; instance = instance }
  /// Batches >=000050ms & <000100ms: -
  let ``Batches >=000050ms & <000100ms`` instance =
    { category = CategoryName; counter = "Batches >=000050ms & <000100ms"; instance = instance }
  /// Batches >=000100ms & <000200ms: -
  let ``Batches >=000100ms & <000200ms`` instance =
    { category = CategoryName; counter = "Batches >=000100ms & <000200ms"; instance = instance }
  /// Batches >=000200ms & <000500ms: -
  let ``Batches >=000200ms & <000500ms`` instance =
    { category = CategoryName; counter = "Batches >=000200ms & <000500ms"; instance = instance }
  /// Batches >=000500ms & <001000ms: -
  let ``Batches >=000500ms & <001000ms`` instance =
    { category = CategoryName; counter = "Batches >=000500ms & <001000ms"; instance = instance }
  /// Batches >=001000ms & <002000ms: -
  let ``Batches >=001000ms & <002000ms`` instance =
    { category = CategoryName; counter = "Batches >=001000ms & <002000ms"; instance = instance }
  /// Batches >=002000ms & <005000ms: -
  let ``Batches >=002000ms & <005000ms`` instance =
    { category = CategoryName; counter = "Batches >=002000ms & <005000ms"; instance = instance }
  /// Batches >=005000ms & <010000ms: -
  let ``Batches >=005000ms & <010000ms`` instance =
    { category = CategoryName; counter = "Batches >=005000ms & <010000ms"; instance = instance }
  /// Batches >=010000ms & <020000ms: -
  let ``Batches >=010000ms & <020000ms`` instance =
    { category = CategoryName; counter = "Batches >=010000ms & <020000ms"; instance = instance }
  /// Batches >=020000ms & <050000ms: -
  let ``Batches >=020000ms & <050000ms`` instance =
    { category = CategoryName; counter = "Batches >=020000ms & <050000ms"; instance = instance }
  /// Batches >=050000ms & <100000ms: -
  let ``Batches >=050000ms & <100000ms`` instance =
    { category = CategoryName; counter = "Batches >=050000ms & <100000ms"; instance = instance }
  /// Batches >=100000ms: -
  let ``Batches >=100000ms`` instance =
    { category = CategoryName; counter = "Batches >=100000ms"; instance = instance }

  let allCounters =
    [| ``Batches >=000000ms & <000001ms``
       ``Batches >=000001ms & <000002ms``
       ``Batches >=000002ms & <000005ms``
       ``Batches >=000005ms & <000010ms``
       ``Batches >=000010ms & <000020ms``
       ``Batches >=000020ms & <000050ms``
       ``Batches >=000050ms & <000100ms``
       ``Batches >=000100ms & <000200ms``
       ``Batches >=000200ms & <000500ms``
       ``Batches >=000500ms & <001000ms``
       ``Batches >=001000ms & <002000ms``
       ``Batches >=002000ms & <005000ms``
       ``Batches >=005000ms & <010000ms``
       ``Batches >=010000ms & <020000ms``
       ``Batches >=020000ms & <050000ms``
       ``Batches >=050000ms & <100000ms``
       ``Batches >=100000ms``
    |]

/// SQLServer:Broker Activation: Service Broker Activation
///
/// This performance counter does not have instance based counters
module ``SQLServer:Broker Activation`` =

  [<Literal>]
  let CategoryName = "SQLServer:Broker Activation"

  let PCC = Category.create CategoryName
  /// Stored Procedures Invoked/sec: -
  let ``Stored Procedures Invoked/sec`` instance =
    { category = CategoryName; counter = "Stored Procedures Invoked/sec"; instance = instance }
  /// Task Limit Reached: -
  let ``Task Limit Reached`` instance =
    { category = CategoryName; counter = "Task Limit Reached"; instance = instance }
  /// Task Limit Reached/sec: -
  let ``Task Limit Reached/sec`` instance =
    { category = CategoryName; counter = "Task Limit Reached/sec"; instance = instance }
  /// Tasks Aborted/sec: -
  let ``Tasks Aborted/sec`` instance =
    { category = CategoryName; counter = "Tasks Aborted/sec"; instance = instance }
  /// Tasks Running: -
  let ``Tasks Running`` instance =
    { category = CategoryName; counter = "Tasks Running"; instance = instance }
  /// Tasks Started/sec: -
  let ``Tasks Started/sec`` instance =
    { category = CategoryName; counter = "Tasks Started/sec"; instance = instance }

  let allCounters =
    [| ``Stored Procedures Invoked/sec``
       ``Task Limit Reached``
       ``Task Limit Reached/sec``
       ``Tasks Aborted/sec``
       ``Tasks Running``
       ``Tasks Started/sec``
    |]

/// SQLServer:Broker Statistics: Service Broker Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Broker Statistics`` =

  [<Literal>]
  let CategoryName = "SQLServer:Broker Statistics"

  let PCC = Category.create CategoryName
  /// Activation Errors Total: The number of times an activation stored procedure exited with an error.
  let ``Activation Errors Total`` =
    { category = CategoryName; counter = "Activation Errors Total"; instance = None }
  /// Broker Transaction Rollbacks: The number of Service Broker related transactions that have rolled back.
  let ``Broker Transaction Rollbacks`` =
    { category = CategoryName; counter = "Broker Transaction Rollbacks"; instance = None }
  /// Corrupted Messages Total: The number of corrupted messages that were received in the instance.
  let ``Corrupted Messages Total`` =
    { category = CategoryName; counter = "Corrupted Messages Total"; instance = None }
  /// Dequeued TransmissionQ Msgs/sec: The number of messages that have been removed from the broker transmission queue per second.
  let ``Dequeued TransmissionQ Msgs/sec`` =
    { category = CategoryName; counter = "Dequeued TransmissionQ Msgs/sec"; instance = None }
  /// Dialog Timer Event Count: The number of dialog endpoint related timer events in the Broker.
  let ``Dialog Timer Event Count`` =
    { category = CategoryName; counter = "Dialog Timer Event Count"; instance = None }
  /// Dropped Messages Total: The number of messages that were received in the instance but could not be delivered.
  let ``Dropped Messages Total`` =
    { category = CategoryName; counter = "Dropped Messages Total"; instance = None }
  /// Enqueued Local Messages Total: Total number of messages from local endpoints that are successfully delivered directly into local target queues.
  let ``Enqueued Local Messages Total`` =
    { category = CategoryName; counter = "Enqueued Local Messages Total"; instance = None }
  /// Enqueued Local Messages/sec: The number of messages from local endpoints that are successfully delivered directly into local target queues per second.
  let ``Enqueued Local Messages/sec`` =
    { category = CategoryName; counter = "Enqueued Local Messages/sec"; instance = None }
  /// Enqueued Messages Total: Total number of messages from local endpoints and the transport that are successfully delivered into local target queues.
  let ``Enqueued Messages Total`` =
    { category = CategoryName; counter = "Enqueued Messages Total"; instance = None }
  /// Enqueued Messages/sec: The number of messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued Messages/sec`` =
    { category = CategoryName; counter = "Enqueued Messages/sec"; instance = None }
  /// Enqueued P1 Messages/sec: The number of priority 1 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P1 Messages/sec`` =
    { category = CategoryName; counter = "Enqueued P1 Messages/sec"; instance = None }
  /// Enqueued P10 Messages/sec: The number of priority 10 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P10 Messages/sec`` =
    { category = CategoryName; counter = "Enqueued P10 Messages/sec"; instance = None }
  /// Enqueued P2 Messages/sec: The number of priority 2 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P2 Messages/sec`` =
    { category = CategoryName; counter = "Enqueued P2 Messages/sec"; instance = None }
  /// Enqueued P3 Messages/sec: The number of priority 3 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P3 Messages/sec`` =
    { category = CategoryName; counter = "Enqueued P3 Messages/sec"; instance = None }
  /// Enqueued P4 Messages/sec: The number of priority 4 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P4 Messages/sec`` =
    { category = CategoryName; counter = "Enqueued P4 Messages/sec"; instance = None }
  /// Enqueued P5 Messages/sec: The number of priority 5 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P5 Messages/sec`` =
    { category = CategoryName; counter = "Enqueued P5 Messages/sec"; instance = None }
  /// Enqueued P6 Messages/sec: The number of priority 6 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P6 Messages/sec`` =
    { category = CategoryName; counter = "Enqueued P6 Messages/sec"; instance = None }
  /// Enqueued P7 Messages/sec: The number of priority 7 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P7 Messages/sec`` =
    { category = CategoryName; counter = "Enqueued P7 Messages/sec"; instance = None }
  /// Enqueued P8 Messages/sec: The number of priority 8 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P8 Messages/sec`` =
    { category = CategoryName; counter = "Enqueued P8 Messages/sec"; instance = None }
  /// Enqueued P9 Messages/sec: The number of priority 9 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P9 Messages/sec`` =
    { category = CategoryName; counter = "Enqueued P9 Messages/sec"; instance = None }
  /// Enqueued TransmissionQ Msgs/sec: The number of messages that have been placed into the broker transmission queue per second.
  let ``Enqueued TransmissionQ Msgs/sec`` =
    { category = CategoryName; counter = "Enqueued TransmissionQ Msgs/sec"; instance = None }
  /// Enqueued Transport Msg Frag Tot: Total number of message fragments from the transport that are successfully delivered into local target queues. Note that the message can be marked as disabled if it is incomplete and/or out of order.
  let ``Enqueued Transport Msg Frag Tot`` =
    { category = CategoryName; counter = "Enqueued Transport Msg Frag Tot"; instance = None }
  /// Enqueued Transport Msg Frags/sec: The number of message fragments from the transport that are successfully delivered into local target queues per second. Note that the message can be marked as disabled if it is incomplete and/or out of order.
  let ``Enqueued Transport Msg Frags/sec`` =
    { category = CategoryName; counter = "Enqueued Transport Msg Frags/sec"; instance = None }
  /// Enqueued Transport Msgs Total: Total number of messages from the transport that are successfully delivered into local target queues. This includes all messages from remote endpoints and messages from local endpoints which go through the transport.
  let ``Enqueued Transport Msgs Total`` =
    { category = CategoryName; counter = "Enqueued Transport Msgs Total"; instance = None }
  /// Enqueued Transport Msgs/sec: The number of messages from the transport that are successfully delivered into local target queues per second. This includes all messages from remote endpoints and messages from local endpoints which go through the transport.
  let ``Enqueued Transport Msgs/sec`` =
    { category = CategoryName; counter = "Enqueued Transport Msgs/sec"; instance = None }
  /// Forwarded Messages Total: Total number of forwarded messages successfully sent.
  let ``Forwarded Messages Total`` =
    { category = CategoryName; counter = "Forwarded Messages Total"; instance = None }
  /// Forwarded Messages/sec: The number of forwarded messages successfully sent per second.
  let ``Forwarded Messages/sec`` =
    { category = CategoryName; counter = "Forwarded Messages/sec"; instance = None }
  /// Forwarded Msg Byte Total: Total number of forwarded message bytes successfully sent.
  let ``Forwarded Msg Byte Total`` =
    { category = CategoryName; counter = "Forwarded Msg Byte Total"; instance = None }
  /// Forwarded Msg Bytes/sec: The number of forwarded message bytes successfully sent per second.
  let ``Forwarded Msg Bytes/sec`` =
    { category = CategoryName; counter = "Forwarded Msg Bytes/sec"; instance = None }
  /// Forwarded Msg Discarded Total: Total number of forwarded messages discarded due to forwarded message memory limits, age limits, etc.
  let ``Forwarded Msg Discarded Total`` =
    { category = CategoryName; counter = "Forwarded Msg Discarded Total"; instance = None }
  /// Forwarded Msgs Discarded/sec: The number of forwarded messages that were discarded per second due to forwarded message memory limits, age limits, etc.
  let ``Forwarded Msgs Discarded/sec`` =
    { category = CategoryName; counter = "Forwarded Msgs Discarded/sec"; instance = None }
  /// Forwarded Pending Msg Bytes: The number of forwarded message bytes that have not been successfully sent yet.
  let ``Forwarded Pending Msg Bytes`` =
    { category = CategoryName; counter = "Forwarded Pending Msg Bytes"; instance = None }
  /// Forwarded Pending Msg Count: The number of forwarded messages that have not been successfully sent yet.
  let ``Forwarded Pending Msg Count`` =
    { category = CategoryName; counter = "Forwarded Pending Msg Count"; instance = None }
  /// SQL RECEIVE Total: Total number of SQL RECEIVE commands processed by the Broker.
  let ``SQL RECEIVE Total`` =
    { category = CategoryName; counter = "SQL RECEIVE Total"; instance = None }
  /// SQL RECEIVEs/sec: The number of SQL RECEIVE commands processed by the Broker per second.
  let ``SQL RECEIVEs/sec`` =
    { category = CategoryName; counter = "SQL RECEIVEs/sec"; instance = None }
  /// SQL SEND Total: Total number of SQL SEND commands processed by the Broker.
  let ``SQL SEND Total`` =
    { category = CategoryName; counter = "SQL SEND Total"; instance = None }
  /// SQL SENDs/sec: The number of SQL SEND commands processed by the Broker per second.
  let ``SQL SENDs/sec`` =
    { category = CategoryName; counter = "SQL SENDs/sec"; instance = None }

  let allCounters =
    [| ``Activation Errors Total``
       ``Broker Transaction Rollbacks``
       ``Corrupted Messages Total``
       ``Dequeued TransmissionQ Msgs/sec``
       ``Dialog Timer Event Count``
       ``Dropped Messages Total``
       ``Enqueued Local Messages Total``
       ``Enqueued Local Messages/sec``
       ``Enqueued Messages Total``
       ``Enqueued Messages/sec``
       ``Enqueued P1 Messages/sec``
       ``Enqueued P10 Messages/sec``
       ``Enqueued P2 Messages/sec``
       ``Enqueued P3 Messages/sec``
       ``Enqueued P4 Messages/sec``
       ``Enqueued P5 Messages/sec``
       ``Enqueued P6 Messages/sec``
       ``Enqueued P7 Messages/sec``
       ``Enqueued P8 Messages/sec``
       ``Enqueued P9 Messages/sec``
       ``Enqueued TransmissionQ Msgs/sec``
       ``Enqueued Transport Msg Frag Tot``
       ``Enqueued Transport Msg Frags/sec``
       ``Enqueued Transport Msgs Total``
       ``Enqueued Transport Msgs/sec``
       ``Forwarded Messages Total``
       ``Forwarded Messages/sec``
       ``Forwarded Msg Byte Total``
       ``Forwarded Msg Bytes/sec``
       ``Forwarded Msg Discarded Total``
       ``Forwarded Msgs Discarded/sec``
       ``Forwarded Pending Msg Bytes``
       ``Forwarded Pending Msg Count``
       ``SQL RECEIVE Total``
       ``SQL RECEIVEs/sec``
       ``SQL SEND Total``
       ``SQL SENDs/sec``
    |]

/// SQLServer:Broker TO Statistics: Service Broker Transmission Object Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Broker TO Statistics`` =

  [<Literal>]
  let CategoryName = "SQLServer:Broker TO Statistics"

  let PCC = Category.create CategoryName
  /// Avg. Length of Batched Writes: Average Number of Transmission Objects saved in a batch.
  let ``Avg. Length of Batched Writes`` =
    { category = CategoryName; counter = "Avg. Length of Batched Writes"; instance = None }
  /// Avg. Length of Batched Writes BS: Average Number of Transmission Objects saved in a batch.
  let ``Avg. Length of Batched Writes BS`` =
    { category = CategoryName; counter = "Avg. Length of Batched Writes BS"; instance = None }
  /// Avg. Time Between Batches (ms): Average time between Transmission Object batch flushes.
  let ``Avg. Time Between Batches (ms)`` =
    { category = CategoryName; counter = "Avg. Time Between Batches (ms)"; instance = None }
  /// Avg. Time Between Batches Base: Average time between Transmission Object batch flushes.
  let ``Avg. Time Between Batches Base`` =
    { category = CategoryName; counter = "Avg. Time Between Batches Base"; instance = None }
  /// Avg. Time to Write Batch (ms): Average time to save a Transmission Object batch.
  let ``Avg. Time to Write Batch (ms)`` =
    { category = CategoryName; counter = "Avg. Time to Write Batch (ms)"; instance = None }
  /// Avg. Time to Write Batch Base: Average time to save a Transmission Object batch.
  let ``Avg. Time to Write Batch Base`` =
    { category = CategoryName; counter = "Avg. Time to Write Batch Base"; instance = None }
  /// Transmission Obj Gets/Sec: The number of Transmission Objects requested per second.
  let ``Transmission Obj Gets/Sec`` =
    { category = CategoryName; counter = "Transmission Obj Gets/Sec"; instance = None }
  /// Transmission Obj Set Dirty/Sec: The number of Transmission Objects marked dirty per second.
  let ``Transmission Obj Set Dirty/Sec`` =
    { category = CategoryName; counter = "Transmission Obj Set Dirty/Sec"; instance = None }
  /// Transmission Obj Writes/Sec: The number of Transmission Objects saved per second.
  let ``Transmission Obj Writes/Sec`` =
    { category = CategoryName; counter = "Transmission Obj Writes/Sec"; instance = None }

  let allCounters =
    [| ``Avg. Length of Batched Writes``
       ``Avg. Length of Batched Writes BS``
       ``Avg. Time Between Batches (ms)``
       ``Avg. Time Between Batches Base``
       ``Avg. Time to Write Batch (ms)``
       ``Avg. Time to Write Batch Base``
       ``Transmission Obj Gets/Sec``
       ``Transmission Obj Set Dirty/Sec``
       ``Transmission Obj Writes/Sec``
    |]

/// SQLServer:Broker/DBM Transport: Service Broker/Database Mirroring Transport Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Broker_DBM Transport`` =

  [<Literal>]
  let CategoryName = "SQLServer:Broker/DBM Transport"

  let PCC = Category.create CategoryName
  /// Current Bytes for Recv I/O: The number of bytes associated with current transport receive I/O operations that haven't completed.
  let ``Current Bytes for Recv I/O`` =
    { category = CategoryName; counter = "Current Bytes for Recv I/O"; instance = None }
  /// Current Bytes for Send I/O: The number of buffer bytes associated with current transport send I/O operations that haven't completed.
  let ``Current Bytes for Send I/O`` =
    { category = CategoryName; counter = "Current Bytes for Send I/O"; instance = None }
  /// Current Msg Frags for Send I/O: The current number of message fragments associated with current transport send I/O operations that haven't completed.
  let ``Current Msg Frags for Send I/O`` =
    { category = CategoryName; counter = "Current Msg Frags for Send I/O"; instance = None }
  /// Message Fragment P1 Sends/sec: The number of priority 1 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P1 Sends/sec`` =
    { category = CategoryName; counter = "Message Fragment P1 Sends/sec"; instance = None }
  /// Message Fragment P10 Sends/sec: The number of priority 10 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P10 Sends/sec`` =
    { category = CategoryName; counter = "Message Fragment P10 Sends/sec"; instance = None }
  /// Message Fragment P2 Sends/sec: The number of priority 2 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P2 Sends/sec`` =
    { category = CategoryName; counter = "Message Fragment P2 Sends/sec"; instance = None }
  /// Message Fragment P3 Sends/sec: The number of priority 3 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P3 Sends/sec`` =
    { category = CategoryName; counter = "Message Fragment P3 Sends/sec"; instance = None }
  /// Message Fragment P4 Sends/sec: The number of priority 4 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P4 Sends/sec`` =
    { category = CategoryName; counter = "Message Fragment P4 Sends/sec"; instance = None }
  /// Message Fragment P5 Sends/sec: The number of priority 5 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P5 Sends/sec`` =
    { category = CategoryName; counter = "Message Fragment P5 Sends/sec"; instance = None }
  /// Message Fragment P6 Sends/sec: The number of priority 6 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P6 Sends/sec`` =
    { category = CategoryName; counter = "Message Fragment P6 Sends/sec"; instance = None }
  /// Message Fragment P7 Sends/sec: The number of priority 7 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P7 Sends/sec`` =
    { category = CategoryName; counter = "Message Fragment P7 Sends/sec"; instance = None }
  /// Message Fragment P8 Sends/sec: The number of priority 8 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P8 Sends/sec`` =
    { category = CategoryName; counter = "Message Fragment P8 Sends/sec"; instance = None }
  /// Message Fragment P9 Sends/sec: The number of priority 9 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P9 Sends/sec`` =
    { category = CategoryName; counter = "Message Fragment P9 Sends/sec"; instance = None }
  /// Message Fragment Receives/sec: The number of message fragments received per second in transport receive I/O operations.
  let ``Message Fragment Receives/sec`` =
    { category = CategoryName; counter = "Message Fragment Receives/sec"; instance = None }
  /// Message Fragment Sends/sec: The number of message fragments sent per second in transport send I/O operations.
  let ``Message Fragment Sends/sec`` =
    { category = CategoryName; counter = "Message Fragment Sends/sec"; instance = None }
  /// Msg Fragment Recv Size Avg: The average byte size of message fragments received in transport receive I/O operations.
  let ``Msg Fragment Recv Size Avg`` =
    { category = CategoryName; counter = "Msg Fragment Recv Size Avg"; instance = None }
  /// Msg Fragment Recv Size Avg Base: Base for the average byte size of message fragments received in transport receive I/O operations.
  let ``Msg Fragment Recv Size Avg Base`` =
    { category = CategoryName; counter = "Msg Fragment Recv Size Avg Base"; instance = None }
  /// Msg Fragment Send Size Avg: The average byte size of message fragments sent in transport send I/O operations.
  let ``Msg Fragment Send Size Avg`` =
    { category = CategoryName; counter = "Msg Fragment Send Size Avg"; instance = None }
  /// Msg Fragment Send Size Avg Base: Base for the average byte size of message fragments sent in transport send I/O operations.
  let ``Msg Fragment Send Size Avg Base`` =
    { category = CategoryName; counter = "Msg Fragment Send Size Avg Base"; instance = None }
  /// Open Connection Count: The total number of transport connections currently open.
  let ``Open Connection Count`` =
    { category = CategoryName; counter = "Open Connection Count"; instance = None }
  /// Pending Bytes for Recv I/O: The number of bytes associated with in completed transport receive I/O operations whose message fragments haven't been enqueued (or rejected) yet.
  let ``Pending Bytes for Recv I/O`` =
    { category = CategoryName; counter = "Pending Bytes for Recv I/O"; instance = None }
  /// Pending Bytes for Send I/O: The number of buffer bytes associated with message fragments being marshalled, or marshalled and ready to be sent with send I/O operations.
  let ``Pending Bytes for Send I/O`` =
    { category = CategoryName; counter = "Pending Bytes for Send I/O"; instance = None }
  /// Pending Msg Frags for Recv I/O: The current number of message fragments received in transport receive I/O operations that have not been enqueued (or rejected) yet.
  let ``Pending Msg Frags for Recv I/O`` =
    { category = CategoryName; counter = "Pending Msg Frags for Recv I/O"; instance = None }
  /// Pending Msg Frags for Send I/O: The current number of message fragments that are being marshalled, or marshalled and ready to be sent via the transport layer.
  let ``Pending Msg Frags for Send I/O`` =
    { category = CategoryName; counter = "Pending Msg Frags for Send I/O"; instance = None }
  /// Receive I/O Len Avg: The average byte length of transport receive I/O operations.
  let ``Receive I/O Len Avg`` =
    { category = CategoryName; counter = "Receive I/O Len Avg"; instance = None }
  /// Receive I/O Len Avg Base: Base for the average byte length of transport receive I/O operations.
  let ``Receive I/O Len Avg Base`` =
    { category = CategoryName; counter = "Receive I/O Len Avg Base"; instance = None }
  /// Receive I/O bytes/sec: The number of transport receive I/O bytes per second.
  let ``Receive I/O bytes/sec`` =
    { category = CategoryName; counter = "Receive I/O bytes/sec"; instance = None }
  /// Receive I/Os/sec: The number of transport receives I/O per second. Note that a transport receive I/O may contain more than one message fragment.
  let ``Receive I/Os/sec`` =
    { category = CategoryName; counter = "Receive I/Os/sec"; instance = None }
  /// Recv I/O Buffer Copies Count: The number of times when transport receive I/O operations had to move buffer fragments in memory.
  let ``Recv I/O Buffer Copies Count`` =
    { category = CategoryName; counter = "Recv I/O Buffer Copies Count"; instance = None }
  /// Recv I/O Buffer Copies bytes/sec: The rate at which transport receive I/O operations had to move buffer fragments in memory.
  let ``Recv I/O Buffer Copies bytes/sec`` =
    { category = CategoryName; counter = "Recv I/O Buffer Copies bytes/sec"; instance = None }
  /// Send I/O Len Avg: The average byte length of transport send I/O operations.
  let ``Send I/O Len Avg`` =
    { category = CategoryName; counter = "Send I/O Len Avg"; instance = None }
  /// Send I/O Len Avg Base: Base for the average byte length of transport send I/O operations.
  let ``Send I/O Len Avg Base`` =
    { category = CategoryName; counter = "Send I/O Len Avg Base"; instance = None }
  /// Send I/O bytes/sec: The number of transport send I/O bytes per second.
  let ``Send I/O bytes/sec`` =
    { category = CategoryName; counter = "Send I/O bytes/sec"; instance = None }
  /// Send I/Os/sec: The number of transport send I/Os per second. Note that a transport send I/O may contain more than one message fragment.
  let ``Send I/Os/sec`` =
    { category = CategoryName; counter = "Send I/Os/sec"; instance = None }

  let allCounters =
    [| ``Current Bytes for Recv I/O``
       ``Current Bytes for Send I/O``
       ``Current Msg Frags for Send I/O``
       ``Message Fragment P1 Sends/sec``
       ``Message Fragment P10 Sends/sec``
       ``Message Fragment P2 Sends/sec``
       ``Message Fragment P3 Sends/sec``
       ``Message Fragment P4 Sends/sec``
       ``Message Fragment P5 Sends/sec``
       ``Message Fragment P6 Sends/sec``
       ``Message Fragment P7 Sends/sec``
       ``Message Fragment P8 Sends/sec``
       ``Message Fragment P9 Sends/sec``
       ``Message Fragment Receives/sec``
       ``Message Fragment Sends/sec``
       ``Msg Fragment Recv Size Avg``
       ``Msg Fragment Recv Size Avg Base``
       ``Msg Fragment Send Size Avg``
       ``Msg Fragment Send Size Avg Base``
       ``Open Connection Count``
       ``Pending Bytes for Recv I/O``
       ``Pending Bytes for Send I/O``
       ``Pending Msg Frags for Recv I/O``
       ``Pending Msg Frags for Send I/O``
       ``Receive I/O Len Avg``
       ``Receive I/O Len Avg Base``
       ``Receive I/O bytes/sec``
       ``Receive I/Os/sec``
       ``Recv I/O Buffer Copies Count``
       ``Recv I/O Buffer Copies bytes/sec``
       ``Send I/O Len Avg``
       ``Send I/O Len Avg Base``
       ``Send I/O bytes/sec``
       ``Send I/Os/sec``
    |]

/// SQLServer:Buffer Manager: Statistics related to SQL Servers buffer manager
///
/// This performance counter does not have instance based counters
module ``SQLServer:Buffer Manager`` =

  [<Literal>]
  let CategoryName = "SQLServer:Buffer Manager"

  let PCC = Category.create CategoryName
  /// Background writer pages/sec: Number of pages flushed to enforce the recovery interval settings.
  let ``Background writer pages/sec`` =
    { category = CategoryName; counter = "Background writer pages/sec"; instance = None }
  /// Buffer cache hit ratio: Percentage of pages that were found in the buffer pool without having to incur a read from disk.
  let ``Buffer cache hit ratio`` =
    { category = CategoryName; counter = "Buffer cache hit ratio"; instance = None }
  /// Buffer cache hit ratio base: Base for prior entry
  let ``Buffer cache hit ratio base`` =
    { category = CategoryName; counter = "Buffer cache hit ratio base"; instance = None }
  /// Checkpoint pages/sec: Number of pages flushed by checkpoint or other operations that require all dirty pages to be flushed.
  let ``Checkpoint pages/sec`` =
    { category = CategoryName; counter = "Checkpoint pages/sec"; instance = None }
  /// Database pages: Number of pages in the buffer pool with database content.
  let ``Database pages`` =
    { category = CategoryName; counter = "Database pages"; instance = None }
  /// Extension allocated pages: Number of pages occupying buffer pool extension cache.
  let ``Extension allocated pages`` =
    { category = CategoryName; counter = "Extension allocated pages"; instance = None }
  /// Extension free pages: Number of pages needed to fill the buffer pool extension cache.
  let ``Extension free pages`` =
    { category = CategoryName; counter = "Extension free pages"; instance = None }
  /// Extension in use as percentage: Percentage of the buffer pool extension paging file occupied by buffer manager pages.
  let ``Extension in use as percentage`` =
    { category = CategoryName; counter = "Extension in use as percentage"; instance = None }
  /// Extension outstanding IO counter: Number of buffer pool extension page reads/writes outstanding.
  let ``Extension outstanding IO counter`` =
    { category = CategoryName; counter = "Extension outstanding IO counter"; instance = None }
  /// Extension page evictions/sec: Number of buffer pool extension page evictions.
  let ``Extension page evictions/sec`` =
    { category = CategoryName; counter = "Extension page evictions/sec"; instance = None }
  /// Extension page reads/sec: Number of buffer pool extension page reads issued.
  let ``Extension page reads/sec`` =
    { category = CategoryName; counter = "Extension page reads/sec"; instance = None }
  /// Extension page unreferenced time: Average seconds a page will stay in the buffer pool extension without references.
  let ``Extension page unreferenced time`` =
    { category = CategoryName; counter = "Extension page unreferenced time"; instance = None }
  /// Extension page writes/sec: Number of Extension page writes issued.
  let ``Extension page writes/sec`` =
    { category = CategoryName; counter = "Extension page writes/sec"; instance = None }
  /// Free list stalls/sec: Number of requests that had to wait for a free page.
  let ``Free list stalls/sec`` =
    { category = CategoryName; counter = "Free list stalls/sec"; instance = None }
  /// Integral Controller Slope: The slope that integral controller for the buffer pool last used, times -10 billion
  let ``Integral Controller Slope`` =
    { category = CategoryName; counter = "Integral Controller Slope"; instance = None }
  /// Lazy writes/sec: Number of buffers written by buffer manager's lazy writer.
  let ``Lazy writes/sec`` =
    { category = CategoryName; counter = "Lazy writes/sec"; instance = None }
  /// Page life expectancy: Number of seconds a page will stay in the buffer pool without references.
  let ``Page life expectancy`` =
    { category = CategoryName; counter = "Page life expectancy"; instance = None }
  /// Page lookups/sec: Number of requests to find a page in the buffer pool.
  let ``Page lookups/sec`` =
    { category = CategoryName; counter = "Page lookups/sec"; instance = None }
  /// Page reads/sec: Number of physical database page reads issued.
  let ``Page reads/sec`` =
    { category = CategoryName; counter = "Page reads/sec"; instance = None }
  /// Page writes/sec: Number of physical database page writes issued.
  let ``Page writes/sec`` =
    { category = CategoryName; counter = "Page writes/sec"; instance = None }
  /// Readahead pages/sec: Number of pages read in anticipation of use.
  let ``Readahead pages/sec`` =
    { category = CategoryName; counter = "Readahead pages/sec"; instance = None }
  /// Readahead time/sec: Time (microseconds) spent issuing readahead.
  let ``Readahead time/sec`` =
    { category = CategoryName; counter = "Readahead time/sec"; instance = None }
  /// Target pages: Ideal number of pages in the buffer pool.
  let ``Target pages`` =
    { category = CategoryName; counter = "Target pages"; instance = None }

  let allCounters =
    [| ``Background writer pages/sec``
       ``Buffer cache hit ratio``
       ``Buffer cache hit ratio base``
       ``Checkpoint pages/sec``
       ``Database pages``
       ``Extension allocated pages``
       ``Extension free pages``
       ``Extension in use as percentage``
       ``Extension outstanding IO counter``
       ``Extension page evictions/sec``
       ``Extension page reads/sec``
       ``Extension page unreferenced time``
       ``Extension page writes/sec``
       ``Free list stalls/sec``
       ``Integral Controller Slope``
       ``Lazy writes/sec``
       ``Page life expectancy``
       ``Page lookups/sec``
       ``Page reads/sec``
       ``Page writes/sec``
       ``Readahead pages/sec``
       ``Readahead time/sec``
       ``Target pages``
    |]

/// SQLServer:Buffer Node: Statistics related to SQL Server's buffer pool by NUMA node
///
/// This performance counter does not have instance based counters
module ``SQLServer:Buffer Node`` =

  [<Literal>]
  let CategoryName = "SQLServer:Buffer Node"

  let PCC = Category.create CategoryName
  /// Database pages: -
  let ``Database pages`` instance =
    { category = CategoryName; counter = "Database pages"; instance = instance }
  /// Local node page lookups/sec: -
  let ``Local node page lookups/sec`` instance =
    { category = CategoryName; counter = "Local node page lookups/sec"; instance = instance }
  /// Page life expectancy: -
  let ``Page life expectancy`` instance =
    { category = CategoryName; counter = "Page life expectancy"; instance = instance }
  /// Remote node page lookups/sec: -
  let ``Remote node page lookups/sec`` instance =
    { category = CategoryName; counter = "Remote node page lookups/sec"; instance = instance }

  let allCounters =
    [| ``Database pages``
       ``Local node page lookups/sec``
       ``Page life expectancy``
       ``Remote node page lookups/sec``
    |]

/// SQLServer:CLR: CLR Execution in SQL Server
///
/// This performance counter does not have instance based counters
module ``SQLServer:CLR`` =

  [<Literal>]
  let CategoryName = "SQLServer:CLR"

  let PCC = Category.create CategoryName
  /// CLR Execution: Total Execution time in CLR ( microseconds ).
  let ``CLR Execution`` =
    { category = CategoryName; counter = "CLR Execution"; instance = None }

  let allCounters =
    [| ``CLR Execution``

    |]

/// SQLServer:Catalog Metadata: This defines a catalog metadata manager object for SQL Server
///
/// This performance counter does not have instance based counters
module ``SQLServer:Catalog Metadata`` =

  [<Literal>]
  let CategoryName = "SQLServer:Catalog Metadata"

  let PCC = Category.create CategoryName
  /// Cache Entries Count: -
  let ``Cache Entries Count`` instance =
    { category = CategoryName; counter = "Cache Entries Count"; instance = instance }
  /// Cache Entries Pinned Count: -
  let ``Cache Entries Pinned Count`` instance =
    { category = CategoryName; counter = "Cache Entries Pinned Count"; instance = instance }
  /// Cache Hit Ratio: -
  let ``Cache Hit Ratio`` instance =
    { category = CategoryName; counter = "Cache Hit Ratio"; instance = instance }
  /// Cache Hit Ratio Base: -
  let ``Cache Hit Ratio Base`` instance =
    { category = CategoryName; counter = "Cache Hit Ratio Base"; instance = instance }

  let allCounters =
    [| ``Cache Entries Count``
       ``Cache Entries Pinned Count``
       ``Cache Hit Ratio``
       ``Cache Hit Ratio Base``
    |]

/// SQLServer:Cursor Manager Total: Counters for cursor properties not grouped by type
///
/// This performance counter does not have instance based counters
module ``SQLServer:Cursor Manager Total`` =

  [<Literal>]
  let CategoryName = "SQLServer:Cursor Manager Total"

  let PCC = Category.create CategoryName
  /// Async population count: Number of cursors being populated asynchronously.
  let ``Async population count`` =
    { category = CategoryName; counter = "Async population count"; instance = None }
  /// Cursor conversion rate: Number of cursor conversions/sec.
  let ``Cursor conversion rate`` =
    { category = CategoryName; counter = "Cursor conversion rate"; instance = None }
  /// Cursor flushes: Total number of times a flush for a cursor xstmt occured.
  let ``Cursor flushes`` =
    { category = CategoryName; counter = "Cursor flushes"; instance = None }

  let allCounters =
    [| ``Async population count``
       ``Cursor conversion rate``
       ``Cursor flushes``
    |]

/// SQLServer:Cursor Manager by Type: Counters for cursor properties grouped by type
///
/// This performance counter does not have instance based counters
module ``SQLServer:Cursor Manager by Type`` =

  [<Literal>]
  let CategoryName = "SQLServer:Cursor Manager by Type"

  let PCC = Category.create CategoryName
  /// Active cursors: -
  let ``Active cursors`` instance =
    { category = CategoryName; counter = "Active cursors"; instance = instance }
  /// Cache Hit Ratio: -
  let ``Cache Hit Ratio`` instance =
    { category = CategoryName; counter = "Cache Hit Ratio"; instance = instance }
  /// Cache Hit Ratio Base: -
  let ``Cache Hit Ratio Base`` instance =
    { category = CategoryName; counter = "Cache Hit Ratio Base"; instance = instance }
  /// Cached Cursor Counts: -
  let ``Cached Cursor Counts`` instance =
    { category = CategoryName; counter = "Cached Cursor Counts"; instance = instance }
  /// Cursor Cache Use Counts/sec: -
  let ``Cursor Cache Use Counts/sec`` instance =
    { category = CategoryName; counter = "Cursor Cache Use Counts/sec"; instance = instance }
  /// Cursor Requests/sec: -
  let ``Cursor Requests/sec`` instance =
    { category = CategoryName; counter = "Cursor Requests/sec"; instance = instance }
  /// Cursor memory usage: -
  let ``Cursor memory usage`` instance =
    { category = CategoryName; counter = "Cursor memory usage"; instance = instance }
  /// Cursor worktable usage: -
  let ``Cursor worktable usage`` instance =
    { category = CategoryName; counter = "Cursor worktable usage"; instance = instance }
  /// Number of active cursor plans: -
  let ``Number of active cursor plans`` instance =
    { category = CategoryName; counter = "Number of active cursor plans"; instance = instance }

  let allCounters =
    [| ``Active cursors``
       ``Cache Hit Ratio``
       ``Cache Hit Ratio Base``
       ``Cached Cursor Counts``
       ``Cursor Cache Use Counts/sec``
       ``Cursor Requests/sec``
       ``Cursor memory usage``
       ``Cursor worktable usage``
       ``Number of active cursor plans``
    |]

/// SQLServer:Database Mirroring: This defines a Database Mirroring object for SQL Server
///
/// This performance counter does not have instance based counters
module ``SQLServer:Database Mirroring`` =

  [<Literal>]
  let CategoryName = "SQLServer:Database Mirroring"

  let PCC = Category.create CategoryName
  /// Bytes Received/sec: -
  let ``Bytes Received/sec`` instance =
    { category = CategoryName; counter = "Bytes Received/sec"; instance = instance }
  /// Bytes Sent/sec: -
  let ``Bytes Sent/sec`` instance =
    { category = CategoryName; counter = "Bytes Sent/sec"; instance = instance }
  /// Log Bytes Received/sec: -
  let ``Log Bytes Received/sec`` instance =
    { category = CategoryName; counter = "Log Bytes Received/sec"; instance = instance }
  /// Log Bytes Redone from Cache/sec: -
  let ``Log Bytes Redone from Cache/sec`` instance =
    { category = CategoryName; counter = "Log Bytes Redone from Cache/sec"; instance = instance }
  /// Log Bytes Sent from Cache/sec: -
  let ``Log Bytes Sent from Cache/sec`` instance =
    { category = CategoryName; counter = "Log Bytes Sent from Cache/sec"; instance = instance }
  /// Log Bytes Sent/sec: -
  let ``Log Bytes Sent/sec`` instance =
    { category = CategoryName; counter = "Log Bytes Sent/sec"; instance = instance }
  /// Log Compressed Bytes Rcvd/sec: -
  let ``Log Compressed Bytes Rcvd/sec`` instance =
    { category = CategoryName; counter = "Log Compressed Bytes Rcvd/sec"; instance = instance }
  /// Log Compressed Bytes Sent/sec: -
  let ``Log Compressed Bytes Sent/sec`` instance =
    { category = CategoryName; counter = "Log Compressed Bytes Sent/sec"; instance = instance }
  /// Log Harden Time (ms): -
  let ``Log Harden Time (ms)`` instance =
    { category = CategoryName; counter = "Log Harden Time (ms)"; instance = instance }
  /// Log Remaining for Undo KB: -
  let ``Log Remaining for Undo KB`` instance =
    { category = CategoryName; counter = "Log Remaining for Undo KB"; instance = instance }
  /// Log Scanned for Undo KB: -
  let ``Log Scanned for Undo KB`` instance =
    { category = CategoryName; counter = "Log Scanned for Undo KB"; instance = instance }
  /// Log Send Flow Control Time (ms): -
  let ``Log Send Flow Control Time (ms)`` instance =
    { category = CategoryName; counter = "Log Send Flow Control Time (ms)"; instance = instance }
  /// Log Send Queue KB: -
  let ``Log Send Queue KB`` instance =
    { category = CategoryName; counter = "Log Send Queue KB"; instance = instance }
  /// Mirrored Write Transactions/sec: -
  let ``Mirrored Write Transactions/sec`` instance =
    { category = CategoryName; counter = "Mirrored Write Transactions/sec"; instance = instance }
  /// Pages Sent/sec: -
  let ``Pages Sent/sec`` instance =
    { category = CategoryName; counter = "Pages Sent/sec"; instance = instance }
  /// Receives/sec: -
  let ``Receives/sec`` instance =
    { category = CategoryName; counter = "Receives/sec"; instance = instance }
  /// Redo Bytes/sec: -
  let ``Redo Bytes/sec`` instance =
    { category = CategoryName; counter = "Redo Bytes/sec"; instance = instance }
  /// Redo Queue KB: -
  let ``Redo Queue KB`` instance =
    { category = CategoryName; counter = "Redo Queue KB"; instance = instance }
  /// Send/Receive Ack Time: -
  let ``Send/Receive Ack Time`` instance =
    { category = CategoryName; counter = "Send/Receive Ack Time"; instance = instance }
  /// Sends/sec: -
  let ``Sends/sec`` instance =
    { category = CategoryName; counter = "Sends/sec"; instance = instance }
  /// Transaction Delay: -
  let ``Transaction Delay`` instance =
    { category = CategoryName; counter = "Transaction Delay"; instance = instance }

  let allCounters =
    [| ``Bytes Received/sec``
       ``Bytes Sent/sec``
       ``Log Bytes Received/sec``
       ``Log Bytes Redone from Cache/sec``
       ``Log Bytes Sent from Cache/sec``
       ``Log Bytes Sent/sec``
       ``Log Compressed Bytes Rcvd/sec``
       ``Log Compressed Bytes Sent/sec``
       ``Log Harden Time (ms)``
       ``Log Remaining for Undo KB``
       ``Log Scanned for Undo KB``
       ``Log Send Flow Control Time (ms)``
       ``Log Send Queue KB``
       ``Mirrored Write Transactions/sec``
       ``Pages Sent/sec``
       ``Receives/sec``
       ``Redo Bytes/sec``
       ``Redo Queue KB``
       ``Send/Receive Ack Time``
       ``Sends/sec``
       ``Transaction Delay``
    |]

/// SQLServer:Database Replica: This defines a HADR secondary database object for SQL Server
///
/// This performance counter does not have instance based counters
module ``SQLServer:Database Replica`` =

  [<Literal>]
  let CategoryName = "SQLServer:Database Replica"

  let PCC = Category.create CategoryName
  /// File Bytes Received/sec: -
  let ``File Bytes Received/sec`` instance =
    { category = CategoryName; counter = "File Bytes Received/sec"; instance = instance }
  /// Log Bytes Received/sec: -
  let ``Log Bytes Received/sec`` instance =
    { category = CategoryName; counter = "Log Bytes Received/sec"; instance = instance }
  /// Log Send Queue: -
  let ``Log Send Queue`` instance =
    { category = CategoryName; counter = "Log Send Queue"; instance = instance }
  /// Log remaining for undo: -
  let ``Log remaining for undo`` instance =
    { category = CategoryName; counter = "Log remaining for undo"; instance = instance }
  /// Mirrored Write Transactions/sec: -
  let ``Mirrored Write Transactions/sec`` instance =
    { category = CategoryName; counter = "Mirrored Write Transactions/sec"; instance = instance }
  /// Recovery Queue: -
  let ``Recovery Queue`` instance =
    { category = CategoryName; counter = "Recovery Queue"; instance = instance }
  /// Redo Bytes Remaining: -
  let ``Redo Bytes Remaining`` instance =
    { category = CategoryName; counter = "Redo Bytes Remaining"; instance = instance }
  /// Redo blocked/sec: -
  let ``Redo blocked/sec`` instance =
    { category = CategoryName; counter = "Redo blocked/sec"; instance = instance }
  /// Redone Bytes/sec: -
  let ``Redone Bytes/sec`` instance =
    { category = CategoryName; counter = "Redone Bytes/sec"; instance = instance }
  /// Total Log requiring undo: -
  let ``Total Log requiring undo`` instance =
    { category = CategoryName; counter = "Total Log requiring undo"; instance = instance }
  /// Transaction Delay: -
  let ``Transaction Delay`` instance =
    { category = CategoryName; counter = "Transaction Delay"; instance = instance }

  let allCounters =
    [| ``File Bytes Received/sec``
       ``Log Bytes Received/sec``
       ``Log Send Queue``
       ``Log remaining for undo``
       ``Mirrored Write Transactions/sec``
       ``Recovery Queue``
       ``Redo Bytes Remaining``
       ``Redo blocked/sec``
       ``Redone Bytes/sec``
       ``Total Log requiring undo``
       ``Transaction Delay``
    |]

/// SQLServer:Databases: This defines a Database manager object for SQL Server
///
/// This performance counter does not have instance based counters
module ``SQLServer:Databases`` =

  [<Literal>]
  let CategoryName = "SQLServer:Databases"

  let PCC = Category.create CategoryName
  /// Active Transactions: -
  let ``Active Transactions`` instance =
    { category = CategoryName; counter = "Active Transactions"; instance = instance }
  /// Backup/Restore Throughput/sec: -
  let ``Backup/Restore Throughput/sec`` instance =
    { category = CategoryName; counter = "Backup/Restore Throughput/sec"; instance = instance }
  /// Bulk Copy Rows/sec: -
  let ``Bulk Copy Rows/sec`` instance =
    { category = CategoryName; counter = "Bulk Copy Rows/sec"; instance = instance }
  /// Bulk Copy Throughput/sec: -
  let ``Bulk Copy Throughput/sec`` instance =
    { category = CategoryName; counter = "Bulk Copy Throughput/sec"; instance = instance }
  /// Commit table entries: -
  let ``Commit table entries`` instance =
    { category = CategoryName; counter = "Commit table entries"; instance = instance }
  /// DBCC Logical Scan Bytes/sec: -
  let ``DBCC Logical Scan Bytes/sec`` instance =
    { category = CategoryName; counter = "DBCC Logical Scan Bytes/sec"; instance = instance }
  /// Data File(s) Size (KB): -
  let ``Data File(s) Size (KB)`` instance =
    { category = CategoryName; counter = "Data File(s) Size (KB)"; instance = instance }
  /// Group Commit Time/sec: -
  let ``Group Commit Time/sec`` instance =
    { category = CategoryName; counter = "Group Commit Time/sec"; instance = instance }
  /// Log Bytes Flushed/sec: -
  let ``Log Bytes Flushed/sec`` instance =
    { category = CategoryName; counter = "Log Bytes Flushed/sec"; instance = instance }
  /// Log Cache Hit Ratio: -
  let ``Log Cache Hit Ratio`` instance =
    { category = CategoryName; counter = "Log Cache Hit Ratio"; instance = instance }
  /// Log Cache Hit Ratio Base: -
  let ``Log Cache Hit Ratio Base`` instance =
    { category = CategoryName; counter = "Log Cache Hit Ratio Base"; instance = instance }
  /// Log Cache Reads/sec: -
  let ``Log Cache Reads/sec`` instance =
    { category = CategoryName; counter = "Log Cache Reads/sec"; instance = instance }
  /// Log File(s) Size (KB): -
  let ``Log File(s) Size (KB)`` instance =
    { category = CategoryName; counter = "Log File(s) Size (KB)"; instance = instance }
  /// Log File(s) Used Size (KB): -
  let ``Log File(s) Used Size (KB)`` instance =
    { category = CategoryName; counter = "Log File(s) Used Size (KB)"; instance = instance }
  /// Log Flush Wait Time: -
  let ``Log Flush Wait Time`` instance =
    { category = CategoryName; counter = "Log Flush Wait Time"; instance = instance }
  /// Log Flush Waits/sec: -
  let ``Log Flush Waits/sec`` instance =
    { category = CategoryName; counter = "Log Flush Waits/sec"; instance = instance }
  /// Log Flush Write Time (ms): -
  let ``Log Flush Write Time (ms)`` instance =
    { category = CategoryName; counter = "Log Flush Write Time (ms)"; instance = instance }
  /// Log Flushes/sec: -
  let ``Log Flushes/sec`` instance =
    { category = CategoryName; counter = "Log Flushes/sec"; instance = instance }
  /// Log Growths: -
  let ``Log Growths`` instance =
    { category = CategoryName; counter = "Log Growths"; instance = instance }
  /// Log Pool Cache Misses/sec: -
  let ``Log Pool Cache Misses/sec`` instance =
    { category = CategoryName; counter = "Log Pool Cache Misses/sec"; instance = instance }
  /// Log Pool Disk Reads/sec: -
  let ``Log Pool Disk Reads/sec`` instance =
    { category = CategoryName; counter = "Log Pool Disk Reads/sec"; instance = instance }
  /// Log Pool Requests/sec: -
  let ``Log Pool Requests/sec`` instance =
    { category = CategoryName; counter = "Log Pool Requests/sec"; instance = instance }
  /// Log Shrinks: -
  let ``Log Shrinks`` instance =
    { category = CategoryName; counter = "Log Shrinks"; instance = instance }
  /// Log Truncations: -
  let ``Log Truncations`` instance =
    { category = CategoryName; counter = "Log Truncations"; instance = instance }
  /// Percent Log Used: -
  let ``Percent Log Used`` instance =
    { category = CategoryName; counter = "Percent Log Used"; instance = instance }
  /// Repl. Pending Xacts: -
  let ``Repl. Pending Xacts`` instance =
    { category = CategoryName; counter = "Repl. Pending Xacts"; instance = instance }
  /// Repl. Trans. Rate: -
  let ``Repl. Trans. Rate`` instance =
    { category = CategoryName; counter = "Repl. Trans. Rate"; instance = instance }
  /// Shrink Data Movement Bytes/sec: -
  let ``Shrink Data Movement Bytes/sec`` instance =
    { category = CategoryName; counter = "Shrink Data Movement Bytes/sec"; instance = instance }
  /// Tracked transactions/sec: -
  let ``Tracked transactions/sec`` instance =
    { category = CategoryName; counter = "Tracked transactions/sec"; instance = instance }
  /// Transactions/sec: -
  let ``Transactions/sec`` instance =
    { category = CategoryName; counter = "Transactions/sec"; instance = instance }
  /// Write Transactions/sec: -
  let ``Write Transactions/sec`` instance =
    { category = CategoryName; counter = "Write Transactions/sec"; instance = instance }
  /// XTP Memory Used (KB): -
  let ``XTP Memory Used (KB)`` instance =
    { category = CategoryName; counter = "XTP Memory Used (KB)"; instance = instance }

  let allCounters =
    [| ``Active Transactions``
       ``Backup/Restore Throughput/sec``
       ``Bulk Copy Rows/sec``
       ``Bulk Copy Throughput/sec``
       ``Commit table entries``
       ``DBCC Logical Scan Bytes/sec``
       ``Data File(s) Size (KB)``
       ``Group Commit Time/sec``
       ``Log Bytes Flushed/sec``
       ``Log Cache Hit Ratio``
       ``Log Cache Hit Ratio Base``
       ``Log Cache Reads/sec``
       ``Log File(s) Size (KB)``
       ``Log File(s) Used Size (KB)``
       ``Log Flush Wait Time``
       ``Log Flush Waits/sec``
       ``Log Flush Write Time (ms)``
       ``Log Flushes/sec``
       ``Log Growths``
       ``Log Pool Cache Misses/sec``
       ``Log Pool Disk Reads/sec``
       ``Log Pool Requests/sec``
       ``Log Shrinks``
       ``Log Truncations``
       ``Percent Log Used``
       ``Repl. Pending Xacts``
       ``Repl. Trans. Rate``
       ``Shrink Data Movement Bytes/sec``
       ``Tracked transactions/sec``
       ``Transactions/sec``
       ``Write Transactions/sec``
       ``XTP Memory Used (KB)``
    |]

/// SQLServer:Deprecated Features: Statistics on deprecated feature usage
///
/// This performance counter does not have instance based counters
module ``SQLServer:Deprecated Features`` =

  [<Literal>]
  let CategoryName = "SQLServer:Deprecated Features"

  let PCC = Category.create CategoryName
  /// Usage: -
  let ``Usage`` instance =
    { category = CategoryName; counter = "Usage"; instance = instance }

  let allCounters =
    [| ``Usage``

    |]

/// SQLServer:Exec Statistics: Execution statistics for external calls
///
/// This performance counter does not have instance based counters
module ``SQLServer:Exec Statistics`` =

  [<Literal>]
  let CategoryName = "SQLServer:Exec Statistics"

  let PCC = Category.create CategoryName
  /// DTC calls: -
  let ``DTC calls`` instance =
    { category = CategoryName; counter = "DTC calls"; instance = instance }
  /// Distributed Query: -
  let ``Distributed Query`` instance =
    { category = CategoryName; counter = "Distributed Query"; instance = instance }
  /// Extended Procedures: -
  let ``Extended Procedures`` instance =
    { category = CategoryName; counter = "Extended Procedures"; instance = instance }
  /// OLEDB calls: -
  let ``OLEDB calls`` instance =
    { category = CategoryName; counter = "OLEDB calls"; instance = instance }

  let allCounters =
    [| ``DTC calls``
       ``Distributed Query``
       ``Extended Procedures``
       ``OLEDB calls``
    |]

/// SQLServer:FileTable: Statistics associated with FileTable and non-transacted access
///
/// This performance counter does not have instance based counters
module ``SQLServer:FileTable`` =

  [<Literal>]
  let CategoryName = "SQLServer:FileTable"

  let PCC = Category.create CategoryName
  /// Avg time FileTable enumeration: Average time (in milliseconds) taken for a FileTable enumeration request.
  let ``Avg time FileTable enumeration`` =
    { category = CategoryName; counter = "Avg time FileTable enumeration"; instance = None }
  /// Avg time FileTable handle kill: Average time (in milliseconds) taken to kill a FileTable handle.
  let ``Avg time FileTable handle kill`` =
    { category = CategoryName; counter = "Avg time FileTable handle kill"; instance = None }
  /// Avg time delete FileTable item: Average time (in milliseconds) taken to delete a FileTable item.
  let ``Avg time delete FileTable item`` =
    { category = CategoryName; counter = "Avg time delete FileTable item"; instance = None }
  /// Avg time move FileTable item: Average time (in milliseconds) taken to move a FileTable item.
  let ``Avg time move FileTable item`` =
    { category = CategoryName; counter = "Avg time move FileTable item"; instance = None }
  /// Avg time per file I/O request: Average time (in milliseconds) spent handling an incoming file I/O request.
  let ``Avg time per file I/O request`` =
    { category = CategoryName; counter = "Avg time per file I/O request"; instance = None }
  /// Avg time per file I/O response: Average time (in milliseconds) spent handling an outgoing file I/O response.
  let ``Avg time per file I/O response`` =
    { category = CategoryName; counter = "Avg time per file I/O response"; instance = None }
  /// Avg time rename FileTable item: Average time (in milliseconds) taken to rename a FileTable item.
  let ``Avg time rename FileTable item`` =
    { category = CategoryName; counter = "Avg time rename FileTable item"; instance = None }
  /// Avg time to get FileTable item: Average time (in milliseconds) taken to retrieve a FileTable item.
  let ``Avg time to get FileTable item`` =
    { category = CategoryName; counter = "Avg time to get FileTable item"; instance = None }
  /// Avg time update FileTable item: Average time (in milliseconds) taken to update a FileTable item.
  let ``Avg time update FileTable item`` =
    { category = CategoryName; counter = "Avg time update FileTable item"; instance = None }
  /// FileTable db operations/sec: Total number of database operational events processed by the FileTable store component per second.
  let ``FileTable db operations/sec`` =
    { category = CategoryName; counter = "FileTable db operations/sec"; instance = None }
  /// FileTable enumeration reqs/sec: Total number of FileTable enumeration requests per second.
  let ``FileTable enumeration reqs/sec`` =
    { category = CategoryName; counter = "FileTable enumeration reqs/sec"; instance = None }
  /// FileTable file I/O requests/sec: Total number of incoming FileTable file I/O requests per second.
  let ``FileTable file I/O requests/sec`` =
    { category = CategoryName; counter = "FileTable file I/O requests/sec"; instance = None }
  /// FileTable file I/O response/sec: Total number of outgoing file I/O responses per second.
  let ``FileTable file I/O response/sec`` =
    { category = CategoryName; counter = "FileTable file I/O response/sec"; instance = None }
  /// FileTable item delete reqs/sec: Total number of FileTable delete item requests per second.
  let ``FileTable item delete reqs/sec`` =
    { category = CategoryName; counter = "FileTable item delete reqs/sec"; instance = None }
  /// FileTable item get requests/sec: Total number of FileTable retrieve item requests per second.
  let ``FileTable item get requests/sec`` =
    { category = CategoryName; counter = "FileTable item get requests/sec"; instance = None }
  /// FileTable item move reqs/sec: Total number of FileTable move item requests per second.
  let ``FileTable item move reqs/sec`` =
    { category = CategoryName; counter = "FileTable item move reqs/sec"; instance = None }
  /// FileTable item rename reqs/sec: Total number of FileTable rename item requests per second.
  let ``FileTable item rename reqs/sec`` =
    { category = CategoryName; counter = "FileTable item rename reqs/sec"; instance = None }
  /// FileTable item update reqs/sec: Total number of FileTable update item requests per second.
  let ``FileTable item update reqs/sec`` =
    { category = CategoryName; counter = "FileTable item update reqs/sec"; instance = None }
  /// FileTable kill handle ops/sec: Total number of FileTable handle kill operations per second.
  let ``FileTable kill handle ops/sec`` =
    { category = CategoryName; counter = "FileTable kill handle ops/sec"; instance = None }
  /// FileTable table operations/sec: Total number of table operational events processed by the FileTable store component per second.
  let ``FileTable table operations/sec`` =
    { category = CategoryName; counter = "FileTable table operations/sec"; instance = None }
  /// Time FileTable enumeration BASE: Average time (in milliseconds) taken for a FileTable enumeration request (BASE).
  let ``Time FileTable enumeration BASE`` =
    { category = CategoryName; counter = "Time FileTable enumeration BASE"; instance = None }
  /// Time FileTable handle kill BASE: Average time (in milliseconds) taken to kill a FileTable handle (BASE).
  let ``Time FileTable handle kill BASE`` =
    { category = CategoryName; counter = "Time FileTable handle kill BASE"; instance = None }
  /// Time delete FileTable item BASE: Average time (in milliseconds) taken to delete a FileTable item (BASE).
  let ``Time delete FileTable item BASE`` =
    { category = CategoryName; counter = "Time delete FileTable item BASE"; instance = None }
  /// Time move FileTable item BASE: Average time (in milliseconds) taken to move a FileTable item (BASE).
  let ``Time move FileTable item BASE`` =
    { category = CategoryName; counter = "Time move FileTable item BASE"; instance = None }
  /// Time per file I/O request BASE: Average time (in milliseconds) spent handling an incoming file I/O request (BASE).
  let ``Time per file I/O request BASE`` =
    { category = CategoryName; counter = "Time per file I/O request BASE"; instance = None }
  /// Time per file I/O response BASE: Average time (in milliseconds) spent handling an outgoing file I/O response (BASE).
  let ``Time per file I/O response BASE`` =
    { category = CategoryName; counter = "Time per file I/O response BASE"; instance = None }
  /// Time rename FileTable item BASE: Average time (in milliseconds) taken to rename a FileTable item (BASE).
  let ``Time rename FileTable item BASE`` =
    { category = CategoryName; counter = "Time rename FileTable item BASE"; instance = None }
  /// Time to get FileTable item BASE: Average time (in milliseconds) taken to retrieve a FileTable item (BASE).
  let ``Time to get FileTable item BASE`` =
    { category = CategoryName; counter = "Time to get FileTable item BASE"; instance = None }
  /// Time update FileTable item BASE: Average time (in milliseconds) taken to update a FileTable item (BASE).
  let ``Time update FileTable item BASE`` =
    { category = CategoryName; counter = "Time update FileTable item BASE"; instance = None }

  let allCounters =
    [| ``Avg time FileTable enumeration``
       ``Avg time FileTable handle kill``
       ``Avg time delete FileTable item``
       ``Avg time move FileTable item``
       ``Avg time per file I/O request``
       ``Avg time per file I/O response``
       ``Avg time rename FileTable item``
       ``Avg time to get FileTable item``
       ``Avg time update FileTable item``
       ``FileTable db operations/sec``
       ``FileTable enumeration reqs/sec``
       ``FileTable file I/O requests/sec``
       ``FileTable file I/O response/sec``
       ``FileTable item delete reqs/sec``
       ``FileTable item get requests/sec``
       ``FileTable item move reqs/sec``
       ``FileTable item rename reqs/sec``
       ``FileTable item update reqs/sec``
       ``FileTable kill handle ops/sec``
       ``FileTable table operations/sec``
       ``Time FileTable enumeration BASE``
       ``Time FileTable handle kill BASE``
       ``Time delete FileTable item BASE``
       ``Time move FileTable item BASE``
       ``Time per file I/O request BASE``
       ``Time per file I/O response BASE``
       ``Time rename FileTable item BASE``
       ``Time to get FileTable item BASE``
       ``Time update FileTable item BASE``
    |]

/// SQLServer:General Statistics: Server General Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:General Statistics`` =

  [<Literal>]
  let CategoryName = "SQLServer:General Statistics"

  let PCC = Category.create CategoryName
  /// Active Temp Tables: Number of temporary tables/table variables in use
  let ``Active Temp Tables`` =
    { category = CategoryName; counter = "Active Temp Tables"; instance = None }
  /// Connection Reset/sec: Total number of connection resets per second.
  let ``Connection Reset/sec`` =
    { category = CategoryName; counter = "Connection Reset/sec"; instance = None }
  /// Event Notifications Delayed Drop: Number of event notifications waiting to be dropped by a system thread
  let ``Event Notifications Delayed Drop`` =
    { category = CategoryName; counter = "Event Notifications Delayed Drop"; instance = None }
  /// HTTP Authenticated Requests: Number of authenticated HTTP requests started per second.
  let ``HTTP Authenticated Requests`` =
    { category = CategoryName; counter = "HTTP Authenticated Requests"; instance = None }
  /// Logical Connections: Number of logical connections to the system.
  let ``Logical Connections`` =
    { category = CategoryName; counter = "Logical Connections"; instance = None }
  /// Logins/sec: Total number of logins started per second.
  let ``Logins/sec`` =
    { category = CategoryName; counter = "Logins/sec"; instance = None }
  /// Logouts/sec: Total number of logouts started per second.
  let ``Logouts/sec`` =
    { category = CategoryName; counter = "Logouts/sec"; instance = None }
  /// Mars Deadlocks: Number of Mars Deadlocks detected.
  let ``Mars Deadlocks`` =
    { category = CategoryName; counter = "Mars Deadlocks"; instance = None }
  /// Non-atomic yield rate: Number of non-atomic yields per second.
  let ``Non-atomic yield rate`` =
    { category = CategoryName; counter = "Non-atomic yield rate"; instance = None }
  /// Processes blocked: Number of currently blocked processes.
  let ``Processes blocked`` =
    { category = CategoryName; counter = "Processes blocked"; instance = None }
  /// SOAP Empty Requests: Number of empty SOAP requests started per second.
  let ``SOAP Empty Requests`` =
    { category = CategoryName; counter = "SOAP Empty Requests"; instance = None }
  /// SOAP Method Invocations: Number of SOAP method invocations started per second.
  let ``SOAP Method Invocations`` =
    { category = CategoryName; counter = "SOAP Method Invocations"; instance = None }
  /// SOAP SQL Requests: Number of SOAP SQL requests started per second.
  let ``SOAP SQL Requests`` =
    { category = CategoryName; counter = "SOAP SQL Requests"; instance = None }
  /// SOAP Session Initiate Requests: Number of SOAP Session initiate requests started per second.
  let ``SOAP Session Initiate Requests`` =
    { category = CategoryName; counter = "SOAP Session Initiate Requests"; instance = None }
  /// SOAP Session Terminate Requests: Number of SOAP Session terminate requests started per second.
  let ``SOAP Session Terminate Requests`` =
    { category = CategoryName; counter = "SOAP Session Terminate Requests"; instance = None }
  /// SOAP WSDL Requests: Number of SOAP Web Service Description Language requests started per second.
  let ``SOAP WSDL Requests`` =
    { category = CategoryName; counter = "SOAP WSDL Requests"; instance = None }
  /// SQL Trace IO Provider Lock Waits: Number of waits for the File IO Provider lock per second
  let ``SQL Trace IO Provider Lock Waits`` =
    { category = CategoryName; counter = "SQL Trace IO Provider Lock Waits"; instance = None }
  /// Temp Tables Creation Rate: Number of temporary tables/table variables created/sec
  let ``Temp Tables Creation Rate`` =
    { category = CategoryName; counter = "Temp Tables Creation Rate"; instance = None }
  /// Temp Tables For Destruction: Number of temporary tables/table variables waiting to be destroyed by the cleanup system thread
  let ``Temp Tables For Destruction`` =
    { category = CategoryName; counter = "Temp Tables For Destruction"; instance = None }
  /// Tempdb recovery unit id: Number of duplicate tempdb recovery unit id generated
  let ``Tempdb recovery unit id`` =
    { category = CategoryName; counter = "Tempdb recovery unit id"; instance = None }
  /// Tempdb rowset id: Number of duplicate tempdb rowset id generated
  let ``Tempdb rowset id`` =
    { category = CategoryName; counter = "Tempdb rowset id"; instance = None }
  /// Trace Event Notification Queue: Number of trace event notification instances waiting in the internal queue to be sent thru Service Broker
  let ``Trace Event Notification Queue`` =
    { category = CategoryName; counter = "Trace Event Notification Queue"; instance = None }
  /// Transactions: Number of transaction enlistments (local, dtc, and bound).
  let ``Transactions`` =
    { category = CategoryName; counter = "Transactions"; instance = None }
  /// User Connections: Number of users connected to the system.
  let ``User Connections`` =
    { category = CategoryName; counter = "User Connections"; instance = None }

  let allCounters =
    [| ``Active Temp Tables``
       ``Connection Reset/sec``
       ``Event Notifications Delayed Drop``
       ``HTTP Authenticated Requests``
       ``Logical Connections``
       ``Logins/sec``
       ``Logouts/sec``
       ``Mars Deadlocks``
       ``Non-atomic yield rate``
       ``Processes blocked``
       ``SOAP Empty Requests``
       ``SOAP Method Invocations``
       ``SOAP SQL Requests``
       ``SOAP Session Initiate Requests``
       ``SOAP Session Terminate Requests``
       ``SOAP WSDL Requests``
       ``SQL Trace IO Provider Lock Waits``
       ``Temp Tables Creation Rate``
       ``Temp Tables For Destruction``
       ``Tempdb recovery unit id``
       ``Tempdb rowset id``
       ``Trace Event Notification Queue``
       ``Transactions``
       ``User Connections``
    |]

/// SQLServer:HTTP Storage: Defines a HTTP storage object for SQL Server.
///
/// This performance counter does not have instance based counters
module ``SQLServer:HTTP Storage`` =

  [<Literal>]
  let CategoryName = "SQLServer:HTTP Storage"

  let PCC = Category.create CategoryName
  /// Avg. Bytes/Read: -
  let ``Avg. Bytes/Read`` instance =
    { category = CategoryName; counter = "Avg. Bytes/Read"; instance = instance }
  /// Avg. Bytes/Read BASE: -
  let ``Avg. Bytes/Read BASE`` instance =
    { category = CategoryName; counter = "Avg. Bytes/Read BASE"; instance = instance }
  /// Avg. Bytes/Transfer: -
  let ``Avg. Bytes/Transfer`` instance =
    { category = CategoryName; counter = "Avg. Bytes/Transfer"; instance = instance }
  /// Avg. Bytes/Transfer BASE: -
  let ``Avg. Bytes/Transfer BASE`` instance =
    { category = CategoryName; counter = "Avg. Bytes/Transfer BASE"; instance = instance }
  /// Avg. Bytes/Write: -
  let ``Avg. Bytes/Write`` instance =
    { category = CategoryName; counter = "Avg. Bytes/Write"; instance = instance }
  /// Avg. Bytes/Write BASE: -
  let ``Avg. Bytes/Write BASE`` instance =
    { category = CategoryName; counter = "Avg. Bytes/Write BASE"; instance = instance }
  /// Avg. microsec/Read: -
  let ``Avg. microsec/Read`` instance =
    { category = CategoryName; counter = "Avg. microsec/Read"; instance = instance }
  /// Avg. microsec/Read BASE: -
  let ``Avg. microsec/Read BASE`` instance =
    { category = CategoryName; counter = "Avg. microsec/Read BASE"; instance = instance }
  /// Avg. microsec/Transfer: -
  let ``Avg. microsec/Transfer`` instance =
    { category = CategoryName; counter = "Avg. microsec/Transfer"; instance = instance }
  /// Avg. microsec/Transfer BASE: -
  let ``Avg. microsec/Transfer BASE`` instance =
    { category = CategoryName; counter = "Avg. microsec/Transfer BASE"; instance = instance }
  /// Avg. microsec/Write: -
  let ``Avg. microsec/Write`` instance =
    { category = CategoryName; counter = "Avg. microsec/Write"; instance = instance }
  /// Avg. microsec/Write BASE: -
  let ``Avg. microsec/Write BASE`` instance =
    { category = CategoryName; counter = "Avg. microsec/Write BASE"; instance = instance }
  /// HTTP Storage IO retry/sec: -
  let ``HTTP Storage IO retry/sec`` instance =
    { category = CategoryName; counter = "HTTP Storage IO retry/sec"; instance = instance }
  /// Outstanding HTTP Storage IO: -
  let ``Outstanding HTTP Storage IO`` instance =
    { category = CategoryName; counter = "Outstanding HTTP Storage IO"; instance = instance }
  /// Read Bytes/Sec: -
  let ``Read Bytes/Sec`` instance =
    { category = CategoryName; counter = "Read Bytes/Sec"; instance = instance }
  /// Reads/Sec: -
  let ``Reads/Sec`` instance =
    { category = CategoryName; counter = "Reads/Sec"; instance = instance }
  /// Total Bytes/Sec: -
  let ``Total Bytes/Sec`` instance =
    { category = CategoryName; counter = "Total Bytes/Sec"; instance = instance }
  /// Transfers/Sec: -
  let ``Transfers/Sec`` instance =
    { category = CategoryName; counter = "Transfers/Sec"; instance = instance }
  /// Write Bytes/Sec: -
  let ``Write Bytes/Sec`` instance =
    { category = CategoryName; counter = "Write Bytes/Sec"; instance = instance }
  /// Writes/Sec: -
  let ``Writes/Sec`` instance =
    { category = CategoryName; counter = "Writes/Sec"; instance = instance }

  let allCounters =
    [| ``Avg. Bytes/Read``
       ``Avg. Bytes/Read BASE``
       ``Avg. Bytes/Transfer``
       ``Avg. Bytes/Transfer BASE``
       ``Avg. Bytes/Write``
       ``Avg. Bytes/Write BASE``
       ``Avg. microsec/Read``
       ``Avg. microsec/Read BASE``
       ``Avg. microsec/Transfer``
       ``Avg. microsec/Transfer BASE``
       ``Avg. microsec/Write``
       ``Avg. microsec/Write BASE``
       ``HTTP Storage IO retry/sec``
       ``Outstanding HTTP Storage IO``
       ``Read Bytes/Sec``
       ``Reads/Sec``
       ``Total Bytes/Sec``
       ``Transfers/Sec``
       ``Write Bytes/Sec``
       ``Writes/Sec``
    |]

/// SQLServer:Latches: Collects statistics associated with internal server latches
///
/// This performance counter does not have instance based counters
module ``SQLServer:Latches`` =

  [<Literal>]
  let CategoryName = "SQLServer:Latches"

  let PCC = Category.create CategoryName
  /// Average Latch Wait Time (ms): Average latch wait time (milliseconds) for latch requests that had to wait.
  let ``Average Latch Wait Time (ms)`` =
    { category = CategoryName; counter = "Average Latch Wait Time (ms)"; instance = None }
  /// Average Latch Wait Time Base: Base for Average Latch Wait Time.
  let ``Average Latch Wait Time Base`` =
    { category = CategoryName; counter = "Average Latch Wait Time Base"; instance = None }
  /// Latch Waits/sec: Number of latch requests that could not be granted immediately and had to wait before being granted.
  let ``Latch Waits/sec`` =
    { category = CategoryName; counter = "Latch Waits/sec"; instance = None }
  /// Number of SuperLatches: Number of latches that are currently SuperLatches.
  let ``Number of SuperLatches`` =
    { category = CategoryName; counter = "Number of SuperLatches"; instance = None }
  /// SuperLatch Demotions/sec: Number of SuperLatches that have been demoted to regular latches
  let ``SuperLatch Demotions/sec`` =
    { category = CategoryName; counter = "SuperLatch Demotions/sec"; instance = None }
  /// SuperLatch Promotions/sec: Number of latches that have been promoted to SuperLatches
  let ``SuperLatch Promotions/sec`` =
    { category = CategoryName; counter = "SuperLatch Promotions/sec"; instance = None }
  /// Total Latch Wait Time (ms): Total latch wait time (milliseconds) for latch requests that had to wait in the last second.
  let ``Total Latch Wait Time (ms)`` =
    { category = CategoryName; counter = "Total Latch Wait Time (ms)"; instance = None }

  let allCounters =
    [| ``Average Latch Wait Time (ms)``
       ``Average Latch Wait Time Base``
       ``Latch Waits/sec``
       ``Number of SuperLatches``
       ``SuperLatch Demotions/sec``
       ``SuperLatch Promotions/sec``
       ``Total Latch Wait Time (ms)``
    |]

/// SQLServer:Locks: Describes statistics for individual lock server lock requests
///
/// This performance counter does not have instance based counters
module ``SQLServer:Locks`` =

  [<Literal>]
  let CategoryName = "SQLServer:Locks"

  let PCC = Category.create CategoryName
  /// Average Wait Time (ms): -
  let ``Average Wait Time (ms)`` instance =
    { category = CategoryName; counter = "Average Wait Time (ms)"; instance = instance }
  /// Average Wait Time Base: -
  let ``Average Wait Time Base`` instance =
    { category = CategoryName; counter = "Average Wait Time Base"; instance = instance }
  /// Lock Requests/sec: -
  let ``Lock Requests/sec`` instance =
    { category = CategoryName; counter = "Lock Requests/sec"; instance = instance }
  /// Lock Timeouts (timeout > 0)/sec: -
  let ``Lock Timeouts (timeout > 0)/sec`` instance =
    { category = CategoryName; counter = "Lock Timeouts (timeout > 0)/sec"; instance = instance }
  /// Lock Timeouts/sec: -
  let ``Lock Timeouts/sec`` instance =
    { category = CategoryName; counter = "Lock Timeouts/sec"; instance = instance }
  /// Lock Wait Time (ms): -
  let ``Lock Wait Time (ms)`` instance =
    { category = CategoryName; counter = "Lock Wait Time (ms)"; instance = instance }
  /// Lock Waits/sec: -
  let ``Lock Waits/sec`` instance =
    { category = CategoryName; counter = "Lock Waits/sec"; instance = instance }
  /// Number of Deadlocks/sec: -
  let ``Number of Deadlocks/sec`` instance =
    { category = CategoryName; counter = "Number of Deadlocks/sec"; instance = instance }

  let allCounters =
    [| ``Average Wait Time (ms)``
       ``Average Wait Time Base``
       ``Lock Requests/sec``
       ``Lock Timeouts (timeout > 0)/sec``
       ``Lock Timeouts/sec``
       ``Lock Wait Time (ms)``
       ``Lock Waits/sec``
       ``Number of Deadlocks/sec``
    |]

/// SQLServer:Memory Broker Clerks: Statistics related to memory broker clerks
///
/// This performance counter does not have instance based counters
module ``SQLServer:Memory Broker Clerks`` =

  [<Literal>]
  let CategoryName = "SQLServer:Memory Broker Clerks"

  let PCC = Category.create CategoryName
  /// Internal benefit: -
  let ``Internal benefit`` instance =
    { category = CategoryName; counter = "Internal benefit"; instance = instance }
  /// Memory broker clerk size: -
  let ``Memory broker clerk size`` instance =
    { category = CategoryName; counter = "Memory broker clerk size"; instance = instance }
  /// Periodic evictions (pages): -
  let ``Periodic evictions (pages)`` instance =
    { category = CategoryName; counter = "Periodic evictions (pages)"; instance = instance }
  /// Pressure evictions (pages/sec): -
  let ``Pressure evictions (pages/sec)`` instance =
    { category = CategoryName; counter = "Pressure evictions (pages/sec)"; instance = instance }
  /// Simulation benefit: -
  let ``Simulation benefit`` instance =
    { category = CategoryName; counter = "Simulation benefit"; instance = instance }
  /// Simulation size: -
  let ``Simulation size`` instance =
    { category = CategoryName; counter = "Simulation size"; instance = instance }

  let allCounters =
    [| ``Internal benefit``
       ``Memory broker clerk size``
       ``Periodic evictions (pages)``
       ``Pressure evictions (pages/sec)``
       ``Simulation benefit``
       ``Simulation size``
    |]

/// SQLServer:Memory Manager: This defines memory usage.
///
/// This performance counter does not have instance based counters
module ``SQLServer:Memory Manager`` =

  [<Literal>]
  let CategoryName = "SQLServer:Memory Manager"

  let PCC = Category.create CategoryName
  /// Connection Memory (KB): Total amount of dynamic memory the server is using for maintaining connections
  let ``Connection Memory (KB)`` =
    { category = CategoryName; counter = "Connection Memory (KB)"; instance = None }
  /// Database Cache Memory (KB): Amount of memory the server is currently using for the database cache.
  let ``Database Cache Memory (KB)`` =
    { category = CategoryName; counter = "Database Cache Memory (KB)"; instance = None }
  /// External benefit of memory: The external value of memory, in ms per page per ms, multiplied by 10 billion and truncated to an integer
  let ``External benefit of memory`` =
    { category = CategoryName; counter = "External benefit of memory"; instance = None }
  /// Free Memory (KB): Amount of memory the server is currently not using.
  let ``Free Memory (KB)`` =
    { category = CategoryName; counter = "Free Memory (KB)"; instance = None }
  /// Granted Workspace Memory (KB): Total amount of memory granted to executing processes. This memory is used for hash, sort and create index operations.
  let ``Granted Workspace Memory (KB)`` =
    { category = CategoryName; counter = "Granted Workspace Memory (KB)"; instance = None }
  /// Lock Blocks: The current number of lock blocks that are in use on the server. Refreshed periodically.
  let ``Lock Blocks`` =
    { category = CategoryName; counter = "Lock Blocks"; instance = None }
  /// Lock Blocks Allocated: The current number of allocated lock blocks.
  let ``Lock Blocks Allocated`` =
    { category = CategoryName; counter = "Lock Blocks Allocated"; instance = None }
  /// Lock Memory (KB): Total amount of dynamic memory the server is using for locks
  let ``Lock Memory (KB)`` =
    { category = CategoryName; counter = "Lock Memory (KB)"; instance = None }
  /// Lock Owner Blocks: The number of lock owner blocks that are currently in use on the server. Refreshed periodically.
  let ``Lock Owner Blocks`` =
    { category = CategoryName; counter = "Lock Owner Blocks"; instance = None }
  /// Lock Owner Blocks Allocated: The current number of allocated lock owner blocks.
  let ``Lock Owner Blocks Allocated`` =
    { category = CategoryName; counter = "Lock Owner Blocks Allocated"; instance = None }
  /// Log Pool Memory (KB): Total amount of dynamic memory the server is using for Log Pool
  let ``Log Pool Memory (KB)`` =
    { category = CategoryName; counter = "Log Pool Memory (KB)"; instance = None }
  /// Maximum Workspace Memory (KB): Total amount of memory available for grants to executing processes. This memory is used primarily for hash, sort and create index operations.
  let ``Maximum Workspace Memory (KB)`` =
    { category = CategoryName; counter = "Maximum Workspace Memory (KB)"; instance = None }
  /// Memory Grants Outstanding: Current number of processes that have successfully acquired a workspace memory grant
  let ``Memory Grants Outstanding`` =
    { category = CategoryName; counter = "Memory Grants Outstanding"; instance = None }
  /// Memory Grants Pending: Current number of processes waiting for a workspace memory grant
  let ``Memory Grants Pending`` =
    { category = CategoryName; counter = "Memory Grants Pending"; instance = None }
  /// Optimizer Memory (KB): Total amount of dynamic memory the server is using for query optimization
  let ``Optimizer Memory (KB)`` =
    { category = CategoryName; counter = "Optimizer Memory (KB)"; instance = None }
  /// Reserved Server Memory (KB): Amount of memory the server has reserved for future usage. This counter shows current unused amount of the initial grant shown in Granted Workspace Memory (KB).
  let ``Reserved Server Memory (KB)`` =
    { category = CategoryName; counter = "Reserved Server Memory (KB)"; instance = None }
  /// SQL Cache Memory (KB): Total amount of dynamic memory the server is using for the dynamic SQL cache
  let ``SQL Cache Memory (KB)`` =
    { category = CategoryName; counter = "SQL Cache Memory (KB)"; instance = None }
  /// Stolen Server Memory (KB): Amount of memory the server is currently using for the purposes other than the database pages.
  let ``Stolen Server Memory (KB)`` =
    { category = CategoryName; counter = "Stolen Server Memory (KB)"; instance = None }
  /// Target Server Memory (KB): Ideal amount of memory the server is willing to consume
  let ``Target Server Memory (KB)`` =
    { category = CategoryName; counter = "Target Server Memory (KB)"; instance = None }
  /// Total Server Memory (KB): Total amount of dynamic memory the server is currently consuming
  let ``Total Server Memory (KB)`` =
    { category = CategoryName; counter = "Total Server Memory (KB)"; instance = None }

  let allCounters =
    [| ``Connection Memory (KB)``
       ``Database Cache Memory (KB)``
       ``External benefit of memory``
       ``Free Memory (KB)``
       ``Granted Workspace Memory (KB)``
       ``Lock Blocks``
       ``Lock Blocks Allocated``
       ``Lock Memory (KB)``
       ``Lock Owner Blocks``
       ``Lock Owner Blocks Allocated``
       ``Log Pool Memory (KB)``
       ``Maximum Workspace Memory (KB)``
       ``Memory Grants Outstanding``
       ``Memory Grants Pending``
       ``Optimizer Memory (KB)``
       ``Reserved Server Memory (KB)``
       ``SQL Cache Memory (KB)``
       ``Stolen Server Memory (KB)``
       ``Target Server Memory (KB)``
       ``Total Server Memory (KB)``
    |]

/// SQLServer:Memory Node: This defines memory usage per NUMA node.
///
/// This performance counter does not have instance based counters
module ``SQLServer:Memory Node`` =

  [<Literal>]
  let CategoryName = "SQLServer:Memory Node"

  let PCC = Category.create CategoryName
  /// Database Node Memory (KB): -
  let ``Database Node Memory (KB)`` instance =
    { category = CategoryName; counter = "Database Node Memory (KB)"; instance = instance }
  /// Foreign Node Memory (KB): -
  let ``Foreign Node Memory (KB)`` instance =
    { category = CategoryName; counter = "Foreign Node Memory (KB)"; instance = instance }
  /// Free Node Memory (KB): -
  let ``Free Node Memory (KB)`` instance =
    { category = CategoryName; counter = "Free Node Memory (KB)"; instance = instance }
  /// Stolen Node Memory (KB): -
  let ``Stolen Node Memory (KB)`` instance =
    { category = CategoryName; counter = "Stolen Node Memory (KB)"; instance = instance }
  /// Target Node Memory (KB): -
  let ``Target Node Memory (KB)`` instance =
    { category = CategoryName; counter = "Target Node Memory (KB)"; instance = instance }
  /// Total Node Memory (KB): -
  let ``Total Node Memory (KB)`` instance =
    { category = CategoryName; counter = "Total Node Memory (KB)"; instance = instance }

  let allCounters =
    [| ``Database Node Memory (KB)``
       ``Foreign Node Memory (KB)``
       ``Free Node Memory (KB)``
       ``Stolen Node Memory (KB)``
       ``Target Node Memory (KB)``
       ``Total Node Memory (KB)``
    |]

/// SQLServer:Plan Cache: This defines cache counters
///
/// This performance counter does not have instance based counters
module ``SQLServer:Plan Cache`` =

  [<Literal>]
  let CategoryName = "SQLServer:Plan Cache"

  let PCC = Category.create CategoryName
  /// Cache Hit Ratio: -
  let ``Cache Hit Ratio`` instance =
    { category = CategoryName; counter = "Cache Hit Ratio"; instance = instance }
  /// Cache Hit Ratio Base: -
  let ``Cache Hit Ratio Base`` instance =
    { category = CategoryName; counter = "Cache Hit Ratio Base"; instance = instance }
  /// Cache Object Counts: -
  let ``Cache Object Counts`` instance =
    { category = CategoryName; counter = "Cache Object Counts"; instance = instance }
  /// Cache Objects in use: -
  let ``Cache Objects in use`` instance =
    { category = CategoryName; counter = "Cache Objects in use"; instance = instance }
  /// Cache Pages: -
  let ``Cache Pages`` instance =
    { category = CategoryName; counter = "Cache Pages"; instance = instance }

  let allCounters =
    [| ``Cache Hit Ratio``
       ``Cache Hit Ratio Base``
       ``Cache Object Counts``
       ``Cache Objects in use``
       ``Cache Pages``
    |]

/// SQLServer:Replication Agents: Replication Summary
///
/// This performance counter does not have instance based counters
module ``SQLServer:Replication Agents`` =

  [<Literal>]
  let CategoryName = "SQLServer:Replication Agents"

  let PCC = Category.create CategoryName
  /// Running: -
  let ``Running`` instance =
    { category = CategoryName; counter = "Running"; instance = instance }

  let allCounters =
    [| ``Running``

    |]

/// SQLServer:Replication Dist.: Replication Distribution Agent Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Replication Dist_`` =

  [<Literal>]
  let CategoryName = "SQLServer:Replication Dist."

  let PCC = Category.create CategoryName
  /// Dist:Delivered Cmds/sec: -
  let ``Dist:Delivered Cmds/sec`` instance =
    { category = CategoryName; counter = "Dist:Delivered Cmds/sec"; instance = instance }
  /// Dist:Delivered Trans/sec: -
  let ``Dist:Delivered Trans/sec`` instance =
    { category = CategoryName; counter = "Dist:Delivered Trans/sec"; instance = instance }
  /// Dist:Delivery Latency: -
  let ``Dist:Delivery Latency`` instance =
    { category = CategoryName; counter = "Dist:Delivery Latency"; instance = instance }

  let allCounters =
    [| ``Dist:Delivered Cmds/sec``
       ``Dist:Delivered Trans/sec``
       ``Dist:Delivery Latency``
    |]

/// SQLServer:Replication Logreader: Replication Logreader Agent Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Replication Logreader`` =

  [<Literal>]
  let CategoryName = "SQLServer:Replication Logreader"

  let PCC = Category.create CategoryName
  /// Logreader:Delivered Cmds/sec: -
  let ``Logreader:Delivered Cmds/sec`` instance =
    { category = CategoryName; counter = "Logreader:Delivered Cmds/sec"; instance = instance }
  /// Logreader:Delivered Trans/sec: -
  let ``Logreader:Delivered Trans/sec`` instance =
    { category = CategoryName; counter = "Logreader:Delivered Trans/sec"; instance = instance }
  /// Logreader:Delivery Latency: -
  let ``Logreader:Delivery Latency`` instance =
    { category = CategoryName; counter = "Logreader:Delivery Latency"; instance = instance }

  let allCounters =
    [| ``Logreader:Delivered Cmds/sec``
       ``Logreader:Delivered Trans/sec``
       ``Logreader:Delivery Latency``
    |]

/// SQLServer:Replication Merge: Replication Merge Agent Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Replication Merge`` =

  [<Literal>]
  let CategoryName = "SQLServer:Replication Merge"

  let PCC = Category.create CategoryName
  /// Conflicts/sec: -
  let ``Conflicts/sec`` instance =
    { category = CategoryName; counter = "Conflicts/sec"; instance = instance }
  /// Downloaded Changes/sec: -
  let ``Downloaded Changes/sec`` instance =
    { category = CategoryName; counter = "Downloaded Changes/sec"; instance = instance }
  /// Uploaded Changes/sec: -
  let ``Uploaded Changes/sec`` instance =
    { category = CategoryName; counter = "Uploaded Changes/sec"; instance = instance }

  let allCounters =
    [| ``Conflicts/sec``
       ``Downloaded Changes/sec``
       ``Uploaded Changes/sec``
    |]

/// SQLServer:Replication Snapshot: Replication Snapshot Agent Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Replication Snapshot`` =

  [<Literal>]
  let CategoryName = "SQLServer:Replication Snapshot"

  let PCC = Category.create CategoryName
  /// Snapshot:Delivered Cmds/sec: -
  let ``Snapshot:Delivered Cmds/sec`` instance =
    { category = CategoryName; counter = "Snapshot:Delivered Cmds/sec"; instance = instance }
  /// Snapshot:Delivered Trans/sec: -
  let ``Snapshot:Delivered Trans/sec`` instance =
    { category = CategoryName; counter = "Snapshot:Delivered Trans/sec"; instance = instance }

  let allCounters =
    [| ``Snapshot:Delivered Cmds/sec``
       ``Snapshot:Delivered Trans/sec``
    |]

/// SQLServer:Resource Pool Stats: Statistics associated with resource pools
///
/// This performance counter does not have instance based counters
module ``SQLServer:Resource Pool Stats`` =

  [<Literal>]
  let CategoryName = "SQLServer:Resource Pool Stats"

  let PCC = Category.create CategoryName
  /// Active memory grant amount (KB): -
  let ``Active memory grant amount (KB)`` instance =
    { category = CategoryName; counter = "Active memory grant amount (KB)"; instance = instance }
  /// Active memory grants count: -
  let ``Active memory grants count`` instance =
    { category = CategoryName; counter = "Active memory grants count"; instance = instance }
  /// Avg Disk Read IO (ms): -
  let ``Avg Disk Read IO (ms)`` instance =
    { category = CategoryName; counter = "Avg Disk Read IO (ms)"; instance = instance }
  /// Avg Disk Read IO (ms) Base: -
  let ``Avg Disk Read IO (ms) Base`` instance =
    { category = CategoryName; counter = "Avg Disk Read IO (ms) Base"; instance = instance }
  /// Avg Disk Write IO (ms): -
  let ``Avg Disk Write IO (ms)`` instance =
    { category = CategoryName; counter = "Avg Disk Write IO (ms)"; instance = instance }
  /// Avg Disk Write IO (ms) Base: -
  let ``Avg Disk Write IO (ms) Base`` instance =
    { category = CategoryName; counter = "Avg Disk Write IO (ms) Base"; instance = instance }
  /// CPU control effect %: -
  let ``CPU control effect %`` instance =
    { category = CategoryName; counter = "CPU control effect %"; instance = instance }
  /// CPU usage %: -
  let ``CPU usage %`` instance =
    { category = CategoryName; counter = "CPU usage %"; instance = instance }
  /// CPU usage % base: -
  let ``CPU usage % base`` instance =
    { category = CategoryName; counter = "CPU usage % base"; instance = instance }
  /// CPU usage target %: -
  let ``CPU usage target %`` instance =
    { category = CategoryName; counter = "CPU usage target %"; instance = instance }
  /// Cache memory target (KB): -
  let ``Cache memory target (KB)`` instance =
    { category = CategoryName; counter = "Cache memory target (KB)"; instance = instance }
  /// Compile memory target (KB): -
  let ``Compile memory target (KB)`` instance =
    { category = CategoryName; counter = "Compile memory target (KB)"; instance = instance }
  /// Disk Read Bytes/sec: -
  let ``Disk Read Bytes/sec`` instance =
    { category = CategoryName; counter = "Disk Read Bytes/sec"; instance = instance }
  /// Disk Read IO Throttled/sec: -
  let ``Disk Read IO Throttled/sec`` instance =
    { category = CategoryName; counter = "Disk Read IO Throttled/sec"; instance = instance }
  /// Disk Read IO/sec: -
  let ``Disk Read IO/sec`` instance =
    { category = CategoryName; counter = "Disk Read IO/sec"; instance = instance }
  /// Disk Write Bytes/sec: -
  let ``Disk Write Bytes/sec`` instance =
    { category = CategoryName; counter = "Disk Write Bytes/sec"; instance = instance }
  /// Disk Write IO Throttled/sec: -
  let ``Disk Write IO Throttled/sec`` instance =
    { category = CategoryName; counter = "Disk Write IO Throttled/sec"; instance = instance }
  /// Disk Write IO/sec: -
  let ``Disk Write IO/sec`` instance =
    { category = CategoryName; counter = "Disk Write IO/sec"; instance = instance }
  /// Max memory (KB): -
  let ``Max memory (KB)`` instance =
    { category = CategoryName; counter = "Max memory (KB)"; instance = instance }
  /// Memory grant timeouts/sec: -
  let ``Memory grant timeouts/sec`` instance =
    { category = CategoryName; counter = "Memory grant timeouts/sec"; instance = instance }
  /// Memory grants/sec: -
  let ``Memory grants/sec`` instance =
    { category = CategoryName; counter = "Memory grants/sec"; instance = instance }
  /// Pending memory grants count: -
  let ``Pending memory grants count`` instance =
    { category = CategoryName; counter = "Pending memory grants count"; instance = instance }
  /// Query exec memory target (KB): -
  let ``Query exec memory target (KB)`` instance =
    { category = CategoryName; counter = "Query exec memory target (KB)"; instance = instance }
  /// Target memory (KB): -
  let ``Target memory (KB)`` instance =
    { category = CategoryName; counter = "Target memory (KB)"; instance = instance }
  /// Used memory (KB): -
  let ``Used memory (KB)`` instance =
    { category = CategoryName; counter = "Used memory (KB)"; instance = instance }

  let allCounters =
    [| ``Active memory grant amount (KB)``
       ``Active memory grants count``
       ``Avg Disk Read IO (ms)``
       ``Avg Disk Read IO (ms) Base``
       ``Avg Disk Write IO (ms)``
       ``Avg Disk Write IO (ms) Base``
       ``CPU control effect %``
       ``CPU usage %``
       ``CPU usage % base``
       ``CPU usage target %``
       ``Cache memory target (KB)``
       ``Compile memory target (KB)``
       ``Disk Read Bytes/sec``
       ``Disk Read IO Throttled/sec``
       ``Disk Read IO/sec``
       ``Disk Write Bytes/sec``
       ``Disk Write IO Throttled/sec``
       ``Disk Write IO/sec``
       ``Max memory (KB)``
       ``Memory grant timeouts/sec``
       ``Memory grants/sec``
       ``Pending memory grants count``
       ``Query exec memory target (KB)``
       ``Target memory (KB)``
       ``Used memory (KB)``
    |]

/// SQLServer:SQL Errors: Statistics about errors in SQL Server
///
/// This performance counter does not have instance based counters
module ``SQLServer:SQL Errors`` =

  [<Literal>]
  let CategoryName = "SQLServer:SQL Errors"

  let PCC = Category.create CategoryName
  /// Errors/sec: -
  let ``Errors/sec`` instance =
    { category = CategoryName; counter = "Errors/sec"; instance = instance }

  let allCounters =
    [| ``Errors/sec``

    |]

/// SQLServer:SQL Statistics: Collects statistics associated with SQL requests
///
/// This performance counter does not have instance based counters
module ``SQLServer:SQL Statistics`` =

  [<Literal>]
  let CategoryName = "SQLServer:SQL Statistics"

  let PCC = Category.create CategoryName
  /// Auto-Param Attempts/sec: Number of auto-parameterization attempts.
  let ``Auto-Param Attempts/sec`` =
    { category = CategoryName; counter = "Auto-Param Attempts/sec"; instance = None }
  /// Batch Requests/sec: Number of SQL batch requests received by server.
  let ``Batch Requests/sec`` =
    { category = CategoryName; counter = "Batch Requests/sec"; instance = None }
  /// Failed Auto-Params/sec: Number of failed auto-parameterizations.
  let ``Failed Auto-Params/sec`` =
    { category = CategoryName; counter = "Failed Auto-Params/sec"; instance = None }
  /// Forced Parameterizations/sec: Number of statements parameterized by forced parameterization per second.
  let ``Forced Parameterizations/sec`` =
    { category = CategoryName; counter = "Forced Parameterizations/sec"; instance = None }
  /// Guided plan executions/sec: Number of plan executions per second in which the query plan has been generated by using a plan guide.
  let ``Guided plan executions/sec`` =
    { category = CategoryName; counter = "Guided plan executions/sec"; instance = None }
  /// Misguided plan executions/sec: Number of plan executions per second in which a plan guide could not be honored during plan generation. The plan guide was disregarded and normal compilation was used to generate the executed plan.
  let ``Misguided plan executions/sec`` =
    { category = CategoryName; counter = "Misguided plan executions/sec"; instance = None }
  /// SQL Attention rate: Number of attentions per second.
  let ``SQL Attention rate`` =
    { category = CategoryName; counter = "SQL Attention rate"; instance = None }
  /// SQL Compilations/sec: Number of SQL compilations.
  let ``SQL Compilations/sec`` =
    { category = CategoryName; counter = "SQL Compilations/sec"; instance = None }
  /// SQL Re-Compilations/sec: Number of SQL re-compiles.
  let ``SQL Re-Compilations/sec`` =
    { category = CategoryName; counter = "SQL Re-Compilations/sec"; instance = None }
  /// Safe Auto-Params/sec: Number of safe auto-parameterizations.
  let ``Safe Auto-Params/sec`` =
    { category = CategoryName; counter = "Safe Auto-Params/sec"; instance = None }
  /// Unsafe Auto-Params/sec: Number of unsafe auto-parameterizations.
  let ``Unsafe Auto-Params/sec`` =
    { category = CategoryName; counter = "Unsafe Auto-Params/sec"; instance = None }

  let allCounters =
    [| ``Auto-Param Attempts/sec``
       ``Batch Requests/sec``
       ``Failed Auto-Params/sec``
       ``Forced Parameterizations/sec``
       ``Guided plan executions/sec``
       ``Misguided plan executions/sec``
       ``SQL Attention rate``
       ``SQL Compilations/sec``
       ``SQL Re-Compilations/sec``
       ``Safe Auto-Params/sec``
       ``Unsafe Auto-Params/sec``
    |]

/// SQLServer:SSIS Service 12.0: SQL Server Integration Services Service performance counters.
///
/// This performance counter does not have instance based counters
module ``SQLServer:SSIS Service 12_0`` =

  [<Literal>]
  let CategoryName = "SQLServer:SSIS Service 12.0"

  let PCC = Category.create CategoryName
  /// SSIS Package Instances: The number of package instances currently running.
  let ``SSIS Package Instances`` =
    { category = CategoryName; counter = "SSIS Package Instances"; instance = None }

  let allCounters =
    [| ``SSIS Package Instances``

    |]

/// SQLServer:Transactions: Statistics related to SQL Server transactions.
///
/// This performance counter does not have instance based counters
module ``SQLServer:Transactions`` =

  [<Literal>]
  let CategoryName = "SQLServer:Transactions"

  let PCC = Category.create CategoryName
  /// Free Space in tempdb (KB): The free space in tempdb in KB.
  let ``Free Space in tempdb (KB)`` =
    { category = CategoryName; counter = "Free Space in tempdb (KB)"; instance = None }
  /// Longest Transaction Running Time: The longest running time of any transaction in seconds.
  let ``Longest Transaction Running Time`` =
    { category = CategoryName; counter = "Longest Transaction Running Time"; instance = None }
  /// NonSnapshot Version Transactions: The total number of active non-snapshot transactions that generate version records.
  let ``NonSnapshot Version Transactions`` =
    { category = CategoryName; counter = "NonSnapshot Version Transactions"; instance = None }
  /// Snapshot Transactions: The total number of active snapshot transactions.
  let ``Snapshot Transactions`` =
    { category = CategoryName; counter = "Snapshot Transactions"; instance = None }
  /// Transactions: The total number of active transactions.
  let ``Transactions`` =
    { category = CategoryName; counter = "Transactions"; instance = None }
  /// Update Snapshot Transactions: The total number of active snapshot transactions that do updates.
  let ``Update Snapshot Transactions`` =
    { category = CategoryName; counter = "Update Snapshot Transactions"; instance = None }
  /// Update conflict ratio: The fraction of update snapshot transactions that have update conflicts to the total number of update snapshot transactions.
  let ``Update conflict ratio`` =
    { category = CategoryName; counter = "Update conflict ratio"; instance = None }
  /// Update conflict ratio base: The total number of update snapshot transactions.
  let ``Update conflict ratio base`` =
    { category = CategoryName; counter = "Update conflict ratio base"; instance = None }
  /// Version Cleanup rate (KB/s): The version cleanup rate in KB per seconds.
  let ``Version Cleanup rate (KB/s)`` =
    { category = CategoryName; counter = "Version Cleanup rate (KB/s)"; instance = None }
  /// Version Generation rate (KB/s): The version generation rate in KB per seconds.
  let ``Version Generation rate (KB/s)`` =
    { category = CategoryName; counter = "Version Generation rate (KB/s)"; instance = None }
  /// Version Store Size (KB): The size of the version store in KB.
  let ``Version Store Size (KB)`` =
    { category = CategoryName; counter = "Version Store Size (KB)"; instance = None }
  /// Version Store unit count: Number of unit in Version Store.
  let ``Version Store unit count`` =
    { category = CategoryName; counter = "Version Store unit count"; instance = None }
  /// Version Store unit creation: Creation of new unit in Version Store.
  let ``Version Store unit creation`` =
    { category = CategoryName; counter = "Version Store unit creation"; instance = None }
  /// Version Store unit truncation: Truncation of unit in Version Store.
  let ``Version Store unit truncation`` =
    { category = CategoryName; counter = "Version Store unit truncation"; instance = None }

  let allCounters =
    [| ``Free Space in tempdb (KB)``
       ``Longest Transaction Running Time``
       ``NonSnapshot Version Transactions``
       ``Snapshot Transactions``
       ``Transactions``
       ``Update Snapshot Transactions``
       ``Update conflict ratio``
       ``Update conflict ratio base``
       ``Version Cleanup rate (KB/s)``
       ``Version Generation rate (KB/s)``
       ``Version Store Size (KB)``
       ``Version Store unit count``
       ``Version Store unit creation``
       ``Version Store unit truncation``
    |]

/// SQLServer:User Settable: This defines user definable counters
///
/// This performance counter does not have instance based counters
module ``SQLServer:User Settable`` =

  [<Literal>]
  let CategoryName = "SQLServer:User Settable"

  let PCC = Category.create CategoryName
  /// Query: -
  let ``Query`` instance =
    { category = CategoryName; counter = "Query"; instance = instance }

  let allCounters =
    [| ``Query``

    |]

/// SQLServer:Wait Statistics: Wait Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Wait Statistics`` =

  [<Literal>]
  let CategoryName = "SQLServer:Wait Statistics"

  let PCC = Category.create CategoryName
  /// Lock waits: -
  let ``Lock waits`` instance =
    { category = CategoryName; counter = "Lock waits"; instance = instance }
  /// Log buffer waits: -
  let ``Log buffer waits`` instance =
    { category = CategoryName; counter = "Log buffer waits"; instance = instance }
  /// Log write waits: -
  let ``Log write waits`` instance =
    { category = CategoryName; counter = "Log write waits"; instance = instance }
  /// Memory grant queue waits: -
  let ``Memory grant queue waits`` instance =
    { category = CategoryName; counter = "Memory grant queue waits"; instance = instance }
  /// Network IO waits: -
  let ``Network IO waits`` instance =
    { category = CategoryName; counter = "Network IO waits"; instance = instance }
  /// Non-Page latch waits: -
  let ``Non-Page latch waits`` instance =
    { category = CategoryName; counter = "Non-Page latch waits"; instance = instance }
  /// Page IO latch waits: -
  let ``Page IO latch waits`` instance =
    { category = CategoryName; counter = "Page IO latch waits"; instance = instance }
  /// Page latch waits: -
  let ``Page latch waits`` instance =
    { category = CategoryName; counter = "Page latch waits"; instance = instance }
  /// Thread-safe memory objects waits: -
  let ``Thread-safe memory objects waits`` instance =
    { category = CategoryName; counter = "Thread-safe memory objects waits"; instance = instance }
  /// Transaction ownership waits: -
  let ``Transaction ownership waits`` instance =
    { category = CategoryName; counter = "Transaction ownership waits"; instance = instance }
  /// Wait for the worker: -
  let ``Wait for the worker`` instance =
    { category = CategoryName; counter = "Wait for the worker"; instance = instance }
  /// Workspace synchronization waits: -
  let ``Workspace synchronization waits`` instance =
    { category = CategoryName; counter = "Workspace synchronization waits"; instance = instance }

  let allCounters =
    [| ``Lock waits``
       ``Log buffer waits``
       ``Log write waits``
       ``Memory grant queue waits``
       ``Network IO waits``
       ``Non-Page latch waits``
       ``Page IO latch waits``
       ``Page latch waits``
       ``Thread-safe memory objects waits``
       ``Transaction ownership waits``
       ``Wait for the worker``
       ``Workspace synchronization waits``
    |]

/// SQLServer:Workload Group Stats: Statistics associated with workload groups
///
/// This performance counter does not have instance based counters
module ``SQLServer:Workload Group Stats`` =

  [<Literal>]
  let CategoryName = "SQLServer:Workload Group Stats"

  let PCC = Category.create CategoryName
  /// Active parallel threads: -
  let ``Active parallel threads`` instance =
    { category = CategoryName; counter = "Active parallel threads"; instance = instance }
  /// Active requests: -
  let ``Active requests`` instance =
    { category = CategoryName; counter = "Active requests"; instance = instance }
  /// Blocked tasks: -
  let ``Blocked tasks`` instance =
    { category = CategoryName; counter = "Blocked tasks"; instance = instance }
  /// CPU usage %: -
  let ``CPU usage %`` instance =
    { category = CategoryName; counter = "CPU usage %"; instance = instance }
  /// CPU usage % base: -
  let ``CPU usage % base`` instance =
    { category = CategoryName; counter = "CPU usage % base"; instance = instance }
  /// Max request cpu time (ms): -
  let ``Max request cpu time (ms)`` instance =
    { category = CategoryName; counter = "Max request cpu time (ms)"; instance = instance }
  /// Max request memory grant (KB): -
  let ``Max request memory grant (KB)`` instance =
    { category = CategoryName; counter = "Max request memory grant (KB)"; instance = instance }
  /// Query optimizations/sec: -
  let ``Query optimizations/sec`` instance =
    { category = CategoryName; counter = "Query optimizations/sec"; instance = instance }
  /// Queued requests: -
  let ``Queued requests`` instance =
    { category = CategoryName; counter = "Queued requests"; instance = instance }
  /// Reduced memory grants/sec: -
  let ``Reduced memory grants/sec`` instance =
    { category = CategoryName; counter = "Reduced memory grants/sec"; instance = instance }
  /// Requests completed/sec: -
  let ``Requests completed/sec`` instance =
    { category = CategoryName; counter = "Requests completed/sec"; instance = instance }
  /// Suboptimal plans/sec: -
  let ``Suboptimal plans/sec`` instance =
    { category = CategoryName; counter = "Suboptimal plans/sec"; instance = instance }

  let allCounters =
    [| ``Active parallel threads``
       ``Active requests``
       ``Blocked tasks``
       ``CPU usage %``
       ``CPU usage % base``
       ``Max request cpu time (ms)``
       ``Max request memory grant (KB)``
       ``Query optimizations/sec``
       ``Queued requests``
       ``Reduced memory grants/sec``
       ``Requests completed/sec``
       ``Suboptimal plans/sec``
    |]

/// Search Indexer: Indexer PlugIn statistics
///
/// This performance counter does not have non-instance based counters
module ``Search Indexer`` =

  [<Literal>]
  let CategoryName = "Search Indexer"

  let PCC = Category.create CategoryName
  /// Active Connections: Active Connections
  let ``Active Connections`` instance =
    { category = CategoryName; counter = "Active Connections"; instance = instance }
  /// Clean WidSets: Number of clean WidSets
  let ``Clean WidSets`` instance =
    { category = CategoryName; counter = "Clean WidSets"; instance = instance }
  /// Dirty WidSets: Number of dirty WidSets
  let ``Dirty WidSets`` instance =
    { category = CategoryName; counter = "Dirty WidSets"; instance = instance }
  /// Documents Filtered: Number of Documents Filtered
  let ``Documents Filtered`` instance =
    { category = CategoryName; counter = "Documents Filtered"; instance = instance }
  /// Index Size: Size of Index
  let ``Index Size`` instance =
    { category = CategoryName; counter = "Index Size"; instance = instance }
  /// L0 Indexes (Wordlists): The number of L0 Indexes (Wordlists)
  let ``L0 Indexes (Wordlists)`` instance =
    { category = CategoryName; counter = "L0 Indexes (Wordlists)"; instance = instance }
  /// L0 Merge (Flush) - Count: The number of L0 merges (flushes) since the catalog was loaded
  let ``L0 Merge (Flush) - Count`` instance =
    { category = CategoryName; counter = "L0 Merge (Flush) - Count"; instance = instance }
  /// L0 Merge (Flush) Speed - Average: The average value [documents/hour] computed for the speed of L0 merges (flushes) since the catalog has been loaded
  let ``L0 Merge (Flush) Speed - Average`` instance =
    { category = CategoryName; counter = "L0 Merge (Flush) Speed - Average"; instance = instance }
  /// L0 Merge (Flush) Speed - Last: The last value [documents/hour] computed for the speed of L0 merges (flushes).
  let ``L0 Merge (Flush) Speed - Last`` instance =
    { category = CategoryName; counter = "L0 Merge (Flush) Speed - Last"; instance = instance }
  /// L0 Merges (flushes) Now.: The number of L0 merges (flushes) in progress at any one moment.
  let ``L0 Merges (flushes) Now.`` instance =
    { category = CategoryName; counter = "L0 Merges (flushes) Now."; instance = instance }
  /// L1 Merge - Count: The number of L1 merges since the catalog was loaded
  let ``L1 Merge - Count`` instance =
    { category = CategoryName; counter = "L1 Merge - Count"; instance = instance }
  /// L1 Merge Speed - average: The average value [documents/hour] computed for the speed of L1 merges since the catalog has been loaded
  let ``L1 Merge Speed - average`` instance =
    { category = CategoryName; counter = "L1 Merge Speed - average"; instance = instance }
  /// L1 Merge Speed - last: The last value [documents/hour] computed for the speed of L1 merges.
  let ``L1 Merge Speed - last`` instance =
    { category = CategoryName; counter = "L1 Merge Speed - last"; instance = instance }
  /// L1 Merges Now.: The number of L1 merges in progress at any one moment.
  let ``L1 Merges Now.`` instance =
    { category = CategoryName; counter = "L1 Merges Now."; instance = instance }
  /// L2 Merge - Count: The number of L2 merges since the catalog was loaded
  let ``L2 Merge - Count`` instance =
    { category = CategoryName; counter = "L2 Merge - Count"; instance = instance }
  /// L2 Merge Speed - average: The average value [documents/hour] computed for the speed of L2 merges since the catalog has been loaded
  let ``L2 Merge Speed - average`` instance =
    { category = CategoryName; counter = "L2 Merge Speed - average"; instance = instance }
  /// L2 Merge Speed - last: The last value [documents/hour] computed for the speed of L2 merges.
  let ``L2 Merge Speed - last`` instance =
    { category = CategoryName; counter = "L2 Merge Speed - last"; instance = instance }
  /// L2 Merges Now.: The number of L2 merges in progress at any one moment.
  let ``L2 Merges Now.`` instance =
    { category = CategoryName; counter = "L2 Merges Now."; instance = instance }
  /// L3 Merge - Count: The number of L3 merges since the catalog was loaded
  let ``L3 Merge - Count`` instance =
    { category = CategoryName; counter = "L3 Merge - Count"; instance = instance }
  /// L3 Merge Speed - average: The average value [documents/hour] computed for the speed of L3 merges since the catalog has been loaded
  let ``L3 Merge Speed - average`` instance =
    { category = CategoryName; counter = "L3 Merge Speed - average"; instance = instance }
  /// L3 Merge Speed - last: The last value [documents/hour] computed for the speed of L3 merges.
  let ``L3 Merge Speed - last`` instance =
    { category = CategoryName; counter = "L3 Merge Speed - last"; instance = instance }
  /// L3 Merges Now.: The number of L3 merges in progress at any one moment.
  let ``L3 Merges Now.`` instance =
    { category = CategoryName; counter = "L3 Merges Now."; instance = instance }
  /// L4 Merge - Count: The number of L4 merges since the catalog was loaded
  let ``L4 Merge - Count`` instance =
    { category = CategoryName; counter = "L4 Merge - Count"; instance = instance }
  /// L4 Merge Speed - average: The average value [documents/hour] computed for the speed of L4 merges since the catalog has been loaded
  let ``L4 Merge Speed - average`` instance =
    { category = CategoryName; counter = "L4 Merge Speed - average"; instance = instance }
  /// L4 Merge Speed - last: The last value [documents/hour] computed for the speed of L4 merges.
  let ``L4 Merge Speed - last`` instance =
    { category = CategoryName; counter = "L4 Merge Speed - last"; instance = instance }
  /// L4 Merges Now.: The number of L4 merges in progress at any one moment.
  let ``L4 Merges Now.`` instance =
    { category = CategoryName; counter = "L4 Merges Now."; instance = instance }
  /// L5 Merge - Count: The number of L5 merges since the catalog was loaded
  let ``L5 Merge - Count`` instance =
    { category = CategoryName; counter = "L5 Merge - Count"; instance = instance }
  /// L5 Merge Speed - average: The average value [documents/hour] computed for the speed of L5 merges since the catalog has been loaded
  let ``L5 Merge Speed - average`` instance =
    { category = CategoryName; counter = "L5 Merge Speed - average"; instance = instance }
  /// L5 Merge Speed - last: The last value [documents/hour] computed for the speed of L5 merges.
  let ``L5 Merge Speed - last`` instance =
    { category = CategoryName; counter = "L5 Merge Speed - last"; instance = instance }
  /// L5 Merges Now.: The number of L5 merges in progress at any one moment.
  let ``L5 Merges Now.`` instance =
    { category = CategoryName; counter = "L5 Merges Now."; instance = instance }
  /// L6 Merge - Count: The number of L6 merges since the catalog was loaded
  let ``L6 Merge - Count`` instance =
    { category = CategoryName; counter = "L6 Merge - Count"; instance = instance }
  /// L6 Merge Speed - average: The average value [documents/hour] computed for the speed of L6 merges since the catalog has been loaded
  let ``L6 Merge Speed - average`` instance =
    { category = CategoryName; counter = "L6 Merge Speed - average"; instance = instance }
  /// L6 Merge Speed - last: The last value [documents/hour] computed for the speed of L6 merges.
  let ``L6 Merge Speed - last`` instance =
    { category = CategoryName; counter = "L6 Merge Speed - last"; instance = instance }
  /// L6 Merges Now.: The number of L6 merges in progress at any one moment.
  let ``L6 Merges Now.`` instance =
    { category = CategoryName; counter = "L6 Merges Now."; instance = instance }
  /// L7 Merge - Count: The number of L7 merges since the catalog was loaded
  let ``L7 Merge - Count`` instance =
    { category = CategoryName; counter = "L7 Merge - Count"; instance = instance }
  /// L7 Merge Speed - average: The average value [documents/hour] computed for the speed of L7 merges since the catalog has been loaded
  let ``L7 Merge Speed - average`` instance =
    { category = CategoryName; counter = "L7 Merge Speed - average"; instance = instance }
  /// L7 Merge Speed - last: The last value [documents/hour] computed for the speed of L7 merges.
  let ``L7 Merge Speed - last`` instance =
    { category = CategoryName; counter = "L7 Merge Speed - last"; instance = instance }
  /// L7 Merges Now.: The number of L7 merges in progress at any one moment.
  let ``L7 Merges Now.`` instance =
    { category = CategoryName; counter = "L7 Merges Now."; instance = instance }
  /// L8 Merge - Count: The number of L8 merges since the catalog was loaded
  let ``L8 Merge - Count`` instance =
    { category = CategoryName; counter = "L8 Merge - Count"; instance = instance }
  /// L8 Merge Speed - average: The average value [documents/hour] computed for the speed of L8 merges since the catalog has been loaded
  let ``L8 Merge Speed - average`` instance =
    { category = CategoryName; counter = "L8 Merge Speed - average"; instance = instance }
  /// L8 Merge Speed - last: The last value [documents/hour] computed for the speed of L8 merges.
  let ``L8 Merge Speed - last`` instance =
    { category = CategoryName; counter = "L8 Merge Speed - last"; instance = instance }
  /// L8 Merges Now.: The number of L8 merges in progress at any one moment.
  let ``L8 Merges Now.`` instance =
    { category = CategoryName; counter = "L8 Merges Now."; instance = instance }
  /// Master Index Level.: The level of the master index.
  let ``Master Index Level.`` instance =
    { category = CategoryName; counter = "Master Index Level."; instance = instance }
  /// Master Merge Progress: Master Merge Progress
  let ``Master Merge Progress`` instance =
    { category = CategoryName; counter = "Master Merge Progress"; instance = instance }
  /// Master Merges Now.: Indicator if a master merge is going on.
  let ``Master Merges Now.`` instance =
    { category = CategoryName; counter = "Master Merges Now."; instance = instance }
  /// Master Merges to Date: Number of Master Merges to Date
  let ``Master Merges to Date`` instance =
    { category = CategoryName; counter = "Master Merges to Date"; instance = instance }
  /// Persistent Indexes: Number of Persistent Indexes
  let ``Persistent Indexes`` instance =
    { category = CategoryName; counter = "Persistent Indexes"; instance = instance }
  /// Persistent Indexes L1: The number of L1 Indexes
  let ``Persistent Indexes L1`` instance =
    { category = CategoryName; counter = "Persistent Indexes L1"; instance = instance }
  /// Persistent Indexes L2: The number of L2 Indexes
  let ``Persistent Indexes L2`` instance =
    { category = CategoryName; counter = "Persistent Indexes L2"; instance = instance }
  /// Persistent Indexes L3: The number of L3 Indexes
  let ``Persistent Indexes L3`` instance =
    { category = CategoryName; counter = "Persistent Indexes L3"; instance = instance }
  /// Persistent Indexes L4: The number of L4 Indexes
  let ``Persistent Indexes L4`` instance =
    { category = CategoryName; counter = "Persistent Indexes L4"; instance = instance }
  /// Persistent Indexes L5: The number of L5 Indexes
  let ``Persistent Indexes L5`` instance =
    { category = CategoryName; counter = "Persistent Indexes L5"; instance = instance }
  /// Persistent Indexes L6: The number of L6 Indexes
  let ``Persistent Indexes L6`` instance =
    { category = CategoryName; counter = "Persistent Indexes L6"; instance = instance }
  /// Persistent Indexes L7: The number of L7 Indexes
  let ``Persistent Indexes L7`` instance =
    { category = CategoryName; counter = "Persistent Indexes L7"; instance = instance }
  /// Persistent Indexes L8: The number of L8 Indexes
  let ``Persistent Indexes L8`` instance =
    { category = CategoryName; counter = "Persistent Indexes L8"; instance = instance }
  /// Queries: Number of Queries
  let ``Queries`` instance =
    { category = CategoryName; counter = "Queries"; instance = instance }
  /// Queries Failed: Number of Queries Failed
  let ``Queries Failed`` instance =
    { category = CategoryName; counter = "Queries Failed"; instance = instance }
  /// Queries Succeeded: Number of Queries Succeeded
  let ``Queries Succeeded`` instance =
    { category = CategoryName; counter = "Queries Succeeded"; instance = instance }
  /// Shadow Merge Levels: Shadow Merge Levels
  let ``Shadow Merge Levels`` instance =
    { category = CategoryName; counter = "Shadow Merge Levels"; instance = instance }
  /// Shadow Merge Levels Threshold: Shadow Merge Levels Threshold
  let ``Shadow Merge Levels Threshold`` instance =
    { category = CategoryName; counter = "Shadow Merge Levels Threshold"; instance = instance }
  /// Unique Keys: Number of Unique Keys
  let ``Unique Keys`` instance =
    { category = CategoryName; counter = "Unique Keys"; instance = instance }
  /// Work Items Created: Number of invalidator work items that were created
  let ``Work Items Created`` instance =
    { category = CategoryName; counter = "Work Items Created"; instance = instance }
  /// Work Items Deleted: Number of invalidator work items that were deleted
  let ``Work Items Deleted`` instance =
    { category = CategoryName; counter = "Work Items Deleted"; instance = instance }

  let allCounters =
    [| ``Active Connections``
       ``Clean WidSets``
       ``Dirty WidSets``
       ``Documents Filtered``
       ``Index Size``
       ``L0 Indexes (Wordlists)``
       ``L0 Merge (Flush) - Count``
       ``L0 Merge (Flush) Speed - Average``
       ``L0 Merge (Flush) Speed - Last``
       ``L0 Merges (flushes) Now.``
       ``L1 Merge - Count``
       ``L1 Merge Speed - average``
       ``L1 Merge Speed - last``
       ``L1 Merges Now.``
       ``L2 Merge - Count``
       ``L2 Merge Speed - average``
       ``L2 Merge Speed - last``
       ``L2 Merges Now.``
       ``L3 Merge - Count``
       ``L3 Merge Speed - average``
       ``L3 Merge Speed - last``
       ``L3 Merges Now.``
       ``L4 Merge - Count``
       ``L4 Merge Speed - average``
       ``L4 Merge Speed - last``
       ``L4 Merges Now.``
       ``L5 Merge - Count``
       ``L5 Merge Speed - average``
       ``L5 Merge Speed - last``
       ``L5 Merges Now.``
       ``L6 Merge - Count``
       ``L6 Merge Speed - average``
       ``L6 Merge Speed - last``
       ``L6 Merges Now.``
       ``L7 Merge - Count``
       ``L7 Merge Speed - average``
       ``L7 Merge Speed - last``
       ``L7 Merges Now.``
       ``L8 Merge - Count``
       ``L8 Merge Speed - average``
       ``L8 Merge Speed - last``
       ``L8 Merges Now.``
       ``Master Index Level.``
       ``Master Merge Progress``
       ``Master Merges Now.``
       ``Master Merges to Date``
       ``Persistent Indexes``
       ``Persistent Indexes L1``
       ``Persistent Indexes L2``
       ``Persistent Indexes L3``
       ``Persistent Indexes L4``
       ``Persistent Indexes L5``
       ``Persistent Indexes L6``
       ``Persistent Indexes L7``
       ``Persistent Indexes L8``
       ``Queries``
       ``Queries Failed``
       ``Queries Succeeded``
       ``Shadow Merge Levels``
       ``Shadow Merge Levels Threshold``
       ``Unique Keys``
       ``Work Items Created``
       ``Work Items Deleted``
    |]

/// ServiceModelEndpoint 3.0.0.0: ServiceModelEndpoint 3.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``ServiceModelEndpoint 3_0_0_0`` =

  [<Literal>]
  let CategoryName = "ServiceModelEndpoint 3.0.0.0"

  let PCC = Category.create CategoryName
  /// Calls: -
  let ``Calls`` instance =
    { category = CategoryName; counter = "Calls"; instance = instance }
  /// Calls Duration: -
  let ``Calls Duration`` instance =
    { category = CategoryName; counter = "Calls Duration"; instance = instance }
  /// Calls Duration Base: -
  let ``Calls Duration Base`` instance =
    { category = CategoryName; counter = "Calls Duration Base"; instance = instance }
  /// Calls Failed: -
  let ``Calls Failed`` instance =
    { category = CategoryName; counter = "Calls Failed"; instance = instance }
  /// Calls Failed Per Second: -
  let ``Calls Failed Per Second`` instance =
    { category = CategoryName; counter = "Calls Failed Per Second"; instance = instance }
  /// Calls Faulted: -
  let ``Calls Faulted`` instance =
    { category = CategoryName; counter = "Calls Faulted"; instance = instance }
  /// Calls Faulted Per Second: -
  let ``Calls Faulted Per Second`` instance =
    { category = CategoryName; counter = "Calls Faulted Per Second"; instance = instance }
  /// Calls Outstanding: -
  let ``Calls Outstanding`` instance =
    { category = CategoryName; counter = "Calls Outstanding"; instance = instance }
  /// Calls Per Second: -
  let ``Calls Per Second`` instance =
    { category = CategoryName; counter = "Calls Per Second"; instance = instance }
  /// Reliable Messaging Messages Dropped: -
  let ``Reliable Messaging Messages Dropped`` instance =
    { category = CategoryName; counter = "Reliable Messaging Messages Dropped"; instance = instance }
  /// Reliable Messaging Messages Dropped Per Second: -
  let ``Reliable Messaging Messages Dropped Per Second`` instance =
    { category = CategoryName; counter = "Reliable Messaging Messages Dropped Per Second"; instance = instance }
  /// Reliable Messaging Sessions Faulted: -
  let ``Reliable Messaging Sessions Faulted`` instance =
    { category = CategoryName; counter = "Reliable Messaging Sessions Faulted"; instance = instance }
  /// Reliable Messaging Sessions Faulted Per Second: -
  let ``Reliable Messaging Sessions Faulted Per Second`` instance =
    { category = CategoryName; counter = "Reliable Messaging Sessions Faulted Per Second"; instance = instance }
  /// Security Calls Not Authorized: -
  let ``Security Calls Not Authorized`` instance =
    { category = CategoryName; counter = "Security Calls Not Authorized"; instance = instance }
  /// Security Calls Not Authorized Per Second: -
  let ``Security Calls Not Authorized Per Second`` instance =
    { category = CategoryName; counter = "Security Calls Not Authorized Per Second"; instance = instance }
  /// Security Validation and Authentication Failures: -
  let ``Security Validation and Authentication Failures`` instance =
    { category = CategoryName; counter = "Security Validation and Authentication Failures"; instance = instance }
  /// Security Validation and Authentication Failures Per Second: -
  let ``Security Validation and Authentication Failures Per Second`` instance =
    { category = CategoryName; counter = "Security Validation and Authentication Failures Per Second"; instance = instance }
  /// Transactions Flowed: -
  let ``Transactions Flowed`` instance =
    { category = CategoryName; counter = "Transactions Flowed"; instance = instance }
  /// Transactions Flowed Per Second: -
  let ``Transactions Flowed Per Second`` instance =
    { category = CategoryName; counter = "Transactions Flowed Per Second"; instance = instance }

  let allCounters =
    [| ``Calls``
       ``Calls Duration``
       ``Calls Duration Base``
       ``Calls Failed``
       ``Calls Failed Per Second``
       ``Calls Faulted``
       ``Calls Faulted Per Second``
       ``Calls Outstanding``
       ``Calls Per Second``
       ``Reliable Messaging Messages Dropped``
       ``Reliable Messaging Messages Dropped Per Second``
       ``Reliable Messaging Sessions Faulted``
       ``Reliable Messaging Sessions Faulted Per Second``
       ``Security Calls Not Authorized``
       ``Security Calls Not Authorized Per Second``
       ``Security Validation and Authentication Failures``
       ``Security Validation and Authentication Failures Per Second``
       ``Transactions Flowed``
       ``Transactions Flowed Per Second``
    |]

/// ServiceModelEndpoint 4.0.0.0: ServiceModel performance counters for endpoint
///
/// This performance counter does not have instance based counters
module ``ServiceModelEndpoint 4_0_0_0`` =

  [<Literal>]
  let CategoryName = "ServiceModelEndpoint 4.0.0.0"

  let PCC = Category.create CategoryName
  /// Calls: -
  let ``Calls`` instance =
    { category = CategoryName; counter = "Calls"; instance = instance }
  /// Calls Duration: -
  let ``Calls Duration`` instance =
    { category = CategoryName; counter = "Calls Duration"; instance = instance }
  /// Calls Failed: -
  let ``Calls Failed`` instance =
    { category = CategoryName; counter = "Calls Failed"; instance = instance }
  /// Calls Failed Per Second: -
  let ``Calls Failed Per Second`` instance =
    { category = CategoryName; counter = "Calls Failed Per Second"; instance = instance }
  /// Calls Faulted: -
  let ``Calls Faulted`` instance =
    { category = CategoryName; counter = "Calls Faulted"; instance = instance }
  /// Calls Faulted Per Second: -
  let ``Calls Faulted Per Second`` instance =
    { category = CategoryName; counter = "Calls Faulted Per Second"; instance = instance }
  /// Calls Outstanding: -
  let ``Calls Outstanding`` instance =
    { category = CategoryName; counter = "Calls Outstanding"; instance = instance }
  /// Calls Per Second: -
  let ``Calls Per Second`` instance =
    { category = CategoryName; counter = "Calls Per Second"; instance = instance }
  /// Reliable Messaging Messages Dropped: -
  let ``Reliable Messaging Messages Dropped`` instance =
    { category = CategoryName; counter = "Reliable Messaging Messages Dropped"; instance = instance }
  /// Reliable Messaging Messages Dropped Per Second: -
  let ``Reliable Messaging Messages Dropped Per Second`` instance =
    { category = CategoryName; counter = "Reliable Messaging Messages Dropped Per Second"; instance = instance }
  /// Reliable Messaging Sessions Faulted: -
  let ``Reliable Messaging Sessions Faulted`` instance =
    { category = CategoryName; counter = "Reliable Messaging Sessions Faulted"; instance = instance }
  /// Reliable Messaging Sessions Faulted Per Second: -
  let ``Reliable Messaging Sessions Faulted Per Second`` instance =
    { category = CategoryName; counter = "Reliable Messaging Sessions Faulted Per Second"; instance = instance }
  /// Security Calls Not Authorized: -
  let ``Security Calls Not Authorized`` instance =
    { category = CategoryName; counter = "Security Calls Not Authorized"; instance = instance }
  /// Security Calls Not Authorized Per Second: -
  let ``Security Calls Not Authorized Per Second`` instance =
    { category = CategoryName; counter = "Security Calls Not Authorized Per Second"; instance = instance }
  /// Security Validation and Authentication Failures: -
  let ``Security Validation and Authentication Failures`` instance =
    { category = CategoryName; counter = "Security Validation and Authentication Failures"; instance = instance }
  /// Security Validation and Authentication Failures Per Second: -
  let ``Security Validation and Authentication Failures Per Second`` instance =
    { category = CategoryName; counter = "Security Validation and Authentication Failures Per Second"; instance = instance }
  /// Transactions Flowed: -
  let ``Transactions Flowed`` instance =
    { category = CategoryName; counter = "Transactions Flowed"; instance = instance }
  /// Transactions Flowed Per Second: -
  let ``Transactions Flowed Per Second`` instance =
    { category = CategoryName; counter = "Transactions Flowed Per Second"; instance = instance }

  let allCounters =
    [| ``Calls``
       ``Calls Duration``
       ``Calls Failed``
       ``Calls Failed Per Second``
       ``Calls Faulted``
       ``Calls Faulted Per Second``
       ``Calls Outstanding``
       ``Calls Per Second``
       ``Reliable Messaging Messages Dropped``
       ``Reliable Messaging Messages Dropped Per Second``
       ``Reliable Messaging Sessions Faulted``
       ``Reliable Messaging Sessions Faulted Per Second``
       ``Security Calls Not Authorized``
       ``Security Calls Not Authorized Per Second``
       ``Security Validation and Authentication Failures``
       ``Security Validation and Authentication Failures Per Second``
       ``Transactions Flowed``
       ``Transactions Flowed Per Second``
    |]

/// ServiceModelOperation 3.0.0.0: ServiceModelOperation 3.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``ServiceModelOperation 3_0_0_0`` =

  [<Literal>]
  let CategoryName = "ServiceModelOperation 3.0.0.0"

  let PCC = Category.create CategoryName
  /// Call Failed Per Second: -
  let ``Call Failed Per Second`` instance =
    { category = CategoryName; counter = "Call Failed Per Second"; instance = instance }
  /// Calls: -
  let ``Calls`` instance =
    { category = CategoryName; counter = "Calls"; instance = instance }
  /// Calls Duration: -
  let ``Calls Duration`` instance =
    { category = CategoryName; counter = "Calls Duration"; instance = instance }
  /// Calls Duration Base: -
  let ``Calls Duration Base`` instance =
    { category = CategoryName; counter = "Calls Duration Base"; instance = instance }
  /// Calls Failed: -
  let ``Calls Failed`` instance =
    { category = CategoryName; counter = "Calls Failed"; instance = instance }
  /// Calls Faulted: -
  let ``Calls Faulted`` instance =
    { category = CategoryName; counter = "Calls Faulted"; instance = instance }
  /// Calls Faulted Per Second: -
  let ``Calls Faulted Per Second`` instance =
    { category = CategoryName; counter = "Calls Faulted Per Second"; instance = instance }
  /// Calls Outstanding: -
  let ``Calls Outstanding`` instance =
    { category = CategoryName; counter = "Calls Outstanding"; instance = instance }
  /// Calls Per Second: -
  let ``Calls Per Second`` instance =
    { category = CategoryName; counter = "Calls Per Second"; instance = instance }
  /// Security Calls Not Authorized: -
  let ``Security Calls Not Authorized`` instance =
    { category = CategoryName; counter = "Security Calls Not Authorized"; instance = instance }
  /// Security Calls Not Authorized Per Second: -
  let ``Security Calls Not Authorized Per Second`` instance =
    { category = CategoryName; counter = "Security Calls Not Authorized Per Second"; instance = instance }
  /// Security Validation and Authentication Failures: -
  let ``Security Validation and Authentication Failures`` instance =
    { category = CategoryName; counter = "Security Validation and Authentication Failures"; instance = instance }
  /// Security Validation and Authentication Failures Per Second: -
  let ``Security Validation and Authentication Failures Per Second`` instance =
    { category = CategoryName; counter = "Security Validation and Authentication Failures Per Second"; instance = instance }
  /// Transactions Flowed: -
  let ``Transactions Flowed`` instance =
    { category = CategoryName; counter = "Transactions Flowed"; instance = instance }
  /// Transactions Flowed Per Second: -
  let ``Transactions Flowed Per Second`` instance =
    { category = CategoryName; counter = "Transactions Flowed Per Second"; instance = instance }

  let allCounters =
    [| ``Call Failed Per Second``
       ``Calls``
       ``Calls Duration``
       ``Calls Duration Base``
       ``Calls Failed``
       ``Calls Faulted``
       ``Calls Faulted Per Second``
       ``Calls Outstanding``
       ``Calls Per Second``
       ``Security Calls Not Authorized``
       ``Security Calls Not Authorized Per Second``
       ``Security Validation and Authentication Failures``
       ``Security Validation and Authentication Failures Per Second``
       ``Transactions Flowed``
       ``Transactions Flowed Per Second``
    |]

/// ServiceModelOperation 4.0.0.0: ServiceModelOperation 4.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``ServiceModelOperation 4_0_0_0`` =

  [<Literal>]
  let CategoryName = "ServiceModelOperation 4.0.0.0"

  let PCC = Category.create CategoryName
  /// Call Failed Per Second: -
  let ``Call Failed Per Second`` instance =
    { category = CategoryName; counter = "Call Failed Per Second"; instance = instance }
  /// Calls: -
  let ``Calls`` instance =
    { category = CategoryName; counter = "Calls"; instance = instance }
  /// Calls Duration: -
  let ``Calls Duration`` instance =
    { category = CategoryName; counter = "Calls Duration"; instance = instance }
  /// Calls Failed: -
  let ``Calls Failed`` instance =
    { category = CategoryName; counter = "Calls Failed"; instance = instance }
  /// Calls Faulted: -
  let ``Calls Faulted`` instance =
    { category = CategoryName; counter = "Calls Faulted"; instance = instance }
  /// Calls Faulted Per Second: -
  let ``Calls Faulted Per Second`` instance =
    { category = CategoryName; counter = "Calls Faulted Per Second"; instance = instance }
  /// Calls Outstanding: -
  let ``Calls Outstanding`` instance =
    { category = CategoryName; counter = "Calls Outstanding"; instance = instance }
  /// Calls Per Second: -
  let ``Calls Per Second`` instance =
    { category = CategoryName; counter = "Calls Per Second"; instance = instance }
  /// Security Calls Not Authorized: -
  let ``Security Calls Not Authorized`` instance =
    { category = CategoryName; counter = "Security Calls Not Authorized"; instance = instance }
  /// Security Calls Not Authorized Per Second: -
  let ``Security Calls Not Authorized Per Second`` instance =
    { category = CategoryName; counter = "Security Calls Not Authorized Per Second"; instance = instance }
  /// Security Validation and Authentication Failures: -
  let ``Security Validation and Authentication Failures`` instance =
    { category = CategoryName; counter = "Security Validation and Authentication Failures"; instance = instance }
  /// Security Validation and Authentication Failures Per Second: -
  let ``Security Validation and Authentication Failures Per Second`` instance =
    { category = CategoryName; counter = "Security Validation and Authentication Failures Per Second"; instance = instance }
  /// Transactions Flowed: -
  let ``Transactions Flowed`` instance =
    { category = CategoryName; counter = "Transactions Flowed"; instance = instance }
  /// Transactions Flowed Per Second: -
  let ``Transactions Flowed Per Second`` instance =
    { category = CategoryName; counter = "Transactions Flowed Per Second"; instance = instance }

  let allCounters =
    [| ``Call Failed Per Second``
       ``Calls``
       ``Calls Duration``
       ``Calls Failed``
       ``Calls Faulted``
       ``Calls Faulted Per Second``
       ``Calls Outstanding``
       ``Calls Per Second``
       ``Security Calls Not Authorized``
       ``Security Calls Not Authorized Per Second``
       ``Security Validation and Authentication Failures``
       ``Security Validation and Authentication Failures Per Second``
       ``Transactions Flowed``
       ``Transactions Flowed Per Second``
    |]

/// ServiceModelService 3.0.0.0: ServiceModelService 3.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``ServiceModelService 3_0_0_0`` =

  [<Literal>]
  let CategoryName = "ServiceModelService 3.0.0.0"

  let PCC = Category.create CategoryName
  /// Calls: -
  let ``Calls`` instance =
    { category = CategoryName; counter = "Calls"; instance = instance }
  /// Calls Duration: -
  let ``Calls Duration`` instance =
    { category = CategoryName; counter = "Calls Duration"; instance = instance }
  /// Calls Duration Base: -
  let ``Calls Duration Base`` instance =
    { category = CategoryName; counter = "Calls Duration Base"; instance = instance }
  /// Calls Failed: -
  let ``Calls Failed`` instance =
    { category = CategoryName; counter = "Calls Failed"; instance = instance }
  /// Calls Failed Per Second: -
  let ``Calls Failed Per Second`` instance =
    { category = CategoryName; counter = "Calls Failed Per Second"; instance = instance }
  /// Calls Faulted: -
  let ``Calls Faulted`` instance =
    { category = CategoryName; counter = "Calls Faulted"; instance = instance }
  /// Calls Faulted Per Second: -
  let ``Calls Faulted Per Second`` instance =
    { category = CategoryName; counter = "Calls Faulted Per Second"; instance = instance }
  /// Calls Outstanding: -
  let ``Calls Outstanding`` instance =
    { category = CategoryName; counter = "Calls Outstanding"; instance = instance }
  /// Calls Per Second: -
  let ``Calls Per Second`` instance =
    { category = CategoryName; counter = "Calls Per Second"; instance = instance }
  /// Instances: -
  let ``Instances`` instance =
    { category = CategoryName; counter = "Instances"; instance = instance }
  /// Instances Created Per Second: -
  let ``Instances Created Per Second`` instance =
    { category = CategoryName; counter = "Instances Created Per Second"; instance = instance }
  /// Queued Messages Dropped: -
  let ``Queued Messages Dropped`` instance =
    { category = CategoryName; counter = "Queued Messages Dropped"; instance = instance }
  /// Queued Messages Dropped Per Second: -
  let ``Queued Messages Dropped Per Second`` instance =
    { category = CategoryName; counter = "Queued Messages Dropped Per Second"; instance = instance }
  /// Queued Messages Rejected: -
  let ``Queued Messages Rejected`` instance =
    { category = CategoryName; counter = "Queued Messages Rejected"; instance = instance }
  /// Queued Messages Rejected Per Second: -
  let ``Queued Messages Rejected Per Second`` instance =
    { category = CategoryName; counter = "Queued Messages Rejected Per Second"; instance = instance }
  /// Queued Poison Messages: -
  let ``Queued Poison Messages`` instance =
    { category = CategoryName; counter = "Queued Poison Messages"; instance = instance }
  /// Queued Poison Messages Per Second: -
  let ``Queued Poison Messages Per Second`` instance =
    { category = CategoryName; counter = "Queued Poison Messages Per Second"; instance = instance }
  /// Reliable Messaging Messages Dropped: -
  let ``Reliable Messaging Messages Dropped`` instance =
    { category = CategoryName; counter = "Reliable Messaging Messages Dropped"; instance = instance }
  /// Reliable Messaging Messages Dropped Per Second: -
  let ``Reliable Messaging Messages Dropped Per Second`` instance =
    { category = CategoryName; counter = "Reliable Messaging Messages Dropped Per Second"; instance = instance }
  /// Reliable Messaging Sessions Faulted: -
  let ``Reliable Messaging Sessions Faulted`` instance =
    { category = CategoryName; counter = "Reliable Messaging Sessions Faulted"; instance = instance }
  /// Reliable Messaging Sessions Faulted Per Second: -
  let ``Reliable Messaging Sessions Faulted Per Second`` instance =
    { category = CategoryName; counter = "Reliable Messaging Sessions Faulted Per Second"; instance = instance }
  /// Security Calls Not Authorized: -
  let ``Security Calls Not Authorized`` instance =
    { category = CategoryName; counter = "Security Calls Not Authorized"; instance = instance }
  /// Security Calls Not Authorized Per Second: -
  let ``Security Calls Not Authorized Per Second`` instance =
    { category = CategoryName; counter = "Security Calls Not Authorized Per Second"; instance = instance }
  /// Security Validation and Authentication Failures: -
  let ``Security Validation and Authentication Failures`` instance =
    { category = CategoryName; counter = "Security Validation and Authentication Failures"; instance = instance }
  /// Security Validation and Authentication Failures Per Second: -
  let ``Security Validation and Authentication Failures Per Second`` instance =
    { category = CategoryName; counter = "Security Validation and Authentication Failures Per Second"; instance = instance }
  /// Transacted Operations Aborted: -
  let ``Transacted Operations Aborted`` instance =
    { category = CategoryName; counter = "Transacted Operations Aborted"; instance = instance }
  /// Transacted Operations Aborted Per Second: -
  let ``Transacted Operations Aborted Per Second`` instance =
    { category = CategoryName; counter = "Transacted Operations Aborted Per Second"; instance = instance }
  /// Transacted Operations Committed: -
  let ``Transacted Operations Committed`` instance =
    { category = CategoryName; counter = "Transacted Operations Committed"; instance = instance }
  /// Transacted Operations Committed Per Second: -
  let ``Transacted Operations Committed Per Second`` instance =
    { category = CategoryName; counter = "Transacted Operations Committed Per Second"; instance = instance }
  /// Transacted Operations In Doubt: -
  let ``Transacted Operations In Doubt`` instance =
    { category = CategoryName; counter = "Transacted Operations In Doubt"; instance = instance }
  /// Transacted Operations In Doubt Per Second: -
  let ``Transacted Operations In Doubt Per Second`` instance =
    { category = CategoryName; counter = "Transacted Operations In Doubt Per Second"; instance = instance }
  /// Transactions Flowed: -
  let ``Transactions Flowed`` instance =
    { category = CategoryName; counter = "Transactions Flowed"; instance = instance }
  /// Transactions Flowed Per Second: -
  let ``Transactions Flowed Per Second`` instance =
    { category = CategoryName; counter = "Transactions Flowed Per Second"; instance = instance }

  let allCounters =
    [| ``Calls``
       ``Calls Duration``
       ``Calls Duration Base``
       ``Calls Failed``
       ``Calls Failed Per Second``
       ``Calls Faulted``
       ``Calls Faulted Per Second``
       ``Calls Outstanding``
       ``Calls Per Second``
       ``Instances``
       ``Instances Created Per Second``
       ``Queued Messages Dropped``
       ``Queued Messages Dropped Per Second``
       ``Queued Messages Rejected``
       ``Queued Messages Rejected Per Second``
       ``Queued Poison Messages``
       ``Queued Poison Messages Per Second``
       ``Reliable Messaging Messages Dropped``
       ``Reliable Messaging Messages Dropped Per Second``
       ``Reliable Messaging Sessions Faulted``
       ``Reliable Messaging Sessions Faulted Per Second``
       ``Security Calls Not Authorized``
       ``Security Calls Not Authorized Per Second``
       ``Security Validation and Authentication Failures``
       ``Security Validation and Authentication Failures Per Second``
       ``Transacted Operations Aborted``
       ``Transacted Operations Aborted Per Second``
       ``Transacted Operations Committed``
       ``Transacted Operations Committed Per Second``
       ``Transacted Operations In Doubt``
       ``Transacted Operations In Doubt Per Second``
       ``Transactions Flowed``
       ``Transactions Flowed Per Second``
    |]

/// ServiceModelService 4.0.0.0: ServiceModel performance counters for service
///
/// This performance counter does not have non-instance based counters
module ``ServiceModelService 4_0_0_0`` =

  [<Literal>]
  let CategoryName = "ServiceModelService 4.0.0.0"

  let PCC = Category.create CategoryName
  /// Calls: The number of calls to this service. http://go.microsoft.com/fwlink/?LinkId=222530
  let ``Calls`` instance =
    { category = CategoryName; counter = "Calls"; instance = instance }
  /// Calls Duration: The average duration of calls to this service. http://go.microsoft.com/fwlink/?LinkId=222537
  let ``Calls Duration`` instance =
    { category = CategoryName; counter = "Calls Duration"; instance = instance }
  /// Calls Failed: The number of calls with unhandled exceptions in this service. http://go.microsoft.com/fwlink/?LinkId=222533
  let ``Calls Failed`` instance =
    { category = CategoryName; counter = "Calls Failed"; instance = instance }
  /// Calls Failed Per Second: The number of calls with unhandled exceptions in this service per second. http://go.microsoft.com/fwlink/?LinkId=222534
  let ``Calls Failed Per Second`` instance =
    { category = CategoryName; counter = "Calls Failed Per Second"; instance = instance }
  /// Calls Faulted: The number of calls to this service that returned faults. http://go.microsoft.com/fwlink/?LinkId=222535
  let ``Calls Faulted`` instance =
    { category = CategoryName; counter = "Calls Faulted"; instance = instance }
  /// Calls Faulted Per Second: The number of calls to this service that returned faults per second. http://go.microsoft.com/fwlink/?LinkId=222536
  let ``Calls Faulted Per Second`` instance =
    { category = CategoryName; counter = "Calls Faulted Per Second"; instance = instance }
  /// Calls Outstanding: The number of calls to this service that are in progress. http://go.microsoft.com/fwlink/?LinkId=222532
  let ``Calls Outstanding`` instance =
    { category = CategoryName; counter = "Calls Outstanding"; instance = instance }
  /// Calls Per Second: The number of calls to this service per second. http://go.microsoft.com/fwlink/?LinkId=222531
  let ``Calls Per Second`` instance =
    { category = CategoryName; counter = "Calls Per Second"; instance = instance }
  /// Instances: The total number of instances of the service. http://go.microsoft.com/fwlink/?LinkId=222538
  let ``Instances`` instance =
    { category = CategoryName; counter = "Instances"; instance = instance }
  /// Instances Created Per Second: The creation rate of service instances per second. http://go.microsoft.com/fwlink/?LinkId=222539
  let ``Instances Created Per Second`` instance =
    { category = CategoryName; counter = "Instances Created Per Second"; instance = instance }
  /// Percent Of Max Concurrent Calls: Number of calls waiting to be or being processed in the dispatcher as a percentage of max calls throttle. http://go.microsoft.com/fwlink/?LinkId=222540
  let ``Percent Of Max Concurrent Calls`` instance =
    { category = CategoryName; counter = "Percent Of Max Concurrent Calls"; instance = instance }
  /// Percent Of Max Concurrent Instances: Number of active instances and messages waiting for instances as a percentage of max instances throttle. http://go.microsoft.com/fwlink/?LinkId=222541
  let ``Percent Of Max Concurrent Instances`` instance =
    { category = CategoryName; counter = "Percent Of Max Concurrent Instances"; instance = instance }
  /// Percent Of Max Concurrent Sessions: Number of active sessions and messages waiting for sessions as a percentage of max sessions throttle. http://go.microsoft.com/fwlink/?LinkId=222542
  let ``Percent Of Max Concurrent Sessions`` instance =
    { category = CategoryName; counter = "Percent Of Max Concurrent Sessions"; instance = instance }
  /// Queued Messages Dropped: The number of messages to this service that were dropped by the queued transport. http://go.microsoft.com/fwlink/?LinkId=222543
  let ``Queued Messages Dropped`` instance =
    { category = CategoryName; counter = "Queued Messages Dropped"; instance = instance }
  /// Queued Messages Dropped Per Second: The number of messages to this service that were dropped by the queued transport per second. http://go.microsoft.com/fwlink/?LinkId=222544
  let ``Queued Messages Dropped Per Second`` instance =
    { category = CategoryName; counter = "Queued Messages Dropped Per Second"; instance = instance }
  /// Queued Messages Rejected: The number of messages to this servcie that were rejected by the queued transport. http://go.microsoft.com/fwlink/?LinkId=222548
  let ``Queued Messages Rejected`` instance =
    { category = CategoryName; counter = "Queued Messages Rejected"; instance = instance }
  /// Queued Messages Rejected Per Second: The number of messages to this service that were rejected by the queued transport per second. http://go.microsoft.com/fwlink/?LinkId=222549
  let ``Queued Messages Rejected Per Second`` instance =
    { category = CategoryName; counter = "Queued Messages Rejected Per Second"; instance = instance }
  /// Queued Poison Messages: The number of messages to this service that were marked poisoned by the queued transport. http://go.microsoft.com/fwlink/?LinkId=222546
  let ``Queued Poison Messages`` instance =
    { category = CategoryName; counter = "Queued Poison Messages"; instance = instance }
  /// Queued Poison Messages Per Second: The number of messages to this service that were marked poisoned by the queued transport per second. http://go.microsoft.com/fwlink/?LinkId=222547
  let ``Queued Poison Messages Per Second`` instance =
    { category = CategoryName; counter = "Queued Poison Messages Per Second"; instance = instance }
  /// Reliable Messaging Messages Dropped: The number of reliable messaging messages that were dropped in this service. http://go.microsoft.com/fwlink/?LinkId=222550
  let ``Reliable Messaging Messages Dropped`` instance =
    { category = CategoryName; counter = "Reliable Messaging Messages Dropped"; instance = instance }
  /// Reliable Messaging Messages Dropped Per Second: The number of reliable messaging messages that were dropped in this service per second. http://go.microsoft.com/fwlink/?LinkId=222551
  let ``Reliable Messaging Messages Dropped Per Second`` instance =
    { category = CategoryName; counter = "Reliable Messaging Messages Dropped Per Second"; instance = instance }
  /// Reliable Messaging Sessions Faulted: The number of reliable messaging sessions that were faulted in this service. http://go.microsoft.com/fwlink/?LinkId=222552
  let ``Reliable Messaging Sessions Faulted`` instance =
    { category = CategoryName; counter = "Reliable Messaging Sessions Faulted"; instance = instance }
  /// Reliable Messaging Sessions Faulted Per Second: The number of reliable messaging sessions that were faulted in this service per second. http://go.microsoft.com/fwlink/?LinkId=222553
  let ``Reliable Messaging Sessions Faulted Per Second`` instance =
    { category = CategoryName; counter = "Reliable Messaging Sessions Faulted Per Second"; instance = instance }
  /// Security Calls Not Authorized: The number of calls to this service that failed authorization. http://go.microsoft.com/fwlink/?LinkId=222555
  let ``Security Calls Not Authorized`` instance =
    { category = CategoryName; counter = "Security Calls Not Authorized"; instance = instance }
  /// Security Calls Not Authorized Per Second: The number of calls to this service that failed authorization per second. http://go.microsoft.com/fwlink/?LinkId=222556
  let ``Security Calls Not Authorized Per Second`` instance =
    { category = CategoryName; counter = "Security Calls Not Authorized Per Second"; instance = instance }
  /// Security Validation and Authentication Failures: The number of calls to this service that failed validation or authentication. http://go.microsoft.com/fwlink/?LinkId=222558
  let ``Security Validation and Authentication Failures`` instance =
    { category = CategoryName; counter = "Security Validation and Authentication Failures"; instance = instance }
  /// Security Validation and Authentication Failures Per Second: The number of calls to this service that failed validation or authentication per second. http://go.microsoft.com/fwlink/?LinkId=222559
  let ``Security Validation and Authentication Failures Per Second`` instance =
    { category = CategoryName; counter = "Security Validation and Authentication Failures Per Second"; instance = instance }
  /// Transacted Operations Aborted: The number of transacted operations with the outcome aborted in this service. Work done under such operations is rolled back. Resources are reverted to their previous state. http://go.microsoft.com/fwlink/?LinkId=222562
  let ``Transacted Operations Aborted`` instance =
    { category = CategoryName; counter = "Transacted Operations Aborted"; instance = instance }
  /// Transacted Operations Aborted Per Second: The number of transacted operations with the outcome aborted in this service per second. Work done under such operations is rolled back. Resources are reverted to their previous state. http://go.microsoft.com/fwlink/?LinkId=222563
  let ``Transacted Operations Aborted Per Second`` instance =
    { category = CategoryName; counter = "Transacted Operations Aborted Per Second"; instance = instance }
  /// Transacted Operations Committed: The number of transacted operations with the outcome committed in this service. Work done under such operations is fully committed. Resources are updated in accordance with the work done in the operation. http://go.microsoft.com/fwlink/?LinkId=222564
  let ``Transacted Operations Committed`` instance =
    { category = CategoryName; counter = "Transacted Operations Committed"; instance = instance }
  /// Transacted Operations Committed Per Second: The number of transacted operations with the outcome committed in this service per second. Work done under such operations is fully committed. Resources are updated in accordance with the work done in the operation. http://go.microsoft.com/fwlink/?LinkId=222565
  let ``Transacted Operations Committed Per Second`` instance =
    { category = CategoryName; counter = "Transacted Operations Committed Per Second"; instance = instance }
  /// Transacted Operations In Doubt: The number of transacted operations with an outcome in doubt in this service. Work done with an outcome in doubt is in an indeterminate state. Resources are held pending outcome. http://go.microsoft.com/fwlink/?LinkId=222566
  let ``Transacted Operations In Doubt`` instance =
    { category = CategoryName; counter = "Transacted Operations In Doubt"; instance = instance }
  /// Transacted Operations In Doubt Per Second: The number of transacted operations with an outcome in doubt in this service per second. Work done with an outcome in doubt is in an indeterminate state. Resources are held pending outcome. http://go.microsoft.com/fwlink/?LinkId=222567
  let ``Transacted Operations In Doubt Per Second`` instance =
    { category = CategoryName; counter = "Transacted Operations In Doubt Per Second"; instance = instance }
  /// Transactions Flowed: The number of transactions that flowed to operations in this service. This counter is incremented any time a transaction ID is present in the message that is sent to the service. http://go.microsoft.com/fwlink/?LinkId=222560
  let ``Transactions Flowed`` instance =
    { category = CategoryName; counter = "Transactions Flowed"; instance = instance }
  /// Transactions Flowed Per Second: The number of transactions that flowed to operations in this service per second. This counter is incremented any time a transaction ID is present in the message that is sent to the service. http://go.microsoft.com/fwlink/?LinkId=222561
  let ``Transactions Flowed Per Second`` instance =
    { category = CategoryName; counter = "Transactions Flowed Per Second"; instance = instance }

  let allCounters =
    [| ``Calls``
       ``Calls Duration``
       ``Calls Failed``
       ``Calls Failed Per Second``
       ``Calls Faulted``
       ``Calls Faulted Per Second``
       ``Calls Outstanding``
       ``Calls Per Second``
       ``Instances``
       ``Instances Created Per Second``
       ``Percent Of Max Concurrent Calls``
       ``Percent Of Max Concurrent Instances``
       ``Percent Of Max Concurrent Sessions``
       ``Queued Messages Dropped``
       ``Queued Messages Dropped Per Second``
       ``Queued Messages Rejected``
       ``Queued Messages Rejected Per Second``
       ``Queued Poison Messages``
       ``Queued Poison Messages Per Second``
       ``Reliable Messaging Messages Dropped``
       ``Reliable Messaging Messages Dropped Per Second``
       ``Reliable Messaging Sessions Faulted``
       ``Reliable Messaging Sessions Faulted Per Second``
       ``Security Calls Not Authorized``
       ``Security Calls Not Authorized Per Second``
       ``Security Validation and Authentication Failures``
       ``Security Validation and Authentication Failures Per Second``
       ``Transacted Operations Aborted``
       ``Transacted Operations Aborted Per Second``
       ``Transacted Operations Committed``
       ``Transacted Operations Committed Per Second``
       ``Transacted Operations In Doubt``
       ``Transacted Operations In Doubt Per Second``
       ``Transactions Flowed``
       ``Transactions Flowed Per Second``
    |]

/// Storage Spaces Tier: The Storage Spaces Tier performance object consists of counters that show information about Storage Spaces tiers.
///
/// This performance counter does not have instance based counters
module ``Storage Spaces Tier`` =

  [<Literal>]
  let CategoryName = "Storage Spaces Tier"

  let PCC = Category.create CategoryName
  /// Avg. Tier Bytes/Read: -
  let ``Avg. Tier Bytes/Read`` instance =
    { category = CategoryName; counter = "Avg. Tier Bytes/Read"; instance = instance }
  /// Avg. Tier Bytes/Transfer: -
  let ``Avg. Tier Bytes/Transfer`` instance =
    { category = CategoryName; counter = "Avg. Tier Bytes/Transfer"; instance = instance }
  /// Avg. Tier Bytes/Write: -
  let ``Avg. Tier Bytes/Write`` instance =
    { category = CategoryName; counter = "Avg. Tier Bytes/Write"; instance = instance }
  /// Avg. Tier Queue Length: -
  let ``Avg. Tier Queue Length`` instance =
    { category = CategoryName; counter = "Avg. Tier Queue Length"; instance = instance }
  /// Avg. Tier Read Queue Length: -
  let ``Avg. Tier Read Queue Length`` instance =
    { category = CategoryName; counter = "Avg. Tier Read Queue Length"; instance = instance }
  /// Avg. Tier Write Queue Length: -
  let ``Avg. Tier Write Queue Length`` instance =
    { category = CategoryName; counter = "Avg. Tier Write Queue Length"; instance = instance }
  /// Avg. Tier sec/Read: -
  let ``Avg. Tier sec/Read`` instance =
    { category = CategoryName; counter = "Avg. Tier sec/Read"; instance = instance }
  /// Avg. Tier sec/Transfer: -
  let ``Avg. Tier sec/Transfer`` instance =
    { category = CategoryName; counter = "Avg. Tier sec/Transfer"; instance = instance }
  /// Avg. Tier sec/Write: -
  let ``Avg. Tier sec/Write`` instance =
    { category = CategoryName; counter = "Avg. Tier sec/Write"; instance = instance }
  /// Current Tier Queue Length: -
  let ``Current Tier Queue Length`` instance =
    { category = CategoryName; counter = "Current Tier Queue Length"; instance = instance }
  /// Tier Read Bytes/sec: -
  let ``Tier Read Bytes/sec`` instance =
    { category = CategoryName; counter = "Tier Read Bytes/sec"; instance = instance }
  /// Tier Reads/sec: -
  let ``Tier Reads/sec`` instance =
    { category = CategoryName; counter = "Tier Reads/sec"; instance = instance }
  /// Tier Transfer Bytes/sec: -
  let ``Tier Transfer Bytes/sec`` instance =
    { category = CategoryName; counter = "Tier Transfer Bytes/sec"; instance = instance }
  /// Tier Transfers/sec: -
  let ``Tier Transfers/sec`` instance =
    { category = CategoryName; counter = "Tier Transfers/sec"; instance = instance }
  /// Tier Write Bytes/sec: -
  let ``Tier Write Bytes/sec`` instance =
    { category = CategoryName; counter = "Tier Write Bytes/sec"; instance = instance }
  /// Tier Writes/sec: -
  let ``Tier Writes/sec`` instance =
    { category = CategoryName; counter = "Tier Writes/sec"; instance = instance }

  let allCounters =
    [| ``Avg. Tier Bytes/Read``
       ``Avg. Tier Bytes/Transfer``
       ``Avg. Tier Bytes/Write``
       ``Avg. Tier Queue Length``
       ``Avg. Tier Read Queue Length``
       ``Avg. Tier Write Queue Length``
       ``Avg. Tier sec/Read``
       ``Avg. Tier sec/Transfer``
       ``Avg. Tier sec/Write``
       ``Current Tier Queue Length``
       ``Tier Read Bytes/sec``
       ``Tier Reads/sec``
       ``Tier Transfer Bytes/sec``
       ``Tier Transfers/sec``
       ``Tier Write Bytes/sec``
       ``Tier Writes/sec``
    |]

/// Storage Spaces Write Cache: The Storage Spaces Write Cache performance object consists of counters that show information about Storage Spaces write caches.
///
/// This performance counter does not have instance based counters
module ``Storage Spaces Write Cache`` =

  [<Literal>]
  let CategoryName = "Storage Spaces Write Cache"

  let PCC = Category.create CategoryName
  /// Avg. Cache Bytes/Evict: -
  let ``Avg. Cache Bytes/Evict`` instance =
    { category = CategoryName; counter = "Avg. Cache Bytes/Evict"; instance = instance }
  /// Avg. Cache Bytes/Overwrite: -
  let ``Avg. Cache Bytes/Overwrite`` instance =
    { category = CategoryName; counter = "Avg. Cache Bytes/Overwrite"; instance = instance }
  /// Avg. Cache Bytes/Write: -
  let ``Avg. Cache Bytes/Write`` instance =
    { category = CategoryName; counter = "Avg. Cache Bytes/Write"; instance = instance }
  /// Avg. Destage Bytes/Evict: -
  let ``Avg. Destage Bytes/Evict`` instance =
    { category = CategoryName; counter = "Avg. Destage Bytes/Evict"; instance = instance }
  /// Avg. Destage Bytes/Transfer: -
  let ``Avg. Destage Bytes/Transfer`` instance =
    { category = CategoryName; counter = "Avg. Destage Bytes/Transfer"; instance = instance }
  /// Avg. Destage Evict Bytes/Operation: -
  let ``Avg. Destage Evict Bytes/Operation`` instance =
    { category = CategoryName; counter = "Avg. Destage Evict Bytes/Operation"; instance = instance }
  /// Avg. Destage Evicts/Operation: -
  let ``Avg. Destage Evicts/Operation`` instance =
    { category = CategoryName; counter = "Avg. Destage Evicts/Operation"; instance = instance }
  /// Avg. Destage Queue Length: -
  let ``Avg. Destage Queue Length`` instance =
    { category = CategoryName; counter = "Avg. Destage Queue Length"; instance = instance }
  /// Avg. Destage Transfer Bytes/Operation: -
  let ``Avg. Destage Transfer Bytes/Operation`` instance =
    { category = CategoryName; counter = "Avg. Destage Transfer Bytes/Operation"; instance = instance }
  /// Avg. Destage Transfers/Evict: -
  let ``Avg. Destage Transfers/Evict`` instance =
    { category = CategoryName; counter = "Avg. Destage Transfers/Evict"; instance = instance }
  /// Avg. Destage Transfers/Operation: -
  let ``Avg. Destage Transfers/Operation`` instance =
    { category = CategoryName; counter = "Avg. Destage Transfers/Operation"; instance = instance }
  /// Avg. Destage sec/Operation: -
  let ``Avg. Destage sec/Operation`` instance =
    { category = CategoryName; counter = "Avg. Destage sec/Operation"; instance = instance }
  /// Bytes Cached: -
  let ``Bytes Cached`` instance =
    { category = CategoryName; counter = "Bytes Cached"; instance = instance }
  /// Bytes Reclaimable: -
  let ``Bytes Reclaimable`` instance =
    { category = CategoryName; counter = "Bytes Reclaimable"; instance = instance }
  /// Bytes Reserved: -
  let ``Bytes Reserved`` instance =
    { category = CategoryName; counter = "Bytes Reserved"; instance = instance }
  /// Bytes Used: -
  let ``Bytes Used`` instance =
    { category = CategoryName; counter = "Bytes Used"; instance = instance }
  /// Cache Evict Bytes/sec: -
  let ``Cache Evict Bytes/sec`` instance =
    { category = CategoryName; counter = "Cache Evict Bytes/sec"; instance = instance }
  /// Cache Evicts/sec: -
  let ``Cache Evicts/sec`` instance =
    { category = CategoryName; counter = "Cache Evicts/sec"; instance = instance }
  /// Cache Overwrite Bytes/sec: -
  let ``Cache Overwrite Bytes/sec`` instance =
    { category = CategoryName; counter = "Cache Overwrite Bytes/sec"; instance = instance }
  /// Cache Overwrites/sec: -
  let ``Cache Overwrites/sec`` instance =
    { category = CategoryName; counter = "Cache Overwrites/sec"; instance = instance }
  /// Cache Size: -
  let ``Cache Size`` instance =
    { category = CategoryName; counter = "Cache Size"; instance = instance }
  /// Cache Write Bytes/sec: -
  let ``Cache Write Bytes/sec`` instance =
    { category = CategoryName; counter = "Cache Write Bytes/sec"; instance = instance }
  /// Cache Writes/sec: -
  let ``Cache Writes/sec`` instance =
    { category = CategoryName; counter = "Cache Writes/sec"; instance = instance }
  /// Current Destage Queue Length: -
  let ``Current Destage Queue Length`` instance =
    { category = CategoryName; counter = "Current Destage Queue Length"; instance = instance }
  /// Destage Evict Bytes/sec: -
  let ``Destage Evict Bytes/sec`` instance =
    { category = CategoryName; counter = "Destage Evict Bytes/sec"; instance = instance }
  /// Destage Evicts/sec: -
  let ``Destage Evicts/sec`` instance =
    { category = CategoryName; counter = "Destage Evicts/sec"; instance = instance }
  /// Destage Operations/sec: -
  let ``Destage Operations/sec`` instance =
    { category = CategoryName; counter = "Destage Operations/sec"; instance = instance }
  /// Destage Optimized Operations/sec: -
  let ``Destage Optimized Operations/sec`` instance =
    { category = CategoryName; counter = "Destage Optimized Operations/sec"; instance = instance }
  /// Destage Transfer Bytes/sec: -
  let ``Destage Transfer Bytes/sec`` instance =
    { category = CategoryName; counter = "Destage Transfer Bytes/sec"; instance = instance }
  /// Destage Transfers/sec: -
  let ``Destage Transfers/sec`` instance =
    { category = CategoryName; counter = "Destage Transfers/sec"; instance = instance }

  let allCounters =
    [| ``Avg. Cache Bytes/Evict``
       ``Avg. Cache Bytes/Overwrite``
       ``Avg. Cache Bytes/Write``
       ``Avg. Destage Bytes/Evict``
       ``Avg. Destage Bytes/Transfer``
       ``Avg. Destage Evict Bytes/Operation``
       ``Avg. Destage Evicts/Operation``
       ``Avg. Destage Queue Length``
       ``Avg. Destage Transfer Bytes/Operation``
       ``Avg. Destage Transfers/Evict``
       ``Avg. Destage Transfers/Operation``
       ``Avg. Destage sec/Operation``
       ``Bytes Cached``
       ``Bytes Reclaimable``
       ``Bytes Reserved``
       ``Bytes Used``
       ``Cache Evict Bytes/sec``
       ``Cache Evicts/sec``
       ``Cache Overwrite Bytes/sec``
       ``Cache Overwrites/sec``
       ``Cache Size``
       ``Cache Write Bytes/sec``
       ``Cache Writes/sec``
       ``Current Destage Queue Length``
       ``Destage Evict Bytes/sec``
       ``Destage Evicts/sec``
       ``Destage Operations/sec``
       ``Destage Optimized Operations/sec``
       ``Destage Transfer Bytes/sec``
       ``Destage Transfers/sec``
    |]

/// Synchronization: The Synchronization performance object consists of counters for kernel synchronization. The synchronization object represents each processor as an instance of the object.
///
/// This performance counter does not have non-instance based counters
module ``Synchronization`` =

  [<Literal>]
  let CategoryName = "Synchronization"

  let PCC = Category.create CategoryName
  /// Exec. Resource Acquires AcqExclLite/sec: Frequency of first exclusive acquires from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Acquires AcqExclLite/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Acquires AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Acquires AcqShrdLite/sec: Frequency of first shared acquires from ExAcquireResourceSharedLite.
  let ``Exec. Resource Acquires AcqShrdLite/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Acquires AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Acquires AcqShrdStarveExcl/sec: Frequency of first shared acquires from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Acquires AcqShrdStarveExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Acquires AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Acquires AcqShrdWaitForExcl/sec: Frequency of first shared acquires from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Acquires AcqShrdWaitForExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Acquires AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Attempts AcqExclLite/sec: Frequency of acquire exclusive attempts on Executive Resources from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Attempts AcqExclLite/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Attempts AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Attempts AcqShrdLite/sec: Frequency of acquire shared attempts on Executive Resources from ExAcquireResourceSharedLite.
  let ``Exec. Resource Attempts AcqShrdLite/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Attempts AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Attempts AcqShrdStarveExcl/sec: Frequency of acquire shared attempts on Executive Resources from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Attempts AcqShrdStarveExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Attempts AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Attempts AcqShrdWaitForExcl/sec: Frequency of acquire shared attempts on Executive Resources from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Attempts AcqShrdWaitForExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Attempts AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Boost Excl. Owner/sec: Frequency of boosting exclusive ownwer when waiting for this Executive Resource.
  let ``Exec. Resource Boost Excl. Owner/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Boost Excl. Owner/sec"; instance = instance }
  /// Exec. Resource Boost Shared Owners/sec: Frequency of boosting shared ownwer(s) when waiting for this Executive Resource.
  let ``Exec. Resource Boost Shared Owners/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Boost Shared Owners/sec"; instance = instance }
  /// Exec. Resource Contention AcqExclLite/sec: Frequency of waits during exclusive acquire attempts from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Contention AcqExclLite/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Contention AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Contention AcqShrdLite/sec: Frequency of waits during acquire attempts from ExAcquireResourceSharedLite.
  let ``Exec. Resource Contention AcqShrdLite/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Contention AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Contention AcqShrdStarveExcl/sec: Frequency of waits during shared acquire attempts from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Contention AcqShrdStarveExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Contention AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Contention AcqShrdWaitForExcl/sec: Frequency of waits during shared acquire attempts from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Contention AcqShrdWaitForExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Contention AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqExclLite/sec: Frequency of recursive exclusive acquires from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Recursive Excl. Acquires AcqExclLite/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Recursive Excl. Acquires AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec: Frequency of recursive exclusive acquires from ExAcquireResourceSharedLite.
  let ``Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec: Frequency of recursive exclusive acquires from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec: Frequency of recursive exclusive acquires from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec: Frequency of recursive shared acquires from ExAcquireResourceSharedLite.
  let ``Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec: Frequency of recursive shared acquires from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec: Frequency of recursive shared acquires from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Set Owner Pointer Exclusive/sec: Frequency of ExSetResourceOwnerPointer to an exclusive owner.
  let ``Exec. Resource Set Owner Pointer Exclusive/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Set Owner Pointer Exclusive/sec"; instance = instance }
  /// Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec: Frequency of ExSetResourceOwnerPointer to an existing shared owner.
  let ``Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec"; instance = instance }
  /// Exec. Resource Set Owner Pointer Shared (New Owner)/sec: Frequency of ExSetResourceOwnerPointer to a new shared owner.
  let ``Exec. Resource Set Owner Pointer Shared (New Owner)/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Set Owner Pointer Shared (New Owner)/sec"; instance = instance }
  /// Exec. Resource Total Acquires/sec: Frequency of acquire operations on Executive Resources.
  let ``Exec. Resource Total Acquires/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Total Acquires/sec"; instance = instance }
  /// Exec. Resource Total Contentions/sec: Contention rate on Executive Resources.
  let ``Exec. Resource Total Contentions/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Total Contentions/sec"; instance = instance }
  /// Exec. Resource Total Conv. Exclusive To Shared/sec: Frequency of convert to shared operations on Executive Resources.
  let ``Exec. Resource Total Conv. Exclusive To Shared/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Total Conv. Exclusive To Shared/sec"; instance = instance }
  /// Exec. Resource Total Delete/sec: Frequency of delete operations on Executive Resources.
  let ``Exec. Resource Total Delete/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Total Delete/sec"; instance = instance }
  /// Exec. Resource Total Exclusive Releases/sec: Frequency of Exclusive releases on Executive Resources.
  let ``Exec. Resource Total Exclusive Releases/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Total Exclusive Releases/sec"; instance = instance }
  /// Exec. Resource Total Initialize/sec: Frequency of initialization operations on Executive Resources.
  let ``Exec. Resource Total Initialize/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Total Initialize/sec"; instance = instance }
  /// Exec. Resource Total Re-Initialize/sec: Frequency of re-initialization operations on Executive Resources.
  let ``Exec. Resource Total Re-Initialize/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Total Re-Initialize/sec"; instance = instance }
  /// Exec. Resource Total Shared Releases/sec: Frequency of Shared releases on Executive Resources.
  let ``Exec. Resource Total Shared Releases/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Total Shared Releases/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqExclLite/sec: Frequency of no-waits during exclusive acquire attempts from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource no-Waits AcqExclLite/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource no-Waits AcqExclLite/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqShrdLite/sec: Frequency of no-waits during acquire attempts from ExAcquireResourceSharedLite.
  let ``Exec. Resource no-Waits AcqShrdLite/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource no-Waits AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqShrdStarveExcl/sec: Frequency of no-waits during shared acquire attempts from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource no-Waits AcqShrdStarveExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource no-Waits AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqShrdWaitForExcl/sec: Frequency of no-waits during exclusive acquire attempts from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource no-Waits AcqShrdWaitForExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource no-Waits AcqShrdWaitForExcl/sec"; instance = instance }
  /// IPI Send Broadcast Requests/sec: IPI Send Broadcast Requests/sec is the rate of IPI broadcast requests.
  let ``IPI Send Broadcast Requests/sec`` instance =
    { category = CategoryName; counter = "IPI Send Broadcast Requests/sec"; instance = instance }
  /// IPI Send Routine Requests/sec: IPI Send Routine Requests/sec is the rate of IPI routine requests.
  let ``IPI Send Routine Requests/sec`` instance =
    { category = CategoryName; counter = "IPI Send Routine Requests/sec"; instance = instance }
  /// IPI Send Software Interrupts/sec: IPI Send Software Interrrupts/sec is the rate of software interrupts.
  let ``IPI Send Software Interrupts/sec`` instance =
    { category = CategoryName; counter = "IPI Send Software Interrupts/sec"; instance = instance }
  /// Spinlock Acquires/sec: Spinlock acquires/sec is the rate of spinlock acquisitions. It includes the basic spinlocks, queued spinlocks, in-stack queued spinlocks, and shared spinlocks acquisitions.
  let ``Spinlock Acquires/sec`` instance =
    { category = CategoryName; counter = "Spinlock Acquires/sec"; instance = instance }
  /// Spinlock Contentions/sec: Spinlock contentions/sec is the rate of spinlock contentions. It includes the basic spinlocks, queued spinlocks, in-stack queued spinlocks, and shared spinlocks contentions.
  let ``Spinlock Contentions/sec`` instance =
    { category = CategoryName; counter = "Spinlock Contentions/sec"; instance = instance }
  /// Spinlock Spins/sec: Spinlock spins/sec is the rate of spinlock spins. It includes the spins to acquire basic spinlocks, queued spinlocks, in-stack queued spinlocks, and shared spinlocks.
  let ``Spinlock Spins/sec`` instance =
    { category = CategoryName; counter = "Spinlock Spins/sec"; instance = instance }

  let allCounters =
    [| ``Exec. Resource Acquires AcqExclLite/sec``
       ``Exec. Resource Acquires AcqShrdLite/sec``
       ``Exec. Resource Acquires AcqShrdStarveExcl/sec``
       ``Exec. Resource Acquires AcqShrdWaitForExcl/sec``
       ``Exec. Resource Attempts AcqExclLite/sec``
       ``Exec. Resource Attempts AcqShrdLite/sec``
       ``Exec. Resource Attempts AcqShrdStarveExcl/sec``
       ``Exec. Resource Attempts AcqShrdWaitForExcl/sec``
       ``Exec. Resource Boost Excl. Owner/sec``
       ``Exec. Resource Boost Shared Owners/sec``
       ``Exec. Resource Contention AcqExclLite/sec``
       ``Exec. Resource Contention AcqShrdLite/sec``
       ``Exec. Resource Contention AcqShrdStarveExcl/sec``
       ``Exec. Resource Contention AcqShrdWaitForExcl/sec``
       ``Exec. Resource Recursive Excl. Acquires AcqExclLite/sec``
       ``Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec``
       ``Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec``
       ``Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec``
       ``Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec``
       ``Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec``
       ``Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec``
       ``Exec. Resource Set Owner Pointer Exclusive/sec``
       ``Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec``
       ``Exec. Resource Set Owner Pointer Shared (New Owner)/sec``
       ``Exec. Resource Total Acquires/sec``
       ``Exec. Resource Total Contentions/sec``
       ``Exec. Resource Total Conv. Exclusive To Shared/sec``
       ``Exec. Resource Total Delete/sec``
       ``Exec. Resource Total Exclusive Releases/sec``
       ``Exec. Resource Total Initialize/sec``
       ``Exec. Resource Total Re-Initialize/sec``
       ``Exec. Resource Total Shared Releases/sec``
       ``Exec. Resource no-Waits AcqExclLite/sec``
       ``Exec. Resource no-Waits AcqShrdLite/sec``
       ``Exec. Resource no-Waits AcqShrdStarveExcl/sec``
       ``Exec. Resource no-Waits AcqShrdWaitForExcl/sec``
       ``IPI Send Broadcast Requests/sec``
       ``IPI Send Routine Requests/sec``
       ``IPI Send Software Interrupts/sec``
       ``Spinlock Acquires/sec``
       ``Spinlock Contentions/sec``
       ``Spinlock Spins/sec``
    |]

/// SynchronizationNuma: The Synchronization performance object consists of counters for kernel synchronization. The synchronization object represents each processor as an instance of the object. The counters are aggregated based on the system NUMA topology.
///
/// This performance counter does not have non-instance based counters
module ``SynchronizationNuma`` =

  [<Literal>]
  let CategoryName = "SynchronizationNuma"

  let PCC = Category.create CategoryName
  /// Exec. Resource Acquires AcqExclLite/sec: Frequency of first exclusive acquires from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Acquires AcqExclLite/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Acquires AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Acquires AcqShrdLite/sec: Frequency of first shared acquires from ExAcquireResourceSharedLite.
  let ``Exec. Resource Acquires AcqShrdLite/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Acquires AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Acquires AcqShrdStarveExcl/sec: Frequency of first shared acquires from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Acquires AcqShrdStarveExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Acquires AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Acquires AcqShrdWaitForExcl/sec: Frequency of first shared acquires from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Acquires AcqShrdWaitForExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Acquires AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Attempts AcqExclLite/sec: Frequency of acquire exclusive attempts on Executive Resources from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Attempts AcqExclLite/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Attempts AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Attempts AcqShrdLite/sec: Frequency of acquire shared attempts on Executive Resources from ExAcquireResourceSharedLite.
  let ``Exec. Resource Attempts AcqShrdLite/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Attempts AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Attempts AcqShrdStarveExcl/sec: Frequency of acquire shared attempts on Executive Resources from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Attempts AcqShrdStarveExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Attempts AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Attempts AcqShrdWaitForExcl/sec: Frequency of acquire shared attempts on Executive Resources from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Attempts AcqShrdWaitForExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Attempts AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Boost Excl. Owner/sec: Frequency of boosting exclusive ownwer when waiting for this Executive Resource.
  let ``Exec. Resource Boost Excl. Owner/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Boost Excl. Owner/sec"; instance = instance }
  /// Exec. Resource Boost Shared Owners/sec: Frequency of boosting shared ownwer(s) when waiting for this Executive Resource.
  let ``Exec. Resource Boost Shared Owners/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Boost Shared Owners/sec"; instance = instance }
  /// Exec. Resource Contention AcqExclLite/sec: Frequency of waits during exclusive acquire attempts from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Contention AcqExclLite/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Contention AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Contention AcqShrdLite/sec: Frequency of waits during acquire attempts from ExAcquireResourceSharedLite.
  let ``Exec. Resource Contention AcqShrdLite/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Contention AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Contention AcqShrdStarveExcl/sec: Frequency of waits during shared acquire attempts from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Contention AcqShrdStarveExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Contention AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Contention AcqShrdWaitForExcl/sec: Frequency of waits during shared acquire attempts from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Contention AcqShrdWaitForExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Contention AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqExclLite/sec: Frequency of recursive exclusive acquires from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Recursive Excl. Acquires AcqExclLite/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Recursive Excl. Acquires AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec: Frequency of recursive exclusive acquires from ExAcquireResourceSharedLite.
  let ``Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec: Frequency of recursive exclusive acquires from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec: Frequency of recursive exclusive acquires from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec: Frequency of recursive shared acquires from ExAcquireResourceSharedLite.
  let ``Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec: Frequency of recursive shared acquires from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec: Frequency of recursive shared acquires from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Set Owner Pointer Exclusive/sec: Frequency of ExSetResourceOwnerPointer to an exclusive owner.
  let ``Exec. Resource Set Owner Pointer Exclusive/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Set Owner Pointer Exclusive/sec"; instance = instance }
  /// Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec: Frequency of ExSetResourceOwnerPointer to an existing shared owner.
  let ``Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec"; instance = instance }
  /// Exec. Resource Set Owner Pointer Shared (New Owner)/sec: Frequency of ExSetResourceOwnerPointer to a new shared owner.
  let ``Exec. Resource Set Owner Pointer Shared (New Owner)/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Set Owner Pointer Shared (New Owner)/sec"; instance = instance }
  /// Exec. Resource Total Acquires/sec: Frequency of acquire operations on Executive Resources.
  let ``Exec. Resource Total Acquires/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Total Acquires/sec"; instance = instance }
  /// Exec. Resource Total Contentions/sec: Contention rate on Executive Resources.
  let ``Exec. Resource Total Contentions/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Total Contentions/sec"; instance = instance }
  /// Exec. Resource Total Conv. Exclusive To Shared/sec: Frequency of convert to shared operations on Executive Resources.
  let ``Exec. Resource Total Conv. Exclusive To Shared/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Total Conv. Exclusive To Shared/sec"; instance = instance }
  /// Exec. Resource Total Delete/sec: Frequency of delete operations on Executive Resources.
  let ``Exec. Resource Total Delete/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Total Delete/sec"; instance = instance }
  /// Exec. Resource Total Exclusive Releases/sec: Frequency of Exclusive releases on Executive Resources.
  let ``Exec. Resource Total Exclusive Releases/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Total Exclusive Releases/sec"; instance = instance }
  /// Exec. Resource Total Initialize/sec: Frequency of initialization operations on Executive Resources.
  let ``Exec. Resource Total Initialize/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Total Initialize/sec"; instance = instance }
  /// Exec. Resource Total Re-Initialize/sec: Frequency of re-initialization operations on Executive Resources.
  let ``Exec. Resource Total Re-Initialize/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Total Re-Initialize/sec"; instance = instance }
  /// Exec. Resource Total Shared Releases/sec: Frequency of Shared releases on Executive Resources.
  let ``Exec. Resource Total Shared Releases/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource Total Shared Releases/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqExclLite/sec: Frequency of no-waits during exclusive acquire attempts from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource no-Waits AcqExclLite/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource no-Waits AcqExclLite/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqShrdLite/sec: Frequency of no-waits during acquire attempts from ExAcquireResourceSharedLite.
  let ``Exec. Resource no-Waits AcqShrdLite/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource no-Waits AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqShrdStarveExcl/sec: Frequency of no-waits during shared acquire attempts from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource no-Waits AcqShrdStarveExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource no-Waits AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqShrdWaitForExcl/sec: Frequency of no-waits during exclusive acquire attempts from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource no-Waits AcqShrdWaitForExcl/sec`` instance =
    { category = CategoryName; counter = "Exec. Resource no-Waits AcqShrdWaitForExcl/sec"; instance = instance }
  /// IPI Send Broadcast Requests/sec: IPI Send Broadcast Requests/sec is the rate of IPI broadcast requests.
  let ``IPI Send Broadcast Requests/sec`` instance =
    { category = CategoryName; counter = "IPI Send Broadcast Requests/sec"; instance = instance }
  /// IPI Send Routine Requests/sec: IPI Send Routine Requests/sec is the rate of IPI routine requests.
  let ``IPI Send Routine Requests/sec`` instance =
    { category = CategoryName; counter = "IPI Send Routine Requests/sec"; instance = instance }
  /// IPI Send Software Interrupts/sec: IPI Send Software Interrrupts/sec is the rate of software interrupts.
  let ``IPI Send Software Interrupts/sec`` instance =
    { category = CategoryName; counter = "IPI Send Software Interrupts/sec"; instance = instance }
  /// Spinlock Acquires/sec: Spinlock acquires/sec is the rate of spinlock acquisitions. It includes the basic spinlocks, queued spinlocks, in-stack queued spinlocks, and shared spinlocks acquisitions.
  let ``Spinlock Acquires/sec`` instance =
    { category = CategoryName; counter = "Spinlock Acquires/sec"; instance = instance }
  /// Spinlock Contentions/sec: Spinlock contentions/sec is the rate of spinlock contentions. It includes the basic spinlocks, queued spinlocks, in-stack queued spinlocks, and shared spinlocks contentions.
  let ``Spinlock Contentions/sec`` instance =
    { category = CategoryName; counter = "Spinlock Contentions/sec"; instance = instance }
  /// Spinlock Spins/sec: Spinlock spins/sec is the rate of spinlock spins. It includes the spins to acquire basic spinlocks, queued spinlocks, in-stack queued spinlocks, and shared spinlocks.
  let ``Spinlock Spins/sec`` instance =
    { category = CategoryName; counter = "Spinlock Spins/sec"; instance = instance }

  let allCounters =
    [| ``Exec. Resource Acquires AcqExclLite/sec``
       ``Exec. Resource Acquires AcqShrdLite/sec``
       ``Exec. Resource Acquires AcqShrdStarveExcl/sec``
       ``Exec. Resource Acquires AcqShrdWaitForExcl/sec``
       ``Exec. Resource Attempts AcqExclLite/sec``
       ``Exec. Resource Attempts AcqShrdLite/sec``
       ``Exec. Resource Attempts AcqShrdStarveExcl/sec``
       ``Exec. Resource Attempts AcqShrdWaitForExcl/sec``
       ``Exec. Resource Boost Excl. Owner/sec``
       ``Exec. Resource Boost Shared Owners/sec``
       ``Exec. Resource Contention AcqExclLite/sec``
       ``Exec. Resource Contention AcqShrdLite/sec``
       ``Exec. Resource Contention AcqShrdStarveExcl/sec``
       ``Exec. Resource Contention AcqShrdWaitForExcl/sec``
       ``Exec. Resource Recursive Excl. Acquires AcqExclLite/sec``
       ``Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec``
       ``Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec``
       ``Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec``
       ``Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec``
       ``Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec``
       ``Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec``
       ``Exec. Resource Set Owner Pointer Exclusive/sec``
       ``Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec``
       ``Exec. Resource Set Owner Pointer Shared (New Owner)/sec``
       ``Exec. Resource Total Acquires/sec``
       ``Exec. Resource Total Contentions/sec``
       ``Exec. Resource Total Conv. Exclusive To Shared/sec``
       ``Exec. Resource Total Delete/sec``
       ``Exec. Resource Total Exclusive Releases/sec``
       ``Exec. Resource Total Initialize/sec``
       ``Exec. Resource Total Re-Initialize/sec``
       ``Exec. Resource Total Shared Releases/sec``
       ``Exec. Resource no-Waits AcqExclLite/sec``
       ``Exec. Resource no-Waits AcqShrdLite/sec``
       ``Exec. Resource no-Waits AcqShrdStarveExcl/sec``
       ``Exec. Resource no-Waits AcqShrdWaitForExcl/sec``
       ``IPI Send Broadcast Requests/sec``
       ``IPI Send Routine Requests/sec``
       ``IPI Send Software Interrupts/sec``
       ``Spinlock Acquires/sec``
       ``Spinlock Contentions/sec``
       ``Spinlock Spins/sec``
    |]

/// System: The System performance object consists of counters that apply to more than one instance of a component processors on the computer.
///
/// This performance counter does not have instance based counters
module ``System`` =

  [<Literal>]
  let CategoryName = "System"

  let PCC = Category.create CategoryName
  /// % Registry Quota In Use: % Registry Quota In Use is the percentage of the Total Registry Quota Allowed that is currently being used by the system.  This counter displays the current percentage value only; it is not an average.
  let ``% Registry Quota In Use`` =
    { category = CategoryName; counter = "% Registry Quota In Use"; instance = None }
  /// Alignment Fixups/sec: Alignment Fixups/sec is the rate, in incidents per seconds, at alignment faults were fixed by the system.
  let ``Alignment Fixups/sec`` =
    { category = CategoryName; counter = "Alignment Fixups/sec"; instance = None }
  /// Context Switches/sec: Context Switches/sec is the combined rate at which all processors on the computer are switched from one thread to another.  Context switches occur when a running thread voluntarily relinquishes the processor, is preempted by a higher priority ready thread, or switches between user-mode and privileged (kernel) mode to use an Executive or subsystem service.  It is the sum of Thread\\Context Switches/sec for all threads running on all processors in the computer and is measured in numbers of switches.  There are context switch counters on the System and Thread objects. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Context Switches/sec`` =
    { category = CategoryName; counter = "Context Switches/sec"; instance = None }
  /// Exception Dispatches/sec: Exception Dispatches/sec is the rate, in incidents per second, at which exceptions were dispatched by the system.
  let ``Exception Dispatches/sec`` =
    { category = CategoryName; counter = "Exception Dispatches/sec"; instance = None }
  /// File Control Bytes/sec: File Control Bytes/sec is the overall rate at which bytes are transferred for all file system operations that are neither reads nor writes, including file system control requests and requests for information about device characteristics or status.  It is measured in numbers of bytes.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``File Control Bytes/sec`` =
    { category = CategoryName; counter = "File Control Bytes/sec"; instance = None }
  /// File Control Operations/sec: File Control Operations/sec is the combined rate of file system operations that are neither reads nor writes, such as file system control requests and requests for information about device characteristics or status.  This is the inverse of System: File Data Operations/sec and is measured in number of operations perf second.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``File Control Operations/sec`` =
    { category = CategoryName; counter = "File Control Operations/sec"; instance = None }
  /// File Data Operations/sec: File Data Operations/ sec is the combined rate of read and write operations on all logical disks on the computer.  This is the inverse of System: File Control Operations/sec.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``File Data Operations/sec`` =
    { category = CategoryName; counter = "File Data Operations/sec"; instance = None }
  /// File Read Bytes/sec: File Read Bytes/sec is the overall rate at which bytes are read to satisfy  file system read requests to all devices on the computer, including reads from the file system cache.  It is measured in number of bytes per second.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``File Read Bytes/sec`` =
    { category = CategoryName; counter = "File Read Bytes/sec"; instance = None }
  /// File Read Operations/sec: File Read Operations/sec is the combined rate of file system read requests to all devices on the computer, including requests to read from the file system cache.  It is measured in numbers of reads.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``File Read Operations/sec`` =
    { category = CategoryName; counter = "File Read Operations/sec"; instance = None }
  /// File Write Bytes/sec: File Write Bytes/sec is the overall rate at which bytes are written to satisfy file system write requests to all devices on the computer, including writes to the file system cache.  It is measured in number of bytes per second.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``File Write Bytes/sec`` =
    { category = CategoryName; counter = "File Write Bytes/sec"; instance = None }
  /// File Write Operations/sec: File Write Operations/sec is the combined rate of the file system write requests to all devices on the computer, including requests to write to data in the file system cache.  It is measured in numbers of writes. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``File Write Operations/sec`` =
    { category = CategoryName; counter = "File Write Operations/sec"; instance = None }
  /// Floating Emulations/sec: Floating Emulations/sec is the rate of floating emulations performed by the system.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Floating Emulations/sec`` =
    { category = CategoryName; counter = "Floating Emulations/sec"; instance = None }
  /// Processes: Processes is the number of processes in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  Each process represents the running of a program.
  let ``Processes`` =
    { category = CategoryName; counter = "Processes"; instance = None }
  /// Processor Queue Length: Processor Queue Length is the number of threads in the processor queue.  Unlike the disk counters, this counter counters, this counter shows ready threads only, not threads that are running.  There is a single queue for processor time even on computers with multiple processors. Therefore, if a computer has multiple processors, you need to divide this value by the number of processors servicing the workload. A sustained processor queue of less than 10 threads per processor is normally acceptable, dependent of the workload.
  let ``Processor Queue Length`` =
    { category = CategoryName; counter = "Processor Queue Length"; instance = None }
  /// System Calls/sec: System Calls/sec is the combined rate of calls to operating system service routines by all processes running on the computer. These routines perform all of the basic scheduling and synchronization of activities on the computer, and provide access to non-graphic devices, memory management, and name space management. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``System Calls/sec`` =
    { category = CategoryName; counter = "System Calls/sec"; instance = None }
  /// System Up Time: System Up Time is the elapsed time (in seconds) that the computer has been running since it was last started.  This counter displays the difference between the start time and the current time.
  let ``System Up Time`` =
    { category = CategoryName; counter = "System Up Time"; instance = None }
  /// Threads: Threads is the number of threads in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  A thread is the basic executable entity that can execute instructions in a processor.
  let ``Threads`` =
    { category = CategoryName; counter = "Threads"; instance = None }

  let allCounters =
    [| ``% Registry Quota In Use``
       ``Alignment Fixups/sec``
       ``Context Switches/sec``
       ``Exception Dispatches/sec``
       ``File Control Bytes/sec``
       ``File Control Operations/sec``
       ``File Data Operations/sec``
       ``File Read Bytes/sec``
       ``File Read Operations/sec``
       ``File Write Bytes/sec``
       ``File Write Operations/sec``
       ``Floating Emulations/sec``
       ``Processes``
       ``Processor Queue Length``
       ``System Calls/sec``
       ``System Up Time``
       ``Threads``
    |]

/// TCPIP Performance Diagnostics: This counter set measures various TCPIP activity for performance diagnostics.
///
/// This performance counter does not have instance based counters
module ``TCPIP Performance Diagnostics`` =

  [<Literal>]
  let CategoryName = "TCPIP Performance Diagnostics"

  let PCC = Category.create CategoryName
  /// Denied connect or send requests in low-power mode: Total number of TCP connect or TCP/UDP/RAW send requests denied by the TCPIP stack because the outbound network interface was in low-power mode
  let ``Denied connect or send requests in low-power mode`` =
    { category = CategoryName; counter = "Denied connect or send requests in low-power mode"; instance = None }
  /// IPv4 NBLs indicated with low-resource flag: Total number of inbound NetBufferLists indicated from IPv4 Framing Layer to IPv4 Network Layer with low-resource flag
  let ``IPv4 NBLs indicated with low-resource flag`` =
    { category = CategoryName; counter = "IPv4 NBLs indicated with low-resource flag"; instance = None }
  /// IPv4 NBLs indicated without prevalidation: Total number of inbound NetBufferLists indicated from IPv4 Framing Layer to IPv4 Network Layer without prevalidation
  let ``IPv4 NBLs indicated without prevalidation`` =
    { category = CategoryName; counter = "IPv4 NBLs indicated without prevalidation"; instance = None }
  /// IPv4 NBLs treated as non-prevalidated: Total number of inbound NetBufferLists indicated to IPv4 Network Layer as prevalidated but treated as non-prevalidated consequently
  let ``IPv4 NBLs treated as non-prevalidated`` =
    { category = CategoryName; counter = "IPv4 NBLs treated as non-prevalidated"; instance = None }
  /// IPv4 NBLs/sec indicated with low-resource flag: Rate of inbound NetBufferLists indicated from IPv4 Framing Layer to IPv4 Network Layer with low-resource flag
  let ``IPv4 NBLs/sec indicated with low-resource flag`` =
    { category = CategoryName; counter = "IPv4 NBLs/sec indicated with low-resource flag"; instance = None }
  /// IPv4 NBLs/sec indicated without prevalidation: Rate of inbound NetBufferLists indicated from IPv4 Framing Layer to IPv4 Network Layer without prevalidation
  let ``IPv4 NBLs/sec indicated without prevalidation`` =
    { category = CategoryName; counter = "IPv4 NBLs/sec indicated without prevalidation"; instance = None }
  /// IPv4 NBLs/sec treated as non-prevalidated: Rate of inbound NetBufferLists indicated to IPv4 Network Layer as prevalidated but treated as non-prevalidated consequently
  let ``IPv4 NBLs/sec treated as non-prevalidated`` =
    { category = CategoryName; counter = "IPv4 NBLs/sec treated as non-prevalidated"; instance = None }
  /// IPv4 outbound NBLs not processed via fast path: Total number of outbound NetBufferLists that could not be processed via IPv4 Framing Layer fast path
  let ``IPv4 outbound NBLs not processed via fast path`` =
    { category = CategoryName; counter = "IPv4 outbound NBLs not processed via fast path"; instance = None }
  /// IPv4 outbound NBLs/sec not processed via fast path: Rate of outbound NetBufferLists that could not be processed via IPv4 Framing Layer fast path
  let ``IPv4 outbound NBLs/sec not processed via fast path`` =
    { category = CategoryName; counter = "IPv4 outbound NBLs/sec not processed via fast path"; instance = None }
  /// IPv6 NBLs indicated with low-resource flag: Total number of inbound NetBufferLists indicated from IPv6 Framing Layer to IPv6 Network Layer with low-resource flag
  let ``IPv6 NBLs indicated with low-resource flag`` =
    { category = CategoryName; counter = "IPv6 NBLs indicated with low-resource flag"; instance = None }
  /// IPv6 NBLs indicated without prevalidation: Total number of inbound NetBufferLists indicated from IPv6 Framing Layer to IPv6 Network Layer without prevalidation
  let ``IPv6 NBLs indicated without prevalidation`` =
    { category = CategoryName; counter = "IPv6 NBLs indicated without prevalidation"; instance = None }
  /// IPv6 NBLs treated as non-prevalidated: Total number of inbound NetBufferLists indicated to IPv6 Network Layer as prevalidated but treated as non-prevalidated consequently
  let ``IPv6 NBLs treated as non-prevalidated`` =
    { category = CategoryName; counter = "IPv6 NBLs treated as non-prevalidated"; instance = None }
  /// IPv6 NBLs/sec indicated with low-resource flag: Rate of inbound NetBufferLists indicated from IPv6 Framing Layer to IPv6 Network Layer with low-resource flag
  let ``IPv6 NBLs/sec indicated with low-resource flag`` =
    { category = CategoryName; counter = "IPv6 NBLs/sec indicated with low-resource flag"; instance = None }
  /// IPv6 NBLs/sec indicated without prevalidation: Rate of inbound NetBufferLists indicated from IPv6 Framing Layer to IPv6 Network Layer without prevalidation
  let ``IPv6 NBLs/sec indicated without prevalidation`` =
    { category = CategoryName; counter = "IPv6 NBLs/sec indicated without prevalidation"; instance = None }
  /// IPv6 NBLs/sec treated as non-prevalidated: Rate of inbound NetBufferLists indicated to IPv6 Network Layer as prevalidated but treated as non-prevalidated consequently
  let ``IPv6 NBLs/sec treated as non-prevalidated`` =
    { category = CategoryName; counter = "IPv6 NBLs/sec treated as non-prevalidated"; instance = None }
  /// IPv6 outbound NBLs not processed via fast path: Total number of outbound NetBufferLists that could not be processed via IPv6 Framing Layer fast path
  let ``IPv6 outbound NBLs not processed via fast path`` =
    { category = CategoryName; counter = "IPv6 outbound NBLs not processed via fast path"; instance = None }
  /// IPv6 outbound NBLs/sec not processed via fast path: Rate of outbound NetBufferLists that could not be processed via IPv6 Framing Layer fast path
  let ``IPv6 outbound NBLs/sec not processed via fast path`` =
    { category = CategoryName; counter = "IPv6 outbound NBLs/sec not processed via fast path"; instance = None }
  /// TCP connect requests fallen off loopback fast path: Total number of TCP connect requests which were established over normal loopback path despite loopback fast path was requested
  let ``TCP connect requests fallen off loopback fast path`` =
    { category = CategoryName; counter = "TCP connect requests fallen off loopback fast path"; instance = None }
  /// TCP connect requests/sec fallen off loopback fast path: Rate of TCP connect requests which were established over normal loopback path despite loopback fast path was requested
  let ``TCP connect requests/sec fallen off loopback fast path`` =
    { category = CategoryName; counter = "TCP connect requests/sec fallen off loopback fast path"; instance = None }
  /// TCP inbound segments not processed via fast path: Total number of inbound TCP segments that could not be processed via fast path
  let ``TCP inbound segments not processed via fast path`` =
    { category = CategoryName; counter = "TCP inbound segments not processed via fast path"; instance = None }
  /// TCP inbound segments/sec not processed via fast path: Rate of inbound TCP segments that could not be processed via fast path
  let ``TCP inbound segments/sec not processed via fast path`` =
    { category = CategoryName; counter = "TCP inbound segments/sec not processed via fast path"; instance = None }

  let allCounters =
    [| ``Denied connect or send requests in low-power mode``
       ``IPv4 NBLs indicated with low-resource flag``
       ``IPv4 NBLs indicated without prevalidation``
       ``IPv4 NBLs treated as non-prevalidated``
       ``IPv4 NBLs/sec indicated with low-resource flag``
       ``IPv4 NBLs/sec indicated without prevalidation``
       ``IPv4 NBLs/sec treated as non-prevalidated``
       ``IPv4 outbound NBLs not processed via fast path``
       ``IPv4 outbound NBLs/sec not processed via fast path``
       ``IPv6 NBLs indicated with low-resource flag``
       ``IPv6 NBLs indicated without prevalidation``
       ``IPv6 NBLs treated as non-prevalidated``
       ``IPv6 NBLs/sec indicated with low-resource flag``
       ``IPv6 NBLs/sec indicated without prevalidation``
       ``IPv6 NBLs/sec treated as non-prevalidated``
       ``IPv6 outbound NBLs not processed via fast path``
       ``IPv6 outbound NBLs/sec not processed via fast path``
       ``TCP connect requests fallen off loopback fast path``
       ``TCP connect requests/sec fallen off loopback fast path``
       ``TCP inbound segments not processed via fast path``
       ``TCP inbound segments/sec not processed via fast path``
    |]

/// TCPv4: The TCP performance object consists of counters that measure the rates at which TCP Segments are sent and received by using the TCP protocol.  It includes counters that monitor the number of TCP connections in each TCP connection state.
///
/// This performance counter does not have instance based counters
module ``TCPv4`` =

  [<Literal>]
  let CategoryName = "TCPv4"

  let PCC = Category.create CategoryName
  /// Connection Failures: Connection Failures is the number of times TCP connections have made a direct transition to the CLOSED state from the SYN-SENT state or the SYN-RCVD state, plus the number of times TCP connections have made a direct transition to the LISTEN state from the SYN-RCVD state.
  let ``Connection Failures`` =
    { category = CategoryName; counter = "Connection Failures"; instance = None }
  /// Connections Active: Connections Active is the number of times TCP connections have made a direct transition to the SYN-SENT state from the CLOSED state. In other words, it shows a number of connections which are initiated by the local computer. The value is a cumulative total.
  let ``Connections Active`` =
    { category = CategoryName; counter = "Connections Active"; instance = None }
  /// Connections Established: Connections Established is the number of TCP connections for which the current state is either ESTABLISHED or CLOSE-WAIT.
  let ``Connections Established`` =
    { category = CategoryName; counter = "Connections Established"; instance = None }
  /// Connections Passive: Connections Passive is the number of times TCP connections have made a direct transition to the SYN-RCVD state from the LISTEN state. In other words, it shows a number of connections to the local computer, which are initiated by remote computers. The value is a cumulative total.
  let ``Connections Passive`` =
    { category = CategoryName; counter = "Connections Passive"; instance = None }
  /// Connections Reset: Connections Reset is the number of times TCP connections have made a direct transition to the CLOSED state from either the ESTABLISHED state or the CLOSE-WAIT state.
  let ``Connections Reset`` =
    { category = CategoryName; counter = "Connections Reset"; instance = None }
  /// Segments Received/sec: Segments Received/sec is the rate at which segments are received, including those received in error.  This count includes segments received on currently established connections.
  let ``Segments Received/sec`` =
    { category = CategoryName; counter = "Segments Received/sec"; instance = None }
  /// Segments Retransmitted/sec: Segments Retransmitted/sec is the rate at which segments are retransmitted, that is, segments transmitted containing one or more previously transmitted bytes.
  let ``Segments Retransmitted/sec`` =
    { category = CategoryName; counter = "Segments Retransmitted/sec"; instance = None }
  /// Segments Sent/sec: Segments Sent/sec is the rate at which segments are sent, including those on current connections, but excluding those containing only retransmitted bytes.
  let ``Segments Sent/sec`` =
    { category = CategoryName; counter = "Segments Sent/sec"; instance = None }
  /// Segments/sec: Segments/sec is the rate at which TCP segments are sent or received using the TCP protocol.
  let ``Segments/sec`` =
    { category = CategoryName; counter = "Segments/sec"; instance = None }

  let allCounters =
    [| ``Connection Failures``
       ``Connections Active``
       ``Connections Established``
       ``Connections Passive``
       ``Connections Reset``
       ``Segments Received/sec``
       ``Segments Retransmitted/sec``
       ``Segments Sent/sec``
       ``Segments/sec``
    |]

/// TCPv6: The TCP performance object consists of counters that measure the rates at which TCP Segments are sent and received by using the TCP protocol.  It includes counters that monitor the number of TCP connections in each TCP connection state.
///
/// This performance counter does not have instance based counters
module ``TCPv6`` =

  [<Literal>]
  let CategoryName = "TCPv6"

  let PCC = Category.create CategoryName
  /// Connection Failures: Connection Failures is the number of times TCP connections have made a direct transition to the CLOSED state from the SYN-SENT state or the SYN-RCVD state, plus the number of times TCP connections have made a direct transition to the LISTEN state from the SYN-RCVD state.
  let ``Connection Failures`` =
    { category = CategoryName; counter = "Connection Failures"; instance = None }
  /// Connections Active: Connections Active is the number of times TCP connections have made a direct transition to the SYN-SENT state from the CLOSED state. In other words, it shows a number of connections which are initiated by the local computer. The value is a cumulative total.
  let ``Connections Active`` =
    { category = CategoryName; counter = "Connections Active"; instance = None }
  /// Connections Established: Connections Established is the number of TCP connections for which the current state is either ESTABLISHED or CLOSE-WAIT.
  let ``Connections Established`` =
    { category = CategoryName; counter = "Connections Established"; instance = None }
  /// Connections Passive: Connections Passive is the number of times TCP connections have made a direct transition to the SYN-RCVD state from the LISTEN state. In other words, it shows a number of connections to the local computer, which are initiated by remote computers. The value is a cumulative total.
  let ``Connections Passive`` =
    { category = CategoryName; counter = "Connections Passive"; instance = None }
  /// Connections Reset: Connections Reset is the number of times TCP connections have made a direct transition to the CLOSED state from either the ESTABLISHED state or the CLOSE-WAIT state.
  let ``Connections Reset`` =
    { category = CategoryName; counter = "Connections Reset"; instance = None }
  /// Segments Received/sec: Segments Received/sec is the rate at which segments are received, including those received in error.  This count includes segments received on currently established connections.
  let ``Segments Received/sec`` =
    { category = CategoryName; counter = "Segments Received/sec"; instance = None }
  /// Segments Retransmitted/sec: Segments Retransmitted/sec is the rate at which segments are retransmitted, that is, segments transmitted containing one or more previously transmitted bytes.
  let ``Segments Retransmitted/sec`` =
    { category = CategoryName; counter = "Segments Retransmitted/sec"; instance = None }
  /// Segments Sent/sec: Segments Sent/sec is the rate at which segments are sent, including those on current connections, but excluding those containing only retransmitted bytes.
  let ``Segments Sent/sec`` =
    { category = CategoryName; counter = "Segments Sent/sec"; instance = None }
  /// Segments/sec: Segments/sec is the rate at which TCP segments are sent or received using the TCP protocol.
  let ``Segments/sec`` =
    { category = CategoryName; counter = "Segments/sec"; instance = None }

  let allCounters =
    [| ``Connection Failures``
       ``Connections Active``
       ``Connections Established``
       ``Connections Passive``
       ``Connections Reset``
       ``Segments Received/sec``
       ``Segments Retransmitted/sec``
       ``Segments Sent/sec``
       ``Segments/sec``
    |]

/// Telephony: The Telephony System
///
/// This performance counter does not have instance based counters
module ``Telephony`` =

  [<Literal>]
  let CategoryName = "Telephony"

  let PCC = Category.create CategoryName
  /// Active Lines: The number of telephone lines serviced by this computer that are currently active.
  let ``Active Lines`` =
    { category = CategoryName; counter = "Active Lines"; instance = None }
  /// Active Telephones: The number of telephone devices that are currently being monitored.
  let ``Active Telephones`` =
    { category = CategoryName; counter = "Active Telephones"; instance = None }
  /// Client Apps: The number of applications that are currently using telephony services.
  let ``Client Apps`` =
    { category = CategoryName; counter = "Client Apps"; instance = None }
  /// Current Incoming Calls: Current incoming calls being serviced by this computer.
  let ``Current Incoming Calls`` =
    { category = CategoryName; counter = "Current Incoming Calls"; instance = None }
  /// Current Outgoing Calls: Current outgoing calls being serviced by this computer.
  let ``Current Outgoing Calls`` =
    { category = CategoryName; counter = "Current Outgoing Calls"; instance = None }
  /// Incoming Calls/sec: The rate of incoming calls answered by this computer.
  let ``Incoming Calls/sec`` =
    { category = CategoryName; counter = "Incoming Calls/sec"; instance = None }
  /// Lines: The number of telephone lines serviced by this computer.
  let ``Lines`` =
    { category = CategoryName; counter = "Lines"; instance = None }
  /// Outgoing Calls/sec: The rate of outgoing calls made by this computer.
  let ``Outgoing Calls/sec`` =
    { category = CategoryName; counter = "Outgoing Calls/sec"; instance = None }
  /// Telephone Devices: The number of telephone devices serviced by this computer.
  let ``Telephone Devices`` =
    { category = CategoryName; counter = "Telephone Devices"; instance = None }

  let allCounters =
    [| ``Active Lines``
       ``Active Telephones``
       ``Client Apps``
       ``Current Incoming Calls``
       ``Current Outgoing Calls``
       ``Incoming Calls/sec``
       ``Lines``
       ``Outgoing Calls/sec``
       ``Telephone Devices``
    |]

/// Teredo Client: Statistics of Teredo client.
///
/// This performance counter does not have non-instance based counters
module ``Teredo Client`` =

  [<Literal>]
  let CategoryName = "Teredo Client"

  let PCC = Category.create CategoryName
  /// In - Teredo Bubble: Total bubble packets received by the Teredo client.
  let ``In - Teredo Bubble`` instance =
    { category = CategoryName; counter = "In - Teredo Bubble"; instance = instance }
  /// In - Teredo Data: Total data packets received by the Teredo client.
  let ``In - Teredo Data`` instance =
    { category = CategoryName; counter = "In - Teredo Data"; instance = instance }
  /// In - Teredo Data Kernel Mode: Total data packets received by the Teredo client in kernel mode.
  let ``In - Teredo Data Kernel Mode`` instance =
    { category = CategoryName; counter = "In - Teredo Data Kernel Mode"; instance = instance }
  /// In - Teredo Data User Mode: Total data packets received by the Teredo client in user mode.
  let ``In - Teredo Data User Mode`` instance =
    { category = CategoryName; counter = "In - Teredo Data User Mode"; instance = instance }
  /// In - Teredo Invalid: Total error packets received by the Teredo client.
  let ``In - Teredo Invalid`` instance =
    { category = CategoryName; counter = "In - Teredo Invalid"; instance = instance }
  /// In - Teredo Router Advertisement: Total Router Advertisement packets received by the Teredo client.
  let ``In - Teredo Router Advertisement`` instance =
    { category = CategoryName; counter = "In - Teredo Router Advertisement"; instance = instance }
  /// Out - Teredo Bubble: Total bubble packets sent by the Teredo client.
  let ``Out - Teredo Bubble`` instance =
    { category = CategoryName; counter = "Out - Teredo Bubble"; instance = instance }
  /// Out - Teredo Data: Total data packets sent by the Teredo client.
  let ``Out - Teredo Data`` instance =
    { category = CategoryName; counter = "Out - Teredo Data"; instance = instance }
  /// Out - Teredo Data Kernel Mode: Total data packets sent by the Teredo client in kernel mode.
  let ``Out - Teredo Data Kernel Mode`` instance =
    { category = CategoryName; counter = "Out - Teredo Data Kernel Mode"; instance = instance }
  /// Out - Teredo Data User Mode: Total data packets sent by the Teredo client in user mode.
  let ``Out - Teredo Data User Mode`` instance =
    { category = CategoryName; counter = "Out - Teredo Data User Mode"; instance = instance }
  /// Out - Teredo Router Solicitation: Total Router Solicitation packets sent by the Teredo client.
  let ``Out - Teredo Router Solicitation`` instance =
    { category = CategoryName; counter = "Out - Teredo Router Solicitation"; instance = instance }

  let allCounters =
    [| ``In - Teredo Bubble``
       ``In - Teredo Data``
       ``In - Teredo Data Kernel Mode``
       ``In - Teredo Data User Mode``
       ``In - Teredo Invalid``
       ``In - Teredo Router Advertisement``
       ``Out - Teredo Bubble``
       ``Out - Teredo Data``
       ``Out - Teredo Data Kernel Mode``
       ``Out - Teredo Data User Mode``
       ``Out - Teredo Router Solicitation``
    |]

/// Teredo Relay: Statistics of Teredo relay hosted on this machine.
///
/// This performance counter does not have non-instance based counters
module ``Teredo Relay`` =

  [<Literal>]
  let CategoryName = "Teredo Relay"

  let PCC = Category.create CategoryName
  /// In - Teredo Relay Error Packets: Destination Error: Total error packets( destination error) received by the Teredo relay.
  let ``In - Teredo Relay Error Packets: Destination Error`` instance =
    { category = CategoryName; counter = "In - Teredo Relay Error Packets: Destination Error"; instance = instance }
  /// In - Teredo Relay Error Packets: Header Error: Total error packets( header error) received by the Teredo relay.
  let ``In - Teredo Relay Error Packets: Header Error`` instance =
    { category = CategoryName; counter = "In - Teredo Relay Error Packets: Header Error"; instance = instance }
  /// In - Teredo Relay Error Packets: Source Error: Total error packets( source error) received by the Teredo relay.
  let ``In - Teredo Relay Error Packets: Source Error`` instance =
    { category = CategoryName; counter = "In - Teredo Relay Error Packets: Source Error"; instance = instance }
  /// In - Teredo Relay Error Packets: Total: Total error packets received by the Teredo relay.
  let ``In - Teredo Relay Error Packets: Total`` instance =
    { category = CategoryName; counter = "In - Teredo Relay Error Packets: Total"; instance = instance }
  /// In - Teredo Relay Success Packets: Bubbles: Total bubbles received by the Teredo relay.
  let ``In - Teredo Relay Success Packets: Bubbles`` instance =
    { category = CategoryName; counter = "In - Teredo Relay Success Packets: Bubbles"; instance = instance }
  /// In - Teredo Relay Success Packets: Data Packets: Total data packets received by the Teredo relay.
  let ``In - Teredo Relay Success Packets: Data Packets`` instance =
    { category = CategoryName; counter = "In - Teredo Relay Success Packets: Data Packets"; instance = instance }
  /// In - Teredo Relay Success Packets: Data Packets Kernel Mode: Total data packets received by the Teredo relay in kernel mode.
  let ``In - Teredo Relay Success Packets: Data Packets Kernel Mode`` instance =
    { category = CategoryName; counter = "In - Teredo Relay Success Packets: Data Packets Kernel Mode"; instance = instance }
  /// In - Teredo Relay Success Packets: Data Packets User Mode: Total data packets received by the Teredo relay in user mode.
  let ``In - Teredo Relay Success Packets: Data Packets User Mode`` instance =
    { category = CategoryName; counter = "In - Teredo Relay Success Packets: Data Packets User Mode"; instance = instance }
  /// In - Teredo Relay Success Packets: Total: Total valid packets received by the Teredo relay.
  let ``In - Teredo Relay Success Packets: Total`` instance =
    { category = CategoryName; counter = "In - Teredo Relay Success Packets: Total"; instance = instance }
  /// In - Teredo Relay Total Packets: Success + Error: Total packets received by the Teredo relay.
  let ``In - Teredo Relay Total Packets: Success + Error`` instance =
    { category = CategoryName; counter = "In - Teredo Relay Total Packets: Success + Error"; instance = instance }
  /// In - Teredo Relay Total Packets: Success + Error / sec: Rate of total packets received by the Teredo relay.
  let ``In - Teredo Relay Total Packets: Success + Error / sec`` instance =
    { category = CategoryName; counter = "In - Teredo Relay Total Packets: Success + Error / sec"; instance = instance }
  /// Out - Teredo Relay Error Packets: Total packets failed to be sent by the Teredo relay.
  let ``Out - Teredo Relay Error Packets`` instance =
    { category = CategoryName; counter = "Out - Teredo Relay Error Packets"; instance = instance }
  /// Out - Teredo Relay Error Packets: Destination Error: Total packets failed( destination error) to be sent by the Teredo relay.
  let ``Out - Teredo Relay Error Packets: Destination Error`` instance =
    { category = CategoryName; counter = "Out - Teredo Relay Error Packets: Destination Error"; instance = instance }
  /// Out - Teredo Relay Error Packets: Header Error: Total packets failed( header error) to be sent by the Teredo relay.
  let ``Out - Teredo Relay Error Packets: Header Error`` instance =
    { category = CategoryName; counter = "Out - Teredo Relay Error Packets: Header Error"; instance = instance }
  /// Out - Teredo Relay Error Packets: Source Error: Total packets failed( source error) to be sent by the Teredo relay.
  let ``Out - Teredo Relay Error Packets: Source Error`` instance =
    { category = CategoryName; counter = "Out - Teredo Relay Error Packets: Source Error"; instance = instance }
  /// Out - Teredo Relay Success Packets: Total packets successfully sent by the Teredo relay.
  let ``Out - Teredo Relay Success Packets`` instance =
    { category = CategoryName; counter = "Out - Teredo Relay Success Packets"; instance = instance }
  /// Out - Teredo Relay Success Packets: Bubbles: Total bubbles sent by the Teredo relay.
  let ``Out - Teredo Relay Success Packets: Bubbles`` instance =
    { category = CategoryName; counter = "Out - Teredo Relay Success Packets: Bubbles"; instance = instance }
  /// Out - Teredo Relay Success Packets: Data Packets: Total data packets sent by the Teredo relay.
  let ``Out - Teredo Relay Success Packets: Data Packets`` instance =
    { category = CategoryName; counter = "Out - Teredo Relay Success Packets: Data Packets"; instance = instance }
  /// Out - Teredo Relay Success Packets: Data Packets Kernel Mode: Total data packets sent by the Teredo relay in kernel mode.
  let ``Out - Teredo Relay Success Packets: Data Packets Kernel Mode`` instance =
    { category = CategoryName; counter = "Out - Teredo Relay Success Packets: Data Packets Kernel Mode"; instance = instance }
  /// Out - Teredo Relay Success Packets: Data Packets User Mode: Total data packets sent by the Teredo relay in user mode.
  let ``Out - Teredo Relay Success Packets: Data Packets User Mode`` instance =
    { category = CategoryName; counter = "Out - Teredo Relay Success Packets: Data Packets User Mode"; instance = instance }
  /// Out - Teredo Relay Total Packets: Success + Error: Total packets sent by the Teredo relay.
  let ``Out - Teredo Relay Total Packets: Success + Error`` instance =
    { category = CategoryName; counter = "Out - Teredo Relay Total Packets: Success + Error"; instance = instance }
  /// Out - Teredo Relay Total Packets: Success + Error / sec: Rate of total packets sent by the Teredo relay.
  let ``Out - Teredo Relay Total Packets: Success + Error / sec`` instance =
    { category = CategoryName; counter = "Out - Teredo Relay Total Packets: Success + Error / sec"; instance = instance }

  let allCounters =
    [| ``In - Teredo Relay Error Packets: Destination Error``
       ``In - Teredo Relay Error Packets: Header Error``
       ``In - Teredo Relay Error Packets: Source Error``
       ``In - Teredo Relay Error Packets: Total``
       ``In - Teredo Relay Success Packets: Bubbles``
       ``In - Teredo Relay Success Packets: Data Packets``
       ``In - Teredo Relay Success Packets: Data Packets Kernel Mode``
       ``In - Teredo Relay Success Packets: Data Packets User Mode``
       ``In - Teredo Relay Success Packets: Total``
       ``In - Teredo Relay Total Packets: Success + Error``
       ``In - Teredo Relay Total Packets: Success + Error / sec``
       ``Out - Teredo Relay Error Packets``
       ``Out - Teredo Relay Error Packets: Destination Error``
       ``Out - Teredo Relay Error Packets: Header Error``
       ``Out - Teredo Relay Error Packets: Source Error``
       ``Out - Teredo Relay Success Packets``
       ``Out - Teredo Relay Success Packets: Bubbles``
       ``Out - Teredo Relay Success Packets: Data Packets``
       ``Out - Teredo Relay Success Packets: Data Packets Kernel Mode``
       ``Out - Teredo Relay Success Packets: Data Packets User Mode``
       ``Out - Teredo Relay Total Packets: Success + Error``
       ``Out - Teredo Relay Total Packets: Success + Error / sec``
    |]

/// Teredo Server: Statistics of Teredo server hosted on this machine.
///
/// This performance counter does not have non-instance based counters
module ``Teredo Server`` =

  [<Literal>]
  let CategoryName = "Teredo Server"

  let PCC = Category.create CategoryName
  /// In - Teredo Server Error Packets: Authentication Error: Total error packets( authentication error) received by the Teredo server.
  let ``In - Teredo Server Error Packets: Authentication Error`` instance =
    { category = CategoryName; counter = "In - Teredo Server Error Packets: Authentication Error"; instance = instance }
  /// In - Teredo Server Error Packets: Destination Error: Total error packets( destination error) received by the Teredo server.
  let ``In - Teredo Server Error Packets: Destination Error`` instance =
    { category = CategoryName; counter = "In - Teredo Server Error Packets: Destination Error"; instance = instance }
  /// In - Teredo Server Error Packets: Header Error: Total error packets( header error) received by the Teredo server.
  let ``In - Teredo Server Error Packets: Header Error`` instance =
    { category = CategoryName; counter = "In - Teredo Server Error Packets: Header Error"; instance = instance }
  /// In - Teredo Server Error Packets: Source Error: Total error packets( source error) received by the Teredo server.
  let ``In - Teredo Server Error Packets: Source Error`` instance =
    { category = CategoryName; counter = "In - Teredo Server Error Packets: Source Error"; instance = instance }
  /// In - Teredo Server Error Packets: Total: Total error packets received by the Teredo server.
  let ``In - Teredo Server Error Packets: Total`` instance =
    { category = CategoryName; counter = "In - Teredo Server Error Packets: Total"; instance = instance }
  /// In - Teredo Server Success Packets: Bubbles: Total bubbles received by the Teredo server.
  let ``In - Teredo Server Success Packets: Bubbles`` instance =
    { category = CategoryName; counter = "In - Teredo Server Success Packets: Bubbles"; instance = instance }
  /// In - Teredo Server Success Packets: Echo: Total echo packets received by the Teredo server.
  let ``In - Teredo Server Success Packets: Echo`` instance =
    { category = CategoryName; counter = "In - Teredo Server Success Packets: Echo"; instance = instance }
  /// In - Teredo Server Success Packets: RS-Primary: Total Router Solicitations received by the primary server.
  let ``In - Teredo Server Success Packets: RS-Primary`` instance =
    { category = CategoryName; counter = "In - Teredo Server Success Packets: RS-Primary"; instance = instance }
  /// In - Teredo Server Success Packets: RS-Secondary: Total Router Solicitations received by the secondary server
  let ``In - Teredo Server Success Packets: RS-Secondary`` instance =
    { category = CategoryName; counter = "In - Teredo Server Success Packets: RS-Secondary"; instance = instance }
  /// In - Teredo Server Success Packets: Total: Total valid packets received by the Teredo server.
  let ``In - Teredo Server Success Packets: Total`` instance =
    { category = CategoryName; counter = "In - Teredo Server Success Packets: Total"; instance = instance }
  /// In - Teredo Server Total Packets: Success + Error: Total packets received by the Teredo server.
  let ``In - Teredo Server Total Packets: Success + Error`` instance =
    { category = CategoryName; counter = "In - Teredo Server Total Packets: Success + Error"; instance = instance }
  /// In - Teredo Server Total Packets: Success + Error / sec: Rate of total packets received by the Teredo server.
  let ``In - Teredo Server Total Packets: Success + Error / sec`` instance =
    { category = CategoryName; counter = "In - Teredo Server Total Packets: Success + Error / sec"; instance = instance }
  /// Out - Teredo Server: RA-Primary: Total Router Advertisements sent by the primary server.
  let ``Out - Teredo Server: RA-Primary`` instance =
    { category = CategoryName; counter = "Out - Teredo Server: RA-Primary"; instance = instance }
  /// Out - Teredo Server: RA-Secondary : Total Router Advertisements sent by the secondary server.
  let ``Out - Teredo Server: RA-Secondary `` instance =
    { category = CategoryName; counter = "Out - Teredo Server: RA-Secondary "; instance = instance }

  let allCounters =
    [| ``In - Teredo Server Error Packets: Authentication Error``
       ``In - Teredo Server Error Packets: Destination Error``
       ``In - Teredo Server Error Packets: Header Error``
       ``In - Teredo Server Error Packets: Source Error``
       ``In - Teredo Server Error Packets: Total``
       ``In - Teredo Server Success Packets: Bubbles``
       ``In - Teredo Server Success Packets: Echo``
       ``In - Teredo Server Success Packets: RS-Primary``
       ``In - Teredo Server Success Packets: RS-Secondary``
       ``In - Teredo Server Success Packets: Total``
       ``In - Teredo Server Total Packets: Success + Error``
       ``In - Teredo Server Total Packets: Success + Error / sec``
       ``Out - Teredo Server: RA-Primary``
       ``Out - Teredo Server: RA-Secondary ``
    |]

/// Terminal Services: Terminal Services Summary Information
///
/// This performance counter does not have instance based counters
module ``Terminal Services`` =

  [<Literal>]
  let CategoryName = "Terminal Services"

  let PCC = Category.create CategoryName
  /// Active Sessions: Number of active Terminal Services sessions
  let ``Active Sessions`` =
    { category = CategoryName; counter = "Active Sessions"; instance = None }
  /// Inactive Sessions: Number of inactive Terminal Services sessions
  let ``Inactive Sessions`` =
    { category = CategoryName; counter = "Inactive Sessions"; instance = None }
  /// Total Sessions: Total number Terminal services sessions
  let ``Total Sessions`` =
    { category = CategoryName; counter = "Total Sessions"; instance = None }

  let allCounters =
    [| ``Active Sessions``
       ``Inactive Sessions``
       ``Total Sessions``
    |]

/// Terminal Services Session: Terminal Services per-session resource monitoring.
///
/// This performance counter does not have non-instance based counters
module ``Terminal Services Session`` =

  [<Literal>]
  let CategoryName = "Terminal Services Session"

  let PCC = Category.create CategoryName
  /// % Privileged Time: % Privileged Time is the percentage of elapsed time that the process threads spent executing code in privileged mode. When a Windows system service is called, the service will often run in privileged mode to gain access to system-private data. Such data is protected from access by threads executing in user mode. Calls to the system can be explicit or implicit, such as page faults or interrupts. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.
  let ``% Privileged Time`` instance =
    { category = CategoryName; counter = "% Privileged Time"; instance = instance }
  /// % Processor Time: % Processor Time is the percentage of elapsed time that all of process threads used the processor to execution instructions. An instruction is the basic unit of execution in a computer, a thread is the object that executes instructions, and a process is the object created when a program is run. Code executed to handle some hardware interrupts and trap conditions are included in this count.
  let ``% Processor Time`` instance =
    { category = CategoryName; counter = "% Processor Time"; instance = instance }
  /// % User Time: % User Time is the percentage of elapsed time that the process threads spent executing code in user mode. Applications, environment subsystems, and integral subsystems execute in user mode. Code executing in user mode cannot damage the integrity of the Windows executive, kernel, and device drivers. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.
  let ``% User Time`` instance =
    { category = CategoryName; counter = "% User Time"; instance = instance }
  /// Handle Count: The total number of handles currently open by this process. This number is equal to the sum of the handles currently open by each thread in this process.
  let ``Handle Count`` instance =
    { category = CategoryName; counter = "Handle Count"; instance = instance }
  /// Page Faults/sec: Page Faults/sec is the rate at which page faults by the threads executing in this process are occurring.  A page fault occurs when a thread refers to a virtual memory page that is not in its working set in main memory. This may not cause the page to be fetched from disk if it is on the standby list and hence already in main memory, or if it is in use by another process with whom the page is shared.
  let ``Page Faults/sec`` instance =
    { category = CategoryName; counter = "Page Faults/sec"; instance = instance }
  /// Page File Bytes: Page File Bytes is the current amount of virtual memory, in bytes, that this process has reserved for use in the paging file(s). Paging files are used to store pages of memory used by the process that are not contained in other files. Paging files are shared by all processes, and the lack of space in paging files can prevent other processes from allocating memory. If there is no paging file, this counter reflects the current amount of virtual memory that the process has reserved for use in physical memory.
  let ``Page File Bytes`` instance =
    { category = CategoryName; counter = "Page File Bytes"; instance = instance }
  /// Page File Bytes Peak: Page File Bytes Peak is the maximum amount of virtual memory, in bytes, that this process has reserved for use in the paging file(s). Paging files are used to store pages of memory used by the process that are not contained in other files.  Paging files are shared by all processes, and the lack of space in paging files can prevent other processes from allocating memory. If there is no paging file, this counter reflects the maximum amount of virtual memory that the process has reserved for use in physical memory.
  let ``Page File Bytes Peak`` instance =
    { category = CategoryName; counter = "Page File Bytes Peak"; instance = instance }
  /// Pool Nonpaged Bytes: Pool Nonpaged Bytes is the size, in bytes, of the nonpaged pool, an area of the system virtual memory that is used for objects that cannot be written to disk, but must remain in physical memory as long as they are allocated.  Memory\\Pool Nonpaged Bytes is calculated differently than Process\\Pool Nonpaged Bytes, so it might not equal Process(_Total)\\Pool Nonpaged Bytes.  This counter displays the last observed value only; it is not an average.
  let ``Pool Nonpaged Bytes`` instance =
    { category = CategoryName; counter = "Pool Nonpaged Bytes"; instance = instance }
  /// Pool Paged Bytes: Pool Paged Bytes is the size, in bytes, of the paged pool, an area of the system virtual memory that is used for objects that can be written to disk when they are not being used.  Memory\\Pool Paged Bytes is calculated differently than Process\\Pool Paged Bytes, so it might not equal Process(_Total)\\Pool Paged Bytes. This counter displays the last observed value only; it is not an average.
  let ``Pool Paged Bytes`` instance =
    { category = CategoryName; counter = "Pool Paged Bytes"; instance = instance }
  /// Private Bytes: Private Bytes is the current size, in bytes, of memory that this process has allocated that cannot be shared with other processes.
  let ``Private Bytes`` instance =
    { category = CategoryName; counter = "Private Bytes"; instance = instance }
  /// Thread Count: The number of threads currently active in this process. An instruction is the basic unit of execution in a processor, and a thread is the object that executes instructions. Every running process has at least one thread.
  let ``Thread Count`` instance =
    { category = CategoryName; counter = "Thread Count"; instance = instance }
  /// Virtual Bytes: Virtual Bytes is the current size, in bytes, of the virtual address space the process is using. Use of virtual address space does not necessarily imply corresponding use of either disk or main memory pages. Virtual space is finite, and the process can limit its ability to load libraries.
  let ``Virtual Bytes`` instance =
    { category = CategoryName; counter = "Virtual Bytes"; instance = instance }
  /// Virtual Bytes Peak: Virtual Bytes Peak is the maximum size, in bytes, of virtual address space the process has used at any one time. Use of virtual address space does not necessarily imply corresponding use of either disk or main memory pages. However, virtual space is finite, and the process might limit its ability to load libraries.
  let ``Virtual Bytes Peak`` instance =
    { category = CategoryName; counter = "Virtual Bytes Peak"; instance = instance }
  /// Working Set: Working Set is the current size, in bytes, of the Working Set of this process. The Working Set is the set of memory pages touched recently by the threads in the process. If free memory in the computer is above a threshold, pages are left in the Working Set of a process even if they are not in use.  When free memory falls below a threshold, pages are trimmed from Working Sets. If they are needed they will then be soft-faulted back into the Working Set before leaving main memory.
  let ``Working Set`` instance =
    { category = CategoryName; counter = "Working Set"; instance = instance }
  /// Working Set Peak: Working Set Peak is the maximum size, in bytes, of the Working Set of this process at any point in time. The Working Set is the set of memory pages touched recently by the threads in the process. If free memory in the computer is above a threshold, pages are left in the Working Set of a process even if they are not in use. When free memory falls below a threshold, pages are trimmed from Working Sets. If they are needed they will then be soft-faulted back into the Working Set before they leave main memory.
  let ``Working Set Peak`` instance =
    { category = CategoryName; counter = "Working Set Peak"; instance = instance }

  let allCounters =
    [| ``% Privileged Time``
       ``% Processor Time``
       ``% User Time``
       ``Handle Count``
       ``Page Faults/sec``
       ``Page File Bytes``
       ``Page File Bytes Peak``
       ``Pool Nonpaged Bytes``
       ``Pool Paged Bytes``
       ``Private Bytes``
       ``Thread Count``
       ``Virtual Bytes``
       ``Virtual Bytes Peak``
       ``Working Set``
       ``Working Set Peak``
    |]

/// Thermal Zone Information: The Thermal Zone Information performance counter set consists of counters that measure aspects of each thermal zone in the system.
///
/// This performance counter does not have non-instance based counters
module ``Thermal Zone Information`` =

  [<Literal>]
  let CategoryName = "Thermal Zone Information"

  let PCC = Category.create CategoryName
  /// % Passive Limit: % Passive Limit is the current limit this thermal zone is placing on the devices it controls. A limit of 100% indicates the devices are unconstrained. A limit of 0% indicates the devices are fully constrained.
  let ``% Passive Limit`` instance =
    { category = CategoryName; counter = "% Passive Limit"; instance = instance }
  /// Temperature: Temperature of the thermal zone, in degrees Kelvin.
  let ``Temperature`` instance =
    { category = CategoryName; counter = "Temperature"; instance = instance }
  /// Throttle Reasons: Throttle Reasons indicate reasons why the thermal zone is limiting performance of the devices it controls.
  let ``Throttle Reasons`` instance =
    { category = CategoryName; counter = "Throttle Reasons"; instance = instance }

  let allCounters =
    [| ``% Passive Limit``
       ``Temperature``
       ``Throttle Reasons``
    |]

/// Thread: The Thread performance object consists of counters that measure aspects of thread behavior.  A thread is the basic object that executes instructions on a processor.  All running processes have at least one thread.
///
/// This performance counter does not have non-instance based counters
module ``Thread`` =

  [<Literal>]
  let CategoryName = "Thread"

  let PCC = Category.create CategoryName
  /// % Privileged Time: % Privileged Time is the percentage of elapsed time that the process threads spent executing code in privileged mode.  When a Windows system service in called, the service will often run in privileged mode to gain access to system-private data. Such data is protected from access by threads executing in user mode. Calls to the system can be explicit or implicit, such as page faults or interrupts. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.
  let ``% Privileged Time`` instance =
    { category = CategoryName; counter = "% Privileged Time"; instance = instance }
  /// % Processor Time: % Processor Time is the percentage of elapsed time that all of process threads used the processor to execution instructions. An instruction is the basic unit of execution in a computer, a thread is the object that executes instructions, and a process is the object created when a program is run. Code executed to handle some hardware interrupts and trap conditions are included in this count.
  let ``% Processor Time`` instance =
    { category = CategoryName; counter = "% Processor Time"; instance = instance }
  /// % User Time: % User Time is the percentage of elapsed time that this thread has spent executing code in user mode.  Applications, environment subsystems, and integral subsystems execute in user mode.  Code executing in user mode cannot damage the integrity of the Windows NT Executive, Kernel, and device drivers.  Unlike some early operating systems, Windows NT uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes.  These subsystem processes provide additional protection.  Therefore, some work done by Windows NT on behalf of your application might appear in other subsystem processes in addition to the privileged time in your process.
  let ``% User Time`` instance =
    { category = CategoryName; counter = "% User Time"; instance = instance }
  /// Context Switches/sec: Context Switches/sec is the rate of switches from one thread to another.  Thread switches can occur either inside of a single process or across processes.  A thread switch can be caused either by one thread asking another for information, or by a thread being preempted by another, higher priority thread becoming ready to run.  Unlike some early operating systems, Windows NT uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes.  These subsystem processes provide additional protection.  Therefore, some work done by Windows NT on behalf of an application  appear in other subsystem processes in addition to the privileged time in the application.  Switching to the subsystem process causes one Context Switch in the application thread.  Switching back causes another Context Switch in the subsystem thread.
  let ``Context Switches/sec`` instance =
    { category = CategoryName; counter = "Context Switches/sec"; instance = instance }
  /// Elapsed Time: The total elapsed time (in seconds) this thread has been running.
  let ``Elapsed Time`` instance =
    { category = CategoryName; counter = "Elapsed Time"; instance = instance }
  /// ID Process: ID Process is the unique identifier of this process. ID Process numbers are reused, so they only identify a process for the lifetime of that process.
  let ``ID Process`` instance =
    { category = CategoryName; counter = "ID Process"; instance = instance }
  /// ID Thread: ID Thread is the unique identifier of this thread.  ID Thread numbers are reused, so they only identify a thread for the lifetime of that thread.
  let ``ID Thread`` instance =
    { category = CategoryName; counter = "ID Thread"; instance = instance }
  /// Priority Base: The current base priority of this thread.  The system can raise the thread's dynamic priority above the base priority if the thread is handling user input, or lower it towards the base priority if the thread becomes compute bound.
  let ``Priority Base`` instance =
    { category = CategoryName; counter = "Priority Base"; instance = instance }
  /// Priority Current: The current dynamic priority of this thread.  The system can raise the thread's dynamic priority above the base priority if the thread is handling user input, or lower it towards the base priority if the thread becomes compute bound.
  let ``Priority Current`` instance =
    { category = CategoryName; counter = "Priority Current"; instance = instance }
  /// Start Address: Starting virtual address for this thread.
  let ``Start Address`` instance =
    { category = CategoryName; counter = "Start Address"; instance = instance }
  /// Thread State: Thread State is the current state of the thread.  It is 0 for Initialized, 1 for Ready, 2 for Running, 3 for Standby, 4 for Terminated, 5 for Wait, 6 for Transition, 7 for Unknown.  A Running thread is using a processor; a Standby thread is about to use one.  A Ready thread wants to use a processor, but is waiting for a processor because none are free.  A thread in Transition is waiting for a resource in order to execute, such as waiting for its execution stack to be paged in from disk.  A Waiting thread has no use for the processor because it is waiting for a peripheral operation to complete or a resource to become free.
  let ``Thread State`` instance =
    { category = CategoryName; counter = "Thread State"; instance = instance }
  /// Thread Wait Reason: Thread Wait Reason is only applicable when the thread is in the Wait state (see Thread State).  It is 0 or 7 when the thread is waiting for the Executive, 1 or 8 for a Free Page, 2 or 9 for a Page In, 3 or 10 for a Pool Allocation, 4 or 11 for an Execution Delay, 5 or 12 for a Suspended condition, 6 or 13 for a User Request, 14 for an Event Pair High, 15 for an Event Pair Low, 16 for an LPC Receive, 17 for an LPC Reply, 18 for Virtual Memory, 19 for a Page Out; 20 and higher are not assigned at the time of this writing.  Event Pairs are used to communicate with protected subsystems (see Context Switches).
  let ``Thread Wait Reason`` instance =
    { category = CategoryName; counter = "Thread Wait Reason"; instance = instance }

  let allCounters =
    [| ``% Privileged Time``
       ``% Processor Time``
       ``% User Time``
       ``Context Switches/sec``
       ``Elapsed Time``
       ``ID Process``
       ``ID Thread``
       ``Priority Base``
       ``Priority Current``
       ``Start Address``
       ``Thread State``
       ``Thread Wait Reason``
    |]

/// UDPv4: The UDP performance object consists of counters that measure the rates at which UDP datagrams are sent and received by using the UDP protocol.  It includes counters that monitor UDP protocol errors.
///
/// This performance counter does not have instance based counters
module ``UDPv4`` =

  [<Literal>]
  let CategoryName = "UDPv4"

  let PCC = Category.create CategoryName
  /// Datagrams No Port/sec: Datagrams No Port/sec is the rate of received UDP datagrams for which there was no application at the destination port.
  let ``Datagrams No Port/sec`` =
    { category = CategoryName; counter = "Datagrams No Port/sec"; instance = None }
  /// Datagrams Received Errors: Datagrams Received Errors is the number of received UDP datagrams that could not be delivered for reasons other than the lack of an application at the destination port.
  let ``Datagrams Received Errors`` =
    { category = CategoryName; counter = "Datagrams Received Errors"; instance = None }
  /// Datagrams Received/sec: Datagrams Received/sec is the rate at which UDP datagrams are delivered to UDP users.
  let ``Datagrams Received/sec`` =
    { category = CategoryName; counter = "Datagrams Received/sec"; instance = None }
  /// Datagrams Sent/sec: Datagrams Sent/sec is the rate at which UDP datagrams are sent from the entity.
  let ``Datagrams Sent/sec`` =
    { category = CategoryName; counter = "Datagrams Sent/sec"; instance = None }
  /// Datagrams/sec: Datagrams/sec is the rate at which UDP datagrams are sent or received by the entity.
  let ``Datagrams/sec`` =
    { category = CategoryName; counter = "Datagrams/sec"; instance = None }

  let allCounters =
    [| ``Datagrams No Port/sec``
       ``Datagrams Received Errors``
       ``Datagrams Received/sec``
       ``Datagrams Sent/sec``
       ``Datagrams/sec``
    |]

/// UDPv6: The UDP performance object consists of counters that measure the rates at which UDP datagrams are sent and received by using the UDP protocol.  It includes counters that monitor UDP protocol errors.
///
/// This performance counter does not have instance based counters
module ``UDPv6`` =

  [<Literal>]
  let CategoryName = "UDPv6"

  let PCC = Category.create CategoryName
  /// Datagrams No Port/sec: Datagrams No Port/sec is the rate of received UDP datagrams for which there was no application at the destination port.
  let ``Datagrams No Port/sec`` =
    { category = CategoryName; counter = "Datagrams No Port/sec"; instance = None }
  /// Datagrams Received Errors: Datagrams Received Errors is the number of received UDP datagrams that could not be delivered for reasons other than the lack of an application at the destination port.
  let ``Datagrams Received Errors`` =
    { category = CategoryName; counter = "Datagrams Received Errors"; instance = None }
  /// Datagrams Received/sec: Datagrams Received/sec is the rate at which UDP datagrams are delivered to UDP users.
  let ``Datagrams Received/sec`` =
    { category = CategoryName; counter = "Datagrams Received/sec"; instance = None }
  /// Datagrams Sent/sec: Datagrams Sent/sec is the rate at which UDP datagrams are sent from the entity.
  let ``Datagrams Sent/sec`` =
    { category = CategoryName; counter = "Datagrams Sent/sec"; instance = None }
  /// Datagrams/sec: Datagrams/sec is the rate at which UDP datagrams are sent or received by the entity.
  let ``Datagrams/sec`` =
    { category = CategoryName; counter = "Datagrams/sec"; instance = None }

  let allCounters =
    [| ``Datagrams No Port/sec``
       ``Datagrams Received Errors``
       ``Datagrams Received/sec``
       ``Datagrams Sent/sec``
       ``Datagrams/sec``
    |]

/// USB: USB I/O Counters
///
/// This performance counter does not have non-instance based counters
module ``USB`` =

  [<Literal>]
  let CategoryName = "USB"

  let PCC = Category.create CategoryName
  /// % Total Bandwidth Used for Interrupt: Displays the percentage of BW reserved for interrupt transfers
  let ``% Total Bandwidth Used for Interrupt`` instance =
    { category = CategoryName; counter = "% Total Bandwidth Used for Interrupt"; instance = instance }
  /// % Total Bandwidth Used for Iso: Displays the percentage of BW reserved for ISO transfers
  let ``% Total Bandwidth Used for Iso`` instance =
    { category = CategoryName; counter = "% Total Bandwidth Used for Iso"; instance = instance }
  /// Avg ms latency for ISO transfers: Avg number of ms between the current frame and the start frame of an ISO transfer when scheduled.  For device instances only.
  let ``Avg ms latency for ISO transfers`` instance =
    { category = CategoryName; counter = "Avg ms latency for ISO transfers"; instance = instance }
  /// Avg. Bytes/Transfer: Displays the average size of all transfer URBs. For device instances only.
  let ``Avg. Bytes/Transfer`` instance =
    { category = CategoryName; counter = "Avg. Bytes/Transfer"; instance = instance }
  /// Bulk Bytes/Sec: Displays the current bulk transfer rate in bytes/sec.
  let ``Bulk Bytes/Sec`` instance =
    { category = CategoryName; counter = "Bulk Bytes/Sec"; instance = instance }
  /// Control Data Bytes/Sec: Displays the current control transfer rate in bytes/sec.
  let ``Control Data Bytes/Sec`` instance =
    { category = CategoryName; counter = "Control Data Bytes/Sec"; instance = instance }
  /// Controller PCI Interrupts/Sec: Displays the rate of PCI interrupt generation by the USB controller. For controller instances only.
  let ``Controller PCI Interrupts/Sec`` instance =
    { category = CategoryName; counter = "Controller PCI Interrupts/Sec"; instance = instance }
  /// Controller WorkSignals/Sec: Displays the current rate Work Signals generated per second by the usbport driver.  For controller instances only.
  let ``Controller WorkSignals/Sec`` instance =
    { category = CategoryName; counter = "Controller WorkSignals/Sec"; instance = instance }
  /// Host Controller Async Cache Flush Count: Incremented each time the controller async cache is flushed.
  let ``Host Controller Async Cache Flush Count`` instance =
    { category = CategoryName; counter = "Host Controller Async Cache Flush Count"; instance = instance }
  /// Host Controller Async Idle: Non-Zero value if the host controller async schedule is not running(idle).
  let ``Host Controller Async Idle`` instance =
    { category = CategoryName; counter = "Host Controller Async Idle"; instance = instance }
  /// Host Controller Idle: Non-zero value if the host controller is not running(idle).
  let ``Host Controller Idle`` instance =
    { category = CategoryName; counter = "Host Controller Idle"; instance = instance }
  /// Host Controller Periodic Cache Flush Count: Incremented each time the controller periodic cache is flushed.
  let ``Host Controller Periodic Cache Flush Count`` instance =
    { category = CategoryName; counter = "Host Controller Periodic Cache Flush Count"; instance = instance }
  /// Host Controller Periodic Idle: Non-Zero if the periodic schedule is not running(idle).
  let ``Host Controller Periodic Idle`` instance =
    { category = CategoryName; counter = "Host Controller Periodic Idle"; instance = instance }
  /// Interrupt Bytes/Sec: Displays the current interrupt transfer rate in bytes/sec.
  let ``Interrupt Bytes/Sec`` instance =
    { category = CategoryName; counter = "Interrupt Bytes/Sec"; instance = instance }
  /// Iso Packet Errors/Sec: Number of ISO packets that are NOT late, but complete with an error. For device instances only.
  let ``Iso Packet Errors/Sec`` instance =
    { category = CategoryName; counter = "Iso Packet Errors/Sec"; instance = instance }
  /// Isochronous Bytes/Sec: Displays the current isochronous transfer rate in bytes/sec.
  let ``Isochronous Bytes/Sec`` instance =
    { category = CategoryName; counter = "Isochronous Bytes/Sec"; instance = instance }
  /// Transfer Errors/Sec: Number of Transfer URBs completing with an error status. For device instances only.
  let ``Transfer Errors/Sec`` instance =
    { category = CategoryName; counter = "Transfer Errors/Sec"; instance = instance }

  let allCounters =
    [| ``% Total Bandwidth Used for Interrupt``
       ``% Total Bandwidth Used for Iso``
       ``Avg ms latency for ISO transfers``
       ``Avg. Bytes/Transfer``
       ``Bulk Bytes/Sec``
       ``Control Data Bytes/Sec``
       ``Controller PCI Interrupts/Sec``
       ``Controller WorkSignals/Sec``
       ``Host Controller Async Cache Flush Count``
       ``Host Controller Async Idle``
       ``Host Controller Idle``
       ``Host Controller Periodic Cache Flush Count``
       ``Host Controller Periodic Idle``
       ``Interrupt Bytes/Sec``
       ``Iso Packet Errors/Sec``
       ``Isochronous Bytes/Sec``
       ``Transfer Errors/Sec``
    |]

/// W3SVC_W3WP: This counter set exposes HTTP request processing related counters for the worker process.
///
/// This performance counter does not have instance based counters
module ``W3SVC_W3WP`` =

  [<Literal>]
  let CategoryName = "W3SVC_W3WP"

  let PCC = Category.create CategoryName
  /// % 401 HTTP Response Sent: -
  let ``% 401 HTTP Response Sent`` instance =
    { category = CategoryName; counter = "% 401 HTTP Response Sent"; instance = instance }
  /// % 403 HTTP Response Sent: -
  let ``% 403 HTTP Response Sent`` instance =
    { category = CategoryName; counter = "% 403 HTTP Response Sent"; instance = instance }
  /// % 404 HTTP Response Sent: -
  let ``% 404 HTTP Response Sent`` instance =
    { category = CategoryName; counter = "% 404 HTTP Response Sent"; instance = instance }
  /// % 500 HTTP Response Sent: -
  let ``% 500 HTTP Response Sent`` instance =
    { category = CategoryName; counter = "% 500 HTTP Response Sent"; instance = instance }
  /// Active Flushed Entries: -
  let ``Active Flushed Entries`` instance =
    { category = CategoryName; counter = "Active Flushed Entries"; instance = instance }
  /// Active Requests: -
  let ``Active Requests`` instance =
    { category = CategoryName; counter = "Active Requests"; instance = instance }
  /// Active Threads Count: -
  let ``Active Threads Count`` instance =
    { category = CategoryName; counter = "Active Threads Count"; instance = instance }
  /// Current File Cache Memory Usage: -
  let ``Current File Cache Memory Usage`` instance =
    { category = CategoryName; counter = "Current File Cache Memory Usage"; instance = instance }
  /// Current Files Cached: -
  let ``Current Files Cached`` instance =
    { category = CategoryName; counter = "Current Files Cached"; instance = instance }
  /// Current Metadata Cached: -
  let ``Current Metadata Cached`` instance =
    { category = CategoryName; counter = "Current Metadata Cached"; instance = instance }
  /// Current URIs Cached: -
  let ``Current URIs Cached`` instance =
    { category = CategoryName; counter = "Current URIs Cached"; instance = instance }
  /// File Cache Flushes: -
  let ``File Cache Flushes`` instance =
    { category = CategoryName; counter = "File Cache Flushes"; instance = instance }
  /// File Cache Hits: -
  let ``File Cache Hits`` instance =
    { category = CategoryName; counter = "File Cache Hits"; instance = instance }
  /// File Cache Hits / sec: -
  let ``File Cache Hits / sec`` instance =
    { category = CategoryName; counter = "File Cache Hits / sec"; instance = instance }
  /// File Cache Misses: -
  let ``File Cache Misses`` instance =
    { category = CategoryName; counter = "File Cache Misses"; instance = instance }
  /// File Cache Misses / sec: -
  let ``File Cache Misses / sec`` instance =
    { category = CategoryName; counter = "File Cache Misses / sec"; instance = instance }
  /// Maximum File Cache Memory Usage: -
  let ``Maximum File Cache Memory Usage`` instance =
    { category = CategoryName; counter = "Maximum File Cache Memory Usage"; instance = instance }
  /// Maximum Threads Count: -
  let ``Maximum Threads Count`` instance =
    { category = CategoryName; counter = "Maximum Threads Count"; instance = instance }
  /// Metadata Cache Flushes: -
  let ``Metadata Cache Flushes`` instance =
    { category = CategoryName; counter = "Metadata Cache Flushes"; instance = instance }
  /// Metadata Cache Hits: -
  let ``Metadata Cache Hits`` instance =
    { category = CategoryName; counter = "Metadata Cache Hits"; instance = instance }
  /// Metadata Cache Hits / sec: -
  let ``Metadata Cache Hits / sec`` instance =
    { category = CategoryName; counter = "Metadata Cache Hits / sec"; instance = instance }
  /// Metadata Cache Misses: -
  let ``Metadata Cache Misses`` instance =
    { category = CategoryName; counter = "Metadata Cache Misses"; instance = instance }
  /// Metadata Cache Misses / sec: -
  let ``Metadata Cache Misses / sec`` instance =
    { category = CategoryName; counter = "Metadata Cache Misses / sec"; instance = instance }
  /// Output Cache Current Flushed Items: -
  let ``Output Cache Current Flushed Items`` instance =
    { category = CategoryName; counter = "Output Cache Current Flushed Items"; instance = instance }
  /// Output Cache Current Items: -
  let ``Output Cache Current Items`` instance =
    { category = CategoryName; counter = "Output Cache Current Items"; instance = instance }
  /// Output Cache Current Memory Usage: -
  let ``Output Cache Current Memory Usage`` instance =
    { category = CategoryName; counter = "Output Cache Current Memory Usage"; instance = instance }
  /// Output Cache Hits / sec: -
  let ``Output Cache Hits / sec`` instance =
    { category = CategoryName; counter = "Output Cache Hits / sec"; instance = instance }
  /// Output Cache Misses / sec: -
  let ``Output Cache Misses / sec`` instance =
    { category = CategoryName; counter = "Output Cache Misses / sec"; instance = instance }
  /// Output Cache Total Flushed Items: -
  let ``Output Cache Total Flushed Items`` instance =
    { category = CategoryName; counter = "Output Cache Total Flushed Items"; instance = instance }
  /// Output Cache Total Flushes: -
  let ``Output Cache Total Flushes`` instance =
    { category = CategoryName; counter = "Output Cache Total Flushes"; instance = instance }
  /// Output Cache Total Hits: -
  let ``Output Cache Total Hits`` instance =
    { category = CategoryName; counter = "Output Cache Total Hits"; instance = instance }
  /// Output Cache Total Misses: -
  let ``Output Cache Total Misses`` instance =
    { category = CategoryName; counter = "Output Cache Total Misses"; instance = instance }
  /// Requests / Sec: -
  let ``Requests / Sec`` instance =
    { category = CategoryName; counter = "Requests / Sec"; instance = instance }
  /// Total Files Cached: -
  let ``Total Files Cached`` instance =
    { category = CategoryName; counter = "Total Files Cached"; instance = instance }
  /// Total Flushed Files: -
  let ``Total Flushed Files`` instance =
    { category = CategoryName; counter = "Total Flushed Files"; instance = instance }
  /// Total Flushed Metadata: -
  let ``Total Flushed Metadata`` instance =
    { category = CategoryName; counter = "Total Flushed Metadata"; instance = instance }
  /// Total Flushed URIs: -
  let ``Total Flushed URIs`` instance =
    { category = CategoryName; counter = "Total Flushed URIs"; instance = instance }
  /// Total HTTP Requests Served: -
  let ``Total HTTP Requests Served`` instance =
    { category = CategoryName; counter = "Total HTTP Requests Served"; instance = instance }
  /// Total Metadata Cached: -
  let ``Total Metadata Cached`` instance =
    { category = CategoryName; counter = "Total Metadata Cached"; instance = instance }
  /// Total Threads: -
  let ``Total Threads`` instance =
    { category = CategoryName; counter = "Total Threads"; instance = instance }
  /// Total URIs Cached: -
  let ``Total URIs Cached`` instance =
    { category = CategoryName; counter = "Total URIs Cached"; instance = instance }
  /// URI Cache Flushes: -
  let ``URI Cache Flushes`` instance =
    { category = CategoryName; counter = "URI Cache Flushes"; instance = instance }
  /// URI Cache Hits: -
  let ``URI Cache Hits`` instance =
    { category = CategoryName; counter = "URI Cache Hits"; instance = instance }
  /// URI Cache Misses: -
  let ``URI Cache Misses`` instance =
    { category = CategoryName; counter = "URI Cache Misses"; instance = instance }
  /// Uri Cache Hits / sec: -
  let ``Uri Cache Hits / sec`` instance =
    { category = CategoryName; counter = "Uri Cache Hits / sec"; instance = instance }
  /// Uri Cache Misses / sec: -
  let ``Uri Cache Misses / sec`` instance =
    { category = CategoryName; counter = "Uri Cache Misses / sec"; instance = instance }
  /// WebSocket Active Requests: -
  let ``WebSocket Active Requests`` instance =
    { category = CategoryName; counter = "WebSocket Active Requests"; instance = instance }
  /// WebSocket Connection Attempts / Sec: -
  let ``WebSocket Connection Attempts / Sec`` instance =
    { category = CategoryName; counter = "WebSocket Connection Attempts / Sec"; instance = instance }
  /// WebSocket Connections Accepted / Sec: -
  let ``WebSocket Connections Accepted / Sec`` instance =
    { category = CategoryName; counter = "WebSocket Connections Accepted / Sec"; instance = instance }
  /// WebSocket Connections Rejected / Sec: -
  let ``WebSocket Connections Rejected / Sec`` instance =
    { category = CategoryName; counter = "WebSocket Connections Rejected / Sec"; instance = instance }

  let allCounters =
    [| ``% 401 HTTP Response Sent``
       ``% 403 HTTP Response Sent``
       ``% 404 HTTP Response Sent``
       ``% 500 HTTP Response Sent``
       ``Active Flushed Entries``
       ``Active Requests``
       ``Active Threads Count``
       ``Current File Cache Memory Usage``
       ``Current Files Cached``
       ``Current Metadata Cached``
       ``Current URIs Cached``
       ``File Cache Flushes``
       ``File Cache Hits``
       ``File Cache Hits / sec``
       ``File Cache Misses``
       ``File Cache Misses / sec``
       ``Maximum File Cache Memory Usage``
       ``Maximum Threads Count``
       ``Metadata Cache Flushes``
       ``Metadata Cache Hits``
       ``Metadata Cache Hits / sec``
       ``Metadata Cache Misses``
       ``Metadata Cache Misses / sec``
       ``Output Cache Current Flushed Items``
       ``Output Cache Current Items``
       ``Output Cache Current Memory Usage``
       ``Output Cache Hits / sec``
       ``Output Cache Misses / sec``
       ``Output Cache Total Flushed Items``
       ``Output Cache Total Flushes``
       ``Output Cache Total Hits``
       ``Output Cache Total Misses``
       ``Requests / Sec``
       ``Total Files Cached``
       ``Total Flushed Files``
       ``Total Flushed Metadata``
       ``Total Flushed URIs``
       ``Total HTTP Requests Served``
       ``Total Metadata Cached``
       ``Total Threads``
       ``Total URIs Cached``
       ``URI Cache Flushes``
       ``URI Cache Hits``
       ``URI Cache Misses``
       ``Uri Cache Hits / sec``
       ``Uri Cache Misses / sec``
       ``WebSocket Active Requests``
       ``WebSocket Connection Attempts / Sec``
       ``WebSocket Connections Accepted / Sec``
       ``WebSocket Connections Rejected / Sec``
    |]

/// WAS_W3WP: This counter set exposes Windows Process Activation Service (WAS) related counters for the worker process.
///
/// This performance counter does not have instance based counters
module ``WAS_W3WP`` =

  [<Literal>]
  let CategoryName = "WAS_W3WP"

  let PCC = Category.create CategoryName
  /// Active Listener Channels: -
  let ``Active Listener Channels`` instance =
    { category = CategoryName; counter = "Active Listener Channels"; instance = instance }
  /// Active Protocol Handlers: -
  let ``Active Protocol Handlers`` instance =
    { category = CategoryName; counter = "Active Protocol Handlers"; instance = instance }
  /// Health Ping Reply Latency: -
  let ``Health Ping Reply Latency`` instance =
    { category = CategoryName; counter = "Health Ping Reply Latency"; instance = instance }
  /// Total Health Pings.: -
  let ``Total Health Pings.`` instance =
    { category = CategoryName; counter = "Total Health Pings."; instance = instance }
  /// Total Messages Sent to WAS: -
  let ``Total Messages Sent to WAS`` instance =
    { category = CategoryName; counter = "Total Messages Sent to WAS"; instance = instance }
  /// Total Requests Served: -
  let ``Total Requests Served`` instance =
    { category = CategoryName; counter = "Total Requests Served"; instance = instance }
  /// Total Runtime Status Queries: -
  let ``Total Runtime Status Queries`` instance =
    { category = CategoryName; counter = "Total Runtime Status Queries"; instance = instance }
  /// Total WAS Messages Received: -
  let ``Total WAS Messages Received`` instance =
    { category = CategoryName; counter = "Total WAS Messages Received"; instance = instance }

  let allCounters =
    [| ``Active Listener Channels``
       ``Active Protocol Handlers``
       ``Health Ping Reply Latency``
       ``Total Health Pings.``
       ``Total Messages Sent to WAS``
       ``Total Requests Served``
       ``Total Runtime Status Queries``
       ``Total WAS Messages Received``
    |]

/// WF (System.Workflow) 4.0.0.0: Windows Workflow Foundation Performance Counters
///
/// This performance counter does not have instance based counters
module ``WF (System_Workflow) 4_0_0_0`` =

  [<Literal>]
  let CategoryName = "WF (System.Workflow) 4.0.0.0"

  let PCC = Category.create CategoryName
  /// Workflows Aborted: -
  let ``Workflows Aborted`` instance =
    { category = CategoryName; counter = "Workflows Aborted"; instance = instance }
  /// Workflows Aborted/sec: -
  let ``Workflows Aborted/sec`` instance =
    { category = CategoryName; counter = "Workflows Aborted/sec"; instance = instance }
  /// Workflows Completed: -
  let ``Workflows Completed`` instance =
    { category = CategoryName; counter = "Workflows Completed"; instance = instance }
  /// Workflows Completed/sec: -
  let ``Workflows Completed/sec`` instance =
    { category = CategoryName; counter = "Workflows Completed/sec"; instance = instance }
  /// Workflows Created: -
  let ``Workflows Created`` instance =
    { category = CategoryName; counter = "Workflows Created"; instance = instance }
  /// Workflows Created/sec: -
  let ``Workflows Created/sec`` instance =
    { category = CategoryName; counter = "Workflows Created/sec"; instance = instance }
  /// Workflows Executing: -
  let ``Workflows Executing`` instance =
    { category = CategoryName; counter = "Workflows Executing"; instance = instance }
  /// Workflows Idle/sec: -
  let ``Workflows Idle/sec`` instance =
    { category = CategoryName; counter = "Workflows Idle/sec"; instance = instance }
  /// Workflows In Memory: -
  let ``Workflows In Memory`` instance =
    { category = CategoryName; counter = "Workflows In Memory"; instance = instance }
  /// Workflows Loaded: -
  let ``Workflows Loaded`` instance =
    { category = CategoryName; counter = "Workflows Loaded"; instance = instance }
  /// Workflows Loaded/sec: -
  let ``Workflows Loaded/sec`` instance =
    { category = CategoryName; counter = "Workflows Loaded/sec"; instance = instance }
  /// Workflows Pending: -
  let ``Workflows Pending`` instance =
    { category = CategoryName; counter = "Workflows Pending"; instance = instance }
  /// Workflows Persisted: -
  let ``Workflows Persisted`` instance =
    { category = CategoryName; counter = "Workflows Persisted"; instance = instance }
  /// Workflows Persisted/sec: -
  let ``Workflows Persisted/sec`` instance =
    { category = CategoryName; counter = "Workflows Persisted/sec"; instance = instance }
  /// Workflows Runnable: -
  let ``Workflows Runnable`` instance =
    { category = CategoryName; counter = "Workflows Runnable"; instance = instance }
  /// Workflows Suspended: -
  let ``Workflows Suspended`` instance =
    { category = CategoryName; counter = "Workflows Suspended"; instance = instance }
  /// Workflows Suspended/sec: -
  let ``Workflows Suspended/sec`` instance =
    { category = CategoryName; counter = "Workflows Suspended/sec"; instance = instance }
  /// Workflows Terminated: -
  let ``Workflows Terminated`` instance =
    { category = CategoryName; counter = "Workflows Terminated"; instance = instance }
  /// Workflows Terminated/sec: -
  let ``Workflows Terminated/sec`` instance =
    { category = CategoryName; counter = "Workflows Terminated/sec"; instance = instance }
  /// Workflows Unloaded: -
  let ``Workflows Unloaded`` instance =
    { category = CategoryName; counter = "Workflows Unloaded"; instance = instance }
  /// Workflows Unloaded/sec: -
  let ``Workflows Unloaded/sec`` instance =
    { category = CategoryName; counter = "Workflows Unloaded/sec"; instance = instance }

  let allCounters =
    [| ``Workflows Aborted``
       ``Workflows Aborted/sec``
       ``Workflows Completed``
       ``Workflows Completed/sec``
       ``Workflows Created``
       ``Workflows Created/sec``
       ``Workflows Executing``
       ``Workflows Idle/sec``
       ``Workflows In Memory``
       ``Workflows Loaded``
       ``Workflows Loaded/sec``
       ``Workflows Pending``
       ``Workflows Persisted``
       ``Workflows Persisted/sec``
       ``Workflows Runnable``
       ``Workflows Suspended``
       ``Workflows Suspended/sec``
       ``Workflows Terminated``
       ``Workflows Terminated/sec``
       ``Workflows Unloaded``
       ``Workflows Unloaded/sec``
    |]

/// WFP: WFP is the set of Windows Filtering Platform counters that do not apply to any specific Internet Protocol version.
///
/// This performance counter does not have instance based counters
module ``WFP`` =

  [<Literal>]
  let CategoryName = "WFP"

  let PCC = Category.create CategoryName
  /// Provider Count: Provider Count is the number of providers registered with the Windows Filtering Platform.
  let ``Provider Count`` =
    { category = CategoryName; counter = "Provider Count"; instance = None }

  let allCounters =
    [| ``Provider Count``

    |]

/// WFPv4: WFPv4 is the set of Windows Filtering Platform counters that apply to traffic and connections over Internet Protocol version 4.
///
/// This performance counter does not have instance based counters
module ``WFPv4`` =

  [<Literal>]
  let CategoryName = "WFPv4"

  let PCC = Category.create CategoryName
  /// Active Inbound Connections: Active Inbound Connections is the number of current inbound connections allowed by the Windows Filtering Platform.
  let ``Active Inbound Connections`` =
    { category = CategoryName; counter = "Active Inbound Connections"; instance = None }
  /// Active Outbound Connections: Active Outbound Connections is the number of current outbound connections allowed by the Windows Filtering Platform.
  let ``Active Outbound Connections`` =
    { category = CategoryName; counter = "Active Outbound Connections"; instance = None }
  /// Allowed Classifies/sec: Allowed Classifies per Second is the rate of Windows Filtering Platform security rule evaluations which allow network activity.
  let ``Allowed Classifies/sec`` =
    { category = CategoryName; counter = "Allowed Classifies/sec"; instance = None }
  /// Blocked Binds: Blocked Binds is the number of network resource assignment requests blocked by the Windows Filtering Platform since the computer was last started.
  let ``Blocked Binds`` =
    { category = CategoryName; counter = "Blocked Binds"; instance = None }
  /// Inbound Connections: Inbound Connections is the number of inbound connections allowed by the Windows Filtering Platform since the computer was last started.
  let ``Inbound Connections`` =
    { category = CategoryName; counter = "Inbound Connections"; instance = None }
  /// Inbound Connections Allowed/sec: Inbound Connections Allowed per Second is the rate at which inbound connections are being allowed by the Windows Filtering Platform.
  let ``Inbound Connections Allowed/sec`` =
    { category = CategoryName; counter = "Inbound Connections Allowed/sec"; instance = None }
  /// Inbound Connections Blocked/sec: Inbound Connections Blocked per Second is the rate at which inbound connections are being blocked by the Windows Filtering Platform.
  let ``Inbound Connections Blocked/sec`` =
    { category = CategoryName; counter = "Inbound Connections Blocked/sec"; instance = None }
  /// Inbound Packets Discarded/sec: Inbound Packets Discarded per Second is the rate at which inbound packets are discarded by the Windows Filtering Platform.
  let ``Inbound Packets Discarded/sec`` =
    { category = CategoryName; counter = "Inbound Packets Discarded/sec"; instance = None }
  /// Outbound Connections: Outbound Connections is the number of outbound connections allowed by the Windows Filtering Platform since the computer was last started.
  let ``Outbound Connections`` =
    { category = CategoryName; counter = "Outbound Connections"; instance = None }
  /// Outbound Connections Allowed/sec: Outbound Connections Allowed per Second is the rate at which outbound connections are being allowed by the Windows Filtering Platform.
  let ``Outbound Connections Allowed/sec`` =
    { category = CategoryName; counter = "Outbound Connections Allowed/sec"; instance = None }
  /// Outbound Connections Blocked/sec: Outbound Connections Blocked per Second is the rate at which outbound connections are being blocked by the Windows Filtering Platform.
  let ``Outbound Connections Blocked/sec`` =
    { category = CategoryName; counter = "Outbound Connections Blocked/sec"; instance = None }
  /// Outbound Packets Discarded/sec: Outbound Packets Discarded per Second is the rate at which outbound packets are discarded by the Windows Filtering Platform.
  let ``Outbound Packets Discarded/sec`` =
    { category = CategoryName; counter = "Outbound Packets Discarded/sec"; instance = None }
  /// Packets Discarded/sec: Packets Discarded per Second is the rate at which the total of inbound and outbound packets are discarded by the Windows Filtering Platform.
  let ``Packets Discarded/sec`` =
    { category = CategoryName; counter = "Packets Discarded/sec"; instance = None }

  let allCounters =
    [| ``Active Inbound Connections``
       ``Active Outbound Connections``
       ``Allowed Classifies/sec``
       ``Blocked Binds``
       ``Inbound Connections``
       ``Inbound Connections Allowed/sec``
       ``Inbound Connections Blocked/sec``
       ``Inbound Packets Discarded/sec``
       ``Outbound Connections``
       ``Outbound Connections Allowed/sec``
       ``Outbound Connections Blocked/sec``
       ``Outbound Packets Discarded/sec``
       ``Packets Discarded/sec``
    |]

/// WFPv6: WFPv6 is the set of Windows Filtering Platform counters that apply to traffic and connections over Internet Protocol version 6.
///
/// This performance counter does not have instance based counters
module ``WFPv6`` =

  [<Literal>]
  let CategoryName = "WFPv6"

  let PCC = Category.create CategoryName
  /// Active Inbound Connections: Active Inbound Connections is the number of current inbound connections allowed by the Windows Filtering Platform.
  let ``Active Inbound Connections`` =
    { category = CategoryName; counter = "Active Inbound Connections"; instance = None }
  /// Active Outbound Connections: Active Outbound Connections is the number of current outbound connections allowed by the Windows Filtering Platform.
  let ``Active Outbound Connections`` =
    { category = CategoryName; counter = "Active Outbound Connections"; instance = None }
  /// Allowed Classifies/sec: Allowed Classifies per Second is the rate of Windows Filtering Platform security rule evaluations which allow network activity.
  let ``Allowed Classifies/sec`` =
    { category = CategoryName; counter = "Allowed Classifies/sec"; instance = None }
  /// Blocked Binds: Blocked Binds is the number of network resource assignment requests blocked by the Windows Filtering Platform since the computer was last started.
  let ``Blocked Binds`` =
    { category = CategoryName; counter = "Blocked Binds"; instance = None }
  /// Inbound Connections: Inbound Connections is the number of inbound connections allowed by the Windows Filtering Platform since the computer was last started.
  let ``Inbound Connections`` =
    { category = CategoryName; counter = "Inbound Connections"; instance = None }
  /// Inbound Connections Allowed/sec: Inbound Connections Allowed per Second is the rate at which inbound connections are being allowed by the Windows Filtering Platform.
  let ``Inbound Connections Allowed/sec`` =
    { category = CategoryName; counter = "Inbound Connections Allowed/sec"; instance = None }
  /// Inbound Connections Blocked/sec: Inbound Connections Blocked per Second is the rate at which inbound connections are being blocked by the Windows Filtering Platform.
  let ``Inbound Connections Blocked/sec`` =
    { category = CategoryName; counter = "Inbound Connections Blocked/sec"; instance = None }
  /// Inbound Packets Discarded/sec: Inbound Packets Discarded per Second is the rate at which inbound packets are discarded by the Windows Filtering Platform.
  let ``Inbound Packets Discarded/sec`` =
    { category = CategoryName; counter = "Inbound Packets Discarded/sec"; instance = None }
  /// Outbound Connections: Outbound Connections is the number of outbound connections allowed by the Windows Filtering Platform since the computer was last started.
  let ``Outbound Connections`` =
    { category = CategoryName; counter = "Outbound Connections"; instance = None }
  /// Outbound Connections Allowed/sec: Outbound Connections Allowed per Second is the rate at which outbound connections are being allowed by the Windows Filtering Platform.
  let ``Outbound Connections Allowed/sec`` =
    { category = CategoryName; counter = "Outbound Connections Allowed/sec"; instance = None }
  /// Outbound Connections Blocked/sec: Outbound Connections Blocked per Second is the rate at which outbound connections are being blocked by the Windows Filtering Platform.
  let ``Outbound Connections Blocked/sec`` =
    { category = CategoryName; counter = "Outbound Connections Blocked/sec"; instance = None }
  /// Outbound Packets Discarded/sec: Outbound Packets Discarded per Second is the rate at which outbound packets are discarded by the Windows Filtering Platform.
  let ``Outbound Packets Discarded/sec`` =
    { category = CategoryName; counter = "Outbound Packets Discarded/sec"; instance = None }
  /// Packets Discarded/sec: Packets Discarded per Second is the rate at which the total of inbound and outbound packets are discarded by the Windows Filtering Platform.
  let ``Packets Discarded/sec`` =
    { category = CategoryName; counter = "Packets Discarded/sec"; instance = None }

  let allCounters =
    [| ``Active Inbound Connections``
       ``Active Outbound Connections``
       ``Allowed Classifies/sec``
       ``Blocked Binds``
       ``Inbound Connections``
       ``Inbound Connections Allowed/sec``
       ``Inbound Connections Blocked/sec``
       ``Inbound Packets Discarded/sec``
       ``Outbound Connections``
       ``Outbound Connections Allowed/sec``
       ``Outbound Connections Blocked/sec``
       ``Outbound Packets Discarded/sec``
       ``Packets Discarded/sec``
    |]

/// WSMan Quota Statistics: Displays quota usage and violation information for WS-Management processes.
///
/// This performance counter does not have non-instance based counters
module ``WSMan Quota Statistics`` =

  [<Literal>]
  let CategoryName = "WSMan Quota Statistics"

  let PCC = Category.create CategoryName
  /// Active Operations: Displays the current number of active operations for all users.
  let ``Active Operations`` instance =
    { category = CategoryName; counter = "Active Operations"; instance = instance }
  /// Active Shells: Displays the current number of active shells for all users.
  let ``Active Shells`` instance =
    { category = CategoryName; counter = "Active Shells"; instance = instance }
  /// Active Users: Displays the current number of active, authorized users.
  let ``Active Users`` instance =
    { category = CategoryName; counter = "Active Users"; instance = instance }
  /// Process ID: Displays the current process ID (PID)
  let ``Process ID`` instance =
    { category = CategoryName; counter = "Process ID"; instance = instance }
  /// System Quota Violations/Second: Displays the number of requests subject to system throttling.
  let ``System Quota Violations/Second`` instance =
    { category = CategoryName; counter = "System Quota Violations/Second"; instance = instance }
  /// Total Requests/Second: Displays the number of approved and rejected requests per second from authorized users.
  let ``Total Requests/Second`` instance =
    { category = CategoryName; counter = "Total Requests/Second"; instance = instance }
  /// User Quota Violations/Second: Displays the number of user quota violations.
  let ``User Quota Violations/Second`` instance =
    { category = CategoryName; counter = "User Quota Violations/Second"; instance = instance }

  let allCounters =
    [| ``Active Operations``
       ``Active Shells``
       ``Active Users``
       ``Process ID``
       ``System Quota Violations/Second``
       ``Total Requests/Second``
       ``User Quota Violations/Second``
    |]

/// Web Service: The Web Service object includes counters specific to the World Wide Web Publishing Service.
///
/// This performance counter does not have non-instance based counters
module ``Web Service`` =

  [<Literal>]
  let CategoryName = "Web Service"

  let PCC = Category.create CategoryName
  /// Anonymous Users/sec: The rate users are making anonymous connections to the Web service.
  let ``Anonymous Users/sec`` instance =
    { category = CategoryName; counter = "Anonymous Users/sec"; instance = instance }
  /// Bytes Received/sec: Bytes Received/sec is the rate that data bytes are received by the Web service.
  let ``Bytes Received/sec`` instance =
    { category = CategoryName; counter = "Bytes Received/sec"; instance = instance }
  /// Bytes Sent/sec: Bytes Sent/sec is the rate data bytes are being sent by the Web service.
  let ``Bytes Sent/sec`` instance =
    { category = CategoryName; counter = "Bytes Sent/sec"; instance = instance }
  /// Bytes Total/sec: Bytes Total/sec is the sum of Bytes Sent/sec and Bytes Received/sec.  This is the total rate of bytes transferred by the Web service.
  let ``Bytes Total/sec`` instance =
    { category = CategoryName; counter = "Bytes Total/sec"; instance = instance }
  /// CGI Requests/sec: The rate CGI requests are received by the Web service.
  let ``CGI Requests/sec`` instance =
    { category = CategoryName; counter = "CGI Requests/sec"; instance = instance }
  /// Connection Attempts/sec: The rate that connections to the Web service are being attempted.
  let ``Connection Attempts/sec`` instance =
    { category = CategoryName; counter = "Connection Attempts/sec"; instance = instance }
  /// Copy Requests/sec: The rate HTTP requests using the COPY method are made.  Copy requests are used for copying files and directories.
  let ``Copy Requests/sec`` instance =
    { category = CategoryName; counter = "Copy Requests/sec"; instance = instance }
  /// Current Anonymous Users: Current Anonymous Users is the number of users who currently have an anonymous connection using the Web service.
  let ``Current Anonymous Users`` instance =
    { category = CategoryName; counter = "Current Anonymous Users"; instance = instance }
  /// Current Blocked Async I/O Requests: Current requests temporarily blocked due to bandwidth throttling settings.
  let ``Current Blocked Async I/O Requests`` instance =
    { category = CategoryName; counter = "Current Blocked Async I/O Requests"; instance = instance }
  /// Current CAL count for SSL connections: This counter is no longer valid. Value will always be zero.
  let ``Current CAL count for SSL connections`` instance =
    { category = CategoryName; counter = "Current CAL count for SSL connections"; instance = instance }
  /// Current CAL count for authenticated users: This counter is no longer valid. Value will always be zero.
  let ``Current CAL count for authenticated users`` instance =
    { category = CategoryName; counter = "Current CAL count for authenticated users"; instance = instance }
  /// Current CGI Requests: Current CGI Requests is the current number of CGI requests being simultaneously processed by the Web service.
  let ``Current CGI Requests`` instance =
    { category = CategoryName; counter = "Current CGI Requests"; instance = instance }
  /// Current Connections: Current Connections is the current number of connections established with the Web service.
  let ``Current Connections`` instance =
    { category = CategoryName; counter = "Current Connections"; instance = instance }
  /// Current ISAPI Extension Requests: Current ISAPI Extension Requests is the current number of ISAPI requests being simultaneously processed by the Web service.
  let ``Current ISAPI Extension Requests`` instance =
    { category = CategoryName; counter = "Current ISAPI Extension Requests"; instance = instance }
  /// Current NonAnonymous Users: Current NonAnonymous Users is the number of users who currently have a non-anonymous connection using the Web service.
  let ``Current NonAnonymous Users`` instance =
    { category = CategoryName; counter = "Current NonAnonymous Users"; instance = instance }
  /// Current blocked bandwidth bytes.: Current bytes temporarily blocked due to bandwidth throttling settings.
  let ``Current blocked bandwidth bytes.`` instance =
    { category = CategoryName; counter = "Current blocked bandwidth bytes."; instance = instance }
  /// Delete Requests/sec: The rate HTTP requests using the DELETE method are made.  Delete requests are generally used for file removals.
  let ``Delete Requests/sec`` instance =
    { category = CategoryName; counter = "Delete Requests/sec"; instance = instance }
  /// Files Received/sec: The rate files are received by the Web service.
  let ``Files Received/sec`` instance =
    { category = CategoryName; counter = "Files Received/sec"; instance = instance }
  /// Files Sent/sec: The rate files are sent by the Web service.
  let ``Files Sent/sec`` instance =
    { category = CategoryName; counter = "Files Sent/sec"; instance = instance }
  /// Files/sec: The rate files are transferred, that is, sent and received by the Web service.
  let ``Files/sec`` instance =
    { category = CategoryName; counter = "Files/sec"; instance = instance }
  /// Get Requests/sec: The rate HTTP requests using the GET method are made.  Get requests are the most common HTTP request.
  let ``Get Requests/sec`` instance =
    { category = CategoryName; counter = "Get Requests/sec"; instance = instance }
  /// Head Requests/sec: The rate HTTP requests using the HEAD method are made.  Head requests generally indicate a client is querying the state of a document they already have to see if it needs to be refreshed.
  let ``Head Requests/sec`` instance =
    { category = CategoryName; counter = "Head Requests/sec"; instance = instance }
  /// ISAPI Extension Requests/sec: The rate that ISAPI Extension requests are received by the Web service.
  let ``ISAPI Extension Requests/sec`` instance =
    { category = CategoryName; counter = "ISAPI Extension Requests/sec"; instance = instance }
  /// Lock Requests/sec: The rate HTTP requests using the LOCK method are made.  Lock requests are used to lock a file for one user so that only that user can modify the file.
  let ``Lock Requests/sec`` instance =
    { category = CategoryName; counter = "Lock Requests/sec"; instance = instance }
  /// Locked Errors/sec: The rate of errors due to requests that couldn't be satisfied by the server because the requested document was locked.  These are generally reported as an HTTP 423 error code to the client.
  let ``Locked Errors/sec`` instance =
    { category = CategoryName; counter = "Locked Errors/sec"; instance = instance }
  /// Logon Attempts/sec: The rate that logons to the Web service are being attempted.
  let ``Logon Attempts/sec`` instance =
    { category = CategoryName; counter = "Logon Attempts/sec"; instance = instance }
  /// Maximum Anonymous Users: Maximum Anonymous Users is the maximum number of users who established concurrent anonymous connections using the Web service (since service startup).
  let ``Maximum Anonymous Users`` instance =
    { category = CategoryName; counter = "Maximum Anonymous Users"; instance = instance }
  /// Maximum CAL count for SSL connections: This counter is no longer valid. Value will always be zero.
  let ``Maximum CAL count for SSL connections`` instance =
    { category = CategoryName; counter = "Maximum CAL count for SSL connections"; instance = instance }
  /// Maximum CAL count for authenticated users: This counter is no longer valid. Value will always be zero.
  let ``Maximum CAL count for authenticated users`` instance =
    { category = CategoryName; counter = "Maximum CAL count for authenticated users"; instance = instance }
  /// Maximum CGI Requests: Maximum CGI Requests is the maximum number of CGI requests simultaneously processed by the Web service (since service startup).
  let ``Maximum CGI Requests`` instance =
    { category = CategoryName; counter = "Maximum CGI Requests"; instance = instance }
  /// Maximum Connections: Maximum Connections is the maximum number of concurrent connections established with the Web service (since service startup).
  let ``Maximum Connections`` instance =
    { category = CategoryName; counter = "Maximum Connections"; instance = instance }
  /// Maximum ISAPI Extension Requests: Maximum ISAPI Extension Requests is the maximum number of ISAPI requests simultaneously processed by the Web service (since service startup).
  let ``Maximum ISAPI Extension Requests`` instance =
    { category = CategoryName; counter = "Maximum ISAPI Extension Requests"; instance = instance }
  /// Maximum NonAnonymous Users: Maximum NonAnonymous Users is the maximum number of concurrent non-anonymous connections to the Web service (since service startup).
  let ``Maximum NonAnonymous Users`` instance =
    { category = CategoryName; counter = "Maximum NonAnonymous Users"; instance = instance }
  /// Measured Async I/O Bandwidth Usage: Measured bandwidth of asynchronous I/O averaged over a minute.
  let ``Measured Async I/O Bandwidth Usage`` instance =
    { category = CategoryName; counter = "Measured Async I/O Bandwidth Usage"; instance = instance }
  /// Mkcol Requests/sec: The rate HTTP requests using the MKCOL method are made.  Mkcol requests are used to create directories on the server.
  let ``Mkcol Requests/sec`` instance =
    { category = CategoryName; counter = "Mkcol Requests/sec"; instance = instance }
  /// Move Requests/sec: The rate HTTP requests using the MOVE method are made.  Move requests are used for moving files and directories.
  let ``Move Requests/sec`` instance =
    { category = CategoryName; counter = "Move Requests/sec"; instance = instance }
  /// NonAnonymous Users/sec: The rate users are making non-anonymous connections to the Web service.
  let ``NonAnonymous Users/sec`` instance =
    { category = CategoryName; counter = "NonAnonymous Users/sec"; instance = instance }
  /// Not Found Errors/sec: The rate of errors due to requests that couldn't be satisfied by the server because the requested document could not be found.  These are generally reported as an HTTP 404 error code to the client.
  let ``Not Found Errors/sec`` instance =
    { category = CategoryName; counter = "Not Found Errors/sec"; instance = instance }
  /// Options Requests/sec: The rate HTTP requests using the OPTIONS method are made.
  let ``Options Requests/sec`` instance =
    { category = CategoryName; counter = "Options Requests/sec"; instance = instance }
  /// Other Request Methods/sec: The rate HTTP requests are made that do not use the OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, MOVE, COPY, MKCOL, PROPFIND, PROPPATCH, SEARCH, LOCK or UNLOCK methods.
  let ``Other Request Methods/sec`` instance =
    { category = CategoryName; counter = "Other Request Methods/sec"; instance = instance }
  /// Post Requests/sec: The rate HTTP requests using the POST method are made.
  let ``Post Requests/sec`` instance =
    { category = CategoryName; counter = "Post Requests/sec"; instance = instance }
  /// Propfind Requests/sec: The rate HTTP requests using the PROPFIND method are made.  Propfind requests retrieve property values on files and directories.
  let ``Propfind Requests/sec`` instance =
    { category = CategoryName; counter = "Propfind Requests/sec"; instance = instance }
  /// Proppatch Requests/sec: The rate HTTP requests using the PROPPATCH method are made.  Proppatch requests set property values on files and directories.
  let ``Proppatch Requests/sec`` instance =
    { category = CategoryName; counter = "Proppatch Requests/sec"; instance = instance }
  /// Put Requests/sec: The rate HTTP requests using the PUT method are made.
  let ``Put Requests/sec`` instance =
    { category = CategoryName; counter = "Put Requests/sec"; instance = instance }
  /// Search Requests/sec: The rate HTTP requests using the SEARCH method are made.  Search requests are used to query the server to find resources that match a set of conditions provided by the client.
  let ``Search Requests/sec`` instance =
    { category = CategoryName; counter = "Search Requests/sec"; instance = instance }
  /// Service Uptime: The length of time the Web Service has been running.
  let ``Service Uptime`` instance =
    { category = CategoryName; counter = "Service Uptime"; instance = instance }
  /// Total Allowed Async I/O Requests: Total requests allowed by bandwidth throttling settings (since service startup).
  let ``Total Allowed Async I/O Requests`` instance =
    { category = CategoryName; counter = "Total Allowed Async I/O Requests"; instance = instance }
  /// Total Anonymous Users: Total Anonymous Users is the total number of users who established an anonymous connection with the Web service (since service startup).
  let ``Total Anonymous Users`` instance =
    { category = CategoryName; counter = "Total Anonymous Users"; instance = instance }
  /// Total Blocked Async I/O Requests: Total requests temporarily blocked due to bandwidth throttling settings (since service startup).
  let ``Total Blocked Async I/O Requests`` instance =
    { category = CategoryName; counter = "Total Blocked Async I/O Requests"; instance = instance }
  /// Total Bytes Received: Total Bytes Received is the number of data bytes that have been received by the Web service (since service startup).
  let ``Total Bytes Received`` instance =
    { category = CategoryName; counter = "Total Bytes Received"; instance = instance }
  /// Total Bytes Sent: Total Bytes Sent is the number of data bytes that have been sent by the Web service (since service startup).
  let ``Total Bytes Sent`` instance =
    { category = CategoryName; counter = "Total Bytes Sent"; instance = instance }
  /// Total Bytes Transferred: Total bytes either received or sent by the Web service (since service startup).
  let ``Total Bytes Transferred`` instance =
    { category = CategoryName; counter = "Total Bytes Transferred"; instance = instance }
  /// Total CGI Requests: Total CGI requests is the total number of CGI requests (since service startup).
  let ``Total CGI Requests`` instance =
    { category = CategoryName; counter = "Total CGI Requests"; instance = instance }
  /// Total Connection Attempts (all instances): Total Connection Attempts is the number of connections that have been attempted using the Web service (since service startup).  This counter is for all instances listed.
  let ``Total Connection Attempts (all instances)`` instance =
    { category = CategoryName; counter = "Total Connection Attempts (all instances)"; instance = instance }
  /// Total Copy Requests: Total Copy Requests is the number of HTTP requests using the COPY method (since service startup).  Copy requests are used for copying files and directories.
  let ``Total Copy Requests`` instance =
    { category = CategoryName; counter = "Total Copy Requests"; instance = instance }
  /// Total Delete Requests: Total Delete Requests is the number of HTTP requests using the DELETE method (since service startup).  Delete requests are generally used for file removals.
  let ``Total Delete Requests`` instance =
    { category = CategoryName; counter = "Total Delete Requests"; instance = instance }
  /// Total Files Received: Total Files Received is the total number of files received by the Web service (since service startup).
  let ``Total Files Received`` instance =
    { category = CategoryName; counter = "Total Files Received"; instance = instance }
  /// Total Files Sent: Total Files Sent is the total number of files sent by the Web service (since service startup).
  let ``Total Files Sent`` instance =
    { category = CategoryName; counter = "Total Files Sent"; instance = instance }
  /// Total Files Transferred: Total Files Transferred is the sum of Files Sent and Files Received (since service startup).
  let ``Total Files Transferred`` instance =
    { category = CategoryName; counter = "Total Files Transferred"; instance = instance }
  /// Total Get Requests: Total Get Requests is the number of HTTP requests using the GET method (since service startup).  Get requests are the most common HTTP request.
  let ``Total Get Requests`` instance =
    { category = CategoryName; counter = "Total Get Requests"; instance = instance }
  /// Total Head Requests: Total Head Requests is the number of HTTP requests using the HEAD method (since service startup).  Head requests generally indicate a client is querying the state of a document they already have to see if it needs to be refreshed.
  let ``Total Head Requests`` instance =
    { category = CategoryName; counter = "Total Head Requests"; instance = instance }
  /// Total ISAPI Extension Requests: Total ISAPI Extension Requests received (since service startup).
  let ``Total ISAPI Extension Requests`` instance =
    { category = CategoryName; counter = "Total ISAPI Extension Requests"; instance = instance }
  /// Total Lock Requests: Total Lock Requests is the number of HTTP requests using the LOCK method (since service startup).  Lock requests are used to lock a file for one user so that only that user can modify the file.
  let ``Total Lock Requests`` instance =
    { category = CategoryName; counter = "Total Lock Requests"; instance = instance }
  /// Total Locked Errors: Total Locked Errors is the number of requests that couldn't be satisfied by the server because the requested was locked (since service startup).  These are generally reported as an HTTP 423 error code to the client.
  let ``Total Locked Errors`` instance =
    { category = CategoryName; counter = "Total Locked Errors"; instance = instance }
  /// Total Logon Attempts: Total Logon Attempts is the number of logons attempts to the Web Service (since service startup).
  let ``Total Logon Attempts`` instance =
    { category = CategoryName; counter = "Total Logon Attempts"; instance = instance }
  /// Total Method Requests: Total Method Requests is the number of all HTTP requests (since service startup).
  let ``Total Method Requests`` instance =
    { category = CategoryName; counter = "Total Method Requests"; instance = instance }
  /// Total Method Requests/sec: The rate HTTP requests are received.
  let ``Total Method Requests/sec`` instance =
    { category = CategoryName; counter = "Total Method Requests/sec"; instance = instance }
  /// Total Mkcol Requests: Total Mkcol Requests is the number of HTTP requests using the MKCOL method (since service startup).  Mkcol requests are used to create directories on the server.
  let ``Total Mkcol Requests`` instance =
    { category = CategoryName; counter = "Total Mkcol Requests"; instance = instance }
  /// Total Move Requests: Total Move Requests is the number of HTTP requests using the MOVE method (since service startup).  Move requests are used for moving files and directories.
  let ``Total Move Requests`` instance =
    { category = CategoryName; counter = "Total Move Requests"; instance = instance }
  /// Total NonAnonymous Users: Total NonAnonymous Users is the total number of users who established a non-anonymous connection with the Web service (since service startup).
  let ``Total NonAnonymous Users`` instance =
    { category = CategoryName; counter = "Total NonAnonymous Users"; instance = instance }
  /// Total Not Found Errors: Total Not Found Errors is the number of requests that couldn't be satisfied by the server because the requested document could not be found (since service startup).  These are generally reported as an HTTP 404 error code to the client.
  let ``Total Not Found Errors`` instance =
    { category = CategoryName; counter = "Total Not Found Errors"; instance = instance }
  /// Total Options Requests: Total Options Requests is the number of HTTP requests using the OPTIONS method (since service startup).
  let ``Total Options Requests`` instance =
    { category = CategoryName; counter = "Total Options Requests"; instance = instance }
  /// Total Other Request Methods: Total Other Request Methods is the number of HTTP requests that are not OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, MOVE, COPY, MKCOL, PROPFIND, PROPPATCH, SEARCH, LOCK or UNLOCK methods (since service startup).
  let ``Total Other Request Methods`` instance =
    { category = CategoryName; counter = "Total Other Request Methods"; instance = instance }
  /// Total Post Requests: Total Post Requests is the number of HTTP requests using the POST method (since service startup).
  let ``Total Post Requests`` instance =
    { category = CategoryName; counter = "Total Post Requests"; instance = instance }
  /// Total Propfind Requests: Total Propfind Requests is the number of HTTP requests using the PROPFIND method (since service startup).  Propfind requests retrieve property values on files and directories.
  let ``Total Propfind Requests`` instance =
    { category = CategoryName; counter = "Total Propfind Requests"; instance = instance }
  /// Total Proppatch Requests: Total Proppatch Requests is the number of HTTP requests using the PROPPATCH method (since service startup).  Proppatch requests set property values on files and directories.
  let ``Total Proppatch Requests`` instance =
    { category = CategoryName; counter = "Total Proppatch Requests"; instance = instance }
  /// Total Put Requests: Total Put Requests is the number of HTTP requests using the PUT method (since service startup).
  let ``Total Put Requests`` instance =
    { category = CategoryName; counter = "Total Put Requests"; instance = instance }
  /// Total Rejected Async I/O Requests: Total requests rejected due to bandwidth throttling settings (since service startup).
  let ``Total Rejected Async I/O Requests`` instance =
    { category = CategoryName; counter = "Total Rejected Async I/O Requests"; instance = instance }
  /// Total Search Requests: Total Search Requests is the number of HTTP requests using the SEARCH method (since service startup).  Search requests are used to query the server to find resources that match a set of conditions provided by the client.
  let ``Total Search Requests`` instance =
    { category = CategoryName; counter = "Total Search Requests"; instance = instance }
  /// Total Trace Requests: Total Trace Requests is the number of HTTP requests using the TRACE method (since service startup).  Trace requests allow the client to see what is being received at the end of the request chain and use the information for diagnostic purposes.
  let ``Total Trace Requests`` instance =
    { category = CategoryName; counter = "Total Trace Requests"; instance = instance }
  /// Total Unlock Requests: Total Unlock Requests is the number of HTTP requests using the UNLOCK method (since service startup).  Unlock requests are used to remove locks from files.
  let ``Total Unlock Requests`` instance =
    { category = CategoryName; counter = "Total Unlock Requests"; instance = instance }
  /// Total blocked bandwidth bytes.: Total bytes blocked due to bandwidth throttling settings (since service startup).
  let ``Total blocked bandwidth bytes.`` instance =
    { category = CategoryName; counter = "Total blocked bandwidth bytes."; instance = instance }
  /// Total count of failed CAL requests for SSL connections: This counter is no longer valid. Value will always be zero.
  let ``Total count of failed CAL requests for SSL connections`` instance =
    { category = CategoryName; counter = "Total count of failed CAL requests for SSL connections"; instance = instance }
  /// Total count of failed CAL requests for authenticated users: This counter is no longer valid. Value will always be zero.
  let ``Total count of failed CAL requests for authenticated users`` instance =
    { category = CategoryName; counter = "Total count of failed CAL requests for authenticated users"; instance = instance }
  /// Trace Requests/sec: The rate HTTP requests using the TRACE method are made.  Trace requests allow the client to see what is being received at the end of the request chain and use the information for diagnostic purposes.
  let ``Trace Requests/sec`` instance =
    { category = CategoryName; counter = "Trace Requests/sec"; instance = instance }
  /// Unlock Requests/sec: The rate HTTP requests using the UNLOCK method are made.  Unlock requests are used to remove locks from files.
  let ``Unlock Requests/sec`` instance =
    { category = CategoryName; counter = "Unlock Requests/sec"; instance = instance }

  let allCounters =
    [| ``Anonymous Users/sec``
       ``Bytes Received/sec``
       ``Bytes Sent/sec``
       ``Bytes Total/sec``
       ``CGI Requests/sec``
       ``Connection Attempts/sec``
       ``Copy Requests/sec``
       ``Current Anonymous Users``
       ``Current Blocked Async I/O Requests``
       ``Current CAL count for SSL connections``
       ``Current CAL count for authenticated users``
       ``Current CGI Requests``
       ``Current Connections``
       ``Current ISAPI Extension Requests``
       ``Current NonAnonymous Users``
       ``Current blocked bandwidth bytes.``
       ``Delete Requests/sec``
       ``Files Received/sec``
       ``Files Sent/sec``
       ``Files/sec``
       ``Get Requests/sec``
       ``Head Requests/sec``
       ``ISAPI Extension Requests/sec``
       ``Lock Requests/sec``
       ``Locked Errors/sec``
       ``Logon Attempts/sec``
       ``Maximum Anonymous Users``
       ``Maximum CAL count for SSL connections``
       ``Maximum CAL count for authenticated users``
       ``Maximum CGI Requests``
       ``Maximum Connections``
       ``Maximum ISAPI Extension Requests``
       ``Maximum NonAnonymous Users``
       ``Measured Async I/O Bandwidth Usage``
       ``Mkcol Requests/sec``
       ``Move Requests/sec``
       ``NonAnonymous Users/sec``
       ``Not Found Errors/sec``
       ``Options Requests/sec``
       ``Other Request Methods/sec``
       ``Post Requests/sec``
       ``Propfind Requests/sec``
       ``Proppatch Requests/sec``
       ``Put Requests/sec``
       ``Search Requests/sec``
       ``Service Uptime``
       ``Total Allowed Async I/O Requests``
       ``Total Anonymous Users``
       ``Total Blocked Async I/O Requests``
       ``Total Bytes Received``
       ``Total Bytes Sent``
       ``Total Bytes Transferred``
       ``Total CGI Requests``
       ``Total Connection Attempts (all instances)``
       ``Total Copy Requests``
       ``Total Delete Requests``
       ``Total Files Received``
       ``Total Files Sent``
       ``Total Files Transferred``
       ``Total Get Requests``
       ``Total Head Requests``
       ``Total ISAPI Extension Requests``
       ``Total Lock Requests``
       ``Total Locked Errors``
       ``Total Logon Attempts``
       ``Total Method Requests``
       ``Total Method Requests/sec``
       ``Total Mkcol Requests``
       ``Total Move Requests``
       ``Total NonAnonymous Users``
       ``Total Not Found Errors``
       ``Total Options Requests``
       ``Total Other Request Methods``
       ``Total Post Requests``
       ``Total Propfind Requests``
       ``Total Proppatch Requests``
       ``Total Put Requests``
       ``Total Rejected Async I/O Requests``
       ``Total Search Requests``
       ``Total Trace Requests``
       ``Total Unlock Requests``
       ``Total blocked bandwidth bytes.``
       ``Total count of failed CAL requests for SSL connections``
       ``Total count of failed CAL requests for authenticated users``
       ``Trace Requests/sec``
       ``Unlock Requests/sec``
    |]

/// Web Service Cache: The Web Service Cache Counters object includes cache counters specific to the World Wide Web Publishing Service.
///
/// This performance counter does not have instance based counters
module ``Web Service Cache`` =

  [<Literal>]
  let CategoryName = "Web Service Cache"

  let PCC = Category.create CategoryName
  /// Active Flushed Entries: Active Flushed Entries are file handles cached in user-mode that will be closed when all current transfers complete.
  let ``Active Flushed Entries`` =
    { category = CategoryName; counter = "Active Flushed Entries"; instance = None }
  /// Current File Cache Memory Usage: Current number of bytes used for the user-mode file cache.
  let ``Current File Cache Memory Usage`` =
    { category = CategoryName; counter = "Current File Cache Memory Usage"; instance = None }
  /// Current Files Cached: Current number of files whose content is in the user-mode cache.
  let ``Current Files Cached`` =
    { category = CategoryName; counter = "Current Files Cached"; instance = None }
  /// Current Metadata Cached: Current number of metadata information blocks currently in the user-mode cache.
  let ``Current Metadata Cached`` =
    { category = CategoryName; counter = "Current Metadata Cached"; instance = None }
  /// Current URIs Cached: URI information blocks currently in the user-mode cache.
  let ``Current URIs Cached`` =
    { category = CategoryName; counter = "Current URIs Cached"; instance = None }
  /// File Cache Flushes: The number of files removed from the user-mode cache (since service startup).
  let ``File Cache Flushes`` =
    { category = CategoryName; counter = "File Cache Flushes"; instance = None }
  /// File Cache Hits: Total number of successful lookups in the user-mode file cache (since service startup).
  let ``File Cache Hits`` =
    { category = CategoryName; counter = "File Cache Hits"; instance = None }
  /// File Cache Hits %: The ratio of user-mode file cache hits to total cache requests (since service startup).
  let ``File Cache Hits %`` =
    { category = CategoryName; counter = "File Cache Hits %"; instance = None }
  /// File Cache Misses: Total number of unsuccessful lookups in the user-mode file cache (since service startup).
  let ``File Cache Misses`` =
    { category = CategoryName; counter = "File Cache Misses"; instance = None }
  /// Kernel: Current URIs Cached: URI information blocks currently cached by the kernel.
  let ``Kernel: Current URIs Cached`` =
    { category = CategoryName; counter = "Kernel: Current URIs Cached"; instance = None }
  /// Kernel: Total Flushed URIs: The number of URI information blocks that have been removed from the kernel cache (since service startup).
  let ``Kernel: Total Flushed URIs`` =
    { category = CategoryName; counter = "Kernel: Total Flushed URIs"; instance = None }
  /// Kernel: Total URIs Cached: Total number of URI information blocks added to the kernel cache (since service startup).
  let ``Kernel: Total URIs Cached`` =
    { category = CategoryName; counter = "Kernel: Total URIs Cached"; instance = None }
  /// Kernel: URI Cache Flushes: Kernel URI Cache Flushes (since server startup).
  let ``Kernel: URI Cache Flushes`` =
    { category = CategoryName; counter = "Kernel: URI Cache Flushes"; instance = None }
  /// Kernel: URI Cache Hits: Total number of successful lookups in the kernel URI cache (since service startup).
  let ``Kernel: URI Cache Hits`` =
    { category = CategoryName; counter = "Kernel: URI Cache Hits"; instance = None }
  /// Kernel: URI Cache Hits %: The ratio of kernel URI cache hits to total cache requests (since service startup).
  let ``Kernel: URI Cache Hits %`` =
    { category = CategoryName; counter = "Kernel: URI Cache Hits %"; instance = None }
  /// Kernel: URI Cache Misses: Total number of unsuccessful lookups in the kernel URI cache (since service startup).
  let ``Kernel: URI Cache Misses`` =
    { category = CategoryName; counter = "Kernel: URI Cache Misses"; instance = None }
  /// Kernel: Uri Cache Hits/sec: The rate of kernel URI Cache hits.
  let ``Kernel: Uri Cache Hits/sec`` =
    { category = CategoryName; counter = "Kernel: Uri Cache Hits/sec"; instance = None }
  /// Maximum File Cache Memory Usage: Maximum number of bytes used for user-mode file cache (since service startup).
  let ``Maximum File Cache Memory Usage`` =
    { category = CategoryName; counter = "Maximum File Cache Memory Usage"; instance = None }
  /// Metadata Cache Flushes: The number of user-mode metadata cache flushes (since service startup).
  let ``Metadata Cache Flushes`` =
    { category = CategoryName; counter = "Metadata Cache Flushes"; instance = None }
  /// Metadata Cache Hits: Total number of successful lookups in the user-mode metadata cache (since service startup).
  let ``Metadata Cache Hits`` =
    { category = CategoryName; counter = "Metadata Cache Hits"; instance = None }
  /// Metadata Cache Hits %: The ratio of user-mode metadata cache hits to total cache requests (since service startup).
  let ``Metadata Cache Hits %`` =
    { category = CategoryName; counter = "Metadata Cache Hits %"; instance = None }
  /// Metadata Cache Misses: Total number of unsuccessful lookups in the user-mode metadata cache (since service startup).
  let ``Metadata Cache Misses`` =
    { category = CategoryName; counter = "Metadata Cache Misses"; instance = None }
  /// Output Cache Current Flushed Items: Number of items that have been flushed, but are still being used by outgoing responses so are still taking up memory.
  let ``Output Cache Current Flushed Items`` =
    { category = CategoryName; counter = "Output Cache Current Flushed Items"; instance = None }
  /// Output Cache Current Hits %: Output Cache current hit ratio. Calculated as (H)/(H+M) where H and M represent Hits and Misses in previous sample interval respectively.
  let ``Output Cache Current Hits %`` =
    { category = CategoryName; counter = "Output Cache Current Hits %"; instance = None }
  /// Output Cache Current Items: Number of items currently in output cache.
  let ``Output Cache Current Items`` =
    { category = CategoryName; counter = "Output Cache Current Items"; instance = None }
  /// Output Cache Current Memory Usage: Current memory usage by output cache.
  let ``Output Cache Current Memory Usage`` =
    { category = CategoryName; counter = "Output Cache Current Memory Usage"; instance = None }
  /// Output Cache Total Flushed Items: Total number of items flushed by cache.
  let ``Output Cache Total Flushed Items`` =
    { category = CategoryName; counter = "Output Cache Total Flushed Items"; instance = None }
  /// Output Cache Total Flushes: Total number of flushes in output cache.
  let ``Output Cache Total Flushes`` =
    { category = CategoryName; counter = "Output Cache Total Flushes"; instance = None }
  /// Output Cache Total Hits: Total number of hits in output cache.
  let ``Output Cache Total Hits`` =
    { category = CategoryName; counter = "Output Cache Total Hits"; instance = None }
  /// Output Cache Total Misses: Total number of misses in output cache.
  let ``Output Cache Total Misses`` =
    { category = CategoryName; counter = "Output Cache Total Misses"; instance = None }
  /// Total Files Cached: Total number of files whose content was ever added to the user-mode cache (since service startup).
  let ``Total Files Cached`` =
    { category = CategoryName; counter = "Total Files Cached"; instance = None }
  /// Total Flushed Files: Total Flushed Files is the number of file handles that have been removed from the user-mode cache (since service startup).
  let ``Total Flushed Files`` =
    { category = CategoryName; counter = "Total Flushed Files"; instance = None }
  /// Total Flushed Metadata: Total Flushed Metadata is the number of Metadata information blocks that have been removed from the user-mode cache (since service startup).
  let ``Total Flushed Metadata`` =
    { category = CategoryName; counter = "Total Flushed Metadata"; instance = None }
  /// Total Flushed URIs: The number of URI information blocks that have been removed from the user-mode cache (since service startup).
  let ``Total Flushed URIs`` =
    { category = CategoryName; counter = "Total Flushed URIs"; instance = None }
  /// Total Metadata Cached: Total number of metadata information blocks added to the user-mode cache (since service startup).
  let ``Total Metadata Cached`` =
    { category = CategoryName; counter = "Total Metadata Cached"; instance = None }
  /// Total URIs Cached: Total number of URI information blocks added to the user-mode cache (since service startup).
  let ``Total URIs Cached`` =
    { category = CategoryName; counter = "Total URIs Cached"; instance = None }
  /// URI Cache Flushes: User-mode URI Cache flushes (since service startup).
  let ``URI Cache Flushes`` =
    { category = CategoryName; counter = "URI Cache Flushes"; instance = None }
  /// URI Cache Hits: Total number of successful lookups in the user-mode URI cache (since service startup).
  let ``URI Cache Hits`` =
    { category = CategoryName; counter = "URI Cache Hits"; instance = None }
  /// URI Cache Hits %: The ratio of user-mode URI Cache Hits to total cache requests (since service startup).
  let ``URI Cache Hits %`` =
    { category = CategoryName; counter = "URI Cache Hits %"; instance = None }
  /// URI Cache Misses: Total number of unsuccessful lookups in the user-mode URI cache (since service startup).
  let ``URI Cache Misses`` =
    { category = CategoryName; counter = "URI Cache Misses"; instance = None }
  /// W3SVC_W3WP: This counter set exposes HTTP request processing related counters for the worker process.
  let ``W3SVC_W3WP`` =
    { category = CategoryName; counter = "W3SVC_W3WP"; instance = None }

  let allCounters =
    [| ``Active Flushed Entries``
       ``Current File Cache Memory Usage``
       ``Current Files Cached``
       ``Current Metadata Cached``
       ``Current URIs Cached``
       ``File Cache Flushes``
       ``File Cache Hits``
       ``File Cache Hits %``
       ``File Cache Misses``
       ``Kernel: Current URIs Cached``
       ``Kernel: Total Flushed URIs``
       ``Kernel: Total URIs Cached``
       ``Kernel: URI Cache Flushes``
       ``Kernel: URI Cache Hits``
       ``Kernel: URI Cache Hits %``
       ``Kernel: URI Cache Misses``
       ``Kernel: Uri Cache Hits/sec``
       ``Maximum File Cache Memory Usage``
       ``Metadata Cache Flushes``
       ``Metadata Cache Hits``
       ``Metadata Cache Hits %``
       ``Metadata Cache Misses``
       ``Output Cache Current Flushed Items``
       ``Output Cache Current Hits %``
       ``Output Cache Current Items``
       ``Output Cache Current Memory Usage``
       ``Output Cache Total Flushed Items``
       ``Output Cache Total Flushes``
       ``Output Cache Total Hits``
       ``Output Cache Total Misses``
       ``Total Files Cached``
       ``Total Flushed Files``
       ``Total Flushed Metadata``
       ``Total Flushed URIs``
       ``Total Metadata Cached``
       ``Total URIs Cached``
       ``URI Cache Flushes``
       ``URI Cache Hits``
       ``URI Cache Hits %``
       ``URI Cache Misses``
       ``W3SVC_W3WP``
    |]

/// WinNAT: WinNAT general counter set measures network activity for all network address translated packets.
///
/// This performance counter does not have instance based counters
module ``WinNAT`` =

  [<Literal>]
  let CategoryName = "WinNAT"

  let PCC = Category.create CategoryName
  /// Current Session Count: Total number of current sessions
  let ``Current Session Count`` =
    { category = CategoryName; counter = "Current Session Count"; instance = None }
  /// Dropped ICMP error packets: Total number of ICMP error packets dropped due to inner IP packet parsing or validation failure
  let ``Dropped ICMP error packets`` =
    { category = CategoryName; counter = "Dropped ICMP error packets"; instance = None }
  /// Dropped ICMP error packets/sec: Number of ICMP error packets dropped per second due to inner IP packet parsing or validation failure
  let ``Dropped ICMP error packets/sec`` =
    { category = CategoryName; counter = "Dropped ICMP error packets/sec"; instance = None }
  /// Dropped Packets: Total number of dropped packets
  let ``Dropped Packets`` =
    { category = CategoryName; counter = "Dropped Packets"; instance = None }
  /// Dropped Packets/sec: Number of packets dropped per second
  let ``Dropped Packets/sec`` =
    { category = CategoryName; counter = "Dropped Packets/sec"; instance = None }
  /// Inter-RoutingDomain Hairpinned Packets: Total number of packets hairpinned between different routing domains
  let ``Inter-RoutingDomain Hairpinned Packets`` =
    { category = CategoryName; counter = "Inter-RoutingDomain Hairpinned Packets"; instance = None }
  /// Inter-RoutingDomain Hairpinned Packets/sec: Number of packets hairpinned per second between different routing domains
  let ``Inter-RoutingDomain Hairpinned Packets/sec`` =
    { category = CategoryName; counter = "Inter-RoutingDomain Hairpinned Packets/sec"; instance = None }
  /// Intra-RoutingDomain Hairpinned Packets: Total number of packets hairpinned back to originating routing domains
  let ``Intra-RoutingDomain Hairpinned Packets`` =
    { category = CategoryName; counter = "Intra-RoutingDomain Hairpinned Packets"; instance = None }
  /// Intra-RoutingDomain Hairpinned Packets/sec: Number of packets hairpinned per second back to originating routing domains
  let ``Intra-RoutingDomain Hairpinned Packets/sec`` =
    { category = CategoryName; counter = "Intra-RoutingDomain Hairpinned Packets/sec"; instance = None }
  /// Packets External to Internal: Total number of packets translated from external to internal
  let ``Packets External to Internal`` =
    { category = CategoryName; counter = "Packets External to Internal"; instance = None }
  /// Packets Internal to External: Total number of packets translated from internal to external
  let ``Packets Internal to External`` =
    { category = CategoryName; counter = "Packets Internal to External"; instance = None }
  /// Packets/sec External to Internal: Number of packets translated per second from external to internal
  let ``Packets/sec External to Internal`` =
    { category = CategoryName; counter = "Packets/sec External to Internal"; instance = None }
  /// Packets/sec Internal to External: Number of packets translated per second from internal to external
  let ``Packets/sec Internal to External`` =
    { category = CategoryName; counter = "Packets/sec Internal to External"; instance = None }
  /// Sessions/sec: Number of new sessions established per second
  let ``Sessions/sec`` =
    { category = CategoryName; counter = "Sessions/sec"; instance = None }

  let allCounters =
    [| ``Current Session Count``
       ``Dropped ICMP error packets``
       ``Dropped ICMP error packets/sec``
       ``Dropped Packets``
       ``Dropped Packets/sec``
       ``Inter-RoutingDomain Hairpinned Packets``
       ``Inter-RoutingDomain Hairpinned Packets/sec``
       ``Intra-RoutingDomain Hairpinned Packets``
       ``Intra-RoutingDomain Hairpinned Packets/sec``
       ``Packets External to Internal``
       ``Packets Internal to External``
       ``Packets/sec External to Internal``
       ``Packets/sec Internal to External``
       ``Sessions/sec``
    |]

/// WinNAT ICMP: WinNat ICMP counter set measures network activity for network address translated ICMP packets.
///
/// This performance counter does not have instance based counters
module ``WinNAT ICMP`` =

  [<Literal>]
  let CategoryName = "WinNAT ICMP"

  let PCC = Category.create CategoryName
  /// NumExtToIntTranslations: Total number of ICMP packets translated from external to internal.
  let ``NumExtToIntTranslations`` =
    { category = CategoryName; counter = "NumExtToIntTranslations"; instance = None }
  /// NumIntToExtTranslations: Total number of ICMP packets translated from internal to external.
  let ``NumIntToExtTranslations`` =
    { category = CategoryName; counter = "NumIntToExtTranslations"; instance = None }
  /// NumPacketsDropped: Total number of ICMP packets dropped due to absence of binding.
  let ``NumPacketsDropped`` =
    { category = CategoryName; counter = "NumPacketsDropped"; instance = None }
  /// NumSessionsTimedOut: Total number of ICMP sessions timed out due to inactivity.
  let ``NumSessionsTimedOut`` =
    { category = CategoryName; counter = "NumSessionsTimedOut"; instance = None }
  /// NumberOfBindings: Total number of ICMP bindings.
  let ``NumberOfBindings`` =
    { category = CategoryName; counter = "NumberOfBindings"; instance = None }
  /// NumberOfSessions: Total number of ICMP sessions.
  let ``NumberOfSessions`` =
    { category = CategoryName; counter = "NumberOfSessions"; instance = None }

  let allCounters =
    [| ``NumExtToIntTranslations``
       ``NumIntToExtTranslations``
       ``NumPacketsDropped``
       ``NumSessionsTimedOut``
       ``NumberOfBindings``
       ``NumberOfSessions``
    |]

/// WinNAT Instance: WinNAT instance counterset provides resource usage information per NAT instance.
///
/// This performance counter does not have instance based counters
module ``WinNAT Instance`` =

  [<Literal>]
  let CategoryName = "WinNAT Instance"

  let PCC = Category.create CategoryName
  /// TCP Ports Available: -
  let ``TCP Ports Available`` instance =
    { category = CategoryName; counter = "TCP Ports Available"; instance = instance }
  /// TCP Ports In Use: -
  let ``TCP Ports In Use`` instance =
    { category = CategoryName; counter = "TCP Ports In Use"; instance = instance }
  /// UDP Ports Available: -
  let ``UDP Ports Available`` instance =
    { category = CategoryName; counter = "UDP Ports Available"; instance = instance }
  /// UDP Ports In Use: -
  let ``UDP Ports In Use`` instance =
    { category = CategoryName; counter = "UDP Ports In Use"; instance = instance }

  let allCounters =
    [| ``TCP Ports Available``
       ``TCP Ports In Use``
       ``UDP Ports Available``
       ``UDP Ports In Use``
    |]

/// WinNAT SLB: Windows Software Load Balancer per Vip usage
///
/// This performance counter does not have instance based counters
module ``WinNAT SLB`` =

  [<Literal>]
  let CategoryName = "WinNAT SLB"

  let PCC = Category.create CategoryName
  /// DroppedPackets: -
  let ``DroppedPackets`` instance =
    { category = CategoryName; counter = "DroppedPackets"; instance = instance }
  /// DroppedPackets/sec: -
  let ``DroppedPackets/sec`` instance =
    { category = CategoryName; counter = "DroppedPackets/sec"; instance = instance }
  /// ProcessedPackets: -
  let ``ProcessedPackets`` instance =
    { category = CategoryName; counter = "ProcessedPackets"; instance = instance }
  /// ProcessedPackets/sec: -
  let ``ProcessedPackets/sec`` instance =
    { category = CategoryName; counter = "ProcessedPackets/sec"; instance = instance }
  /// Sessions: -
  let ``Sessions`` instance =
    { category = CategoryName; counter = "Sessions"; instance = instance }
  /// Sessions/sec: -
  let ``Sessions/sec`` instance =
    { category = CategoryName; counter = "Sessions/sec"; instance = instance }

  let allCounters =
    [| ``DroppedPackets``
       ``DroppedPackets/sec``
       ``ProcessedPackets``
       ``ProcessedPackets/sec``
       ``Sessions``
       ``Sessions/sec``
    |]

/// WinNAT TCP: WinNat TCP counter set measures network activity for network address translated TCP packets.
///
/// This performance counter does not have instance based counters
module ``WinNAT TCP`` =

  [<Literal>]
  let CategoryName = "WinNAT TCP"

  let PCC = Category.create CategoryName
  /// NumExtToIntTranslations: Total number of TCP packets translated from external to internal.
  let ``NumExtToIntTranslations`` =
    { category = CategoryName; counter = "NumExtToIntTranslations"; instance = None }
  /// NumIntToExtTranslations: Total number of TCP packets translated from internal to external.
  let ``NumIntToExtTranslations`` =
    { category = CategoryName; counter = "NumIntToExtTranslations"; instance = None }
  /// NumPacketsDropped: Total number of TCP packets dropped due to absence of binding.
  let ``NumPacketsDropped`` =
    { category = CategoryName; counter = "NumPacketsDropped"; instance = None }
  /// NumSessionsTimedOut: Total number of TCP sessions timed out due to inactivity.
  let ``NumSessionsTimedOut`` =
    { category = CategoryName; counter = "NumSessionsTimedOut"; instance = None }
  /// NumberOfBindings: Total number of TCP bindings.
  let ``NumberOfBindings`` =
    { category = CategoryName; counter = "NumberOfBindings"; instance = None }
  /// NumberOfSessions: Total number of TCP sessions.
  let ``NumberOfSessions`` =
    { category = CategoryName; counter = "NumberOfSessions"; instance = None }

  let allCounters =
    [| ``NumExtToIntTranslations``
       ``NumIntToExtTranslations``
       ``NumPacketsDropped``
       ``NumSessionsTimedOut``
       ``NumberOfBindings``
       ``NumberOfSessions``
    |]

/// WinNAT UDP: WinNat UDP counter set measures network activity for network address translated UDP packets.
///
/// This performance counter does not have instance based counters
module ``WinNAT UDP`` =

  [<Literal>]
  let CategoryName = "WinNAT UDP"

  let PCC = Category.create CategoryName
  /// NumExtToIntTranslations: Total number of UDP packets translated from external to internal.
  let ``NumExtToIntTranslations`` =
    { category = CategoryName; counter = "NumExtToIntTranslations"; instance = None }
  /// NumIntToExtTranslations: Total number of UDP packets translated from internal to external.
  let ``NumIntToExtTranslations`` =
    { category = CategoryName; counter = "NumIntToExtTranslations"; instance = None }
  /// NumPacketsDropped: Total number of UDP packets dropped due to absence of binding.
  let ``NumPacketsDropped`` =
    { category = CategoryName; counter = "NumPacketsDropped"; instance = None }
  /// NumSessionsTimedOut: Total number of UDP sessions timed out due to inactivity.
  let ``NumSessionsTimedOut`` =
    { category = CategoryName; counter = "NumSessionsTimedOut"; instance = None }
  /// NumberOfBindings: Total number of UDP bindings.
  let ``NumberOfBindings`` =
    { category = CategoryName; counter = "NumberOfBindings"; instance = None }
  /// NumberOfSessions: Total number of UDP sessions.
  let ``NumberOfSessions`` =
    { category = CategoryName; counter = "NumberOfSessions"; instance = None }

  let allCounters =
    [| ``NumExtToIntTranslations``
       ``NumIntToExtTranslations``
       ``NumPacketsDropped``
       ``NumSessionsTimedOut``
       ``NumberOfBindings``
       ``NumberOfSessions``
    |]

/// Windows Media Player Metadata: Windows Media Player Metadata
///
/// This performance counter does not have instance based counters
module ``Windows Media Player Metadata`` =

  [<Literal>]
  let CategoryName = "Windows Media Player Metadata"

  let PCC = Category.create CategoryName
  /// AFTS Execution Time (ms): -
  let ``AFTS Execution Time (ms)`` instance =
    { category = CategoryName; counter = "AFTS Execution Time (ms)"; instance = instance }
  /// Art Extraction Time (ms): -
  let ``Art Extraction Time (ms)`` instance =
    { category = CategoryName; counter = "Art Extraction Time (ms)"; instance = instance }
  /// Commit Time (ms): -
  let ``Commit Time (ms)`` instance =
    { category = CategoryName; counter = "Commit Time (ms)"; instance = instance }
  /// Directory Change Queue Length: -
  let ``Directory Change Queue Length`` instance =
    { category = CategoryName; counter = "Directory Change Queue Length"; instance = instance }
  /// Dirty Directory Hit Count: -
  let ``Dirty Directory Hit Count`` instance =
    { category = CategoryName; counter = "Dirty Directory Hit Count"; instance = instance }
  /// File Scanning Thread Prioirty: -
  let ``File Scanning Thread Prioirty`` instance =
    { category = CategoryName; counter = "File Scanning Thread Prioirty"; instance = instance }
  /// Files Scanned/Minute: -
  let ``Files Scanned/Minute`` instance =
    { category = CategoryName; counter = "Files Scanned/Minute"; instance = instance }
  /// Groveler Service Routine Executions/Second: -
  let ``Groveler Service Routine Executions/Second`` instance =
    { category = CategoryName; counter = "Groveler Service Routine Executions/Second"; instance = instance }
  /// Library Description Change Notifications/Second: -
  let ``Library Description Change Notifications/Second`` instance =
    { category = CategoryName; counter = "Library Description Change Notifications/Second"; instance = instance }
  /// Library Description Updates/Second: -
  let ``Library Description Updates/Second`` instance =
    { category = CategoryName; counter = "Library Description Updates/Second"; instance = instance }
  /// Monitored Folder Updates/Second: -
  let ``Monitored Folder Updates/Second`` instance =
    { category = CategoryName; counter = "Monitored Folder Updates/Second"; instance = instance }
  /// Normalization Time (ms): -
  let ``Normalization Time (ms)`` instance =
    { category = CategoryName; counter = "Normalization Time (ms)"; instance = instance }
  /// Property Extraction Time (ms): -
  let ``Property Extraction Time (ms)`` instance =
    { category = CategoryName; counter = "Property Extraction Time (ms)"; instance = instance }
  /// Reorganize Time (ms): -
  let ``Reorganize Time (ms)`` instance =
    { category = CategoryName; counter = "Reorganize Time (ms)"; instance = instance }
  /// Scanning State: -
  let ``Scanning State`` instance =
    { category = CategoryName; counter = "Scanning State"; instance = instance }
  /// Timestamp Directory Hit Count: -
  let ``Timestamp Directory Hit Count`` instance =
    { category = CategoryName; counter = "Timestamp Directory Hit Count"; instance = instance }
  /// URL Classification Time (ms): -
  let ``URL Classification Time (ms)`` instance =
    { category = CategoryName; counter = "URL Classification Time (ms)"; instance = instance }

  let allCounters =
    [| ``AFTS Execution Time (ms)``
       ``Art Extraction Time (ms)``
       ``Commit Time (ms)``
       ``Directory Change Queue Length``
       ``Dirty Directory Hit Count``
       ``File Scanning Thread Prioirty``
       ``Files Scanned/Minute``
       ``Groveler Service Routine Executions/Second``
       ``Library Description Change Notifications/Second``
       ``Library Description Updates/Second``
       ``Monitored Folder Updates/Second``
       ``Normalization Time (ms)``
       ``Property Extraction Time (ms)``
       ``Reorganize Time (ms)``
       ``Scanning State``
       ``Timestamp Directory Hit Count``
       ``URL Classification Time (ms)``
    |]

/// Windows Workflow Foundation: Windows Workflow Foundation Performance Counters
///
/// This performance counter does not have instance based counters
module ``Windows Workflow Foundation`` =

  [<Literal>]
  let CategoryName = "Windows Workflow Foundation"

  let PCC = Category.create CategoryName
  /// Workflows Aborted: -
  let ``Workflows Aborted`` instance =
    { category = CategoryName; counter = "Workflows Aborted"; instance = instance }
  /// Workflows Aborted/sec: -
  let ``Workflows Aborted/sec`` instance =
    { category = CategoryName; counter = "Workflows Aborted/sec"; instance = instance }
  /// Workflows Completed: -
  let ``Workflows Completed`` instance =
    { category = CategoryName; counter = "Workflows Completed"; instance = instance }
  /// Workflows Completed/sec: -
  let ``Workflows Completed/sec`` instance =
    { category = CategoryName; counter = "Workflows Completed/sec"; instance = instance }
  /// Workflows Created: -
  let ``Workflows Created`` instance =
    { category = CategoryName; counter = "Workflows Created"; instance = instance }
  /// Workflows Created/sec: -
  let ``Workflows Created/sec`` instance =
    { category = CategoryName; counter = "Workflows Created/sec"; instance = instance }
  /// Workflows Executing: -
  let ``Workflows Executing`` instance =
    { category = CategoryName; counter = "Workflows Executing"; instance = instance }
  /// Workflows Idle/sec: -
  let ``Workflows Idle/sec`` instance =
    { category = CategoryName; counter = "Workflows Idle/sec"; instance = instance }
  /// Workflows In Memory: -
  let ``Workflows In Memory`` instance =
    { category = CategoryName; counter = "Workflows In Memory"; instance = instance }
  /// Workflows Loaded: -
  let ``Workflows Loaded`` instance =
    { category = CategoryName; counter = "Workflows Loaded"; instance = instance }
  /// Workflows Loaded/sec: -
  let ``Workflows Loaded/sec`` instance =
    { category = CategoryName; counter = "Workflows Loaded/sec"; instance = instance }
  /// Workflows Pending: -
  let ``Workflows Pending`` instance =
    { category = CategoryName; counter = "Workflows Pending"; instance = instance }
  /// Workflows Persisted: -
  let ``Workflows Persisted`` instance =
    { category = CategoryName; counter = "Workflows Persisted"; instance = instance }
  /// Workflows Persisted/sec: -
  let ``Workflows Persisted/sec`` instance =
    { category = CategoryName; counter = "Workflows Persisted/sec"; instance = instance }
  /// Workflows Runnable: -
  let ``Workflows Runnable`` instance =
    { category = CategoryName; counter = "Workflows Runnable"; instance = instance }
  /// Workflows Suspended: -
  let ``Workflows Suspended`` instance =
    { category = CategoryName; counter = "Workflows Suspended"; instance = instance }
  /// Workflows Suspended/sec: -
  let ``Workflows Suspended/sec`` instance =
    { category = CategoryName; counter = "Workflows Suspended/sec"; instance = instance }
  /// Workflows Terminated: -
  let ``Workflows Terminated`` instance =
    { category = CategoryName; counter = "Workflows Terminated"; instance = instance }
  /// Workflows Terminated/sec: -
  let ``Workflows Terminated/sec`` instance =
    { category = CategoryName; counter = "Workflows Terminated/sec"; instance = instance }
  /// Workflows Unloaded: -
  let ``Workflows Unloaded`` instance =
    { category = CategoryName; counter = "Workflows Unloaded"; instance = instance }
  /// Workflows Unloaded/sec: -
  let ``Workflows Unloaded/sec`` instance =
    { category = CategoryName; counter = "Workflows Unloaded/sec"; instance = instance }

  let allCounters =
    [| ``Workflows Aborted``
       ``Workflows Aborted/sec``
       ``Workflows Completed``
       ``Workflows Completed/sec``
       ``Workflows Created``
       ``Workflows Created/sec``
       ``Workflows Executing``
       ``Workflows Idle/sec``
       ``Workflows In Memory``
       ``Workflows Loaded``
       ``Workflows Loaded/sec``
       ``Workflows Pending``
       ``Workflows Persisted``
       ``Workflows Persisted/sec``
       ``Workflows Runnable``
       ``Workflows Suspended``
       ``Workflows Suspended/sec``
       ``Workflows Terminated``
       ``Workflows Terminated/sec``
       ``Workflows Unloaded``
       ``Workflows Unloaded/sec``
    |]

/// WorkflowServiceHost 4.0.0.0: WorkflowServiceHost performance counters for workflow service
///
/// This performance counter does not have instance based counters
module ``WorkflowServiceHost 4_0_0_0`` =

  [<Literal>]
  let CategoryName = "WorkflowServiceHost 4.0.0.0"

  let PCC = Category.create CategoryName
  /// Average Workflow Load Time: -
  let ``Average Workflow Load Time`` instance =
    { category = CategoryName; counter = "Average Workflow Load Time"; instance = instance }
  /// Average Workflow Persist Time: -
  let ``Average Workflow Persist Time`` instance =
    { category = CategoryName; counter = "Average Workflow Persist Time"; instance = instance }
  /// Workflows Aborted: -
  let ``Workflows Aborted`` instance =
    { category = CategoryName; counter = "Workflows Aborted"; instance = instance }
  /// Workflows Aborted Per Second: -
  let ``Workflows Aborted Per Second`` instance =
    { category = CategoryName; counter = "Workflows Aborted Per Second"; instance = instance }
  /// Workflows Completed: -
  let ``Workflows Completed`` instance =
    { category = CategoryName; counter = "Workflows Completed"; instance = instance }
  /// Workflows Completed Per Second: -
  let ``Workflows Completed Per Second`` instance =
    { category = CategoryName; counter = "Workflows Completed Per Second"; instance = instance }
  /// Workflows Created: -
  let ``Workflows Created`` instance =
    { category = CategoryName; counter = "Workflows Created"; instance = instance }
  /// Workflows Created Per Second: -
  let ``Workflows Created Per Second`` instance =
    { category = CategoryName; counter = "Workflows Created Per Second"; instance = instance }
  /// Workflows Executing: -
  let ``Workflows Executing`` instance =
    { category = CategoryName; counter = "Workflows Executing"; instance = instance }
  /// Workflows Idle Per Second: -
  let ``Workflows Idle Per Second`` instance =
    { category = CategoryName; counter = "Workflows Idle Per Second"; instance = instance }
  /// Workflows In Memory: -
  let ``Workflows In Memory`` instance =
    { category = CategoryName; counter = "Workflows In Memory"; instance = instance }
  /// Workflows Loaded: -
  let ``Workflows Loaded`` instance =
    { category = CategoryName; counter = "Workflows Loaded"; instance = instance }
  /// Workflows Loaded Per Second: -
  let ``Workflows Loaded Per Second`` instance =
    { category = CategoryName; counter = "Workflows Loaded Per Second"; instance = instance }
  /// Workflows Persisted: -
  let ``Workflows Persisted`` instance =
    { category = CategoryName; counter = "Workflows Persisted"; instance = instance }
  /// Workflows Persisted Per Second: -
  let ``Workflows Persisted Per Second`` instance =
    { category = CategoryName; counter = "Workflows Persisted Per Second"; instance = instance }
  /// Workflows Suspended: -
  let ``Workflows Suspended`` instance =
    { category = CategoryName; counter = "Workflows Suspended"; instance = instance }
  /// Workflows Suspended Per Second: -
  let ``Workflows Suspended Per Second`` instance =
    { category = CategoryName; counter = "Workflows Suspended Per Second"; instance = instance }
  /// Workflows Terminated: -
  let ``Workflows Terminated`` instance =
    { category = CategoryName; counter = "Workflows Terminated"; instance = instance }
  /// Workflows Terminated Per Second: -
  let ``Workflows Terminated Per Second`` instance =
    { category = CategoryName; counter = "Workflows Terminated Per Second"; instance = instance }
  /// Workflows Unloaded: -
  let ``Workflows Unloaded`` instance =
    { category = CategoryName; counter = "Workflows Unloaded"; instance = instance }
  /// Workflows Unloaded Per Second: -
  let ``Workflows Unloaded Per Second`` instance =
    { category = CategoryName; counter = "Workflows Unloaded Per Second"; instance = instance }

  let allCounters =
    [| ``Average Workflow Load Time``
       ``Average Workflow Persist Time``
       ``Workflows Aborted``
       ``Workflows Aborted Per Second``
       ``Workflows Completed``
       ``Workflows Completed Per Second``
       ``Workflows Created``
       ``Workflows Created Per Second``
       ``Workflows Executing``
       ``Workflows Idle Per Second``
       ``Workflows In Memory``
       ``Workflows Loaded``
       ``Workflows Loaded Per Second``
       ``Workflows Persisted``
       ``Workflows Persisted Per Second``
       ``Workflows Suspended``
       ``Workflows Suspended Per Second``
       ``Workflows Terminated``
       ``Workflows Terminated Per Second``
       ``Workflows Unloaded``
       ``Workflows Unloaded Per Second``
    |]

/// XHCI CommonBuffer: Consists of counters that measure aspects of a CommonBuffer object of an xHCI controller.
///
/// This performance counter does not have instance based counters
module ``XHCI CommonBuffer`` =

  [<Literal>]
  let CategoryName = "XHCI CommonBuffer"

  let PCC = Category.create CategoryName
  /// AllocationCount: -
  let ``AllocationCount`` instance =
    { category = CategoryName; counter = "AllocationCount"; instance = instance }
  /// FreeCount: -
  let ``FreeCount`` instance =
    { category = CategoryName; counter = "FreeCount"; instance = instance }
  /// PagesInUse: -
  let ``PagesInUse`` instance =
    { category = CategoryName; counter = "PagesInUse"; instance = instance }
  /// PagesTotal: -
  let ``PagesTotal`` instance =
    { category = CategoryName; counter = "PagesTotal"; instance = instance }

  let allCounters =
    [| ``AllocationCount``
       ``FreeCount``
       ``PagesInUse``
       ``PagesTotal``
    |]

/// XHCI Interrupter: Consists of counters that measure aspects of an interrupter of an xHCI controller.
///
/// This performance counter does not have instance based counters
module ``XHCI Interrupter`` =

  [<Literal>]
  let CategoryName = "XHCI Interrupter"

  let PCC = Category.create CategoryName
  /// DPCs/sec: -
  let ``DPCs/sec`` instance =
    { category = CategoryName; counter = "DPCs/sec"; instance = instance }
  /// DpcRequeueCount: -
  let ``DpcRequeueCount`` instance =
    { category = CategoryName; counter = "DpcRequeueCount"; instance = instance }
  /// EventRingFullCount: -
  let ``EventRingFullCount`` instance =
    { category = CategoryName; counter = "EventRingFullCount"; instance = instance }
  /// Events processed/DPC: -
  let ``Events processed/DPC`` instance =
    { category = CategoryName; counter = "Events processed/DPC"; instance = instance }
  /// Interrupts/sec: -
  let ``Interrupts/sec`` instance =
    { category = CategoryName; counter = "Interrupts/sec"; instance = instance }

  let allCounters =
    [| ``DPCs/sec``
       ``DpcRequeueCount``
       ``EventRingFullCount``
       ``Events processed/DPC``
       ``Interrupts/sec``
    |]

/// XHCI TransferRing: Consists of counters that measure aspects of a transferring of an xHCI controller.
///
/// This performance counter does not have instance based counters
module ``XHCI TransferRing`` =

  [<Literal>]
  let CategoryName = "XHCI TransferRing"

  let PCC = Category.create CategoryName
  /// Bytes/Sec: -
  let ``Bytes/Sec`` instance =
    { category = CategoryName; counter = "Bytes/Sec"; instance = instance }
  /// Failed Transfer Count: -
  let ``Failed Transfer Count`` instance =
    { category = CategoryName; counter = "Failed Transfer Count"; instance = instance }
  /// Isoch TD Failures/sec: -
  let ``Isoch TD Failures/sec`` instance =
    { category = CategoryName; counter = "Isoch TD Failures/sec"; instance = instance }
  /// Isoch TD/sec: -
  let ``Isoch TD/sec`` instance =
    { category = CategoryName; counter = "Isoch TD/sec"; instance = instance }
  /// Missed Service Error Count: -
  let ``Missed Service Error Count`` instance =
    { category = CategoryName; counter = "Missed Service Error Count"; instance = instance }
  /// Transfers/sec: -
  let ``Transfers/sec`` instance =
    { category = CategoryName; counter = "Transfers/sec"; instance = instance }
  /// Underrun Overrun count: -
  let ``Underrun Overrun count`` instance =
    { category = CategoryName; counter = "Underrun Overrun count"; instance = instance }

  let allCounters =
    [| ``Bytes/Sec``
       ``Failed Transfer Count``
       ``Isoch TD Failures/sec``
       ``Isoch TD/sec``
       ``Missed Service Error Count``
       ``Transfers/sec``
       ``Underrun Overrun count``
    |]

/// XTP Cursors: The XTP Cursors performance object contains counters related to internal XTP engine cursors. Cursors are the low-level building blocks the XTP engine uses to process T-SQL queries. As such, a user does not typically have direct control over them.
///
/// This performance counter does not have non-instance based counters
module ``XTP Cursors`` =

  [<Literal>]
  let CategoryName = "XTP Cursors"

  let PCC = Category.create CategoryName
  /// Cursor deletes/sec: The number of cursor deletes (on average), per second.
  let ``Cursor deletes/sec`` instance =
    { category = CategoryName; counter = "Cursor deletes/sec"; instance = instance }
  /// Cursor inserts/sec: The number of cursor inserts (on average), per second.
  let ``Cursor inserts/sec`` instance =
    { category = CategoryName; counter = "Cursor inserts/sec"; instance = instance }
  /// Cursor scans started/sec: The number of cursor scans started (on average), per second.
  let ``Cursor scans started/sec`` instance =
    { category = CategoryName; counter = "Cursor scans started/sec"; instance = instance }
  /// Cursor unique violations/sec: The number of unique-constraint violations (on average), per second.
  let ``Cursor unique violations/sec`` instance =
    { category = CategoryName; counter = "Cursor unique violations/sec"; instance = instance }
  /// Cursor updates/sec: The number of cursor updates (on average), per second.
  let ``Cursor updates/sec`` instance =
    { category = CategoryName; counter = "Cursor updates/sec"; instance = instance }
  /// Cursor write conflicts/sec: The number of write-write conflicts to the same row version (on average), per second.
  let ``Cursor write conflicts/sec`` instance =
    { category = CategoryName; counter = "Cursor write conflicts/sec"; instance = instance }
  /// Dusty corner scan retries/sec (user-issued): The number of scan retries due to write conflicts during dusty corner sweeps issued by a user's full-table scan (on average), per second. This is a very low-level counter, not intended for customer use.
  let ``Dusty corner scan retries/sec (user-issued)`` instance =
    { category = CategoryName; counter = "Dusty corner scan retries/sec (user-issued)"; instance = instance }
  /// Expired rows removed/sec: The number of expired rows removed by cursors (on average), per second.
  let ``Expired rows removed/sec`` instance =
    { category = CategoryName; counter = "Expired rows removed/sec"; instance = instance }
  /// Expired rows touched/sec: The number of expired rows touched by cursors (on average), per second.
  let ``Expired rows touched/sec`` instance =
    { category = CategoryName; counter = "Expired rows touched/sec"; instance = instance }
  /// Rows returned/sec: The number of rows returned by cursors (on average), per second.
  let ``Rows returned/sec`` instance =
    { category = CategoryName; counter = "Rows returned/sec"; instance = instance }
  /// Rows touched/sec: The number of rows touched by cursors (on average), per second.
  let ``Rows touched/sec`` instance =
    { category = CategoryName; counter = "Rows touched/sec"; instance = instance }
  /// Tentatively-deleted rows touched/sec: The number of expiring rows touched by cursors (on average), per second. A row is expiring if the transaction that deleted it is still active (i.e. has not yet committed or aborted.)
  let ``Tentatively-deleted rows touched/sec`` instance =
    { category = CategoryName; counter = "Tentatively-deleted rows touched/sec"; instance = instance }

  let allCounters =
    [| ``Cursor deletes/sec``
       ``Cursor inserts/sec``
       ``Cursor scans started/sec``
       ``Cursor unique violations/sec``
       ``Cursor updates/sec``
       ``Cursor write conflicts/sec``
       ``Dusty corner scan retries/sec (user-issued)``
       ``Expired rows removed/sec``
       ``Expired rows touched/sec``
       ``Rows returned/sec``
       ``Rows touched/sec``
       ``Tentatively-deleted rows touched/sec``
    |]

/// XTP Garbage Collection: The XTP Garbage Collection performance object contains counters related to the XTP engine's garbage collector.
///
/// This performance counter does not have non-instance based counters
module ``XTP Garbage Collection`` =

  [<Literal>]
  let CategoryName = "XTP Garbage Collection"

  let PCC = Category.create CategoryName
  /// Dusty corner scan retries/sec (GC-issued): The number of scan retries due to write conflicts during dusty corner sweeps issued by the garbage collector (on average), per second. This is a very low-level counter, not intended for customer use.
  let ``Dusty corner scan retries/sec (GC-issued)`` instance =
    { category = CategoryName; counter = "Dusty corner scan retries/sec (GC-issued)"; instance = instance }
  /// Main GC work items/sec: The number of work items processed by the main GC thread.
  let ``Main GC work items/sec`` instance =
    { category = CategoryName; counter = "Main GC work items/sec"; instance = instance }
  /// Parallel GC work item/sec: The number of times a parallel thread has executed a GC work item.
  let ``Parallel GC work item/sec`` instance =
    { category = CategoryName; counter = "Parallel GC work item/sec"; instance = instance }
  /// Rows processed/sec: The number of rows processed by the garbage collector (on average), per second.
  let ``Rows processed/sec`` instance =
    { category = CategoryName; counter = "Rows processed/sec"; instance = instance }
  /// Rows processed/sec (first in bucket and removed): The number of rows processed by the garbage collector that were first in the corresponding hash bucket, and were able to be removed immediately (on average), per second.
  let ``Rows processed/sec (first in bucket and removed)`` instance =
    { category = CategoryName; counter = "Rows processed/sec (first in bucket and removed)"; instance = instance }
  /// Rows processed/sec (first in bucket): The number of rows processed by the garbage collector that were first in the corresponding hash bucket (on average), per second.
  let ``Rows processed/sec (first in bucket)`` instance =
    { category = CategoryName; counter = "Rows processed/sec (first in bucket)"; instance = instance }
  /// Rows processed/sec (marked for unlink): The number of rows processed by the garbage collector that were already marked for unlink (on average), per second.
  let ``Rows processed/sec (marked for unlink)`` instance =
    { category = CategoryName; counter = "Rows processed/sec (marked for unlink)"; instance = instance }
  /// Rows processed/sec (no sweep needed): The number of rows processed by the garbage collector that will not require a dusty corner sweep (on average), per second.
  let ``Rows processed/sec (no sweep needed)`` instance =
    { category = CategoryName; counter = "Rows processed/sec (no sweep needed)"; instance = instance }
  /// Sweep expired rows removed/sec: The number of expired rows removed during dusty corner sweeps (on average), per second.
  let ``Sweep expired rows removed/sec`` instance =
    { category = CategoryName; counter = "Sweep expired rows removed/sec"; instance = instance }
  /// Sweep expired rows touched/sec: The number of expired rows touched during dusty corner sweeps (on average), per second.
  let ``Sweep expired rows touched/sec`` instance =
    { category = CategoryName; counter = "Sweep expired rows touched/sec"; instance = instance }
  /// Sweep expiring rows touched/sec: The number of expiring rows touched during dusty corner sweeps (on average), per second.
  let ``Sweep expiring rows touched/sec`` instance =
    { category = CategoryName; counter = "Sweep expiring rows touched/sec"; instance = instance }
  /// Sweep rows touched/sec: The number of rows touched during dusty corner sweeps (on average), per second.
  let ``Sweep rows touched/sec`` instance =
    { category = CategoryName; counter = "Sweep rows touched/sec"; instance = instance }
  /// Sweep scans started/sec: The number of dusty corner sweep scans started (on average), per second.
  let ``Sweep scans started/sec`` instance =
    { category = CategoryName; counter = "Sweep scans started/sec"; instance = instance }

  let allCounters =
    [| ``Dusty corner scan retries/sec (GC-issued)``
       ``Main GC work items/sec``
       ``Parallel GC work item/sec``
       ``Rows processed/sec``
       ``Rows processed/sec (first in bucket and removed)``
       ``Rows processed/sec (first in bucket)``
       ``Rows processed/sec (marked for unlink)``
       ``Rows processed/sec (no sweep needed)``
       ``Sweep expired rows removed/sec``
       ``Sweep expired rows touched/sec``
       ``Sweep expiring rows touched/sec``
       ``Sweep rows touched/sec``
       ``Sweep scans started/sec``
    |]

/// XTP Phantom Processor: The XTP Phantom Processor performance object contains counters related to the XTP engine's phantom processing subsystem. This component is responsible for detecting phantom rows in transactions running at the SERIALIZABLE isolation level.
///
/// This performance counter does not have non-instance based counters
module ``XTP Phantom Processor`` =

  [<Literal>]
  let CategoryName = "XTP Phantom Processor"

  let PCC = Category.create CategoryName
  /// Dusty corner scan retries/sec (Phantom-issued): The number of scan retries due to write conflicts during dusty corner sweeps issued by the phantom processor (on average), per second. This is a very low-level counter, not intended for customer use.
  let ``Dusty corner scan retries/sec (Phantom-issued)`` instance =
    { category = CategoryName; counter = "Dusty corner scan retries/sec (Phantom-issued)"; instance = instance }
  /// Phantom expired rows removed/sec: The number of expired rows removed by phantom scans (on average), per second.
  let ``Phantom expired rows removed/sec`` instance =
    { category = CategoryName; counter = "Phantom expired rows removed/sec"; instance = instance }
  /// Phantom expired rows touched/sec: The number of expired rows touched by phantom scans (on average), per second.
  let ``Phantom expired rows touched/sec`` instance =
    { category = CategoryName; counter = "Phantom expired rows touched/sec"; instance = instance }
  /// Phantom expiring rows touched/sec: The number of expiring rows touched by phantom scans (on average), per second.
  let ``Phantom expiring rows touched/sec`` instance =
    { category = CategoryName; counter = "Phantom expiring rows touched/sec"; instance = instance }
  /// Phantom rows touched/sec: The number of rows touched by phantom scans (on average), per second.
  let ``Phantom rows touched/sec`` instance =
    { category = CategoryName; counter = "Phantom rows touched/sec"; instance = instance }
  /// Phantom scans started/sec: The number of phantom scans started (on average), per second.
  let ``Phantom scans started/sec`` instance =
    { category = CategoryName; counter = "Phantom scans started/sec"; instance = instance }

  let allCounters =
    [| ``Dusty corner scan retries/sec (Phantom-issued)``
       ``Phantom expired rows removed/sec``
       ``Phantom expired rows touched/sec``
       ``Phantom expiring rows touched/sec``
       ``Phantom rows touched/sec``
       ``Phantom scans started/sec``
    |]

/// XTP Storage: The XTP Storage performance object contains counters related to the XTP engine's storage subsystem. This includes checkpointing and merge of checkpoint files.
///
/// This performance counter does not have non-instance based counters
module ``XTP Storage`` =

  [<Literal>]
  let CategoryName = "XTP Storage"

  let PCC = Category.create CategoryName
  /// Checkpoints Closed: Count of checkpoints closed done by online agent
  let ``Checkpoints Closed`` instance =
    { category = CategoryName; counter = "Checkpoints Closed"; instance = instance }
  /// Checkpoints Completed: Count of checkpoints processed by offline checkpoint thread
  let ``Checkpoints Completed`` instance =
    { category = CategoryName; counter = "Checkpoints Completed"; instance = instance }
  /// Core Merges Completed: The number of core merges completed by the merge worker thread. These merges still need to be installed.
  let ``Core Merges Completed`` instance =
    { category = CategoryName; counter = "Core Merges Completed"; instance = instance }
  /// Merge Policy Evaluations: The number of merge policy evaluations since the server started.
  let ``Merge Policy Evaluations`` instance =
    { category = CategoryName; counter = "Merge Policy Evaluations"; instance = instance }
  /// Merge Requests Outstanding: The number of merge requests outstanding since the server started.
  let ``Merge Requests Outstanding`` instance =
    { category = CategoryName; counter = "Merge Requests Outstanding"; instance = instance }
  /// Merges Abandoned: The number of merges abandoned due to failure.
  let ``Merges Abandoned`` instance =
    { category = CategoryName; counter = "Merges Abandoned"; instance = instance }
  /// Merges Installed: The number of merges successfully installed.
  let ``Merges Installed`` instance =
    { category = CategoryName; counter = "Merges Installed"; instance = instance }
  /// Total Files Merged: The total number of source files merged. This count can be used to find the average number of source files in the merge
  let ``Total Files Merged`` instance =
    { category = CategoryName; counter = "Total Files Merged"; instance = instance }

  let allCounters =
    [| ``Checkpoints Closed``
       ``Checkpoints Completed``
       ``Core Merges Completed``
       ``Merge Policy Evaluations``
       ``Merge Requests Outstanding``
       ``Merges Abandoned``
       ``Merges Installed``
       ``Total Files Merged``
    |]

/// XTP Transaction Log: The XTP Transaction Log performance object contains counters related to XTP transaction logging in SQL Server.
///
/// This performance counter does not have non-instance based counters
module ``XTP Transaction Log`` =

  [<Literal>]
  let CategoryName = "XTP Transaction Log"

  let PCC = Category.create CategoryName
  /// Log bytes written/sec: The number of bytes written to the SQL Server transaction log by the XTP engine (on average), per second.
  let ``Log bytes written/sec`` instance =
    { category = CategoryName; counter = "Log bytes written/sec"; instance = instance }
  /// Log records written/sec: The number of records written to the SQL Server transaction log by the XTP engine (on average), per second.
  let ``Log records written/sec`` instance =
    { category = CategoryName; counter = "Log records written/sec"; instance = instance }

  let allCounters =
    [| ``Log bytes written/sec``
       ``Log records written/sec``
    |]

/// XTP Transactions: The XTP Transactions performance object contains counters related to XTP engine transactions in SQL Server.
///
/// This performance counter does not have non-instance based counters
module ``XTP Transactions`` =

  [<Literal>]
  let CategoryName = "XTP Transactions"

  let PCC = Category.create CategoryName
  /// Cascading aborts/sec: The number of transactions that rolled back to due a commit dependency rollback (on average), per second.
  let ``Cascading aborts/sec`` instance =
    { category = CategoryName; counter = "Cascading aborts/sec"; instance = instance }
  /// Commit dependencies taken/sec: The number of commit dependencies taken by transactions (on average), per second.
  let ``Commit dependencies taken/sec`` instance =
    { category = CategoryName; counter = "Commit dependencies taken/sec"; instance = instance }
  /// Read-only transactions prepared/sec: The number of read-only transactions that were prepared for commit processing, per second.
  let ``Read-only transactions prepared/sec`` instance =
    { category = CategoryName; counter = "Read-only transactions prepared/sec"; instance = instance }
  /// Save point refreshes/sec: The number of times a savepoint was "refreshed", (on average), per second. A savepoint refresh is when an existing savepoint is reset to the current point in the transaction's lifetime.
  let ``Save point refreshes/sec`` instance =
    { category = CategoryName; counter = "Save point refreshes/sec"; instance = instance }
  /// Save point rollbacks/sec: The number of times a transaction rolled back to a save point (on average), per second.
  let ``Save point rollbacks/sec`` instance =
    { category = CategoryName; counter = "Save point rollbacks/sec"; instance = instance }
  /// Save points created/sec: The number of save points created (on average), per second.
  let ``Save points created/sec`` instance =
    { category = CategoryName; counter = "Save points created/sec"; instance = instance }
  /// Transaction validation failures/sec: The number of transactions that failed validation processing (on average), per second.
  let ``Transaction validation failures/sec`` instance =
    { category = CategoryName; counter = "Transaction validation failures/sec"; instance = instance }
  /// Transactions aborted by user/sec: The number of transactions that were aborted by the user (on average), per second.
  let ``Transactions aborted by user/sec`` instance =
    { category = CategoryName; counter = "Transactions aborted by user/sec"; instance = instance }
  /// Transactions aborted/sec: The number of transactions that aborted (both by the user and the system, on average), per second.
  let ``Transactions aborted/sec`` instance =
    { category = CategoryName; counter = "Transactions aborted/sec"; instance = instance }
  /// Transactions created/sec: The number of transactions created in the system (on average), per second.
  let ``Transactions created/sec`` instance =
    { category = CategoryName; counter = "Transactions created/sec"; instance = instance }

  let allCounters =
    [| ``Cascading aborts/sec``
       ``Commit dependencies taken/sec``
       ``Read-only transactions prepared/sec``
       ``Save point refreshes/sec``
       ``Save point rollbacks/sec``
       ``Save points created/sec``
       ``Transaction validation failures/sec``
       ``Transactions aborted by user/sec``
       ``Transactions aborted/sec``
       ``Transactions created/sec``
    |]
