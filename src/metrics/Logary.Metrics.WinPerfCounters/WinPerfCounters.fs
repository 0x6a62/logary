/// Copyright Henrik Feldt 2016. Part of the Logary source code.
/// An autogenerated file with all performance counters found on a Windows 8.1 system
module Logary.Metrics.AllWinPerfCounters

open System
open System.Diagnostics
open Logary.Metrics.WinPerfCounter
/// .NET CLR Data: .Net CLR Data
///
/// This performance counter does not have instance based counters
module ``_NET CLR Data`` =

  [<Literal>]
  let Category = ".NET CLR Data"

  let PCC = getPCC Category
  /// SqlClient: Current # connection pools: -
  let ``SqlClient: Current # connection pools`` instance =
    { category = ".NET CLR Data"; counter = "SqlClient: Current # connection pools"; instance = instance }
  /// SqlClient: Current # pooled and nonpooled connections: -
  let ``SqlClient: Current # pooled and nonpooled connections`` instance =
    { category = ".NET CLR Data"; counter = "SqlClient: Current # pooled and nonpooled connections"; instance = instance }
  /// SqlClient: Current # pooled connections: -
  let ``SqlClient: Current # pooled connections`` instance =
    { category = ".NET CLR Data"; counter = "SqlClient: Current # pooled connections"; instance = instance }
  /// SqlClient: Peak # pooled connections: -
  let ``SqlClient: Peak # pooled connections`` instance =
    { category = ".NET CLR Data"; counter = "SqlClient: Peak # pooled connections"; instance = instance }
  /// SqlClient: Total # failed commands: -
  let ``SqlClient: Total # failed commands`` instance =
    { category = ".NET CLR Data"; counter = "SqlClient: Total # failed commands"; instance = instance }
  /// SqlClient: Total # failed connects: -
  let ``SqlClient: Total # failed connects`` instance =
    { category = ".NET CLR Data"; counter = "SqlClient: Total # failed connects"; instance = instance }

  let allCounters =
    [ ``SqlClient: Current # connection pools``
      ``SqlClient: Current # pooled and nonpooled connections``
      ``SqlClient: Current # pooled connections``
      ``SqlClient: Peak # pooled connections``
      ``SqlClient: Total # failed commands``
      ``SqlClient: Total # failed connects``
    ]

/// .NET CLR Exceptions: Runtime statistics on CLR exception handling.
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR Exceptions`` =

  [<Literal>]
  let Category = ".NET CLR Exceptions"

  let PCC = getPCC Category
  /// # of Exceps Thrown: This counter displays the total number of exceptions thrown since the start of the application. These include both .NET exceptions and unmanaged exceptions that get converted into .NET exceptions e.g. null pointer reference exception in unmanaged code would get re-thrown in managed code as a .NET System.NullReferenceException; this counter includes both handled and unhandled exceptions. Exceptions that are re-thrown would get counted again. Exceptions should only occur in rare situations and not in the normal control flow of the program.
  let ``# of Exceps Thrown`` instance =
    { category = ".NET CLR Exceptions"; counter = "# of Exceps Thrown"; instance = instance }
  /// # of Exceps Thrown / sec: This counter displays the number of exceptions thrown per second. These include both .NET exceptions and unmanaged exceptions that get converted into .NET exceptions e.g. null pointer reference exception in unmanaged code would get re-thrown in managed code as a .NET System.NullReferenceException; this counter includes both handled and unhandled exceptions. Exceptions should only occur in rare situations and not in the normal control flow of the program; this counter was designed as an indicator of potential performance problems due to large (>100s) rate of exceptions thrown. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``# of Exceps Thrown / sec`` instance =
    { category = ".NET CLR Exceptions"; counter = "# of Exceps Thrown / sec"; instance = instance }
  /// # of Filters / sec: This counter displays the number of .NET exception filters executed per second. An exception filter evaluates whether an exception should be handled or not. This counter tracks the rate of exception filters evaluated; irrespective of whether the exception was handled or not. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``# of Filters / sec`` instance =
    { category = ".NET CLR Exceptions"; counter = "# of Filters / sec"; instance = instance }
  /// # of Finallys / sec: This counter displays the number of finally blocks executed per second. A finally block is guaranteed to be executed regardless of how the try block was exited. Only the finally blocks that are executed for an exception are counted; finally blocks on normal code paths are not counted by this counter. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``# of Finallys / sec`` instance =
    { category = ".NET CLR Exceptions"; counter = "# of Finallys / sec"; instance = instance }
  /// Throw To Catch Depth / sec: This counter displays the number of stack frames traversed from the frame that threw the .NET exception to the frame that handled the exception per second. This counter resets to 0 when an exception handler is entered; so nested exceptions would show the handler to handler stack depth. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``Throw To Catch Depth / sec`` instance =
    { category = ".NET CLR Exceptions"; counter = "Throw To Catch Depth / sec"; instance = instance }

  let allCounters =
    [ ``# of Exceps Thrown``
      ``# of Exceps Thrown / sec``
      ``# of Filters / sec``
      ``# of Finallys / sec``
      ``Throw To Catch Depth / sec``
    ]

/// .NET CLR Interop: Stats for CLR interop.
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR Interop`` =

  [<Literal>]
  let Category = ".NET CLR Interop"

  let PCC = getPCC Category
  /// # of CCWs: This counter displays the current number of Com-Callable-Wrappers (CCWs). A CCW is a proxy for the .NET managed object being referenced from unmanaged COM client(s). This counter was designed to indicate the number of managed objects being referenced by unmanaged COM code.
  let ``# of CCWs`` instance =
    { category = ".NET CLR Interop"; counter = "# of CCWs"; instance = instance }
  /// # of Stubs: This counter displays the current number of stubs created by the CLR. Stubs are responsible for marshalling arguments and return values from managed to unmanaged code and vice versa; during a COM Interop call or PInvoke call.
  let ``# of Stubs`` instance =
    { category = ".NET CLR Interop"; counter = "# of Stubs"; instance = instance }
  /// # of TLB exports / sec: Reserved for future use.
  let ``# of TLB exports / sec`` instance =
    { category = ".NET CLR Interop"; counter = "# of TLB exports / sec"; instance = instance }
  /// # of TLB imports / sec: Reserved for future use.
  let ``# of TLB imports / sec`` instance =
    { category = ".NET CLR Interop"; counter = "# of TLB imports / sec"; instance = instance }
  /// # of marshalling: This counter displays the total number of times arguments and return values have been marshaled from managed to unmanaged code and vice versa since the start of the application. This counter is not incremented if the stubs are inlined. (Stubs are responsible for marshalling arguments and return values). Stubs usually get inlined if the marshalling overhead is small.
  let ``# of marshalling`` instance =
    { category = ".NET CLR Interop"; counter = "# of marshalling"; instance = instance }

  let allCounters =
    [ ``# of CCWs``
      ``# of Stubs``
      ``# of TLB exports / sec``
      ``# of TLB imports / sec``
      ``# of marshalling``
    ]

/// .NET CLR Jit: Stats for CLR Jit.
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR Jit`` =

  [<Literal>]
  let Category = ".NET CLR Jit"

  let PCC = getPCC Category
  /// # of IL Bytes Jitted: This counter displays the total IL bytes jitted since the start of the application. This counter is exactly equivalent to the "Total # of IL Bytes Jitted" counter.
  let ``# of IL Bytes Jitted`` instance =
    { category = ".NET CLR Jit"; counter = "# of IL Bytes Jitted"; instance = instance }
  /// # of Methods Jitted: This counter displays the total number of methods compiled Just-In-Time (JIT) by the CLR JIT compiler since the start of the application. This counter does not include the pre-jitted methods.
  let ``# of Methods Jitted`` instance =
    { category = ".NET CLR Jit"; counter = "# of Methods Jitted"; instance = instance }
  /// % Time in Jit: This counter displays the percentage of elapsed time spent in JIT compilation since the last JIT compilation phase. This counter is updated at the end of every JIT compilation phase. A JIT compilation phase is the phase when a method and its dependencies are being compiled.
  let ``% Time in Jit`` instance =
    { category = ".NET CLR Jit"; counter = "% Time in Jit"; instance = instance }
  /// IL Bytes Jitted / sec: This counter displays the rate at which IL bytes are jitted per second. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``IL Bytes Jitted / sec`` instance =
    { category = ".NET CLR Jit"; counter = "IL Bytes Jitted / sec"; instance = instance }
  /// Not Displayed: Not Displayed.
  let ``Not Displayed`` instance =
    { category = ".NET CLR Jit"; counter = "Not Displayed"; instance = instance }
  /// Standard Jit Failures: This counter displays the peak number of methods the JIT compiler has failed to JIT since the start of the application. This failure can occur if the IL cannot be verified or if there was an internal error in the JIT compiler.
  let ``Standard Jit Failures`` instance =
    { category = ".NET CLR Jit"; counter = "Standard Jit Failures"; instance = instance }
  /// Total # of IL Bytes Jitted: This counter displays the total IL bytes jitted since the start of the application. This counter is exactly equivalent to the "# of IL Bytes Jitted" counter.
  let ``Total # of IL Bytes Jitted`` instance =
    { category = ".NET CLR Jit"; counter = "Total # of IL Bytes Jitted"; instance = instance }

  let allCounters =
    [ ``# of IL Bytes Jitted``
      ``# of Methods Jitted``
      ``% Time in Jit``
      ``IL Bytes Jitted / sec``
      ``Not Displayed``
      ``Standard Jit Failures``
      ``Total # of IL Bytes Jitted``
    ]

/// .NET CLR Loading: Statistics for CLR Class Loader.
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR Loading`` =

  [<Literal>]
  let Category = ".NET CLR Loading"

  let PCC = getPCC Category
  /// % Time Loading: Reserved for future use.
  let ``% Time Loading`` instance =
    { category = ".NET CLR Loading"; counter = "% Time Loading"; instance = instance }
  /// Assembly Search Length: Reserved for future use.
  let ``Assembly Search Length`` instance =
    { category = ".NET CLR Loading"; counter = "Assembly Search Length"; instance = instance }
  /// Bytes in Loader Heap: This counter displays the current size (in bytes) of the memory committed by the class loader across all AppDomains. (Committed memory is the physical memory for which space has been reserved on the disk paging file.)
  let ``Bytes in Loader Heap`` instance =
    { category = ".NET CLR Loading"; counter = "Bytes in Loader Heap"; instance = instance }
  /// Current Assemblies: This counter displays the current number of Assemblies loaded across all AppDomains in this application. If the Assembly is loaded as domain-neutral from multiple AppDomains then this counter is incremented once only. Assemblies can be loaded as domain-neutral when their code can be shared by all AppDomains or they can be loaded as domain-specific when their code is private to the AppDomain.
  let ``Current Assemblies`` instance =
    { category = ".NET CLR Loading"; counter = "Current Assemblies"; instance = instance }
  /// Current Classes Loaded: This counter displays the current number of classes loaded in all Assemblies.
  let ``Current Classes Loaded`` instance =
    { category = ".NET CLR Loading"; counter = "Current Classes Loaded"; instance = instance }
  /// Current appdomains: This counter displays the current number of AppDomains loaded in this application. AppDomains (application domains) provide a secure and versatile unit of processing that the CLR can use to provide isolation between applications running in the same process.
  let ``Current appdomains`` instance =
    { category = ".NET CLR Loading"; counter = "Current appdomains"; instance = instance }
  /// Rate of Assemblies: This counter displays the number of Assemblies loaded across all AppDomains per second. If the Assembly is loaded as domain-neutral from multiple AppDomains then this counter is incremented once only. Assemblies can be loaded as domain-neutral when their code can be shared by all AppDomains or they can be loaded as domain-specific when their code is private to the AppDomain. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``Rate of Assemblies`` instance =
    { category = ".NET CLR Loading"; counter = "Rate of Assemblies"; instance = instance }
  /// Rate of Classes Loaded: This counter displays the number of classes loaded per second in all Assemblies. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``Rate of Classes Loaded`` instance =
    { category = ".NET CLR Loading"; counter = "Rate of Classes Loaded"; instance = instance }
  /// Rate of Load Failures: This counter displays the number of classes that failed to load per second. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval. These load failures could be due to many reasons like inadequate security or illegal format. Full details can be found in the profiling services help.
  let ``Rate of Load Failures`` instance =
    { category = ".NET CLR Loading"; counter = "Rate of Load Failures"; instance = instance }
  /// Rate of appdomains: This counter displays the number of AppDomains loaded per second. AppDomains (application domains) provide a secure and versatile unit of processing that the CLR can use to provide isolation between applications running in the same process. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``Rate of appdomains`` instance =
    { category = ".NET CLR Loading"; counter = "Rate of appdomains"; instance = instance }
  /// Rate of appdomains unloaded: This counter displays the number of AppDomains unloaded per second. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``Rate of appdomains unloaded`` instance =
    { category = ".NET CLR Loading"; counter = "Rate of appdomains unloaded"; instance = instance }
  /// Total # of Load Failures: This counter displays the peak number of classes that have failed to load since the start of the application. These load failures could be due to many reasons like inadequate security or illegal format. Full details can be found in the profiling services help.
  let ``Total # of Load Failures`` instance =
    { category = ".NET CLR Loading"; counter = "Total # of Load Failures"; instance = instance }
  /// Total Appdomains: This counter displays the peak number of AppDomains loaded since the start of this application. AppDomains (application domains) provide a secure and versatile unit of processing that the CLR can use to provide isolation between applications running in the same process.
  let ``Total Appdomains`` instance =
    { category = ".NET CLR Loading"; counter = "Total Appdomains"; instance = instance }
  /// Total Assemblies: This counter displays the total number of Assemblies loaded since the start of this application. If the Assembly is loaded as domain-neutral from multiple AppDomains then this counter is incremented once only. Assemblies can be loaded as domain-neutral when their code can be shared by all AppDomains or they can be loaded as domain-specific when their code is private to the AppDomain.
  let ``Total Assemblies`` instance =
    { category = ".NET CLR Loading"; counter = "Total Assemblies"; instance = instance }
  /// Total Classes Loaded: This counter displays the cumulative number of classes loaded in all Assemblies since the start of this application.
  let ``Total Classes Loaded`` instance =
    { category = ".NET CLR Loading"; counter = "Total Classes Loaded"; instance = instance }
  /// Total appdomains unloaded: This counter displays the total number of AppDomains unloaded since the start of the application. If an AppDomain is loaded and unloaded multiple times this counter would count each of those unloads as separate.
  let ``Total appdomains unloaded`` instance =
    { category = ".NET CLR Loading"; counter = "Total appdomains unloaded"; instance = instance }

  let allCounters =
    [ ``% Time Loading``
      ``Assembly Search Length``
      ``Bytes in Loader Heap``
      ``Current Assemblies``
      ``Current Classes Loaded``
      ``Current appdomains``
      ``Rate of Assemblies``
      ``Rate of Classes Loaded``
      ``Rate of Load Failures``
      ``Rate of appdomains``
      ``Rate of appdomains unloaded``
      ``Total # of Load Failures``
      ``Total Appdomains``
      ``Total Assemblies``
      ``Total Classes Loaded``
      ``Total appdomains unloaded``
    ]

/// .NET CLR LocksAndThreads: Stats for CLR Locks and Threads.
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR LocksAndThreads`` =

  [<Literal>]
  let Category = ".NET CLR LocksAndThreads"

  let PCC = getPCC Category
  /// # of current logical Threads: This counter displays the number of current .NET thread objects in the application. A .NET thread object is created either by new System.Threading.Thread or when an unmanaged thread enters the managed environment. This counters maintains the count of both running and stopped threads. This counter is not an average over time; it just displays the last observed value.
  let ``# of current logical Threads`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "# of current logical Threads"; instance = instance }
  /// # of current physical Threads: This counter displays the number of native OS threads created and owned by the CLR to act as underlying threads for .NET thread objects. This counters value does not include the threads used by the CLR in its internal operations; it is a subset of the threads in the OS process.
  let ``# of current physical Threads`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "# of current physical Threads"; instance = instance }
  /// # of current recognized threads: This counter displays the number of threads that are currently recognized by the CLR; they have a corresponding .NET thread object associated with them. These threads are not created by the CLR; they are created outside the CLR but have since run inside the CLR at least once. Only unique threads are tracked; threads with same thread ID re-entering the CLR or recreated after thread exit are not counted twice.
  let ``# of current recognized threads`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "# of current recognized threads"; instance = instance }
  /// # of total recognized threads: This counter displays the total number of threads that have been recognized by the CLR since the start of this application; these threads have a corresponding .NET thread object associated with them. These threads are not created by the CLR; they are created outside the CLR but have since run inside the CLR at least once. Only unique threads are tracked; threads with same thread ID re-entering the CLR or recreated after thread exit are not counted twice.
  let ``# of total recognized threads`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "# of total recognized threads"; instance = instance }
  /// Contention Rate / sec: Rate at which threads in the runtime attempt to acquire a managed lock unsuccessfully. Managed locks can be acquired in many ways; by the "lock" statement in C# or by calling System.Monitor.Enter or by using MethodImplOptions.Synchronized custom attribute.
  let ``Contention Rate / sec`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "Contention Rate / sec"; instance = instance }
  /// Current Queue Length: This counter displays the total number of threads currently waiting to acquire some managed lock in the application. This counter is not an average over time; it displays the last observed value.
  let ``Current Queue Length`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "Current Queue Length"; instance = instance }
  /// Queue Length / sec: This counter displays the number of threads per second waiting to acquire some lock in the application. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``Queue Length / sec`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "Queue Length / sec"; instance = instance }
  /// Queue Length Peak: This counter displays the total number of threads that waited to acquire some managed lock since the start of the application.
  let ``Queue Length Peak`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "Queue Length Peak"; instance = instance }
  /// Total # of Contentions: This counter displays the total number of times threads in the CLR have attempted to acquire a managed lock unsuccessfully. Managed locks can be acquired in many ways; by the "lock" statement in C# or by calling System.Monitor.Enter or by using MethodImplOptions.Synchronized custom attribute.
  let ``Total # of Contentions`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "Total # of Contentions"; instance = instance }
  /// rate of recognized threads / sec: This counter displays the number of threads per second that have been recognized by the CLR; these threads have a corresponding .NET thread object associated with them. These threads are not created by the CLR; they are created outside the CLR but have since run inside the CLR at least once. Only unique threads are tracked; threads with same thread ID re-entering the CLR or recreated after thread exit are not counted twice. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``rate of recognized threads / sec`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "rate of recognized threads / sec"; instance = instance }

  let allCounters =
    [ ``# of current logical Threads``
      ``# of current physical Threads``
      ``# of current recognized threads``
      ``# of total recognized threads``
      ``Contention Rate / sec``
      ``Current Queue Length``
      ``Queue Length / sec``
      ``Queue Length Peak``
      ``Total # of Contentions``
      ``rate of recognized threads / sec``
    ]

/// .NET CLR Memory: Counters for CLR Garbage Collected heap.
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR Memory`` =

  [<Literal>]
  let Category = ".NET CLR Memory"

  let PCC = getPCC Category
  /// # Bytes in all Heaps: This counter is the sum of four other counters; Gen 0 Heap Size; Gen 1 Heap Size; Gen 2 Heap Size and the Large Object Heap Size. This counter indicates the current memory allocated in bytes on the GC Heaps.
  let ``# Bytes in all Heaps`` instance =
    { category = ".NET CLR Memory"; counter = "# Bytes in all Heaps"; instance = instance }
  /// # GC Handles: This counter displays the current number of GC Handles in use. GCHandles are handles to resources external to the CLR and the managed environment. Handles occupy small amounts of memory in the GCHeap but potentially expensive unmanaged resources.
  let ``# GC Handles`` instance =
    { category = ".NET CLR Memory"; counter = "# GC Handles"; instance = instance }
  /// # Gen 0 Collections: This counter displays the number of times the generation 0 objects (youngest; most recently allocated) are garbage collected (Gen 0 GC) since the start of the application. Gen 0 GC occurs when the available memory in generation 0 is not sufficient to satisfy an allocation request. This counter is incremented at the end of a Gen 0 GC. Higher generation GCs include all lower generation GCs. This counter is explicitly incremented when a higher generation (Gen 1 or Gen 2) GC occurs. _Global_ counter value is not accurate and should be ignored. This counter displays the last observed value.
  let ``# Gen 0 Collections`` instance =
    { category = ".NET CLR Memory"; counter = "# Gen 0 Collections"; instance = instance }
  /// # Gen 1 Collections: This counter displays the number of times the generation 1 objects are garbage collected since the start of the application. The counter is incremented at the end of a Gen 1 GC. Higher generation GCs include all lower generation GCs. This counter is explicitly incremented when a higher generation (Gen 2) GC occurs. _Global_ counter value is not accurate and should be ignored. This counter displays the last observed value.
  let ``# Gen 1 Collections`` instance =
    { category = ".NET CLR Memory"; counter = "# Gen 1 Collections"; instance = instance }
  /// # Gen 2 Collections: This counter displays the number of times the generation 2 objects (older) are garbage collected since the start of the application. The counter is incremented at the end of a Gen 2 GC (also called full GC). _Global_ counter value is not accurate and should be ignored. This counter displays the last observed value.
  let ``# Gen 2 Collections`` instance =
    { category = ".NET CLR Memory"; counter = "# Gen 2 Collections"; instance = instance }
  /// # Induced GC: This counter displays the peak number of times a garbage collection was performed because of an explicit call to GC.Collect. Its a good practice to let the GC tune the frequency of its collections.
  let ``# Induced GC`` instance =
    { category = ".NET CLR Memory"; counter = "# Induced GC"; instance = instance }
  /// # Total committed Bytes: This counter displays the amount of virtual memory (in bytes) currently committed by the Garbage Collector. (Committed memory is the physical memory for which space has been reserved on the disk paging file).
  let ``# Total committed Bytes`` instance =
    { category = ".NET CLR Memory"; counter = "# Total committed Bytes"; instance = instance }
  /// # Total reserved Bytes: This counter displays the amount of virtual memory (in bytes) currently reserved by the Garbage Collector. (Reserved memory is the virtual memory space reserved for the application but no disk or main memory pages have been used.)
  let ``# Total reserved Bytes`` instance =
    { category = ".NET CLR Memory"; counter = "# Total reserved Bytes"; instance = instance }
  /// # of Pinned Objects: This counter displays the number of pinned objects encountered in the last GC. This counter tracks the pinned objects only in the heaps that were garbage collected e.g. a Gen 0 GC would cause enumeration of pinned objects in the generation 0 heap only. A pinned object is one that the Garbage Collector cannot move in memory.
  let ``# of Pinned Objects`` instance =
    { category = ".NET CLR Memory"; counter = "# of Pinned Objects"; instance = instance }
  /// # of Sink Blocks in use: This counter displays the current number of sync blocks in use. Sync blocks are per-object data structures allocated for storing synchronization information. Sync blocks hold weak references to managed objects and need to be scanned by the Garbage Collector. Sync blocks are not limited to storing synchronization information and can also store COM interop metadata. This counter was designed to indicate performance problems with heavy use of synchronization primitives.
  let ``# of Sink Blocks in use`` instance =
    { category = ".NET CLR Memory"; counter = "# of Sink Blocks in use"; instance = instance }
  /// % Time in GC: % Time in GC is the percentage of elapsed time that was spent in performing a garbage collection (GC) since the last GC cycle. This counter is usually an indicator of the work done by the Garbage Collector on behalf of the application to collect and compact memory. This counter is updated only at the end of every GC and the counter value reflects the last observed value; its not an average.
  let ``% Time in GC`` instance =
    { category = ".NET CLR Memory"; counter = "% Time in GC"; instance = instance }
  /// Allocated Bytes/sec: This counter displays the rate of bytes per second allocated on the GC Heap. This counter is updated at the end of every GC; not at each allocation. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``Allocated Bytes/sec`` instance =
    { category = ".NET CLR Memory"; counter = "Allocated Bytes/sec"; instance = instance }
  /// Finalization Survivors: This counter displays the number of garbage collected objects that survive a collection because they are waiting to be finalized. If these objects hold references to other objects then those objects also survive but are not counted by this counter; the "Promoted Finalization-Memory from Gen 0" and "Promoted Finalization-Memory from Gen 1" counters represent all the memory that survived due to finalization. This counter is not a cumulative counter; its updated at the end of every GC with count of the survivors during that particular GC only. This counter was designed to indicate the extra overhead that the application might incur because of finalization.
  let ``Finalization Survivors`` instance =
    { category = ".NET CLR Memory"; counter = "Finalization Survivors"; instance = instance }
  /// Gen 0 Promoted Bytes/Sec: This counter displays the bytes per second that are promoted from generation 0 (youngest) to generation 1; objects that are promoted just because they are waiting to be finalized are not included in this counter. Memory is promoted when it survives a garbage collection. This counter was designed as an indicator of relatively long-lived objects being created per sec. This counter displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``Gen 0 Promoted Bytes/Sec`` instance =
    { category = ".NET CLR Memory"; counter = "Gen 0 Promoted Bytes/Sec"; instance = instance }
  /// Gen 0 heap size: This counter displays the maximum bytes that can be allocated in generation 0 (Gen 0); its does not indicate the current number of bytes allocated in Gen 0. A Gen 0 GC is triggered when the allocations since the last GC exceed this size. The Gen 0 size is tuned by the Garbage Collector and can change during the execution of the application. At the end of a Gen 0 collection the size of the Gen 0 heap is infact 0 bytes; this counter displays the size (in bytes) of allocations that would trigger the next Gen 0 GC. This counter is updated at the end of a GC; its not updated on every allocation.
  let ``Gen 0 heap size`` instance =
    { category = ".NET CLR Memory"; counter = "Gen 0 heap size"; instance = instance }
  /// Gen 1 Promoted Bytes/Sec: This counter displays the bytes per second that are promoted from generation 1 to generation 2 (oldest); objects that are promoted just because they are waiting to be finalized are not included in this counter. Memory is promoted when it survives a garbage collection. Nothing is promoted from generation 2 since it is the oldest. This counter was designed as an indicator of very long-lived objects being created per sec. This counter displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``Gen 1 Promoted Bytes/Sec`` instance =
    { category = ".NET CLR Memory"; counter = "Gen 1 Promoted Bytes/Sec"; instance = instance }
  /// Gen 1 heap size: This counter displays the current number of bytes in generation 1 (Gen 1); this counter does not display the maximum size of Gen 1. Objects are not directly allocated in this generation; they are promoted from previous Gen 0 GCs. This counter is updated at the end of a GC; its not updated on every allocation.
  let ``Gen 1 heap size`` instance =
    { category = ".NET CLR Memory"; counter = "Gen 1 heap size"; instance = instance }
  /// Gen 2 heap size: This counter displays the current number of bytes in generation 2 (Gen 2). Objects are not directly allocated in this generation; they are promoted from Gen 1 during previous Gen 1 GCs. This counter is updated at the end of a GC; its not updated on every allocation.
  let ``Gen 2 heap size`` instance =
    { category = ".NET CLR Memory"; counter = "Gen 2 heap size"; instance = instance }
  /// Large Object Heap size: This counter displays the current size of the Large Object Heap in bytes. Objects greater than a threshold are treated as large objects by the Garbage Collector and are directly allocated in a special heap; they are not promoted through the generations. In CLR v1.1 and above this threshold is equal to 85000 bytes. This counter is updated at the end of a GC; it’s not updated on every allocation.
  let ``Large Object Heap size`` instance =
    { category = ".NET CLR Memory"; counter = "Large Object Heap size"; instance = instance }
  /// Not Displayed: Not Displayed.
  let ``Not Displayed`` instance =
    { category = ".NET CLR Memory"; counter = "Not Displayed"; instance = instance }
  /// Process ID: This counter displays the process ID of the CLR process instance being monitored. The value displayed will be 0 until after the first garbage collection.
  let ``Process ID`` instance =
    { category = ".NET CLR Memory"; counter = "Process ID"; instance = instance }
  /// Promoted Finalization-Memory from Gen 0: This counter displays the bytes of memory that are promoted from generation 0 to generation 1 just because they are waiting to be finalized. This counter displays the value observed at the end of the last GC; its not a cumulative counter.
  let ``Promoted Finalization-Memory from Gen 0`` instance =
    { category = ".NET CLR Memory"; counter = "Promoted Finalization-Memory from Gen 0"; instance = instance }
  /// Promoted Memory from Gen 0: This counter displays the bytes of memory that survive garbage collection (GC) and are promoted from generation 0 to generation 1; objects that are promoted just because they are waiting to be finalized are not included in this counter. This counter displays the value observed at the end of the last GC; its not a cumulative counter.
  let ``Promoted Memory from Gen 0`` instance =
    { category = ".NET CLR Memory"; counter = "Promoted Memory from Gen 0"; instance = instance }
  /// Promoted Memory from Gen 1: This counter displays the bytes of memory that survive garbage collection (GC) and are promoted from generation 1 to generation 2; objects that are promoted just because they are waiting to be finalized are not included in this counter. This counter displays the value observed at the end of the last GC; its not a cumulative counter. This counter is reset to 0 if the last GC was a Gen 0 GC only.
  let ``Promoted Memory from Gen 1`` instance =
    { category = ".NET CLR Memory"; counter = "Promoted Memory from Gen 1"; instance = instance }

  let allCounters =
    [ ``# Bytes in all Heaps``
      ``# GC Handles``
      ``# Gen 0 Collections``
      ``# Gen 1 Collections``
      ``# Gen 2 Collections``
      ``# Induced GC``
      ``# Total committed Bytes``
      ``# Total reserved Bytes``
      ``# of Pinned Objects``
      ``# of Sink Blocks in use``
      ``% Time in GC``
      ``Allocated Bytes/sec``
      ``Finalization Survivors``
      ``Gen 0 Promoted Bytes/Sec``
      ``Gen 0 heap size``
      ``Gen 1 Promoted Bytes/Sec``
      ``Gen 1 heap size``
      ``Gen 2 heap size``
      ``Large Object Heap size``
      ``Not Displayed``
      ``Process ID``
      ``Promoted Finalization-Memory from Gen 0``
      ``Promoted Memory from Gen 0``
      ``Promoted Memory from Gen 1``
    ]

/// .NET CLR Networking: Help not available.
///
/// This performance counter does not have instance based counters
module ``_NET CLR Networking`` =

  [<Literal>]
  let Category = ".NET CLR Networking"

  let PCC = getPCC Category
  /// Bytes Received: -
  let ``Bytes Received`` instance =
    { category = ".NET CLR Networking"; counter = "Bytes Received"; instance = instance }
  /// Bytes Sent: -
  let ``Bytes Sent`` instance =
    { category = ".NET CLR Networking"; counter = "Bytes Sent"; instance = instance }
  /// Connections Established: -
  let ``Connections Established`` instance =
    { category = ".NET CLR Networking"; counter = "Connections Established"; instance = instance }
  /// Datagrams Received: -
  let ``Datagrams Received`` instance =
    { category = ".NET CLR Networking"; counter = "Datagrams Received"; instance = instance }
  /// Datagrams Sent: -
  let ``Datagrams Sent`` instance =
    { category = ".NET CLR Networking"; counter = "Datagrams Sent"; instance = instance }

  let allCounters =
    [ ``Bytes Received``
      ``Bytes Sent``
      ``Connections Established``
      ``Datagrams Received``
      ``Datagrams Sent``
    ]

/// .NET CLR Networking 4.0.0.0: Counters for classes in the System.Net namespace.
///
/// This performance counter does not have instance based counters
module ``_NET CLR Networking 4_0_0_0`` =

  [<Literal>]
  let Category = ".NET CLR Networking 4.0.0.0"

  let PCC = getPCC Category
  /// Bytes Received: -
  let ``Bytes Received`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "Bytes Received"; instance = instance }
  /// Bytes Sent: -
  let ``Bytes Sent`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "Bytes Sent"; instance = instance }
  /// Connections Established: -
  let ``Connections Established`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "Connections Established"; instance = instance }
  /// Datagrams Received: -
  let ``Datagrams Received`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "Datagrams Received"; instance = instance }
  /// Datagrams Sent: -
  let ``Datagrams Sent`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "Datagrams Sent"; instance = instance }
  /// HttpWebRequests Aborted/Sec: -
  let ``HttpWebRequests Aborted/Sec`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "HttpWebRequests Aborted/Sec"; instance = instance }
  /// HttpWebRequests Average Lifetime: -
  let ``HttpWebRequests Average Lifetime`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "HttpWebRequests Average Lifetime"; instance = instance }
  /// HttpWebRequests Average Lifetime Base: -
  let ``HttpWebRequests Average Lifetime Base`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "HttpWebRequests Average Lifetime Base"; instance = instance }
  /// HttpWebRequests Average Queue Time: -
  let ``HttpWebRequests Average Queue Time`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "HttpWebRequests Average Queue Time"; instance = instance }
  /// HttpWebRequests Average Queue Time Base: -
  let ``HttpWebRequests Average Queue Time Base`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "HttpWebRequests Average Queue Time Base"; instance = instance }
  /// HttpWebRequests Created/Sec: -
  let ``HttpWebRequests Created/Sec`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "HttpWebRequests Created/Sec"; instance = instance }
  /// HttpWebRequests Failed/Sec: -
  let ``HttpWebRequests Failed/Sec`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "HttpWebRequests Failed/Sec"; instance = instance }
  /// HttpWebRequests Queued/Sec: -
  let ``HttpWebRequests Queued/Sec`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "HttpWebRequests Queued/Sec"; instance = instance }

  let allCounters =
    [ ``Bytes Received``
      ``Bytes Sent``
      ``Connections Established``
      ``Datagrams Received``
      ``Datagrams Sent``
      ``HttpWebRequests Aborted/Sec``
      ``HttpWebRequests Average Lifetime``
      ``HttpWebRequests Average Lifetime Base``
      ``HttpWebRequests Average Queue Time``
      ``HttpWebRequests Average Queue Time Base``
      ``HttpWebRequests Created/Sec``
      ``HttpWebRequests Failed/Sec``
      ``HttpWebRequests Queued/Sec``
    ]

/// .NET CLR Remoting: Stats for CLR Remoting.
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR Remoting`` =

  [<Literal>]
  let Category = ".NET CLR Remoting"

  let PCC = getPCC Category
  /// Channels: This counter displays the total number of remoting channels registered across all AppDomains since the start of the application. Channels are used to transport messages to and from remote objects.
  let ``Channels`` instance =
    { category = ".NET CLR Remoting"; counter = "Channels"; instance = instance }
  /// Context Proxies: This counter displays the total number of remoting proxy objects created in this process since the start of the process. Proxy object acts as a representative of the remote objects and ensures that all calls made on the proxy are forwarded to the correct remote object instance.
  let ``Context Proxies`` instance =
    { category = ".NET CLR Remoting"; counter = "Context Proxies"; instance = instance }
  /// Context-Bound Classes Loaded: This counter displays the current number of context-bound classes loaded. Classes that can be bound to a context are called context-bound classes; context-bound classes are marked with Context Attributes which provide usage rules for synchronization; thread affinity; transactions etc.
  let ``Context-Bound Classes Loaded`` instance =
    { category = ".NET CLR Remoting"; counter = "Context-Bound Classes Loaded"; instance = instance }
  /// Context-Bound Objects Alloc / sec: This counter displays the number of context-bound objects allocated per second. Instances of classes that can be bound to a context are called context-bound objects; context-bound classes are marked with Context Attributes which provide usage rules for synchronization; thread affinity; transactions etc. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``Context-Bound Objects Alloc / sec`` instance =
    { category = ".NET CLR Remoting"; counter = "Context-Bound Objects Alloc / sec"; instance = instance }
  /// Contexts: This counter displays the current number of remoting contexts in the application. A context is a boundary containing a collection of objects with the same usage rules like synchronization; thread affinity; transactions etc.
  let ``Contexts`` instance =
    { category = ".NET CLR Remoting"; counter = "Contexts"; instance = instance }
  /// Remote Calls/sec: This counter displays the number of remote procedure calls invoked per second. A remote procedure call is a call on any object outside the caller;s AppDomain. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``Remote Calls/sec`` instance =
    { category = ".NET CLR Remoting"; counter = "Remote Calls/sec"; instance = instance }
  /// Total Remote Calls: This counter displays the total number of remote procedure calls invoked since the start of this application. A remote procedure call is a call on any object outside the caller;s AppDomain.
  let ``Total Remote Calls`` instance =
    { category = ".NET CLR Remoting"; counter = "Total Remote Calls"; instance = instance }

  let allCounters =
    [ ``Channels``
      ``Context Proxies``
      ``Context-Bound Classes Loaded``
      ``Context-Bound Objects Alloc / sec``
      ``Contexts``
      ``Remote Calls/sec``
      ``Total Remote Calls``
    ]

/// .NET CLR Security: Stats for CLR Security.
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR Security`` =

  [<Literal>]
  let Category = ".NET CLR Security"

  let PCC = getPCC Category
  /// # Link Time Checks: This counter displays the total number of linktime Code Access Security (CAS) checks since the start of the application. Linktime CAS checks are performed when a caller makes a call to a callee demanding a particular permission at JIT compile time; linktime check is performed once per caller. This count is not indicative of serious performance issues; its indicative of the security system activity.
  let ``# Link Time Checks`` instance =
    { category = ".NET CLR Security"; counter = "# Link Time Checks"; instance = instance }
  /// % Time Sig. Authenticating: Reserved for future use.
  let ``% Time Sig. Authenticating`` instance =
    { category = ".NET CLR Security"; counter = "% Time Sig. Authenticating"; instance = instance }
  /// % Time in RT checks: This counter displays the percentage of elapsed time spent in performing runtime Code Access Security (CAS) checks since the last such check. CAS allows code to be trusted to varying degrees and enforces these varying levels of trust depending on code identity. This counter is updated at the end of a runtime security check; it represents the last observed value; its not an average.
  let ``% Time in RT checks`` instance =
    { category = ".NET CLR Security"; counter = "% Time in RT checks"; instance = instance }
  /// Not Displayed: Not Displayed.
  let ``Not Displayed`` instance =
    { category = ".NET CLR Security"; counter = "Not Displayed"; instance = instance }
  /// Stack Walk Depth: This counter displays the depth of the stack during that last runtime Code Access Security check. Runtime Code Access Security check is performed by crawling the stack. This counter is not an average; it just displays the last observed value.
  let ``Stack Walk Depth`` instance =
    { category = ".NET CLR Security"; counter = "Stack Walk Depth"; instance = instance }
  /// Total Runtime Checks: This counter displays the total number of runtime Code Access Security (CAS) checks performed since the start of the application. Runtime CAS checks are performed when a caller makes a call to a callee demanding a particular permission; the runtime check is made on every call by the caller; the check is done by examining the current thread stack of the caller. This counter used together with "Stack Walk Depth" is indicative of performance penalty for security checks.
  let ``Total Runtime Checks`` instance =
    { category = ".NET CLR Security"; counter = "Total Runtime Checks"; instance = instance }

  let allCounters =
    [ ``# Link Time Checks``
      ``% Time Sig. Authenticating``
      ``% Time in RT checks``
      ``Not Displayed``
      ``Stack Walk Depth``
      ``Total Runtime Checks``
    ]

/// .NET Data Provider for Oracle: Counters for System.Data.OracleClient
///
/// This performance counter does not have instance based counters
module ``_NET Data Provider for Oracle`` =

  [<Literal>]
  let Category = ".NET Data Provider for Oracle"

  let PCC = getPCC Category
  /// HardConnectsPerSecond: -
  let ``HardConnectsPerSecond`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "HardConnectsPerSecond"; instance = instance }
  /// HardDisconnectsPerSecond: -
  let ``HardDisconnectsPerSecond`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "HardDisconnectsPerSecond"; instance = instance }
  /// NumberOfActiveConnectionPoolGroups: -
  let ``NumberOfActiveConnectionPoolGroups`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "NumberOfActiveConnectionPoolGroups"; instance = instance }
  /// NumberOfActiveConnectionPools: -
  let ``NumberOfActiveConnectionPools`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "NumberOfActiveConnectionPools"; instance = instance }
  /// NumberOfActiveConnections: -
  let ``NumberOfActiveConnections`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "NumberOfActiveConnections"; instance = instance }
  /// NumberOfFreeConnections: -
  let ``NumberOfFreeConnections`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "NumberOfFreeConnections"; instance = instance }
  /// NumberOfInactiveConnectionPoolGroups: -
  let ``NumberOfInactiveConnectionPoolGroups`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "NumberOfInactiveConnectionPoolGroups"; instance = instance }
  /// NumberOfInactiveConnectionPools: -
  let ``NumberOfInactiveConnectionPools`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "NumberOfInactiveConnectionPools"; instance = instance }
  /// NumberOfNonPooledConnections: -
  let ``NumberOfNonPooledConnections`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "NumberOfNonPooledConnections"; instance = instance }
  /// NumberOfPooledConnections: -
  let ``NumberOfPooledConnections`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "NumberOfPooledConnections"; instance = instance }
  /// NumberOfReclaimedConnections: -
  let ``NumberOfReclaimedConnections`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "NumberOfReclaimedConnections"; instance = instance }
  /// NumberOfStasisConnections: -
  let ``NumberOfStasisConnections`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "NumberOfStasisConnections"; instance = instance }
  /// SoftConnectsPerSecond: -
  let ``SoftConnectsPerSecond`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "SoftConnectsPerSecond"; instance = instance }
  /// SoftDisconnectsPerSecond: -
  let ``SoftDisconnectsPerSecond`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "SoftDisconnectsPerSecond"; instance = instance }

  let allCounters =
    [ ``HardConnectsPerSecond``
      ``HardDisconnectsPerSecond``
      ``NumberOfActiveConnectionPoolGroups``
      ``NumberOfActiveConnectionPools``
      ``NumberOfActiveConnections``
      ``NumberOfFreeConnections``
      ``NumberOfInactiveConnectionPoolGroups``
      ``NumberOfInactiveConnectionPools``
      ``NumberOfNonPooledConnections``
      ``NumberOfPooledConnections``
      ``NumberOfReclaimedConnections``
      ``NumberOfStasisConnections``
      ``SoftConnectsPerSecond``
      ``SoftDisconnectsPerSecond``
    ]

/// .NET Data Provider for SqlServer: Counters for System.Data.SqlClient
///
/// This performance counter does not have instance based counters
module ``_NET Data Provider for SqlServer`` =

  [<Literal>]
  let Category = ".NET Data Provider for SqlServer"

  let PCC = getPCC Category
  /// HardConnectsPerSecond: -
  let ``HardConnectsPerSecond`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "HardConnectsPerSecond"; instance = instance }
  /// HardDisconnectsPerSecond: -
  let ``HardDisconnectsPerSecond`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "HardDisconnectsPerSecond"; instance = instance }
  /// NumberOfActiveConnectionPoolGroups: -
  let ``NumberOfActiveConnectionPoolGroups`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "NumberOfActiveConnectionPoolGroups"; instance = instance }
  /// NumberOfActiveConnectionPools: -
  let ``NumberOfActiveConnectionPools`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "NumberOfActiveConnectionPools"; instance = instance }
  /// NumberOfActiveConnections: -
  let ``NumberOfActiveConnections`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "NumberOfActiveConnections"; instance = instance }
  /// NumberOfFreeConnections: -
  let ``NumberOfFreeConnections`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "NumberOfFreeConnections"; instance = instance }
  /// NumberOfInactiveConnectionPoolGroups: -
  let ``NumberOfInactiveConnectionPoolGroups`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "NumberOfInactiveConnectionPoolGroups"; instance = instance }
  /// NumberOfInactiveConnectionPools: -
  let ``NumberOfInactiveConnectionPools`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "NumberOfInactiveConnectionPools"; instance = instance }
  /// NumberOfNonPooledConnections: -
  let ``NumberOfNonPooledConnections`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "NumberOfNonPooledConnections"; instance = instance }
  /// NumberOfPooledConnections: -
  let ``NumberOfPooledConnections`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "NumberOfPooledConnections"; instance = instance }
  /// NumberOfReclaimedConnections: -
  let ``NumberOfReclaimedConnections`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "NumberOfReclaimedConnections"; instance = instance }
  /// NumberOfStasisConnections: -
  let ``NumberOfStasisConnections`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "NumberOfStasisConnections"; instance = instance }
  /// SoftConnectsPerSecond: -
  let ``SoftConnectsPerSecond`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "SoftConnectsPerSecond"; instance = instance }
  /// SoftDisconnectsPerSecond: -
  let ``SoftDisconnectsPerSecond`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "SoftDisconnectsPerSecond"; instance = instance }

  let allCounters =
    [ ``HardConnectsPerSecond``
      ``HardDisconnectsPerSecond``
      ``NumberOfActiveConnectionPoolGroups``
      ``NumberOfActiveConnectionPools``
      ``NumberOfActiveConnections``
      ``NumberOfFreeConnections``
      ``NumberOfInactiveConnectionPoolGroups``
      ``NumberOfInactiveConnectionPools``
      ``NumberOfNonPooledConnections``
      ``NumberOfPooledConnections``
      ``NumberOfReclaimedConnections``
      ``NumberOfStasisConnections``
      ``SoftConnectsPerSecond``
      ``SoftDisconnectsPerSecond``
    ]

/// ASP.NET: ASP.NET global performance counters
///
/// This performance counter does not have instance based counters
module ``ASP_NET`` =

  [<Literal>]
  let Category = "ASP.NET"

  let PCC = getPCC Category
  /// Application Restarts: Number of times the application has been restarted during the web server's lifetime.
  let ``Application Restarts`` =
    { category = "ASP.NET"; counter = "Application Restarts"; instance = NotApplicable }
  /// Applications Running: Number of currently running web applications.
  let ``Applications Running`` =
    { category = "ASP.NET"; counter = "Applications Running"; instance = NotApplicable }
  /// Audit Failure Events Raised: Number of audit failures in the application since it was started.
  let ``Audit Failure Events Raised`` =
    { category = "ASP.NET"; counter = "Audit Failure Events Raised"; instance = NotApplicable }
  /// Audit Success Events Raised: Number of audit successes in the application since it was started.
  let ``Audit Success Events Raised`` =
    { category = "ASP.NET"; counter = "Audit Success Events Raised"; instance = NotApplicable }
  /// Error Events Raised: Number of error events raised since the application was started.
  let ``Error Events Raised`` =
    { category = "ASP.NET"; counter = "Error Events Raised"; instance = NotApplicable }
  /// Infrastructure Error Events Raised: Number of HTTP error events raised since the application was started.
  let ``Infrastructure Error Events Raised`` =
    { category = "ASP.NET"; counter = "Infrastructure Error Events Raised"; instance = NotApplicable }
  /// Request Error Events Raised: Number of runtime error events raised since the application was started.
  let ``Request Error Events Raised`` =
    { category = "ASP.NET"; counter = "Request Error Events Raised"; instance = NotApplicable }
  /// Request Execution Time: The number of milliseconds that it took to execute the most recent request.
  let ``Request Execution Time`` =
    { category = "ASP.NET"; counter = "Request Execution Time"; instance = NotApplicable }
  /// Request Wait Time: The number of milliseconds the most recent request was waiting in the queue.
  let ``Request Wait Time`` =
    { category = "ASP.NET"; counter = "Request Wait Time"; instance = NotApplicable }
  /// Requests Current: The current number of requests, including those that are queued, currently executing, or waiting to be written to the client.  Under the ASP.NET process model, when this counter exceeds the requestQueueLimit defined in the processModel configuration section, ASP.NET will begin rejecting requests.
  let ``Requests Current`` =
    { category = "ASP.NET"; counter = "Requests Current"; instance = NotApplicable }
  /// Requests Disconnected: The number of requests disconnected due to communication errors or user terminated.
  let ``Requests Disconnected`` =
    { category = "ASP.NET"; counter = "Requests Disconnected"; instance = NotApplicable }
  /// Requests In Native Queue: Requests queued because the concurrency limits have been exceeded.
  let ``Requests In Native Queue`` =
    { category = "ASP.NET"; counter = "Requests In Native Queue"; instance = NotApplicable }
  /// Requests Queued: The number of requests waiting to be processed.
  let ``Requests Queued`` =
    { category = "ASP.NET"; counter = "Requests Queued"; instance = NotApplicable }
  /// Requests Rejected: The number of requests rejected because the request queue was full.
  let ``Requests Rejected`` =
    { category = "ASP.NET"; counter = "Requests Rejected"; instance = NotApplicable }
  /// State Server Sessions Abandoned: The number of sessions that have been explicitly abandoned.
  let ``State Server Sessions Abandoned`` =
    { category = "ASP.NET"; counter = "State Server Sessions Abandoned"; instance = NotApplicable }
  /// State Server Sessions Active: The current number of sessions currently active.
  let ``State Server Sessions Active`` =
    { category = "ASP.NET"; counter = "State Server Sessions Active"; instance = NotApplicable }
  /// State Server Sessions Timed Out: The number of sessions timed out.
  let ``State Server Sessions Timed Out`` =
    { category = "ASP.NET"; counter = "State Server Sessions Timed Out"; instance = NotApplicable }
  /// State Server Sessions Total: The number of sessions total.
  let ``State Server Sessions Total`` =
    { category = "ASP.NET"; counter = "State Server Sessions Total"; instance = NotApplicable }
  /// Worker Process Restarts: Number of times a worker process has restarted on the machine.
  let ``Worker Process Restarts`` =
    { category = "ASP.NET"; counter = "Worker Process Restarts"; instance = NotApplicable }
  /// Worker Processes Running: Number of worker processes running on the machine.
  let ``Worker Processes Running`` =
    { category = "ASP.NET"; counter = "Worker Processes Running"; instance = NotApplicable }

  let allCounters =
    [ ``Application Restarts``
      ``Applications Running``
      ``Audit Failure Events Raised``
      ``Audit Success Events Raised``
      ``Error Events Raised``
      ``Infrastructure Error Events Raised``
      ``Request Error Events Raised``
      ``Request Execution Time``
      ``Request Wait Time``
      ``Requests Current``
      ``Requests Disconnected``
      ``Requests In Native Queue``
      ``Requests Queued``
      ``Requests Rejected``
      ``State Server Sessions Abandoned``
      ``State Server Sessions Active``
      ``State Server Sessions Timed Out``
      ``State Server Sessions Total``
      ``Worker Process Restarts``
      ``Worker Processes Running``
    ]

/// ASP.NET Applications: ASP.NET application performance counters
///
/// This performance counter does not have non-instance based counters
module ``ASP_NET Applications`` =

  [<Literal>]
  let Category = "ASP.NET Applications"

  let PCC = getPCC Category
  /// % Managed Processor Time (estimated): Estimated percentage of elapsed time that the processor spends executing managed application code.  This counter only tracks processor time of managed threads in the application.  It does not include additional processor time spent executing on non-managed threads.  Note that this counter is only updated with new data every five seconds.
  let ``% Managed Processor Time (estimated)`` instance =
    { category = "ASP.NET Applications"; counter = "% Managed Processor Time (estimated)"; instance = instance }
  /// % Managed Processor Time Base (estimated): % Managed Processor Time Base (estimated)
  let ``% Managed Processor Time Base (estimated)`` instance =
    { category = "ASP.NET Applications"; counter = "% Managed Processor Time Base (estimated)"; instance = instance }
  /// Anonymous Requests: Number of requests utilizing anonymous authentication.
  let ``Anonymous Requests`` instance =
    { category = "ASP.NET Applications"; counter = "Anonymous Requests"; instance = instance }
  /// Anonymous Requests/Sec: Number of Authentication Anonymous Requests/Sec
  let ``Anonymous Requests/Sec`` instance =
    { category = "ASP.NET Applications"; counter = "Anonymous Requests/Sec"; instance = instance }
  /// Application Lifetime Events: Number of application events raised since the application was started.
  let ``Application Lifetime Events`` instance =
    { category = "ASP.NET Applications"; counter = "Application Lifetime Events"; instance = instance }
  /// Application Lifetime Events/Sec: Number of application events raised per second.
  let ``Application Lifetime Events/Sec`` instance =
    { category = "ASP.NET Applications"; counter = "Application Lifetime Events/Sec"; instance = instance }
  /// Audit Failure Events Raised: Number of audit failures in the application since it was started.
  let ``Audit Failure Events Raised`` instance =
    { category = "ASP.NET Applications"; counter = "Audit Failure Events Raised"; instance = instance }
  /// Audit Success Events Raised: Number of audit successes in the application since it was started.
  let ``Audit Success Events Raised`` instance =
    { category = "ASP.NET Applications"; counter = "Audit Success Events Raised"; instance = instance }
  /// Cache % Machine Memory Limit Used: The amount of physical memory used by the machine divided by the physical memory limit for the cache, as a percentage.  When this reaches 100%, half of the cache entries will be forcibly removed.  The __Total__ instance is the average of all instances, and therefore cannot be used to determine when cache entries will be forcibly removed.
  let ``Cache % Machine Memory Limit Used`` instance =
    { category = "ASP.NET Applications"; counter = "Cache % Machine Memory Limit Used"; instance = instance }
  /// Cache % Machine Memory Limit Used Base: Cache % Machine Memory Limit Used Base
  let ``Cache % Machine Memory Limit Used Base`` instance =
    { category = "ASP.NET Applications"; counter = "Cache % Machine Memory Limit Used Base"; instance = instance }
  /// Cache % Process Memory Limit Used: The value of private bytes for the worker process divided by the private bytes memory limit for the cache, as a percentage.  When this reaches 100%, half of the cache entries will be forcibly removed.  The __Total__ instance is the average of all instances, and therefore cannot be used to determine when cache entries will be forcibly removed.
  let ``Cache % Process Memory Limit Used`` instance =
    { category = "ASP.NET Applications"; counter = "Cache % Process Memory Limit Used"; instance = instance }
  /// Cache % Process Memory Limit Used Base: Cache % Process Memory Limit Used Base
  let ``Cache % Process Memory Limit Used Base`` instance =
    { category = "ASP.NET Applications"; counter = "Cache % Process Memory Limit Used Base"; instance = instance }
  /// Cache API Entries: Total number of entries within the cache added by the user.
  let ``Cache API Entries`` instance =
    { category = "ASP.NET Applications"; counter = "Cache API Entries"; instance = instance }
  /// Cache API Hit Ratio: Ratio of hits called from user code.
  let ``Cache API Hit Ratio`` instance =
    { category = "ASP.NET Applications"; counter = "Cache API Hit Ratio"; instance = instance }
  /// Cache API Hit Ratio Base: Cache API Hit Ratio Base
  let ``Cache API Hit Ratio Base`` instance =
    { category = "ASP.NET Applications"; counter = "Cache API Hit Ratio Base"; instance = instance }
  /// Cache API Hits: Number of cache hits from user code.
  let ``Cache API Hits`` instance =
    { category = "ASP.NET Applications"; counter = "Cache API Hits"; instance = instance }
  /// Cache API Misses: Number of cache misses called from user code.
  let ``Cache API Misses`` instance =
    { category = "ASP.NET Applications"; counter = "Cache API Misses"; instance = instance }
  /// Cache API Trims: Total number of entries forcibly removed from the cache due to memory pressure that were originally inserted into the cache using one of the public cache APIs.
  let ``Cache API Trims`` instance =
    { category = "ASP.NET Applications"; counter = "Cache API Trims"; instance = instance }
  /// Cache API Turnover Rate: Number of additions and removals to the API cache per second.
  let ``Cache API Turnover Rate`` instance =
    { category = "ASP.NET Applications"; counter = "Cache API Turnover Rate"; instance = instance }
  /// Cache Total Entries: Total number of entries within the cache (both internal and user added)
  let ``Cache Total Entries`` instance =
    { category = "ASP.NET Applications"; counter = "Cache Total Entries"; instance = instance }
  /// Cache Total Hit Ratio: Ratio of hits from all cache calls.
  let ``Cache Total Hit Ratio`` instance =
    { category = "ASP.NET Applications"; counter = "Cache Total Hit Ratio"; instance = instance }
  /// Cache Total Hit Ratio Base: Cache Total Hit Ratio Base
  let ``Cache Total Hit Ratio Base`` instance =
    { category = "ASP.NET Applications"; counter = "Cache Total Hit Ratio Base"; instance = instance }
  /// Cache Total Hits: Total number of hits from the cache.
  let ``Cache Total Hits`` instance =
    { category = "ASP.NET Applications"; counter = "Cache Total Hits"; instance = instance }
  /// Cache Total Misses: Total number of cache misses.
  let ``Cache Total Misses`` instance =
    { category = "ASP.NET Applications"; counter = "Cache Total Misses"; instance = instance }
  /// Cache Total Trims: Total number of entries forcibly removed from the cache due to memory pressure.
  let ``Cache Total Trims`` instance =
    { category = "ASP.NET Applications"; counter = "Cache Total Trims"; instance = instance }
  /// Cache Total Turnover Rate: Number of additions and removals to the total cache per second.
  let ``Cache Total Turnover Rate`` instance =
    { category = "ASP.NET Applications"; counter = "Cache Total Turnover Rate"; instance = instance }
  /// Compilations Total: Number of .asax, .ascx, .ashx, .asmx, or .aspx source files dynamically compiled.
  let ``Compilations Total`` instance =
    { category = "ASP.NET Applications"; counter = "Compilations Total"; instance = instance }
  /// Debugging Requests: Number of debugging requests processed.
  let ``Debugging Requests`` instance =
    { category = "ASP.NET Applications"; counter = "Debugging Requests"; instance = instance }
  /// Error Events Raised: Number of error events raised since the application was started.
  let ``Error Events Raised`` instance =
    { category = "ASP.NET Applications"; counter = "Error Events Raised"; instance = instance }
  /// Error Events Raised/Sec: Number of error events per second.
  let ``Error Events Raised/Sec`` instance =
    { category = "ASP.NET Applications"; counter = "Error Events Raised/Sec"; instance = instance }
  /// Errors During Compilation: Number of errors that have occurred during compilation.
  let ``Errors During Compilation`` instance =
    { category = "ASP.NET Applications"; counter = "Errors During Compilation"; instance = instance }
  /// Errors During Execution: Number of errors that have occurred during the processing of a request.
  let ``Errors During Execution`` instance =
    { category = "ASP.NET Applications"; counter = "Errors During Execution"; instance = instance }
  /// Errors During Preprocessing: Number of errors that have occurred during parsing and configuration.
  let ``Errors During Preprocessing`` instance =
    { category = "ASP.NET Applications"; counter = "Errors During Preprocessing"; instance = instance }
  /// Errors Total: Total number of errors occurred.
  let ``Errors Total`` instance =
    { category = "ASP.NET Applications"; counter = "Errors Total"; instance = instance }
  /// Errors Total/Sec: Rate of errors occurred.
  let ``Errors Total/Sec`` instance =
    { category = "ASP.NET Applications"; counter = "Errors Total/Sec"; instance = instance }
  /// Errors Unhandled During Execution: Number of errors not handled by user code, but by the default error handler.
  let ``Errors Unhandled During Execution`` instance =
    { category = "ASP.NET Applications"; counter = "Errors Unhandled During Execution"; instance = instance }
  /// Errors Unhandled During Execution/Sec: Rate of unhandled errors.
  let ``Errors Unhandled During Execution/Sec`` instance =
    { category = "ASP.NET Applications"; counter = "Errors Unhandled During Execution/Sec"; instance = instance }
  /// Events Raised: Total number of instrumentation events raised since the application was started.
  let ``Events Raised`` instance =
    { category = "ASP.NET Applications"; counter = "Events Raised"; instance = instance }
  /// Events Raised/Sec: Total number of instrumentation events per second.
  let ``Events Raised/Sec`` instance =
    { category = "ASP.NET Applications"; counter = "Events Raised/Sec"; instance = instance }
  /// Forms Authentication Failure: Number of failed forms authentication ticket validations since the application was started.
  let ``Forms Authentication Failure`` instance =
    { category = "ASP.NET Applications"; counter = "Forms Authentication Failure"; instance = instance }
  /// Forms Authentication Success: Number of successful forms authentication ticket validations since the application was started.
  let ``Forms Authentication Success`` instance =
    { category = "ASP.NET Applications"; counter = "Forms Authentication Success"; instance = instance }
  /// Infrastructure Error Events Raised: Number of HTTP error events raised since the application was started.
  let ``Infrastructure Error Events Raised`` instance =
    { category = "ASP.NET Applications"; counter = "Infrastructure Error Events Raised"; instance = instance }
  /// Infrastructure Error Events Raised/Sec: Number of HTTP error events raised per second.
  let ``Infrastructure Error Events Raised/Sec`` instance =
    { category = "ASP.NET Applications"; counter = "Infrastructure Error Events Raised/Sec"; instance = instance }
  /// Managed Memory Used (estimated): Estimated managed heap memory consumption (in KB) by the application.  The accuracy of this counter varies depending on the duration of elapsed time since the last full managed memory heap collection.  Note that this counter is only updated with new data every five seconds.
  let ``Managed Memory Used (estimated)`` instance =
    { category = "ASP.NET Applications"; counter = "Managed Memory Used (estimated)"; instance = instance }
  /// Membership Authentication Failure: Number of failed membership credential validations since the application was started.
  let ``Membership Authentication Failure`` instance =
    { category = "ASP.NET Applications"; counter = "Membership Authentication Failure"; instance = instance }
  /// Membership Authentication Success: Number of successful membership credential validations since the application was started.
  let ``Membership Authentication Success`` instance =
    { category = "ASP.NET Applications"; counter = "Membership Authentication Success"; instance = instance }
  /// Output Cache Entries: Current number of entries in the output cache.
  let ``Output Cache Entries`` instance =
    { category = "ASP.NET Applications"; counter = "Output Cache Entries"; instance = instance }
  /// Output Cache Hit Ratio: Ratio of hits to requests for output cacheable requests.
  let ``Output Cache Hit Ratio`` instance =
    { category = "ASP.NET Applications"; counter = "Output Cache Hit Ratio"; instance = instance }
  /// Output Cache Hit Ratio Base: Output Cache Hit Ratio Base
  let ``Output Cache Hit Ratio Base`` instance =
    { category = "ASP.NET Applications"; counter = "Output Cache Hit Ratio Base"; instance = instance }
  /// Output Cache Hits: Total number of output cacheable requests served from the output cache.
  let ``Output Cache Hits`` instance =
    { category = "ASP.NET Applications"; counter = "Output Cache Hits"; instance = instance }
  /// Output Cache Misses: Total number of output cacheable requests not served from the output cache.
  let ``Output Cache Misses`` instance =
    { category = "ASP.NET Applications"; counter = "Output Cache Misses"; instance = instance }
  /// Output Cache Trims: Total number of entries forcibly removed from the cache due to memory pressure that were originally inserted into the cache by the output cache feature.
  let ``Output Cache Trims`` instance =
    { category = "ASP.NET Applications"; counter = "Output Cache Trims"; instance = instance }
  /// Output Cache Turnover Rate: Number of additions and removals to the output cache per second.
  let ``Output Cache Turnover Rate`` instance =
    { category = "ASP.NET Applications"; counter = "Output Cache Turnover Rate"; instance = instance }
  /// Pipeline Instance Count: Number of active pipeline instances.
  let ``Pipeline Instance Count`` instance =
    { category = "ASP.NET Applications"; counter = "Pipeline Instance Count"; instance = instance }
  /// Request Bytes In Total: The total size, in bytes, of all requests.
  let ``Request Bytes In Total`` instance =
    { category = "ASP.NET Applications"; counter = "Request Bytes In Total"; instance = instance }
  /// Request Bytes In Total (WebSockets): The total size, in bytes, of data received by ASP.NET on WebSocket connections.
  let ``Request Bytes In Total (WebSockets)`` instance =
    { category = "ASP.NET Applications"; counter = "Request Bytes In Total (WebSockets)"; instance = instance }
  /// Request Bytes Out Total: The total size, in bytes, of responses sent to a client.  This does not include standard HTTP response headers.
  let ``Request Bytes Out Total`` instance =
    { category = "ASP.NET Applications"; counter = "Request Bytes Out Total"; instance = instance }
  /// Request Bytes Out Total (WebSockets): The total size, in bytes, of data sent to a client on WebSocket connections.
  let ``Request Bytes Out Total (WebSockets)`` instance =
    { category = "ASP.NET Applications"; counter = "Request Bytes Out Total (WebSockets)"; instance = instance }
  /// Request Error Events Raised: Number of runtime error events raised since the application was started.
  let ``Request Error Events Raised`` instance =
    { category = "ASP.NET Applications"; counter = "Request Error Events Raised"; instance = instance }
  /// Request Error Events Raised/Sec: Number of runtime error events per second.
  let ``Request Error Events Raised/Sec`` instance =
    { category = "ASP.NET Applications"; counter = "Request Error Events Raised/Sec"; instance = instance }
  /// Request Events Raised: Number of request events raised since the application was started
  let ``Request Events Raised`` instance =
    { category = "ASP.NET Applications"; counter = "Request Events Raised"; instance = instance }
  /// Request Events Raised/Sec: Number of request events raised per second.
  let ``Request Events Raised/Sec`` instance =
    { category = "ASP.NET Applications"; counter = "Request Events Raised/Sec"; instance = instance }
  /// Request Execution Time: The number of milliseconds that it took to execute the most recent request.
  let ``Request Execution Time`` instance =
    { category = "ASP.NET Applications"; counter = "Request Execution Time"; instance = instance }
  /// Request Wait Time: The number of milliseconds the most recent request was waiting in the queue.
  let ``Request Wait Time`` instance =
    { category = "ASP.NET Applications"; counter = "Request Wait Time"; instance = instance }
  /// Requests Disconnected: The number of requests disconnected due to communication errors or user terminated.
  let ``Requests Disconnected`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Disconnected"; instance = instance }
  /// Requests Executing: The number of requests currently executing.
  let ``Requests Executing`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Executing"; instance = instance }
  /// Requests Executing (WebSockets): The number of WebSocket requests currently executing.
  let ``Requests Executing (WebSockets)`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Executing (WebSockets)"; instance = instance }
  /// Requests Failed: Total number of failed requests.
  let ``Requests Failed`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Failed"; instance = instance }
  /// Requests Failed (WebSockets): Total number of WebSocket requests that ended up in an aborted state.
  let ``Requests Failed (WebSockets)`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Failed (WebSockets)"; instance = instance }
  /// Requests In Application Queue: The number of requests in the application request queue.
  let ``Requests In Application Queue`` instance =
    { category = "ASP.NET Applications"; counter = "Requests In Application Queue"; instance = instance }
  /// Requests Not Authorized: Number of requests failed due to unauthorized access.
  let ``Requests Not Authorized`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Not Authorized"; instance = instance }
  /// Requests Not Found: The number of requests for resources that were not found.
  let ``Requests Not Found`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Not Found"; instance = instance }
  /// Requests Rejected: The number of requests rejected because the application request queue was full.
  let ``Requests Rejected`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Rejected"; instance = instance }
  /// Requests Succeeded: The number of requests that executed successfully.
  let ``Requests Succeeded`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Succeeded"; instance = instance }
  /// Requests Succeeded (WebSockets): Total number of WebSocket requests that completed gracefully.
  let ``Requests Succeeded (WebSockets)`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Succeeded (WebSockets)"; instance = instance }
  /// Requests Timed Out: The number of requests that timed out.
  let ``Requests Timed Out`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Timed Out"; instance = instance }
  /// Requests Total: The total number of requests since the application was started.
  let ``Requests Total`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Total"; instance = instance }
  /// Requests Total (WebSockets): The total number of WebSocket requests since the application was started.
  let ``Requests Total (WebSockets)`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Total (WebSockets)"; instance = instance }
  /// Requests/Sec: The number of requests executed per second.
  let ``Requests/Sec`` instance =
    { category = "ASP.NET Applications"; counter = "Requests/Sec"; instance = instance }
  /// Session SQL Server connections total: The total number of connections to the SQL Server used by session state.
  let ``Session SQL Server connections total`` instance =
    { category = "ASP.NET Applications"; counter = "Session SQL Server connections total"; instance = instance }
  /// Session State Server connections total: The total number of connections to the State Server used by session state.
  let ``Session State Server connections total`` instance =
    { category = "ASP.NET Applications"; counter = "Session State Server connections total"; instance = instance }
  /// Sessions Abandoned: The number of sessions that have been explicitly abandoned.
  let ``Sessions Abandoned`` instance =
    { category = "ASP.NET Applications"; counter = "Sessions Abandoned"; instance = instance }
  /// Sessions Active: The current number of sessions currently active.
  let ``Sessions Active`` instance =
    { category = "ASP.NET Applications"; counter = "Sessions Active"; instance = instance }
  /// Sessions Timed Out: The number of sessions timed out.
  let ``Sessions Timed Out`` instance =
    { category = "ASP.NET Applications"; counter = "Sessions Timed Out"; instance = instance }
  /// Sessions Total: Total number of sessions since the application was started.
  let ``Sessions Total`` instance =
    { category = "ASP.NET Applications"; counter = "Sessions Total"; instance = instance }
  /// Transactions Aborted: The number of transactions aborted.
  let ``Transactions Aborted`` instance =
    { category = "ASP.NET Applications"; counter = "Transactions Aborted"; instance = instance }
  /// Transactions Committed: The number of transactions committed.
  let ``Transactions Committed`` instance =
    { category = "ASP.NET Applications"; counter = "Transactions Committed"; instance = instance }
  /// Transactions Pending: Number of transactions in progress.
  let ``Transactions Pending`` instance =
    { category = "ASP.NET Applications"; counter = "Transactions Pending"; instance = instance }
  /// Transactions Total: The total number of transactions since the application was started.
  let ``Transactions Total`` instance =
    { category = "ASP.NET Applications"; counter = "Transactions Total"; instance = instance }
  /// Transactions/Sec: Transactions started per second.
  let ``Transactions/Sec`` instance =
    { category = "ASP.NET Applications"; counter = "Transactions/Sec"; instance = instance }
  /// Viewstate MAC Validation Failure: Number of viewstate MAC validations that failed since the application was started.
  let ``Viewstate MAC Validation Failure`` instance =
    { category = "ASP.NET Applications"; counter = "Viewstate MAC Validation Failure"; instance = instance }

  let allCounters =
    [ ``% Managed Processor Time (estimated)``
      ``% Managed Processor Time Base (estimated)``
      ``Anonymous Requests``
      ``Anonymous Requests/Sec``
      ``Application Lifetime Events``
      ``Application Lifetime Events/Sec``
      ``Audit Failure Events Raised``
      ``Audit Success Events Raised``
      ``Cache % Machine Memory Limit Used``
      ``Cache % Machine Memory Limit Used Base``
      ``Cache % Process Memory Limit Used``
      ``Cache % Process Memory Limit Used Base``
      ``Cache API Entries``
      ``Cache API Hit Ratio``
      ``Cache API Hit Ratio Base``
      ``Cache API Hits``
      ``Cache API Misses``
      ``Cache API Trims``
      ``Cache API Turnover Rate``
      ``Cache Total Entries``
      ``Cache Total Hit Ratio``
      ``Cache Total Hit Ratio Base``
      ``Cache Total Hits``
      ``Cache Total Misses``
      ``Cache Total Trims``
      ``Cache Total Turnover Rate``
      ``Compilations Total``
      ``Debugging Requests``
      ``Error Events Raised``
      ``Error Events Raised/Sec``
      ``Errors During Compilation``
      ``Errors During Execution``
      ``Errors During Preprocessing``
      ``Errors Total``
      ``Errors Total/Sec``
      ``Errors Unhandled During Execution``
      ``Errors Unhandled During Execution/Sec``
      ``Events Raised``
      ``Events Raised/Sec``
      ``Forms Authentication Failure``
      ``Forms Authentication Success``
      ``Infrastructure Error Events Raised``
      ``Infrastructure Error Events Raised/Sec``
      ``Managed Memory Used (estimated)``
      ``Membership Authentication Failure``
      ``Membership Authentication Success``
      ``Output Cache Entries``
      ``Output Cache Hit Ratio``
      ``Output Cache Hit Ratio Base``
      ``Output Cache Hits``
      ``Output Cache Misses``
      ``Output Cache Trims``
      ``Output Cache Turnover Rate``
      ``Pipeline Instance Count``
      ``Request Bytes In Total``
      ``Request Bytes In Total (WebSockets)``
      ``Request Bytes Out Total``
      ``Request Bytes Out Total (WebSockets)``
      ``Request Error Events Raised``
      ``Request Error Events Raised/Sec``
      ``Request Events Raised``
      ``Request Events Raised/Sec``
      ``Request Execution Time``
      ``Request Wait Time``
      ``Requests Disconnected``
      ``Requests Executing``
      ``Requests Executing (WebSockets)``
      ``Requests Failed``
      ``Requests Failed (WebSockets)``
      ``Requests In Application Queue``
      ``Requests Not Authorized``
      ``Requests Not Found``
      ``Requests Rejected``
      ``Requests Succeeded``
      ``Requests Succeeded (WebSockets)``
      ``Requests Timed Out``
      ``Requests Total``
      ``Requests Total (WebSockets)``
      ``Requests/Sec``
      ``Session SQL Server connections total``
      ``Session State Server connections total``
      ``Sessions Abandoned``
      ``Sessions Active``
      ``Sessions Timed Out``
      ``Sessions Total``
      ``Transactions Aborted``
      ``Transactions Committed``
      ``Transactions Pending``
      ``Transactions Total``
      ``Transactions/Sec``
      ``Viewstate MAC Validation Failure``
    ]

/// ASP.NET Apps v4.0.30319: ASP.NET application performance counters
///
/// This performance counter does not have non-instance based counters
module ``ASP_NET Apps v4_0_30319`` =

  [<Literal>]
  let Category = "ASP.NET Apps v4.0.30319"

  let PCC = getPCC Category
  /// % Managed Processor Time (estimated): Estimated percentage of elapsed time that the processor spends executing managed application code.  This counter only tracks processor time of managed threads in the application.  It does not include additional processor time spent executing on non-managed threads.  Note that this counter is only updated with new data every five seconds.
  let ``% Managed Processor Time (estimated)`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "% Managed Processor Time (estimated)"; instance = instance }
  /// % Managed Processor Time Base (estimated): % Managed Processor Time Base (estimated)
  let ``% Managed Processor Time Base (estimated)`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "% Managed Processor Time Base (estimated)"; instance = instance }
  /// Anonymous Requests: Number of requests utilizing anonymous authentication.
  let ``Anonymous Requests`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Anonymous Requests"; instance = instance }
  /// Anonymous Requests/Sec: Number of Authentication Anonymous Requests/Sec
  let ``Anonymous Requests/Sec`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Anonymous Requests/Sec"; instance = instance }
  /// Application Lifetime Events: Number of application events raised since the application was started.
  let ``Application Lifetime Events`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Application Lifetime Events"; instance = instance }
  /// Application Lifetime Events/Sec: Number of application events raised per second.
  let ``Application Lifetime Events/Sec`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Application Lifetime Events/Sec"; instance = instance }
  /// Audit Failure Events Raised: Number of audit failures in the application since it was started.
  let ``Audit Failure Events Raised`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Audit Failure Events Raised"; instance = instance }
  /// Audit Success Events Raised: Number of audit successes in the application since it was started.
  let ``Audit Success Events Raised`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Audit Success Events Raised"; instance = instance }
  /// Cache % Machine Memory Limit Used: The amount of physical memory used by the machine divided by the physical memory limit for the cache, as a percentage.  When this reaches 100%, half of the cache entries will be forcibly removed.  The __Total__ instance is the average of all instances, and therefore cannot be used to determine when cache entries will be forcibly removed.
  let ``Cache % Machine Memory Limit Used`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache % Machine Memory Limit Used"; instance = instance }
  /// Cache % Machine Memory Limit Used Base: Cache % Machine Memory Limit Used Base
  let ``Cache % Machine Memory Limit Used Base`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache % Machine Memory Limit Used Base"; instance = instance }
  /// Cache % Process Memory Limit Used: The value of private bytes for the worker process divided by the private bytes memory limit for the cache, as a percentage.  When this reaches 100%, half of the cache entries will be forcibly removed.  The __Total__ instance is the average of all instances, and therefore cannot be used to determine when cache entries will be forcibly removed.
  let ``Cache % Process Memory Limit Used`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache % Process Memory Limit Used"; instance = instance }
  /// Cache % Process Memory Limit Used Base: Cache % Process Memory Limit Used Base
  let ``Cache % Process Memory Limit Used Base`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache % Process Memory Limit Used Base"; instance = instance }
  /// Cache API Entries: Total number of entries within the cache added by the user.
  let ``Cache API Entries`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache API Entries"; instance = instance }
  /// Cache API Hit Ratio: Ratio of hits called from user code.
  let ``Cache API Hit Ratio`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache API Hit Ratio"; instance = instance }
  /// Cache API Hit Ratio Base: Cache API Hit Ratio Base
  let ``Cache API Hit Ratio Base`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache API Hit Ratio Base"; instance = instance }
  /// Cache API Hits: Number of cache hits from user code.
  let ``Cache API Hits`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache API Hits"; instance = instance }
  /// Cache API Misses: Number of cache misses called from user code.
  let ``Cache API Misses`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache API Misses"; instance = instance }
  /// Cache API Trims: Total number of entries forcibly removed from the cache due to memory pressure that were originally inserted into the cache using one of the public cache APIs.
  let ``Cache API Trims`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache API Trims"; instance = instance }
  /// Cache API Turnover Rate: Number of additions and removals to the API cache per second.
  let ``Cache API Turnover Rate`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache API Turnover Rate"; instance = instance }
  /// Cache Total Entries: Total number of entries within the cache (both internal and user added)
  let ``Cache Total Entries`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache Total Entries"; instance = instance }
  /// Cache Total Hit Ratio: Ratio of hits from all cache calls.
  let ``Cache Total Hit Ratio`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache Total Hit Ratio"; instance = instance }
  /// Cache Total Hit Ratio Base: Cache Total Hit Ratio Base
  let ``Cache Total Hit Ratio Base`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache Total Hit Ratio Base"; instance = instance }
  /// Cache Total Hits: Total number of hits from the cache.
  let ``Cache Total Hits`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache Total Hits"; instance = instance }
  /// Cache Total Misses: Total number of cache misses.
  let ``Cache Total Misses`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache Total Misses"; instance = instance }
  /// Cache Total Trims: Total number of entries forcibly removed from the cache due to memory pressure.
  let ``Cache Total Trims`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache Total Trims"; instance = instance }
  /// Cache Total Turnover Rate: Number of additions and removals to the total cache per second.
  let ``Cache Total Turnover Rate`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache Total Turnover Rate"; instance = instance }
  /// Compilations Total: Number of .asax, .ascx, .ashx, .asmx, or .aspx source files dynamically compiled.
  let ``Compilations Total`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Compilations Total"; instance = instance }
  /// Debugging Requests: Number of debugging requests processed.
  let ``Debugging Requests`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Debugging Requests"; instance = instance }
  /// Error Events Raised: Number of error events raised since the application was started.
  let ``Error Events Raised`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Error Events Raised"; instance = instance }
  /// Error Events Raised/Sec: Number of error events per second.
  let ``Error Events Raised/Sec`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Error Events Raised/Sec"; instance = instance }
  /// Errors During Compilation: Number of errors that have occurred during compilation.
  let ``Errors During Compilation`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Errors During Compilation"; instance = instance }
  /// Errors During Execution: Number of errors that have occurred during the processing of a request.
  let ``Errors During Execution`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Errors During Execution"; instance = instance }
  /// Errors During Preprocessing: Number of errors that have occurred during parsing and configuration.
  let ``Errors During Preprocessing`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Errors During Preprocessing"; instance = instance }
  /// Errors Total: Total number of errors occurred.
  let ``Errors Total`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Errors Total"; instance = instance }
  /// Errors Total/Sec: Rate of errors occurred.
  let ``Errors Total/Sec`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Errors Total/Sec"; instance = instance }
  /// Errors Unhandled During Execution: Number of errors not handled by user code, but by the default error handler.
  let ``Errors Unhandled During Execution`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Errors Unhandled During Execution"; instance = instance }
  /// Errors Unhandled During Execution/Sec: Rate of unhandled errors.
  let ``Errors Unhandled During Execution/Sec`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Errors Unhandled During Execution/Sec"; instance = instance }
  /// Events Raised: Total number of instrumentation events raised since the application was started.
  let ``Events Raised`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Events Raised"; instance = instance }
  /// Events Raised/Sec: Total number of instrumentation events per second.
  let ``Events Raised/Sec`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Events Raised/Sec"; instance = instance }
  /// Forms Authentication Failure: Number of failed forms authentication ticket validations since the application was started.
  let ``Forms Authentication Failure`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Forms Authentication Failure"; instance = instance }
  /// Forms Authentication Success: Number of successful forms authentication ticket validations since the application was started.
  let ``Forms Authentication Success`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Forms Authentication Success"; instance = instance }
  /// Infrastructure Error Events Raised: Number of HTTP error events raised since the application was started.
  let ``Infrastructure Error Events Raised`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Infrastructure Error Events Raised"; instance = instance }
  /// Infrastructure Error Events Raised/Sec: Number of HTTP error events raised per second.
  let ``Infrastructure Error Events Raised/Sec`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Infrastructure Error Events Raised/Sec"; instance = instance }
  /// Managed Memory Used (estimated): Estimated managed heap memory consumption (in KB) by the application.  The accuracy of this counter varies depending on the duration of elapsed time since the last full managed memory heap collection.  Note that this counter is only updated with new data every five seconds.
  let ``Managed Memory Used (estimated)`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Managed Memory Used (estimated)"; instance = instance }
  /// Membership Authentication Failure: Number of failed membership credential validations since the application was started.
  let ``Membership Authentication Failure`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Membership Authentication Failure"; instance = instance }
  /// Membership Authentication Success: Number of successful membership credential validations since the application was started.
  let ``Membership Authentication Success`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Membership Authentication Success"; instance = instance }
  /// Output Cache Entries: Current number of entries in the output cache.
  let ``Output Cache Entries`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Output Cache Entries"; instance = instance }
  /// Output Cache Hit Ratio: Ratio of hits to requests for output cacheable requests.
  let ``Output Cache Hit Ratio`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Output Cache Hit Ratio"; instance = instance }
  /// Output Cache Hit Ratio Base: Output Cache Hit Ratio Base
  let ``Output Cache Hit Ratio Base`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Output Cache Hit Ratio Base"; instance = instance }
  /// Output Cache Hits: Total number of output cacheable requests served from the output cache.
  let ``Output Cache Hits`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Output Cache Hits"; instance = instance }
  /// Output Cache Misses: Total number of output cacheable requests not served from the output cache.
  let ``Output Cache Misses`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Output Cache Misses"; instance = instance }
  /// Output Cache Trims: Total number of entries forcibly removed from the cache due to memory pressure that were originally inserted into the cache by the output cache feature.
  let ``Output Cache Trims`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Output Cache Trims"; instance = instance }
  /// Output Cache Turnover Rate: Number of additions and removals to the output cache per second.
  let ``Output Cache Turnover Rate`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Output Cache Turnover Rate"; instance = instance }
  /// Pipeline Instance Count: Number of active pipeline instances.
  let ``Pipeline Instance Count`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Pipeline Instance Count"; instance = instance }
  /// Request Bytes In Total: The total size, in bytes, of all requests.
  let ``Request Bytes In Total`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Request Bytes In Total"; instance = instance }
  /// Request Bytes In Total (WebSockets): The total size, in bytes, of data received by ASP.NET on WebSocket connections.
  let ``Request Bytes In Total (WebSockets)`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Request Bytes In Total (WebSockets)"; instance = instance }
  /// Request Bytes Out Total: The total size, in bytes, of responses sent to a client.  This does not include standard HTTP response headers.
  let ``Request Bytes Out Total`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Request Bytes Out Total"; instance = instance }
  /// Request Bytes Out Total (WebSockets): The total size, in bytes, of data sent to a client on WebSocket connections.
  let ``Request Bytes Out Total (WebSockets)`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Request Bytes Out Total (WebSockets)"; instance = instance }
  /// Request Error Events Raised: Number of runtime error events raised since the application was started.
  let ``Request Error Events Raised`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Request Error Events Raised"; instance = instance }
  /// Request Error Events Raised/Sec: Number of runtime error events per second.
  let ``Request Error Events Raised/Sec`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Request Error Events Raised/Sec"; instance = instance }
  /// Request Events Raised: Number of request events raised since the application was started
  let ``Request Events Raised`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Request Events Raised"; instance = instance }
  /// Request Events Raised/Sec: Number of request events raised per second.
  let ``Request Events Raised/Sec`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Request Events Raised/Sec"; instance = instance }
  /// Request Execution Time: The number of milliseconds that it took to execute the most recent request.
  let ``Request Execution Time`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Request Execution Time"; instance = instance }
  /// Request Wait Time: The number of milliseconds the most recent request was waiting in the queue.
  let ``Request Wait Time`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Request Wait Time"; instance = instance }
  /// Requests Disconnected: The number of requests disconnected due to communication errors or user terminated.
  let ``Requests Disconnected`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Disconnected"; instance = instance }
  /// Requests Executing: The number of requests currently executing.
  let ``Requests Executing`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Executing"; instance = instance }
  /// Requests Executing (WebSockets): The number of WebSocket requests currently executing.
  let ``Requests Executing (WebSockets)`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Executing (WebSockets)"; instance = instance }
  /// Requests Failed: Total number of failed requests.
  let ``Requests Failed`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Failed"; instance = instance }
  /// Requests Failed (WebSockets): Total number of WebSocket requests that ended up in an aborted state.
  let ``Requests Failed (WebSockets)`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Failed (WebSockets)"; instance = instance }
  /// Requests In Application Queue: The number of requests in the application request queue.
  let ``Requests In Application Queue`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests In Application Queue"; instance = instance }
  /// Requests Not Authorized: Number of requests failed due to unauthorized access.
  let ``Requests Not Authorized`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Not Authorized"; instance = instance }
  /// Requests Not Found: The number of requests for resources that were not found.
  let ``Requests Not Found`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Not Found"; instance = instance }
  /// Requests Rejected: The number of requests rejected because the application request queue was full.
  let ``Requests Rejected`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Rejected"; instance = instance }
  /// Requests Succeeded: The number of requests that executed successfully.
  let ``Requests Succeeded`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Succeeded"; instance = instance }
  /// Requests Succeeded (WebSockets): Total number of WebSocket requests that completed gracefully.
  let ``Requests Succeeded (WebSockets)`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Succeeded (WebSockets)"; instance = instance }
  /// Requests Timed Out: The number of requests that timed out.
  let ``Requests Timed Out`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Timed Out"; instance = instance }
  /// Requests Total: The total number of requests since the application was started.
  let ``Requests Total`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Total"; instance = instance }
  /// Requests Total (WebSockets): The total number of WebSocket requests since the application was started.
  let ``Requests Total (WebSockets)`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Total (WebSockets)"; instance = instance }
  /// Requests/Sec: The number of requests executed per second.
  let ``Requests/Sec`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests/Sec"; instance = instance }
  /// Session SQL Server connections total: The total number of connections to the SQL Server used by session state.
  let ``Session SQL Server connections total`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Session SQL Server connections total"; instance = instance }
  /// Session State Server connections total: The total number of connections to the State Server used by session state.
  let ``Session State Server connections total`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Session State Server connections total"; instance = instance }
  /// Sessions Abandoned: The number of sessions that have been explicitly abandoned.
  let ``Sessions Abandoned`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Sessions Abandoned"; instance = instance }
  /// Sessions Active: The current number of sessions currently active.
  let ``Sessions Active`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Sessions Active"; instance = instance }
  /// Sessions Timed Out: The number of sessions timed out.
  let ``Sessions Timed Out`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Sessions Timed Out"; instance = instance }
  /// Sessions Total: Total number of sessions since the application was started.
  let ``Sessions Total`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Sessions Total"; instance = instance }
  /// Transactions Aborted: The number of transactions aborted.
  let ``Transactions Aborted`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Transactions Aborted"; instance = instance }
  /// Transactions Committed: The number of transactions committed.
  let ``Transactions Committed`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Transactions Committed"; instance = instance }
  /// Transactions Pending: Number of transactions in progress.
  let ``Transactions Pending`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Transactions Pending"; instance = instance }
  /// Transactions Total: The total number of transactions since the application was started.
  let ``Transactions Total`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Transactions Total"; instance = instance }
  /// Transactions/Sec: Transactions started per second.
  let ``Transactions/Sec`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Transactions/Sec"; instance = instance }
  /// Viewstate MAC Validation Failure: Number of viewstate MAC validations that failed since the application was started.
  let ``Viewstate MAC Validation Failure`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Viewstate MAC Validation Failure"; instance = instance }

  let allCounters =
    [ ``% Managed Processor Time (estimated)``
      ``% Managed Processor Time Base (estimated)``
      ``Anonymous Requests``
      ``Anonymous Requests/Sec``
      ``Application Lifetime Events``
      ``Application Lifetime Events/Sec``
      ``Audit Failure Events Raised``
      ``Audit Success Events Raised``
      ``Cache % Machine Memory Limit Used``
      ``Cache % Machine Memory Limit Used Base``
      ``Cache % Process Memory Limit Used``
      ``Cache % Process Memory Limit Used Base``
      ``Cache API Entries``
      ``Cache API Hit Ratio``
      ``Cache API Hit Ratio Base``
      ``Cache API Hits``
      ``Cache API Misses``
      ``Cache API Trims``
      ``Cache API Turnover Rate``
      ``Cache Total Entries``
      ``Cache Total Hit Ratio``
      ``Cache Total Hit Ratio Base``
      ``Cache Total Hits``
      ``Cache Total Misses``
      ``Cache Total Trims``
      ``Cache Total Turnover Rate``
      ``Compilations Total``
      ``Debugging Requests``
      ``Error Events Raised``
      ``Error Events Raised/Sec``
      ``Errors During Compilation``
      ``Errors During Execution``
      ``Errors During Preprocessing``
      ``Errors Total``
      ``Errors Total/Sec``
      ``Errors Unhandled During Execution``
      ``Errors Unhandled During Execution/Sec``
      ``Events Raised``
      ``Events Raised/Sec``
      ``Forms Authentication Failure``
      ``Forms Authentication Success``
      ``Infrastructure Error Events Raised``
      ``Infrastructure Error Events Raised/Sec``
      ``Managed Memory Used (estimated)``
      ``Membership Authentication Failure``
      ``Membership Authentication Success``
      ``Output Cache Entries``
      ``Output Cache Hit Ratio``
      ``Output Cache Hit Ratio Base``
      ``Output Cache Hits``
      ``Output Cache Misses``
      ``Output Cache Trims``
      ``Output Cache Turnover Rate``
      ``Pipeline Instance Count``
      ``Request Bytes In Total``
      ``Request Bytes In Total (WebSockets)``
      ``Request Bytes Out Total``
      ``Request Bytes Out Total (WebSockets)``
      ``Request Error Events Raised``
      ``Request Error Events Raised/Sec``
      ``Request Events Raised``
      ``Request Events Raised/Sec``
      ``Request Execution Time``
      ``Request Wait Time``
      ``Requests Disconnected``
      ``Requests Executing``
      ``Requests Executing (WebSockets)``
      ``Requests Failed``
      ``Requests Failed (WebSockets)``
      ``Requests In Application Queue``
      ``Requests Not Authorized``
      ``Requests Not Found``
      ``Requests Rejected``
      ``Requests Succeeded``
      ``Requests Succeeded (WebSockets)``
      ``Requests Timed Out``
      ``Requests Total``
      ``Requests Total (WebSockets)``
      ``Requests/Sec``
      ``Session SQL Server connections total``
      ``Session State Server connections total``
      ``Sessions Abandoned``
      ``Sessions Active``
      ``Sessions Timed Out``
      ``Sessions Total``
      ``Transactions Aborted``
      ``Transactions Committed``
      ``Transactions Pending``
      ``Transactions Total``
      ``Transactions/Sec``
      ``Viewstate MAC Validation Failure``
    ]

/// ASP.NET State Service: ASP.NET State Service
///
/// This performance counter does not have instance based counters
module ``ASP_NET State Service`` =

  [<Literal>]
  let Category = "ASP.NET State Service"

  let PCC = getPCC Category
  /// State Server Sessions Abandoned: The number of sessions that have been explicitly abandoned.
  let ``State Server Sessions Abandoned`` =
    { category = "ASP.NET State Service"; counter = "State Server Sessions Abandoned"; instance = NotApplicable }
  /// State Server Sessions Active: The current number of sessions currently active.
  let ``State Server Sessions Active`` =
    { category = "ASP.NET State Service"; counter = "State Server Sessions Active"; instance = NotApplicable }
  /// State Server Sessions Timed Out: The number of sessions timed out.
  let ``State Server Sessions Timed Out`` =
    { category = "ASP.NET State Service"; counter = "State Server Sessions Timed Out"; instance = NotApplicable }
  /// State Server Sessions Total: The number of sessions total.
  let ``State Server Sessions Total`` =
    { category = "ASP.NET State Service"; counter = "State Server Sessions Total"; instance = NotApplicable }

  let allCounters =
    [ ``State Server Sessions Abandoned``
      ``State Server Sessions Active``
      ``State Server Sessions Timed Out``
      ``State Server Sessions Total``
    ]

/// ASP.NET v4.0.30319: ASP.NET global performance counters
///
/// This performance counter does not have instance based counters
module ``ASP_NET v4_0_30319`` =

  [<Literal>]
  let Category = "ASP.NET v4.0.30319"

  let PCC = getPCC Category
  /// Application Restarts: Number of times the application has been restarted during the web server's lifetime.
  let ``Application Restarts`` =
    { category = "ASP.NET v4.0.30319"; counter = "Application Restarts"; instance = NotApplicable }
  /// Applications Running: Number of currently running web applications.
  let ``Applications Running`` =
    { category = "ASP.NET v4.0.30319"; counter = "Applications Running"; instance = NotApplicable }
  /// Audit Failure Events Raised: Number of audit failures in the application since it was started.
  let ``Audit Failure Events Raised`` =
    { category = "ASP.NET v4.0.30319"; counter = "Audit Failure Events Raised"; instance = NotApplicable }
  /// Audit Success Events Raised: Number of audit successes in the application since it was started.
  let ``Audit Success Events Raised`` =
    { category = "ASP.NET v4.0.30319"; counter = "Audit Success Events Raised"; instance = NotApplicable }
  /// Error Events Raised: Number of error events raised since the application was started.
  let ``Error Events Raised`` =
    { category = "ASP.NET v4.0.30319"; counter = "Error Events Raised"; instance = NotApplicable }
  /// Infrastructure Error Events Raised: Number of HTTP error events raised since the application was started.
  let ``Infrastructure Error Events Raised`` =
    { category = "ASP.NET v4.0.30319"; counter = "Infrastructure Error Events Raised"; instance = NotApplicable }
  /// Request Error Events Raised: Number of runtime error events raised since the application was started.
  let ``Request Error Events Raised`` =
    { category = "ASP.NET v4.0.30319"; counter = "Request Error Events Raised"; instance = NotApplicable }
  /// Request Execution Time: The number of milliseconds that it took to execute the most recent request.
  let ``Request Execution Time`` =
    { category = "ASP.NET v4.0.30319"; counter = "Request Execution Time"; instance = NotApplicable }
  /// Request Wait Time: The number of milliseconds the most recent request was waiting in the queue.
  let ``Request Wait Time`` =
    { category = "ASP.NET v4.0.30319"; counter = "Request Wait Time"; instance = NotApplicable }
  /// Requests Current: The current number of requests, including those that are queued, currently executing, or waiting to be written to the client.  Under the ASP.NET process model, when this counter exceeds the requestQueueLimit defined in the processModel configuration section, ASP.NET will begin rejecting requests.
  let ``Requests Current`` =
    { category = "ASP.NET v4.0.30319"; counter = "Requests Current"; instance = NotApplicable }
  /// Requests Disconnected: The number of requests disconnected due to communication errors or user terminated.
  let ``Requests Disconnected`` =
    { category = "ASP.NET v4.0.30319"; counter = "Requests Disconnected"; instance = NotApplicable }
  /// Requests In Native Queue: Requests queued because the concurrency limits have been exceeded.
  let ``Requests In Native Queue`` =
    { category = "ASP.NET v4.0.30319"; counter = "Requests In Native Queue"; instance = NotApplicable }
  /// Requests Queued: The number of requests waiting to be processed.
  let ``Requests Queued`` =
    { category = "ASP.NET v4.0.30319"; counter = "Requests Queued"; instance = NotApplicable }
  /// Requests Rejected: The number of requests rejected because the request queue was full.
  let ``Requests Rejected`` =
    { category = "ASP.NET v4.0.30319"; counter = "Requests Rejected"; instance = NotApplicable }
  /// State Server Sessions Abandoned: The number of sessions that have been explicitly abandoned.
  let ``State Server Sessions Abandoned`` =
    { category = "ASP.NET v4.0.30319"; counter = "State Server Sessions Abandoned"; instance = NotApplicable }
  /// State Server Sessions Active: The current number of sessions currently active.
  let ``State Server Sessions Active`` =
    { category = "ASP.NET v4.0.30319"; counter = "State Server Sessions Active"; instance = NotApplicable }
  /// State Server Sessions Timed Out: The number of sessions timed out.
  let ``State Server Sessions Timed Out`` =
    { category = "ASP.NET v4.0.30319"; counter = "State Server Sessions Timed Out"; instance = NotApplicable }
  /// State Server Sessions Total: The number of sessions total.
  let ``State Server Sessions Total`` =
    { category = "ASP.NET v4.0.30319"; counter = "State Server Sessions Total"; instance = NotApplicable }
  /// Worker Process Restarts: Number of times a worker process has restarted on the machine.
  let ``Worker Process Restarts`` =
    { category = "ASP.NET v4.0.30319"; counter = "Worker Process Restarts"; instance = NotApplicable }
  /// Worker Processes Running: Number of worker processes running on the machine.
  let ``Worker Processes Running`` =
    { category = "ASP.NET v4.0.30319"; counter = "Worker Processes Running"; instance = NotApplicable }

  let allCounters =
    [ ``Application Restarts``
      ``Applications Running``
      ``Audit Failure Events Raised``
      ``Audit Success Events Raised``
      ``Error Events Raised``
      ``Infrastructure Error Events Raised``
      ``Request Error Events Raised``
      ``Request Execution Time``
      ``Request Wait Time``
      ``Requests Current``
      ``Requests Disconnected``
      ``Requests In Native Queue``
      ``Requests Queued``
      ``Requests Rejected``
      ``State Server Sessions Abandoned``
      ``State Server Sessions Active``
      ``State Server Sessions Timed Out``
      ``State Server Sessions Total``
      ``Worker Process Restarts``
      ``Worker Processes Running``
    ]

/// Authorization Manager Applications: The set of Counters for Authorization Manager application object
///
/// This performance counter does not have instance based counters
module ``Authorization Manager Applications`` =

  [<Literal>]
  let Category = "Authorization Manager Applications"

  let PCC = getPCC Category
  /// Number of Scopes loaded in memory: -
  let ``Number of Scopes loaded in memory`` instance =
    { category = "Authorization Manager Applications"; counter = "Number of Scopes loaded in memory"; instance = instance }
  /// Total number of scopes: -
  let ``Total number of scopes`` instance =
    { category = "Authorization Manager Applications"; counter = "Total number of scopes"; instance = instance }

  let allCounters =
    [ ``Number of Scopes loaded in memory``
      ``Total number of scopes``
    ]

/// BitLocker: BitLocker Drive Encryption performance counters
///
/// This performance counter does not have non-instance based counters
module ``BitLocker`` =

  [<Literal>]
  let Category = "BitLocker"

  let PCC = getPCC Category
  /// Max Read Split Size: Maximum read buffer split size in bytes during last interval
  let ``Max Read Split Size`` instance =
    { category = "BitLocker"; counter = "Max Read Split Size"; instance = instance }
  /// Max Write Split Size: Maximum write buffer split size in bytes during last interval
  let ``Max Write Split Size`` instance =
    { category = "BitLocker"; counter = "Max Write Split Size"; instance = instance }
  /// Min Read Split Size: Minimum read buffer split size in bytes during last interval
  let ``Min Read Split Size`` instance =
    { category = "BitLocker"; counter = "Min Read Split Size"; instance = instance }
  /// Min Write Split Size: Minimum write buffer split size in bytes during last interval
  let ``Min Write Split Size`` instance =
    { category = "BitLocker"; counter = "Min Write Split Size"; instance = instance }
  /// Read Requests/sec: Number of read requests received over the last second
  let ``Read Requests/sec`` instance =
    { category = "BitLocker"; counter = "Read Requests/sec"; instance = instance }
  /// Read Subrequests/sec: Number of read subrequests issued over the last second
  let ``Read Subrequests/sec`` instance =
    { category = "BitLocker"; counter = "Read Subrequests/sec"; instance = instance }
  /// Write Requests/sec: Number of write requests received over the last second
  let ``Write Requests/sec`` instance =
    { category = "BitLocker"; counter = "Write Requests/sec"; instance = instance }
  /// Write Subrequests/sec: Number of write subrequests issued over the last second
  let ``Write Subrequests/sec`` instance =
    { category = "BitLocker"; counter = "Write Subrequests/sec"; instance = instance }

  let allCounters =
    [ ``Max Read Split Size``
      ``Max Write Split Size``
      ``Min Read Split Size``
      ``Min Write Split Size``
      ``Read Requests/sec``
      ``Read Subrequests/sec``
      ``Write Requests/sec``
      ``Write Subrequests/sec``
    ]

/// BranchCache: Counters for measuring bandwidth and latency for BranchCache.
///
/// This performance counter does not have instance based counters
module ``BranchCache`` =

  [<Literal>]
  let Category = "BranchCache"

  let PCC = getPCC Category
  /// BITS: Bytes from cache: Total number of bytes received from the local cache or peers.
  let ``BITS: Bytes from cache`` =
    { category = "BranchCache"; counter = "BITS: Bytes from cache"; instance = NotApplicable }
  /// BITS: Bytes from server: Total number of bytes received from the original content source.
  let ``BITS: Bytes from server`` =
    { category = "BranchCache"; counter = "BITS: Bytes from server"; instance = NotApplicable }
  /// Discovery: Attempted discoveries: Total number of attempted peer discoveries.
  let ``Discovery: Attempted discoveries`` =
    { category = "BranchCache"; counter = "Discovery: Attempted discoveries"; instance = NotApplicable }
  /// Discovery: Successful discoveries: Total number of successful discoveries.
  let ``Discovery: Successful discoveries`` =
    { category = "BranchCache"; counter = "Discovery: Successful discoveries"; instance = NotApplicable }
  /// Discovery: Weighted average discovery time: Weighted average of time between when a peer discovery query was sent and when the first response arrived.
  let ``Discovery: Weighted average discovery time`` =
    { category = "BranchCache"; counter = "Discovery: Weighted average discovery time"; instance = NotApplicable }
  /// Hosted Cache: Client file segment offers made: Count of file segment offers made by peers.
  let ``Hosted Cache: Client file segment offers made`` =
    { category = "BranchCache"; counter = "Hosted Cache: Client file segment offers made"; instance = NotApplicable }
  /// Hosted Cache: Segment offers queue size: Total number of segment offers queued for processing by the Hosted Cache.
  let ``Hosted Cache: Segment offers queue size`` =
    { category = "BranchCache"; counter = "Hosted Cache: Segment offers queue size"; instance = NotApplicable }
  /// Local Cache: Average access time: Average local cache access time when serving content to other clients or Hosted Caches.
  let ``Local Cache: Average access time`` =
    { category = "BranchCache"; counter = "Local Cache: Average access time"; instance = NotApplicable }
  /// Local Cache: Cache complete file segments: Count of complete, content validated, file segments.
  let ``Local Cache: Cache complete file segments`` =
    { category = "BranchCache"; counter = "Local Cache: Cache complete file segments"; instance = NotApplicable }
  /// Local Cache: Cache partial file segments: Count of incomplete file segments that need additional data and/or validation.
  let ``Local Cache: Cache partial file segments`` =
    { category = "BranchCache"; counter = "Local Cache: Cache partial file segments"; instance = NotApplicable }
  /// OTHER: Bytes from cache: Total number of bytes received from the local cache or peers.
  let ``OTHER: Bytes from cache`` =
    { category = "BranchCache"; counter = "OTHER: Bytes from cache"; instance = NotApplicable }
  /// OTHER: Bytes from server: Total number of bytes received from the original content source.
  let ``OTHER: Bytes from server`` =
    { category = "BranchCache"; counter = "OTHER: Bytes from server"; instance = NotApplicable }
  /// Publication Cache: Published contents: Count of complete, hash persisted, published contents.
  let ``Publication Cache: Published contents`` =
    { category = "BranchCache"; counter = "Publication Cache: Published contents"; instance = NotApplicable }
  /// Retrieval: Average branch rate: Average byte rate observed by the current peer while downloading contents from other peers in the branch.
  let ``Retrieval: Average branch rate`` =
    { category = "BranchCache"; counter = "Retrieval: Average branch rate"; instance = NotApplicable }
  /// Retrieval: Bytes from cache: Total number of bytes received from the local cache or peers.
  let ``Retrieval: Bytes from cache`` =
    { category = "BranchCache"; counter = "Retrieval: Bytes from cache"; instance = NotApplicable }
  /// Retrieval: Bytes from server: Total number of bytes received from the original content source.
  let ``Retrieval: Bytes from server`` =
    { category = "BranchCache"; counter = "Retrieval: Bytes from server"; instance = NotApplicable }
  /// Retrieval: Bytes served: Total number of bytes served by this peer to other peers.
  let ``Retrieval: Bytes served`` =
    { category = "BranchCache"; counter = "Retrieval: Bytes served"; instance = NotApplicable }
  /// SMB: Bytes from cache: Total number of bytes received from the local cache or peers.
  let ``SMB: Bytes from cache`` =
    { category = "BranchCache"; counter = "SMB: Bytes from cache"; instance = NotApplicable }
  /// SMB: Bytes from server: Total number of bytes received from the original content source.
  let ``SMB: Bytes from server`` =
    { category = "BranchCache"; counter = "SMB: Bytes from server"; instance = NotApplicable }
  /// WINHTTP: Bytes from cache: Total number of bytes received from the local cache or peers.
  let ``WINHTTP: Bytes from cache`` =
    { category = "BranchCache"; counter = "WINHTTP: Bytes from cache"; instance = NotApplicable }
  /// WINHTTP: Bytes from server: Total number of bytes received from the original content source.
  let ``WINHTTP: Bytes from server`` =
    { category = "BranchCache"; counter = "WINHTTP: Bytes from server"; instance = NotApplicable }
  /// WININET: Bytes from cache: Total number of bytes received from the local cache or peers.
  let ``WININET: Bytes from cache`` =
    { category = "BranchCache"; counter = "WININET: Bytes from cache"; instance = NotApplicable }
  /// WININET: Bytes from server: Total number of bytes received from the original content source.
  let ``WININET: Bytes from server`` =
    { category = "BranchCache"; counter = "WININET: Bytes from server"; instance = NotApplicable }

  let allCounters =
    [ ``BITS: Bytes from cache``
      ``BITS: Bytes from server``
      ``Discovery: Attempted discoveries``
      ``Discovery: Successful discoveries``
      ``Discovery: Weighted average discovery time``
      ``Hosted Cache: Client file segment offers made``
      ``Hosted Cache: Segment offers queue size``
      ``Local Cache: Average access time``
      ``Local Cache: Cache complete file segments``
      ``Local Cache: Cache partial file segments``
      ``OTHER: Bytes from cache``
      ``OTHER: Bytes from server``
      ``Publication Cache: Published contents``
      ``Retrieval: Average branch rate``
      ``Retrieval: Bytes from cache``
      ``Retrieval: Bytes from server``
      ``Retrieval: Bytes served``
      ``SMB: Bytes from cache``
      ``SMB: Bytes from server``
      ``WINHTTP: Bytes from cache``
      ``WINHTTP: Bytes from server``
      ``WININET: Bytes from cache``
      ``WININET: Bytes from server``
    ]

/// Browser: The Browser performance object consists of counters that measure the rates of announcements, enumerations, and other Browser transmissions.
///
/// This performance counter does not have instance based counters
module ``Browser`` =

  [<Literal>]
  let Category = "Browser"

  let PCC = getPCC Category
  /// Announcements Domain/sec: Announcements Domain/sec is the rate at which a domain has announced itself to the network.
  let ``Announcements Domain/sec`` =
    { category = "Browser"; counter = "Announcements Domain/sec"; instance = NotApplicable }
  /// Announcements Server/sec: Announcements Server/sec is the rate at which the servers in this domain have announced themselves to this server.
  let ``Announcements Server/sec`` =
    { category = "Browser"; counter = "Announcements Server/sec"; instance = NotApplicable }
  /// Announcements Total/sec: Announcements Total/sec is the sum of Announcements Server/sec and Announcements Domain/sec.
  let ``Announcements Total/sec`` =
    { category = "Browser"; counter = "Announcements Total/sec"; instance = NotApplicable }
  /// Duplicate Master Announcements: Duplicate Master Announcements indicates the number of times that the master browser has detected another master browser on the same domain.
  let ``Duplicate Master Announcements`` =
    { category = "Browser"; counter = "Duplicate Master Announcements"; instance = NotApplicable }
  /// Election Packets/sec: Election Packets/sec is the rate at which browser election packets have been received by this workstation.
  let ``Election Packets/sec`` =
    { category = "Browser"; counter = "Election Packets/sec"; instance = NotApplicable }
  /// Enumerations Domain/sec: Enumerations Domain/sec is the rate at which domain browse requests have been processed by this workstation.
  let ``Enumerations Domain/sec`` =
    { category = "Browser"; counter = "Enumerations Domain/sec"; instance = NotApplicable }
  /// Enumerations Other/sec: Enumerations Other/sec is the rate at which browse requests processed by this workstation are not domain or server browse requests.
  let ``Enumerations Other/sec`` =
    { category = "Browser"; counter = "Enumerations Other/sec"; instance = NotApplicable }
  /// Enumerations Server/sec: Enumerations Server/sec is the rate at which server browse requests have been processed by this workstation.
  let ``Enumerations Server/sec`` =
    { category = "Browser"; counter = "Enumerations Server/sec"; instance = NotApplicable }
  /// Enumerations Total/sec: Enumerations Total/sec is the rate at which browse requests have been processed by this workstation.  This is the sum of Enumerations Server/sec, Enumerations Domain/sec, and Enumerations Other/sec.
  let ``Enumerations Total/sec`` =
    { category = "Browser"; counter = "Enumerations Total/sec"; instance = NotApplicable }
  /// Illegal Datagrams/sec: Illegal Datagrams/sec is the rate at which incorrectly formatted datagrams have been received by the workstation.
  let ``Illegal Datagrams/sec`` =
    { category = "Browser"; counter = "Illegal Datagrams/sec"; instance = NotApplicable }
  /// Mailslot Allocations Failed: Mailslot Allocations Failed is the number of times the datagram receiver has failed to allocate a buffer to hold a user mailslot write.
  let ``Mailslot Allocations Failed`` =
    { category = "Browser"; counter = "Mailslot Allocations Failed"; instance = NotApplicable }
  /// Mailslot Opens Failed/sec: Mailslot Opens Failed/sec indicates the rate at which mailslot messages to be delivered to mailslots that are not present are received by this workstation.
  let ``Mailslot Opens Failed/sec`` =
    { category = "Browser"; counter = "Mailslot Opens Failed/sec"; instance = NotApplicable }
  /// Mailslot Receives Failed: Mailslot Receives Failed indicates the number of mailslot messages that could not be received due to transport failures.
  let ``Mailslot Receives Failed`` =
    { category = "Browser"; counter = "Mailslot Receives Failed"; instance = NotApplicable }
  /// Mailslot Writes Failed: Mailslot Writes Failed is the total number of mailslot messages that have been successfully received, but that could not be written to the mailslot.
  let ``Mailslot Writes Failed`` =
    { category = "Browser"; counter = "Mailslot Writes Failed"; instance = NotApplicable }
  /// Mailslot Writes/sec: Mailslot Writes/sec is the rate at which mailslot messages have been successfully received.
  let ``Mailslot Writes/sec`` =
    { category = "Browser"; counter = "Mailslot Writes/sec"; instance = NotApplicable }
  /// Missed Mailslot Datagrams: Missed Mailslot Datagrams is the number of Mailslot Datagrams that have been discarded due to configuration or allocation limits.
  let ``Missed Mailslot Datagrams`` =
    { category = "Browser"; counter = "Missed Mailslot Datagrams"; instance = NotApplicable }
  /// Missed Server Announcements: Missed Server Announcements is the number of server announcements that have been missed due to configuration or allocation limits.
  let ``Missed Server Announcements`` =
    { category = "Browser"; counter = "Missed Server Announcements"; instance = NotApplicable }
  /// Missed Server List Requests: Missed Server List Requests is the number of requests to retrieve a list of browser servers that were received by this workstation, but could not be processed.
  let ``Missed Server List Requests`` =
    { category = "Browser"; counter = "Missed Server List Requests"; instance = NotApplicable }
  /// Server Announce Allocations Failed/sec: Server Announce Allocations Failed/sec is the rate at which server (or domain) announcements have failed due to lack of memory.
  let ``Server Announce Allocations Failed/sec`` =
    { category = "Browser"; counter = "Server Announce Allocations Failed/sec"; instance = NotApplicable }
  /// Server List Requests/sec: Server List Requests/sec is the rate at which requests to retrieve a list of browser servers have been processed by this workstation.
  let ``Server List Requests/sec`` =
    { category = "Browser"; counter = "Server List Requests/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Announcements Domain/sec``
      ``Announcements Server/sec``
      ``Announcements Total/sec``
      ``Duplicate Master Announcements``
      ``Election Packets/sec``
      ``Enumerations Domain/sec``
      ``Enumerations Other/sec``
      ``Enumerations Server/sec``
      ``Enumerations Total/sec``
      ``Illegal Datagrams/sec``
      ``Mailslot Allocations Failed``
      ``Mailslot Opens Failed/sec``
      ``Mailslot Receives Failed``
      ``Mailslot Writes Failed``
      ``Mailslot Writes/sec``
      ``Missed Mailslot Datagrams``
      ``Missed Server Announcements``
      ``Missed Server List Requests``
      ``Server Announce Allocations Failed/sec``
      ``Server List Requests/sec``
    ]

/// Cache: The Cache performance object  consists of counters that monitor the file system cache, an area of physical memory that stores recently used data as long as possible to permit access to the data without having to read from the disk.  Because applications typically use the cache, the cache is monitored as an indicator of application I/O operations.  When memory is plentiful, the cache can grow, but when memory is scarce, the cache can become too small to be effective.
///
/// This performance counter does not have instance based counters
module ``Cache`` =

  [<Literal>]
  let Category = "Cache"

  let PCC = getPCC Category
  /// Async Copy Reads/sec: Async Copy Reads/sec is the frequency of reads from pages of the file system cache that involve a memory copy of the data from the cache to the application's buffer.  The application will regain control immediately even if the disk must be accessed to retrieve the page.
  let ``Async Copy Reads/sec`` =
    { category = "Cache"; counter = "Async Copy Reads/sec"; instance = NotApplicable }
  /// Async Data Maps/sec: Async Data Maps/sec is the frequency that an application using a file system, such as NTFS, to map a page of a file into the file system cache to read the page, and does not wait for the page to be retrieved if it is not in main memory.
  let ``Async Data Maps/sec`` =
    { category = "Cache"; counter = "Async Data Maps/sec"; instance = NotApplicable }
  /// Async Fast Reads/sec: Async Fast Reads/sec is the frequency of reads from the file system cache that bypass the installed file system and retrieve the data directly from the cache.  Normally, file I/O requests will invoke the appropriate file system to retrieve data from a file, but this path permits data to be retrieved from the cache directly (without file system involvement) if the data is in the cache.  Even if the data is not in the cache, one invocation of the file system is avoided.  If the data is not in the cache, the request (application program call) will not wait until the data has been retrieved from disk, but will get control immediately.
  let ``Async Fast Reads/sec`` =
    { category = "Cache"; counter = "Async Fast Reads/sec"; instance = NotApplicable }
  /// Async MDL Reads/sec: Async MDL Reads/sec is the frequency of reads from the file system cache that use a Memory Descriptor List (MDL) to access the pages.  The MDL contains the physical address of each page in the transfer, thus permitting Direct Memory Access (DMA) of the pages.  If the accessed page(s) are not in main memory, the calling application program will not wait for the pages to fault in from disk.
  let ``Async MDL Reads/sec`` =
    { category = "Cache"; counter = "Async MDL Reads/sec"; instance = NotApplicable }
  /// Async Pin Reads/sec: Async Pin Reads/sec is the frequency of reading data into the file system cache preparatory to writing the data back to disk.  Pages read in this fashion are pinned in memory at the completion of the read.  The file system will regain control immediately even if the disk must be accessed to retrieve the page.  While pinned, a page's physical address will not be altered.
  let ``Async Pin Reads/sec`` =
    { category = "Cache"; counter = "Async Pin Reads/sec"; instance = NotApplicable }
  /// Copy Read Hits %: Copy Read Hits is the percentage of cache copy read requests that hit the cache, that is, they did not require a disk read in order to provide access to the page in the cache.  A copy read is a file read operation that is satisfied by a memory copy from a page in the cache to the application's buffer.  The LAN Redirector uses this method for retrieving information from the cache, as does the LAN Server for small transfers.  This is a method used by the disk file systems as well.
  let ``Copy Read Hits %`` =
    { category = "Cache"; counter = "Copy Read Hits %"; instance = NotApplicable }
  /// Copy Reads/sec: Copy Reads/sec is the frequency of reads from pages of the file system cache that involve a memory copy of the data from the cache to the application's buffer.  The LAN Redirector uses this method for retrieving information from the file system cache, as does the LAN Server for small transfers.  This is a method used by the disk file systems as well.
  let ``Copy Reads/sec`` =
    { category = "Cache"; counter = "Copy Reads/sec"; instance = NotApplicable }
  /// Data Flush Pages/sec: Data Flush Pages/sec is the number of pages the file system cache has flushed to disk as a result of a request to flush or to satisfy a write-through file write request.  More than one page can be transferred on each flush operation.
  let ``Data Flush Pages/sec`` =
    { category = "Cache"; counter = "Data Flush Pages/sec"; instance = NotApplicable }
  /// Data Flushes/sec: Data Flushes/sec is the rate at which the file system cache has flushed its contents to disk as the result of a request to flush or to satisfy a write-through file write request.  More than one page can be transferred on each flush operation.
  let ``Data Flushes/sec`` =
    { category = "Cache"; counter = "Data Flushes/sec"; instance = NotApplicable }
  /// Data Map Hits %: Data Map Hits is the percentage of data maps in the file system cache that could be resolved without having to retrieve a page from the disk, because the page was already in physical memory.
  let ``Data Map Hits %`` =
    { category = "Cache"; counter = "Data Map Hits %"; instance = NotApplicable }
  /// Data Map Pins/sec: Data Map Pins/sec is the frequency of data maps in the file system cache that resulted in pinning a page in main memory, an action usually preparatory to writing to the file on disk.   While pinned, a page's physical address in main memory and virtual address in the file system cache will not be altered.
  let ``Data Map Pins/sec`` =
    { category = "Cache"; counter = "Data Map Pins/sec"; instance = NotApplicable }
  /// Data Maps/sec: Data Maps/sec is the frequency that a file system such as NTFS, maps a page of a file into the file system cache to read the page.
  let ``Data Maps/sec`` =
    { category = "Cache"; counter = "Data Maps/sec"; instance = NotApplicable }
  /// Dirty Page Threshold: Threshold for number of dirty pages on system cache
  let ``Dirty Page Threshold`` =
    { category = "Cache"; counter = "Dirty Page Threshold"; instance = NotApplicable }
  /// Dirty Pages: Total number of dirty pages on the system cache
  let ``Dirty Pages`` =
    { category = "Cache"; counter = "Dirty Pages"; instance = NotApplicable }
  /// Fast Read Not Possibles/sec: Fast Read Not Possibles/sec is the frequency of attempts by an Application Program Interface (API) function call to bypass the file system to get to data in the file system cache that could not be honored without invoking the file system.
  let ``Fast Read Not Possibles/sec`` =
    { category = "Cache"; counter = "Fast Read Not Possibles/sec"; instance = NotApplicable }
  /// Fast Read Resource Misses/sec: Fast Read Resource Misses/sec is the frequency of cache misses necessitated by the lack of available resources to satisfy the request.
  let ``Fast Read Resource Misses/sec`` =
    { category = "Cache"; counter = "Fast Read Resource Misses/sec"; instance = NotApplicable }
  /// Fast Reads/sec: Fast Reads/sec is the frequency of reads from the file system cache that bypass the installed file system and retrieve the data directly from the cache.  Normally, file I/O requests invoke the appropriate file system to retrieve data from a file, but this path permits direct retrieval of data from the cache without file system involvement if the data is in the cache.  Even if the data is not in the cache, one invocation of the file system is avoided.
  let ``Fast Reads/sec`` =
    { category = "Cache"; counter = "Fast Reads/sec"; instance = NotApplicable }
  /// Lazy Write Flushes/sec: Lazy Write Flushes/sec is the rate at which the Lazy Writer thread has written to disk.  Lazy Writing is the process of updating the disk after the page has been changed in memory, so that the application that changed the file does not have to wait for the disk write to be complete before proceeding.  More than one page can be transferred by each write operation.
  let ``Lazy Write Flushes/sec`` =
    { category = "Cache"; counter = "Lazy Write Flushes/sec"; instance = NotApplicable }
  /// Lazy Write Pages/sec: Lazy Write Pages/sec is the rate at which the Lazy Writer thread has written to disk.  Lazy Writing is the process of updating the disk after the page has been changed in memory, so that the application that changed the file does not have to wait for the disk write to be complete before proceeding.  More than one page can be transferred on a single disk write operation.
  let ``Lazy Write Pages/sec`` =
    { category = "Cache"; counter = "Lazy Write Pages/sec"; instance = NotApplicable }
  /// MDL Read Hits %: MDL Read Hits is the percentage of Memory Descriptor List (MDL) Read requests to the file system cache that hit the cache, i.e., did not require disk accesses in order to provide memory access to the page(s) in the cache.
  let ``MDL Read Hits %`` =
    { category = "Cache"; counter = "MDL Read Hits %"; instance = NotApplicable }
  /// MDL Reads/sec: MDL Reads/sec is the frequency of reads from the file system cache that use a Memory Descriptor List (MDL) to access the data.  The MDL contains the physical address of each page involved in the transfer, and thus can employ a hardware Direct Memory Access (DMA) device to effect the copy.  The LAN Server uses this method for large transfers out of the server.
  let ``MDL Reads/sec`` =
    { category = "Cache"; counter = "MDL Reads/sec"; instance = NotApplicable }
  /// Pin Read Hits %: Pin Read Hits is the percentage of pin read requests that hit the file system cache, i.e., did not require a disk read in order to provide access to the page in the file system cache.  While pinned, a page's physical address in the file system cache will not be altered.  The LAN Redirector uses this method for retrieving data from the cache, as does the LAN Server for small transfers.  This is usually the method used by the disk file systems as well.
  let ``Pin Read Hits %`` =
    { category = "Cache"; counter = "Pin Read Hits %"; instance = NotApplicable }
  /// Pin Reads/sec: Pin Reads/sec is the frequency of reading data into the file system cache preparatory to writing the data back to disk.  Pages read in this fashion are pinned in memory at the completion of the read.  While pinned, a page's physical address in the file system cache will not be altered.
  let ``Pin Reads/sec`` =
    { category = "Cache"; counter = "Pin Reads/sec"; instance = NotApplicable }
  /// Read Aheads/sec: Read Aheads/sec is the frequency of reads from the file system cache in which the Cache detects sequential access to a file.  The read aheads permit the data to be transferred in larger blocks than those being requested by the application, reducing the overhead per access.
  let ``Read Aheads/sec`` =
    { category = "Cache"; counter = "Read Aheads/sec"; instance = NotApplicable }
  /// Sync Copy Reads/sec: Sync Copy Reads/sec is the frequency of reads from pages of the file system cache that involve a memory copy of the data from the cache to the application's buffer.  The file system will not regain control until the copy operation is complete, even if the disk must be accessed to retrieve the page.
  let ``Sync Copy Reads/sec`` =
    { category = "Cache"; counter = "Sync Copy Reads/sec"; instance = NotApplicable }
  /// Sync Data Maps/sec: Sync Data Maps/sec counts the frequency that a file system, such as NTFS, maps a page of a file into the file system cache to read the page, and wishes to wait for the page to be retrieved if it is not in main memory.
  let ``Sync Data Maps/sec`` =
    { category = "Cache"; counter = "Sync Data Maps/sec"; instance = NotApplicable }
  /// Sync Fast Reads/sec: Sync Fast Reads/sec is the frequency of reads from the file system cache that bypass the installed file system and retrieve the data directly from the cache.  Normally, file I/O requests invoke the appropriate file system to retrieve data from a file, but this path permits direct retrieval of data from the cache without file system involvement if the data is in the cache.  Even if the data is not in the cache, one invocation of the file system is avoided.  If the data is not in the cache, the request (application program call) will wait until the data has been retrieved from disk.
  let ``Sync Fast Reads/sec`` =
    { category = "Cache"; counter = "Sync Fast Reads/sec"; instance = NotApplicable }
  /// Sync MDL Reads/sec: Sync MDL Reads/sec is the frequency of reads from the file system cache that use a Memory Descriptor List (MDL) to access the pages.  The MDL contains the physical address of each page in the transfer, thus permitting Direct Memory Access (DMA) of the pages.  If the accessed page(s) are not in main memory, the caller will wait for the pages to fault in from the disk.
  let ``Sync MDL Reads/sec`` =
    { category = "Cache"; counter = "Sync MDL Reads/sec"; instance = NotApplicable }
  /// Sync Pin Reads/sec: Sync Pin Reads/sec is the frequency of reading data into the file system cache preparatory to writing the data back to disk.  Pages read in this fashion are pinned in memory at the completion of the read.  The file system will not regain control until the page is pinned in the file system cache, in particular if the disk must be accessed to retrieve the page.  While pinned, a page's physical address in the file system cache will not be altered.
  let ``Sync Pin Reads/sec`` =
    { category = "Cache"; counter = "Sync Pin Reads/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Async Copy Reads/sec``
      ``Async Data Maps/sec``
      ``Async Fast Reads/sec``
      ``Async MDL Reads/sec``
      ``Async Pin Reads/sec``
      ``Copy Read Hits %``
      ``Copy Reads/sec``
      ``Data Flush Pages/sec``
      ``Data Flushes/sec``
      ``Data Map Hits %``
      ``Data Map Pins/sec``
      ``Data Maps/sec``
      ``Dirty Page Threshold``
      ``Dirty Pages``
      ``Fast Read Not Possibles/sec``
      ``Fast Read Resource Misses/sec``
      ``Fast Reads/sec``
      ``Lazy Write Flushes/sec``
      ``Lazy Write Pages/sec``
      ``MDL Read Hits %``
      ``MDL Reads/sec``
      ``Pin Read Hits %``
      ``Pin Reads/sec``
      ``Read Aheads/sec``
      ``Sync Copy Reads/sec``
      ``Sync Data Maps/sec``
      ``Sync Fast Reads/sec``
      ``Sync MDL Reads/sec``
      ``Sync Pin Reads/sec``
    ]

/// Client Side Caching: Performance counters for SMB BranchCache for reduced bandwidth consumption
///
/// This performance counter does not have instance based counters
module ``Client Side Caching`` =

  [<Literal>]
  let Category = "Client Side Caching"

  let PCC = getPCC Category
  /// Application Bytes Read From Cache: Transparently cached bytes read by applications from the Client Side Cache
  let ``Application Bytes Read From Cache`` =
    { category = "Client Side Caching"; counter = "Application Bytes Read From Cache"; instance = NotApplicable }
  /// Application Bytes Read From Server: Transparently cached bytes read by applications from the server
  let ``Application Bytes Read From Server`` =
    { category = "Client Side Caching"; counter = "Application Bytes Read From Server"; instance = NotApplicable }
  /// Application Bytes Read From Server (Not Cached): Transparently cached bytes read by applications from the server and not cached by the client
  let ``Application Bytes Read From Server (Not Cached)`` =
    { category = "Client Side Caching"; counter = "Application Bytes Read From Server (Not Cached)"; instance = NotApplicable }
  /// Prefetch Bytes Read From Cache: Bytes read by the BranchCache prefetcher service from the Client Side Cache
  let ``Prefetch Bytes Read From Cache`` =
    { category = "Client Side Caching"; counter = "Prefetch Bytes Read From Cache"; instance = NotApplicable }
  /// Prefetch Bytes Read From Server: Bytes read by the BranchCache prefetcher from the server
  let ``Prefetch Bytes Read From Server`` =
    { category = "Client Side Caching"; counter = "Prefetch Bytes Read From Server"; instance = NotApplicable }
  /// Prefetch Operations Queued: Count of prefetch operations queued to retrieve or publish BranchCache data
  let ``Prefetch Operations Queued`` =
    { category = "Client Side Caching"; counter = "Prefetch Operations Queued"; instance = NotApplicable }
  /// SMB BranchCache Bytes Published: Bytes published back to BranchCache
  let ``SMB BranchCache Bytes Published`` =
    { category = "Client Side Caching"; counter = "SMB BranchCache Bytes Published"; instance = NotApplicable }
  /// SMB BranchCache Bytes Received: Bytes received from BranchCache
  let ``SMB BranchCache Bytes Received`` =
    { category = "Client Side Caching"; counter = "SMB BranchCache Bytes Received"; instance = NotApplicable }
  /// SMB BranchCache Bytes Requested: Bytes requested from BranchCache
  let ``SMB BranchCache Bytes Requested`` =
    { category = "Client Side Caching"; counter = "SMB BranchCache Bytes Requested"; instance = NotApplicable }
  /// SMB BranchCache Bytes Requested From Server: Bytes not found in BranchCache and retrieved from the server
  let ``SMB BranchCache Bytes Requested From Server`` =
    { category = "Client Side Caching"; counter = "SMB BranchCache Bytes Requested From Server"; instance = NotApplicable }
  /// SMB BranchCache Hash Bytes Received: Bytes of hash data successfully received back from the server for BranchCache lookup
  let ``SMB BranchCache Hash Bytes Received`` =
    { category = "Client Side Caching"; counter = "SMB BranchCache Hash Bytes Received"; instance = NotApplicable }
  /// SMB BranchCache Hashes Received: Count of hash requests successfully receieved back from the server for BranchCache lookup
  let ``SMB BranchCache Hashes Received`` =
    { category = "Client Side Caching"; counter = "SMB BranchCache Hashes Received"; instance = NotApplicable }
  /// SMB BranchCache Hashes Requested: Count of hash requests sent to the server for BranchCache lookup
  let ``SMB BranchCache Hashes Requested`` =
    { category = "Client Side Caching"; counter = "SMB BranchCache Hashes Requested"; instance = NotApplicable }

  let allCounters =
    [ ``Application Bytes Read From Cache``
      ``Application Bytes Read From Server``
      ``Application Bytes Read From Server (Not Cached)``
      ``Prefetch Bytes Read From Cache``
      ``Prefetch Bytes Read From Server``
      ``Prefetch Operations Queued``
      ``SMB BranchCache Bytes Published``
      ``SMB BranchCache Bytes Received``
      ``SMB BranchCache Bytes Requested``
      ``SMB BranchCache Bytes Requested From Server``
      ``SMB BranchCache Hash Bytes Received``
      ``SMB BranchCache Hashes Received``
      ``SMB BranchCache Hashes Requested``
    ]

/// DNS64 Global: Statistics of DNS64 on this machine.
///
/// This performance counter does not have non-instance based counters
module ``DNS64 Global`` =

  [<Literal>]
  let Category = "DNS64 Global"

  let PCC = getPCC Category
  /// AAAA - Synthesized records: Number of synthesized AAAA records.
  let ``AAAA - Synthesized records`` instance =
    { category = "DNS64 Global"; counter = "AAAA - Synthesized records"; instance = instance }
  /// AAAA queries - Failed: Number of AAAA queries unsuccessfully served by the DNS64 server.
  let ``AAAA queries - Failed`` instance =
    { category = "DNS64 Global"; counter = "AAAA queries - Failed"; instance = instance }
  /// AAAA queries - Successful: Number of AAAA queries successfully served by the DNS64 server.
  let ``AAAA queries - Successful`` instance =
    { category = "DNS64 Global"; counter = "AAAA queries - Successful"; instance = instance }
  /// IP6.ARPA queries - Matched: Number of IP6.ARPA PTR queries, matched configured prefixes.
  let ``IP6.ARPA queries - Matched`` instance =
    { category = "DNS64 Global"; counter = "IP6.ARPA queries - Matched"; instance = instance }
  /// Other queries - Failed: Number of unsuccessfully served pass-through queries.
  let ``Other queries - Failed`` instance =
    { category = "DNS64 Global"; counter = "Other queries - Failed"; instance = instance }
  /// Other queries - Successful: Number of successfully served pass-through queries.
  let ``Other queries - Successful`` instance =
    { category = "DNS64 Global"; counter = "Other queries - Successful"; instance = instance }

  let allCounters =
    [ ``AAAA - Synthesized records``
      ``AAAA queries - Failed``
      ``AAAA queries - Successful``
      ``IP6.ARPA queries - Matched``
      ``Other queries - Failed``
      ``Other queries - Successful``
    ]

/// Database: Database provides performance statistics for each process using the ESE high performance embedded database management system.
///
/// This performance counter does not have non-instance based counters
module ``Database`` =

  [<Literal>]
  let Category = "Database"

  let PCC = getPCC Category
  /// B+ Tree Append Splits/sec: B+ Tree Append Splits/sec is the count of times a page is appended to a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Append Splits/sec`` instance =
    { category = "Database"; counter = "B+ Tree Append Splits/sec"; instance = instance }
  /// B+ Tree Appends/sec: B+ Tree Appends/sec is the count of times a record is appended to a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Appends/sec`` instance =
    { category = "Database"; counter = "B+ Tree Appends/sec"; instance = instance }
  /// B+ Tree Creates (Total): B+ Tree Creates (Total) is the total number of B+ Trees and their corresponding space trees (if any) created.  This can also be viewed as the total number of FDP creates.  [Dev Only]
  let ``B+ Tree Creates (Total)`` instance =
    { category = "Database"; counter = "B+ Tree Creates (Total)"; instance = instance }
  /// B+ Tree Creates/sec: B+ Tree Creates/sec is the number of B+ Trees and their corresponding space trees (if any) created per second.  This can also be viewed as the number of FDP creates per second.  [Dev Only]
  let ``B+ Tree Creates/sec`` instance =
    { category = "Database"; counter = "B+ Tree Creates/sec"; instance = instance }
  /// B+ Tree Deletes/sec: B+ Tree Deletes/sec is the count of times a record is deleted in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Deletes/sec`` instance =
    { category = "Database"; counter = "B+ Tree Deletes/sec"; instance = instance }
  /// B+ Tree Destroys (Total): B+ Tree Destroys (Total) is the total number of B+ Trees and their corresponding space trees (if any) destroyed.  This can also be viewed as the total number of FDP destroys.  [Dev Only]
  let ``B+ Tree Destroys (Total)`` instance =
    { category = "Database"; counter = "B+ Tree Destroys (Total)"; instance = instance }
  /// B+ Tree Destroys/sec: B+ Tree Destroys/sec is the number of B+ Trees and their corresponding space trees (if any) destroyed per second.  This can also be viewed as the number of FDP destroys per second.  [Dev Only]
  let ``B+ Tree Destroys/sec`` instance =
    { category = "Database"; counter = "B+ Tree Destroys/sec"; instance = instance }
  /// B+ Tree Empty Page Merges/sec: B+ Tree Empty Page Merges/sec is the count of empty pages removed from a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Empty Page Merges/sec`` instance =
    { category = "Database"; counter = "B+ Tree Empty Page Merges/sec"; instance = instance }
  /// B+ Tree Failed Simple Page Cleanup Attempts/sec: B+ Tree Failed Simple Page Cleanup Attempts/sec is the rate that attempts to reclaim deleted node space on a page are unsuccessful due to a conflict when attempting to write-latch the page. The cleanup is re-tried by locking the root of the B+ Tree.  [Dev Only]
  let ``B+ Tree Failed Simple Page Cleanup Attempts/sec`` instance =
    { category = "Database"; counter = "B+ Tree Failed Simple Page Cleanup Attempts/sec"; instance = instance }
  /// B+ Tree Flag Deletes/sec: B+ Tree Flag Deletes/sec is the count of times a record is flag deleted in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Flag Deletes/sec`` instance =
    { category = "Database"; counter = "B+ Tree Flag Deletes/sec"; instance = instance }
  /// B+ Tree Inserts/sec: B+ Tree Inserts/sec is the count of times a record is inserted in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Inserts/sec`` instance =
    { category = "Database"; counter = "B+ Tree Inserts/sec"; instance = instance }
  /// B+ Tree Left Merges/sec: B+ Tree Left Merges/sec is the count of pages removed from a database B+ Tree per second by moving all its records to the previous page to the left.  [Dev Only]
  let ``B+ Tree Left Merges/sec`` instance =
    { category = "Database"; counter = "B+ Tree Left Merges/sec"; instance = instance }
  /// B+ Tree Merges/sec: B+ Tree Merges/sec is the count of pages merged in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Merges/sec`` instance =
    { category = "Database"; counter = "B+ Tree Merges/sec"; instance = instance }
  /// B+ Tree Move Nexts (Nodes Filtered)/sec: B+ Tree Move Nexts (Nodes Filtered)/sec is the count of times the database engine filters records while attempting to move to the next record in a B+ Tree per second.  [Dev Only]
  let ``B+ Tree Move Nexts (Nodes Filtered)/sec`` instance =
    { category = "Database"; counter = "B+ Tree Move Nexts (Nodes Filtered)/sec"; instance = instance }
  /// B+ Tree Move Nexts (Non-Visible Nodes Skipped)/sec: B+ Tree Move Nexts (Non-Visible Nodes Skipped)/sec is the count of times the database engine skips non-visible records while attempting to move to the next visible record in a B+ Tree per second.  [Dev Only]
  let ``B+ Tree Move Nexts (Non-Visible Nodes Skipped)/sec`` instance =
    { category = "Database"; counter = "B+ Tree Move Nexts (Non-Visible Nodes Skipped)/sec"; instance = instance }
  /// B+ Tree Move Nexts/sec: B+ Tree Move Nexts/sec is the count of times the database engine moves to the next record in a B+ Tree per second.  [Dev Only]
  let ``B+ Tree Move Nexts/sec`` instance =
    { category = "Database"; counter = "B+ Tree Move Nexts/sec"; instance = instance }
  /// B+ Tree Move Prevs (Nodes Filtered)/sec: B+ Tree Move Prevs (Nodes Filtered)/sec is the count of times the database engine filters records while attempting to move to the previous record in a B+ Tree per second.  [Dev Only]
  let ``B+ Tree Move Prevs (Nodes Filtered)/sec`` instance =
    { category = "Database"; counter = "B+ Tree Move Prevs (Nodes Filtered)/sec"; instance = instance }
  /// B+ Tree Move Prevs (Non-Visible Nodes Skipped)/sec: B+ Tree Move Prevs (Non-Visible Nodes Skipped)/sec is the count of times the database engine skips non-visible records while attempting to move to the previous visible record in a B+ Tree per second.  [Dev Only]
  let ``B+ Tree Move Prevs (Non-Visible Nodes Skipped)/sec`` instance =
    { category = "Database"; counter = "B+ Tree Move Prevs (Non-Visible Nodes Skipped)/sec"; instance = instance }
  /// B+ Tree Move Prevs/sec: B+ Tree Move Prevs/sec is the count of times the database engine moves to the previous record in a B+ Tree per second.  [Dev Only]
  let ``B+ Tree Move Prevs/sec`` instance =
    { category = "Database"; counter = "B+ Tree Move Prevs/sec"; instance = instance }
  /// B+ Tree Opportune Prereads/sec: B+ Tree Opportune Prereads/sec is the number of pages per second that are preread because they are adjacent to a page read by a seek.  [Dev Only]
  let ``B+ Tree Opportune Prereads/sec`` instance =
    { category = "Database"; counter = "B+ Tree Opportune Prereads/sec"; instance = instance }
  /// B+ Tree Page Moves/sec: B+ Tree Page Moves/sec is the count of B+ Tree pages per second where all the records are moved to a new page. [Dev Only]
  let ``B+ Tree Page Moves/sec`` instance =
    { category = "Database"; counter = "B+ Tree Page Moves/sec"; instance = instance }
  /// B+ Tree Partial Left Merges/sec: B+ Tree Partial Left Merges/sec is the count of pages where some of its records are moved to a page on the left in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Partial Left Merges/sec`` instance =
    { category = "Database"; counter = "B+ Tree Partial Left Merges/sec"; instance = instance }
  /// B+ Tree Partial Merges/sec: B+ Tree Partial Merges/sec is the count of pages where some of its records are moved to a page on the right in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Partial Merges/sec`` instance =
    { category = "Database"; counter = "B+ Tree Partial Merges/sec"; instance = instance }
  /// B+ Tree Replaces/sec: B+ Tree Replaces/sec is the count of times a record is replaced in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Replaces/sec`` instance =
    { category = "Database"; counter = "B+ Tree Replaces/sec"; instance = instance }
  /// B+ Tree Right Hotpoint Splits/sec: B+ Tree Right Hotpoint Splits/sec is the count of times a page is split right in a database B+ Tree, but which is treated as an append at a local "hotpoint" in the B+ Tree per second.  [Dev Only]
  let ``B+ Tree Right Hotpoint Splits/sec`` instance =
    { category = "Database"; counter = "B+ Tree Right Hotpoint Splits/sec"; instance = instance }
  /// B+ Tree Right Merges/sec: Right Merges/sec is the count of pages removed from a database B+ Tree per second by moving all its records to the next page to the right.  [Dev Only]
  let ``B+ Tree Right Merges/sec`` instance =
    { category = "Database"; counter = "B+ Tree Right Merges/sec"; instance = instance }
  /// B+ Tree Right Splits/sec: B+ Tree Right Splits/sec is the count of times a page is split right in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Right Splits/sec`` instance =
    { category = "Database"; counter = "B+ Tree Right Splits/sec"; instance = instance }
  /// B+ Tree Seek Short Circuits/sec: B+ Tree Seek Short Circuits/sec is the count of repeated seeks to the same record in a database B+ Tree that are saved by jumping directly to the cached physical location of that record per second.  [Dev Only]
  let ``B+ Tree Seek Short Circuits/sec`` instance =
    { category = "Database"; counter = "B+ Tree Seek Short Circuits/sec"; instance = instance }
  /// B+ Tree Seeks/sec: B+ Tree Seeks/sec is the count of times a record is seeked to by a key in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Seeks/sec`` instance =
    { category = "Database"; counter = "B+ Tree Seeks/sec"; instance = instance }
  /// B+ Tree Splits/sec: B+ Tree Splits/sec is the count of times a page is appended to or split in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Splits/sec`` instance =
    { category = "Database"; counter = "B+ Tree Splits/sec"; instance = instance }
  /// B+ Tree Unnecessary Sibling Latches/sec: B+ Tree Unnecessary Sibling Latches/sec is the count of sibling pages latched during a database B+ Tree Delete in the hopes of performing a merge where a merge is not possible, making that latch unnecessary.  [Dev Only]
  let ``B+ Tree Unnecessary Sibling Latches/sec`` instance =
    { category = "Database"; counter = "B+ Tree Unnecessary Sibling Latches/sec"; instance = instance }
  /// B+ Tree Vertical Splits/sec: B+ Tree Vertical Splits/sec is the count of times a page is split vertically in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Vertical Splits/sec`` instance =
    { category = "Database"; counter = "B+ Tree Vertical Splits/sec"; instance = instance }
  /// Database Cache % Available: Database Cache % Available is the percentage of the database cache that can be allocated to cache database pages that are newly created or read in from the database file(s).  [Dev Only]
  let ``Database Cache % Available`` instance =
    { category = "Database"; counter = "Database Cache % Available"; instance = instance }
  /// Database Cache % Available Max: Database Cache % Available Max is the maximum percentage of the database cache that is kept to be allocated to cache database pages that are newly created or read in from the database file(s).  This percentage should be set as low as possible but far enough above the minimum percentage so that efficient production of availible pages is possible.  [Dev Only]
  let ``Database Cache % Available Max`` instance =
    { category = "Database"; counter = "Database Cache % Available Max"; instance = instance }
  /// Database Cache % Available Min: Database Cache % Available Min is the minimum percentage of the database cache that is kept to be allocated to cache database pages that are newly created or read in from the database file(s).  If the percentage of available pages drops below this minimum, pages are thrown out of the database cache until the maximum percentage of available pages is reached.  This percentage should be set as low as possible without causing the actual percentage to drop to zero, causing cache fault stalls.  [Dev Only]
  let ``Database Cache % Available Min`` instance =
    { category = "Database"; counter = "Database Cache % Available Min"; instance = instance }
  /// Database Cache % Clean: Database Cache % Clean is the percentage of the database cache that does not contain modified data.  [Dev Only]
  let ``Database Cache % Clean`` instance =
    { category = "Database"; counter = "Database Cache % Clean"; instance = instance }
  /// Database Cache % Dehydrated: Database Cache % Dehydrated is the percentage of pages in the database  cache that are currently compressed.
  let ``Database Cache % Dehydrated`` instance =
    { category = "Database"; counter = "Database Cache % Dehydrated"; instance = instance }
  /// Database Cache % Fast Latch: Database Cache % Fast Latch is the percentage of database pages latched for access to their data using a hint to tell the cache manager where that page might be in memory.  Ideally, this percentage should match Database Cache % Hit.  [Dev Only]
  let ``Database Cache % Fast Latch`` instance =
    { category = "Database"; counter = "Database Cache % Fast Latch"; instance = instance }
  /// Database Cache % Hit: Database Cache % Hit is the percentage of database file page requests that were fulfilled by the database cache without causing a file operation.  If this percentage is too low, the database cache size may be too small.
  let ``Database Cache % Hit`` instance =
    { category = "Database"; counter = "Database Cache % Hit"; instance = instance }
  /// Database Cache % Hit (Uncorrelated): Database Cache % Hit (Uncorrelated) is the percentage of uncorrelated  database file page requests that were fulfilled by the database cache.
  let ``Database Cache % Hit (Uncorrelated)`` instance =
    { category = "Database"; counter = "Database Cache % Hit (Uncorrelated)"; instance = instance }
  /// Database Cache % Pinned: Database Cache % Pinned is the percentage of the database cache that pinned in the memory.  [Dev Only]
  let ``Database Cache % Pinned`` instance =
    { category = "Database"; counter = "Database Cache % Pinned"; instance = instance }
  /// Database Cache % Resident: Database Cache % Resident is the percentage of the database cache that are currently in the process's working set.  [Dev Only]
  let ``Database Cache % Resident`` instance =
    { category = "Database"; counter = "Database Cache % Resident"; instance = instance }
  /// Database Cache % Versioned: Database Cache % Versioned is the percentage of the database cache that contains older versions of currently cached pages that have not yet been written to disk and thrown out of the cache.  [Dev Only]
  let ``Database Cache % Versioned`` instance =
    { category = "Database"; counter = "Database Cache % Versioned"; instance = instance }
  /// Database Cache Lifetime (K1): Provides the cache lifetime (in seconds) for all K=1 resources.  [Dev Only]
  let ``Database Cache Lifetime (K1)`` instance =
    { category = "Database"; counter = "Database Cache Lifetime (K1)"; instance = instance }
  /// Database Cache Lifetime (K2): Provides the cache lifetime (in seconds) for all K=2 resources.  [Dev Only]
  let ``Database Cache Lifetime (K2)`` instance =
    { category = "Database"; counter = "Database Cache Lifetime (K2)"; instance = instance }
  /// Database Cache Lifetime (Longest): Provides the cache lifetime to the oldest unevicted record, holding back scavenge.  [Dev Only]
  let ``Database Cache Lifetime (Longest)`` instance =
    { category = "Database"; counter = "Database Cache Lifetime (Longest)"; instance = instance }
  /// Database Cache Lifetime (Low): Provides the cache lifetime to the TRUE most recently evicted resource, across scans.  [Dev Only]
  let ``Database Cache Lifetime (Low)`` instance =
    { category = "Database"; counter = "Database Cache Lifetime (Low)"; instance = instance }
  /// Database Cache Lifetime (Normal): Provides the cache lifetime to the most recently evicted resource, used to base cache priority.  [Dev Only]
  let ``Database Cache Lifetime (Normal)`` instance =
    { category = "Database"; counter = "Database Cache Lifetime (Normal)"; instance = instance }
  /// Database Cache Lifetime (Supercold): Provides a the distance in cache lifetime for the supercold insertion point.  [Dev Only]
  let ``Database Cache Lifetime (Supercold)`` instance =
    { category = "Database"; counter = "Database Cache Lifetime (Supercold)"; instance = instance }
  /// Database Cache Lifetime Agg Var: Provides the delta (in ms) of Cache Lifetime (Low) vs. Cache Lifetime (Normal).  [Dev Only]
  let ``Database Cache Lifetime Agg Var`` instance =
    { category = "Database"; counter = "Database Cache Lifetime Agg Var"; instance = instance }
  /// Database Cache Memory Committed: Database Cache Memory Committed is the amount of memory  committed and ready to use or already in use by the database cache manager. If view-cache is enabled, this counter reflects the expected amount of Windows file cache memory consumed by this application to host database data.
  let ``Database Cache Memory Committed`` instance =
    { category = "Database"; counter = "Database Cache Memory Committed"; instance = instance }
  /// Database Cache Memory Committed (MB): Database Cache Memory Committed (MB) is the amount of memory (in megabytes) committed and ready to use or already in use by the database cache manager. If view-cache is enabled, this counter reflects the expected amount of Windows file cache memory consumed by this application to host database data.
  let ``Database Cache Memory Committed (MB)`` instance =
    { category = "Database"; counter = "Database Cache Memory Committed (MB)"; instance = instance }
  /// Database Cache Memory Reserved: Database Cache Memory Reserved is the amount of memory reserved for use by the database cache manager. If view-cache is enabled, this counter is zero because the Windows file cache is used to host database data.
  let ``Database Cache Memory Reserved`` instance =
    { category = "Database"; counter = "Database Cache Memory Reserved"; instance = instance }
  /// Database Cache Memory Reserved (MB): Database Cache Memory Reserved (MB) is the amount of memory (in megabytes) reserved for use by the database cache manager. If view-cache is enabled, this counter is zero because the Windows file cache is used to host database data.
  let ``Database Cache Memory Reserved (MB)`` instance =
    { category = "Database"; counter = "Database Cache Memory Reserved (MB)"; instance = instance }
  /// Database Cache Misses/sec: Database Cache Misses per second is the rate at which database file page requests were fulfilled by the database cache by causing a file operation.  If this rate is high then the database cache size may be too small.
  let ``Database Cache Misses/sec`` instance =
    { category = "Database"; counter = "Database Cache Misses/sec"; instance = instance }
  /// Database Cache Requests/sec: Database Cache Requests/sec is the rate that pages are requested from the database cache.
  let ``Database Cache Requests/sec`` instance =
    { category = "Database"; counter = "Database Cache Requests/sec"; instance = instance }
  /// Database Cache Scan Buckets Scanned/scan: Provides the number of buckets required to evaluate by LRU-k to do the  last scan.  [Dev Only]
  let ``Database Cache Scan Buckets Scanned/scan`` instance =
    { category = "Database"; counter = "Database Cache Scan Buckets Scanned/scan"; instance = instance }
  /// Database Cache Scan Empty Buckets Scanned/scan: Provides the number of buckets that were empty to evaluate LRU-k during the last scan.  [Dev Only]
  let ``Database Cache Scan Empty Buckets Scanned/scan`` instance =
    { category = "Database"; counter = "Database Cache Scan Empty Buckets Scanned/scan"; instance = instance }
  /// Database Cache Scan Entries/scan: Provides the number of entries returned by LRU-k.  [Dev Only]
  let ``Database Cache Scan Entries/scan`` instance =
    { category = "Database"; counter = "Database Cache Scan Entries/scan"; instance = instance }
  /// Database Cache Scan Found-to-Evict Range: Provides the delta (in ms) between the first found resource during scavenge scan and the last evicted resource.  [Dev Only]
  let ``Database Cache Scan Found-to-Evict Range`` instance =
    { category = "Database"; counter = "Database Cache Scan Found-to-Evict Range"; instance = instance }
  /// Database Cache Scan ID Range/scan: Provides the raw ID range from the approximate index covered during last scan.  [Dev Only]
  let ``Database Cache Scan ID Range/scan`` instance =
    { category = "Database"; counter = "Database Cache Scan ID Range/scan"; instance = instance }
  /// Database Cache Scan Page Evaluated Out-of-Order/sec: Database Cache Scan Page Evaluated Out-of-order/sec is the rate at which database pages are considered for eviction from the database page cache in a priority counter to the page replacement algorithm.  [Dev Only]
  let ``Database Cache Scan Page Evaluated Out-of-Order/sec`` instance =
    { category = "Database"; counter = "Database Cache Scan Page Evaluated Out-of-Order/sec"; instance = instance }
  /// Database Cache Scan Pages Evaluated/sec: Database Cache Scan Pages Evaluated/sec is the rate at which database pages are considered for eviction from the database page cache.  [Dev Only]
  let ``Database Cache Scan Pages Evaluated/sec`` instance =
    { category = "Database"; counter = "Database Cache Scan Pages Evaluated/sec"; instance = instance }
  /// Database Cache Scan Pages Moved/sec: Database Cache Scan Pages Moved/sec is the rate at which database pages are evaluated for returning from the database eviction data structure but instead re-indexed.  [Dev Only]
  let ``Database Cache Scan Pages Moved/sec`` instance =
    { category = "Database"; counter = "Database Cache Scan Pages Moved/sec"; instance = instance }
  /// Database Cache Scan Time (ms)/scan: Provides the scan range in seconds evaluated from the LRU-k.  [Dev Only]
  let ``Database Cache Scan Time (ms)/scan`` instance =
    { category = "Database"; counter = "Database Cache Scan Time (ms)/scan"; instance = instance }
  /// Database Cache Size: Database Cache Size is the amount of system memory used by the database cache manager to hold commonly used information from the database file(s) to prevent file operations. If the database cache size seems to be too small for optimal performance and there is very little available memory on the system (see Memory/Available Bytes), adding more memory to the system may increase performance. If there is lots of available memory on the system and the database cache size is not growing beyond a certain point, the database cache size may be capped at an artificially low limit. Increasing this limit may increase performance.
  let ``Database Cache Size`` instance =
    { category = "Database"; counter = "Database Cache Size"; instance = instance }
  /// Database Cache Size (MB): Database Cache Size (MB) is the amount of system memory, in megabytes, used by the database cache manager to hold commonly used information from the database file(s) to prevent file operations. If the database cache size seems to be too small for optimal performance, and there is very little available memory on the system (see Memory/Available Bytes), an increase of memory in the system may increase performance. If there is a large amount of available memory on the system, and the database cache size is not growing beyond a certain point, the database cache size may be capped at an artificially low limit. An increase in this limit may increase performance.
  let ``Database Cache Size (MB)`` instance =
    { category = "Database"; counter = "Database Cache Size (MB)"; instance = instance }
  /// Database Cache Size Effective: Database Cache Size Effective is the amount of system memory that, hypothetically, would be used by the database cache manager if all used dehydrated/compressed database cache buffers were rehydrated/uncompressed.
  let ``Database Cache Size Effective`` instance =
    { category = "Database"; counter = "Database Cache Size Effective"; instance = instance }
  /// Database Cache Size Effective (MB): Database Cache Size Effective (MB) is the amount of system memory, in megabytes, that, hypothetically, would be used by the database cache manager if all used dehydrated/compressed database cache buffers were rehydrated/uncompressed.
  let ``Database Cache Size Effective (MB)`` instance =
    { category = "Database"; counter = "Database Cache Size Effective (MB)"; instance = instance }
  /// Database Cache Size Max: Database Cache Size Max is the maximum amount of system memory configured for use by the database cache manager to hold commonly used information from the database file(s) to prevent file operations.  [Dev Only]
  let ``Database Cache Size Max`` instance =
    { category = "Database"; counter = "Database Cache Size Max"; instance = instance }
  /// Database Cache Size Min: Database Cache Size Min is the minimum amount of system memory configured for use by the database cache manager to hold commonly used information from the database file(s) to prevent file operations.  [Dev Only]
  let ``Database Cache Size Min`` instance =
    { category = "Database"; counter = "Database Cache Size Min"; instance = instance }
  /// Database Cache Size Resident: Database Cache Size Resident is the amount of system memory used by the database cache that is currently part of the working set of the process.  If Database Cache Size Resident is ever significantly smaller than Database Cache Size then the operating system has chosen to reclaim that system memory for use in other parts of the system.  The database cache will recover from this event but if this is a common occurrence then it can lead to significant performance problems.
  let ``Database Cache Size Resident`` instance =
    { category = "Database"; counter = "Database Cache Size Resident"; instance = instance }
  /// Database Cache Size Resident (MB): Database Cache Size Resident (MB) is the amount of system memory (in megabytes) used by the database cache that is currently part of the working set of the process.  If Database Cache Size Resident (MB) is ever significantly smaller than Database Cache Size (MB) then the operating system has chosen to reclaim that system memory for use in other parts of the system.  The database cache will recover from this event but if this is a common occurrence then it can lead to significant performance problems.
  let ``Database Cache Size Resident (MB)`` instance =
    { category = "Database"; counter = "Database Cache Size Resident (MB)"; instance = instance }
  /// Database Cache Size Target: Database Cache Size Target is the amount of system memory that the database cache manager considers to be ideal to use, given the configuration parameters provided by the application and the overall memory usage of the system. [Dev Only]
  let ``Database Cache Size Target`` instance =
    { category = "Database"; counter = "Database Cache Size Target"; instance = instance }
  /// Database Cache Size Target (MB): Database Cache Size Target (MB) is the amount of system memory (in MegaBytes) that the database cache manager considers to be ideal to use, given the configuration parameters provided by the application and the overall memory usage of the system. [Dev Only]
  let ``Database Cache Size Target (MB)`` instance =
    { category = "Database"; counter = "Database Cache Size Target (MB)"; instance = instance }
  /// Database Cache Size Unattached (MB): Database Cache Size Unattached (MB) is the amount of system memory (in MegaBytes) that the database cache manager is holding in case the database gets  re-attached and the cache becomes useful again. [Dev Only]
  let ``Database Cache Size Unattached (MB)`` instance =
    { category = "Database"; counter = "Database Cache Size Unattached (MB)"; instance = instance }
  /// Database Cache Sizing Duration: Database Cache Sizing Duration is the time elapsed, in seconds, since a currently outstanding cache sizing operation started. This counter displays zero if cache sizing is not running. [Dev Only]
  let ``Database Cache Sizing Duration`` instance =
    { category = "Database"; counter = "Database Cache Sizing Duration"; instance = instance }
  /// Database Cache Super Cold Attempts/sec: Provides the rate at which the engine is attempting to mark pages super  cold, for immediate eviction.  [Dev Only]
  let ``Database Cache Super Cold Attempts/sec`` instance =
    { category = "Database"; counter = "Database Cache Super Cold Attempts/sec"; instance = instance }
  /// Database Cache Super Cold Successes/sec: Provides the rate at which the engine has successfully marked pages super  cold, for immediate eviction.  [Dev Only]
  let ``Database Cache Super Cold Successes/sec`` instance =
    { category = "Database"; counter = "Database Cache Super Cold Successes/sec"; instance = instance }
  /// Database Cache Super Colded Resources: Provides the number of currently super colded resources.  It is not hundred percent accurate.  [Dev Only]
  let ``Database Cache Super Colded Resources`` instance =
    { category = "Database"; counter = "Database Cache Super Colded Resources"; instance = instance }
  /// Database Maintenance Duration: Database Maintenance Duration is the number of hours that have passed since maintenance last completed for this database.
  let ``Database Maintenance Duration`` instance =
    { category = "Database"; counter = "Database Maintenance Duration"; instance = instance }
  /// Database Maintenance IO Re-Reads Average Bytes: Database Maintenance IO Re-Reads Average Bytes is the approximate average size in bytes of Database Maintenance read IO for pages already cached in the buffer manager. [Dev Only]
  let ``Database Maintenance IO Re-Reads Average Bytes`` instance =
    { category = "Database"; counter = "Database Maintenance IO Re-Reads Average Bytes"; instance = instance }
  /// Database Maintenance IO Re-Reads Average Latency: Database Maintenance IO Re-Reads Average Latency is the approximate average latency in milli-seconds for Database Maintenance read IO for pages already cached in the buffer manager. [Dev Only]
  let ``Database Maintenance IO Re-Reads Average Latency`` instance =
    { category = "Database"; counter = "Database Maintenance IO Re-Reads Average Latency"; instance = instance }
  /// Database Maintenance IO Re-Reads/sec: Database Maintenance IO Re-Reads/sec is the approximate number of Database Maintenance read IO operations for pages already cached in the buffer manager generated/sec. [Dev Only]
  let ``Database Maintenance IO Re-Reads/sec`` instance =
    { category = "Database"; counter = "Database Maintenance IO Re-Reads/sec"; instance = instance }
  /// Database Maintenance IO Reads Average Bytes: Database Maintenance IO Reads Average Bytes is the approximate average size in bytes of Database Maintenance read IO. [Dev Only]
  let ``Database Maintenance IO Reads Average Bytes`` instance =
    { category = "Database"; counter = "Database Maintenance IO Reads Average Bytes"; instance = instance }
  /// Database Maintenance IO Reads/sec: Database Maintenance IO Reads/sec is the approximate number of Database Maintenance read IO operations generated/sec. [Dev Only]
  let ``Database Maintenance IO Reads/sec`` instance =
    { category = "Database"; counter = "Database Maintenance IO Reads/sec"; instance = instance }
  /// Database Maintenance Pages Bad Checksums: Database Maintenance Pages Bad Checksums is the number of non-correctable page checksums encountered during a database maintenance pass.
  let ``Database Maintenance Pages Bad Checksums`` instance =
    { category = "Database"; counter = "Database Maintenance Pages Bad Checksums"; instance = instance }
  /// Database Maintenance Pages Read: Database Maintenance Pages Read is the number of pages read by database maintenance. [Dev Only]
  let ``Database Maintenance Pages Read`` instance =
    { category = "Database"; counter = "Database Maintenance Pages Read"; instance = instance }
  /// Database Maintenance Pages Read/sec: Database Maintenance Pages Read/sec is the rate at which pages are read by database maintenance. [Dev Only]
  let ``Database Maintenance Pages Read/sec`` instance =
    { category = "Database"; counter = "Database Maintenance Pages Read/sec"; instance = instance }
  /// Database Maintenance Pages Zeroed: Database Maintenance Pages Zeroed is the number of pages zeroed/scrubbed by database maintenance. [Dev Only]
  let ``Database Maintenance Pages Zeroed`` instance =
    { category = "Database"; counter = "Database Maintenance Pages Zeroed"; instance = instance }
  /// Database Maintenance Pages Zeroed/sec: Database Maintenance Pages Zeroed/sec is the rate at which pages are zeroed/scrubbed by database maintenance. [Dev Only]
  let ``Database Maintenance Pages Zeroed/sec`` instance =
    { category = "Database"; counter = "Database Maintenance Pages Zeroed/sec"; instance = instance }
  /// Database Maintenance Throttle Setting: Database Maintenance Throttle Setting is the current Database Maintenance throttle setting. [Dev Only]
  let ``Database Maintenance Throttle Setting`` instance =
    { category = "Database"; counter = "Database Maintenance Throttle Setting"; instance = instance }
  /// Database Opportune Write Issued (Total): Database Opportune Write Issued (Total) is the count of IO operationshas been issued for opportune write. [Dev Only]
  let ``Database Opportune Write Issued (Total)`` instance =
    { category = "Database"; counter = "Database Opportune Write Issued (Total)"; instance = instance }
  /// Database Page Allocation File Extension Async Consumed/sec: Database Page Allocation File Extension Async Consumed/sec is the rate of page allocations from a database file that must be serviced by extending the database file, but which do not stall when doing doing so.  [Dev Only]
  let ``Database Page Allocation File Extension Async Consumed/sec`` instance =
    { category = "Database"; counter = "Database Page Allocation File Extension Async Consumed/sec"; instance = instance }
  /// Database Page Allocation File Extension Stalls/sec: Database Page Allocation File Extension Stalls/sec is the rate of attempts to extend the database file that stall.  [Dev Only]
  let ``Database Page Allocation File Extension Stalls/sec`` instance =
    { category = "Database"; counter = "Database Page Allocation File Extension Stalls/sec"; instance = instance }
  /// Database Page Allocation File Shrink Stalls/sec: Database Page Allocation File Shrink Stalls/sec is the rate of attempts to shrink the database file that stall.  [Dev Only]
  let ``Database Page Allocation File Shrink Stalls/sec`` instance =
    { category = "Database"; counter = "Database Page Allocation File Shrink Stalls/sec"; instance = instance }
  /// Database Page Bad Latch Hints/sec: Database Page Bad Latch Hints/sec is the rate that incorrect hints to the location of a given page in the cache are given to the cache manager.  These hints are used to perform fast latches.  [Dev Only]
  let ``Database Page Bad Latch Hints/sec`` instance =
    { category = "Database"; counter = "Database Page Bad Latch Hints/sec"; instance = instance }
  /// Database Page Evictions (Patch)/sec: Database Page Evictions (Patch)/sec is the rate that cached pages are evicted due to active page patching.  [Dev Only]
  let ``Database Page Evictions (Patch)/sec`` instance =
    { category = "Database"; counter = "Database Page Evictions (Patch)/sec"; instance = instance }
  /// Database Page Evictions (Preread Untouched)/sec: Database Page Evictions (Preread Untouched)/sec is the rate that pages are read in anticipation of future use from the database file(s) into the database cache that were subsequently thrown out without being used. This is non-ideal behavior that represents a waste of I/O bandwidth and processing time.  [Dev Only]
  let ``Database Page Evictions (Preread Untouched)/sec`` instance =
    { category = "Database"; counter = "Database Page Evictions (Preread Untouched)/sec"; instance = instance }
  /// Database Page Evictions (Purge)/sec: Database Page Evictions (Purge)/sec is the rate that cached pages are evicted due to purging a cached context / database.  [Dev Only]
  let ``Database Page Evictions (Purge)/sec`` instance =
    { category = "Database"; counter = "Database Page Evictions (Purge)/sec"; instance = instance }
  /// Database Page Evictions (Scavenging)/sec: Database Page Evictions (Scavenging)/sec is the rate that cached pages are evicted due to scavenging / avail pool maintenance running.  [Dev Only]
  let ``Database Page Evictions (Scavenging)/sec`` instance =
    { category = "Database"; counter = "Database Page Evictions (Scavenging)/sec"; instance = instance }
  /// Database Page Evictions (Scavenging.SuperCold.Ext)/sec: Database Page Evictions (Scavenging.SuperCold.Ext)/sec is the rate that  externally deprioritized cached pages (such as those scaned by DB maintenance)  are evicted due to scavenging / avail pool maintenance running.  [Dev Only]
  let ``Database Page Evictions (Scavenging.SuperCold.Ext)/sec`` instance =
    { category = "Database"; counter = "Database Page Evictions (Scavenging.SuperCold.Ext)/sec"; instance = instance }
  /// Database Page Evictions (Scavenging.SuperCold.Int)/sec: Database Page Evictions (Scavenging.SuperCold.Int)/sec is the rate that internally deprioritized cached pages (such as older version pages) are evicted  due to scavenging / avail pool maintenance running.  [Dev Only]
  let ``Database Page Evictions (Scavenging.SuperCold.Int)/sec`` instance =
    { category = "Database"; counter = "Database Page Evictions (Scavenging.SuperCold.Int)/sec"; instance = instance }
  /// Database Page Evictions (Shrink)/sec: Database Page Evictions (Shrink)/sec is the rate that cached pages are evicted due to the database cache shrinking.  [Dev Only]
  let ``Database Page Evictions (Shrink)/sec`` instance =
    { category = "Database"; counter = "Database Page Evictions (Shrink)/sec"; instance = instance }
  /// Database Page Evictions (k=1)/sec: Database Page Evictions (k=1)/sec is the rate that database file pages are evicted that were of limited usefulness (k=1 pool).  [Dev Only]
  let ``Database Page Evictions (k=1)/sec`` instance =
    { category = "Database"; counter = "Database Page Evictions (k=1)/sec"; instance = instance }
  /// Database Page Evictions (k=2)/sec: Database Page Evictions (k=2)/sec is the rate that database file pages are evicted that were of high usefulness (k=2 pool).  [Dev Only]
  let ``Database Page Evictions (k=2)/sec`` instance =
    { category = "Database"; counter = "Database Page Evictions (k=2)/sec"; instance = instance }
  /// Database Page Evictions/sec: Database Page Evictions/sec is the rate that database file page requests, which require the database cache manager to allocate a new page from the database cache, force another database page out of the cache.  The eviction count is charged when the page is allocated and not when the previous owner of that page was actually evicted from the cache.  If this rate is too high, the database cache size may be too small.
  let ``Database Page Evictions/sec`` instance =
    { category = "Database"; counter = "Database Page Evictions/sec"; instance = instance }
  /// Database Page Fast Latches/sec: Database Page Fast Latches/sec is the rate that database pages are latched for access to their data using a hint to tell the cache manager where that page might be in memory.  [Dev Only]
  let ``Database Page Fast Latches/sec`` instance =
    { category = "Database"; counter = "Database Page Fast Latches/sec"; instance = instance }
  /// Database Page Fault Stalls/sec: Database Page Fault Stalls/sec is the rate of page faults that cannot be serviced because there are no pages available for allocation from the database cache.  If this counter is nonzero most of the time, the clean threshold may be too low.
  let ``Database Page Fault Stalls/sec`` instance =
    { category = "Database"; counter = "Database Page Fault Stalls/sec"; instance = instance }
  /// Database Page Faults/sec: Database Page Faults/sec is the rate that database file page requests require the database cache manager to allocate a new page from the database cache.
  let ``Database Page Faults/sec`` instance =
    { category = "Database"; counter = "Database Page Faults/sec"; instance = instance }
  /// Database Page History % Hit: Database Page History % Hit is the percentage of database page access history record lookups that were successful.  [Dev Only]
  let ``Database Page History % Hit`` instance =
    { category = "Database"; counter = "Database Page History % Hit"; instance = instance }
  /// Database Page History Records: Database Page History Records is the current number of database page access history records retained for supporting the LRU-K page replacment algorithm.  [Dev Only]
  let ``Database Page History Records`` instance =
    { category = "Database"; counter = "Database Page History Records"; instance = instance }
  /// Database Page Latch Conflicts/sec: Database Page Latch Conflicts/sec is the rate that users latching a database page for access to its data fail due to a conflicting latch owned on that same page by another user.  [Dev Only]
  let ``Database Page Latch Conflicts/sec`` instance =
    { category = "Database"; counter = "Database Page Latch Conflicts/sec"; instance = instance }
  /// Database Page Latch Stalls/sec: Database Page Latch Stalls/sec is the rate that users latching a database page for access to its data must wait for another user to release a latch on that same page.  [Dev Only]
  let ``Database Page Latch Stalls/sec`` instance =
    { category = "Database"; counter = "Database Page Latch Stalls/sec"; instance = instance }
  /// Database Page Latches/sec: Database Page Latches/sec is the rate that database pages are latched for access to their data.  [Dev Only]
  let ``Database Page Latches/sec`` instance =
    { category = "Database"; counter = "Database Page Latches/sec"; instance = instance }
  /// Database Page Preread Stalls/sec: Database Page Preread Stalls/sec is the rate that pages are read in anticipation of future use from the database file(s) into the database cache but did not complete preread before intended use.  [Dev Only]
  let ``Database Page Preread Stalls/sec`` instance =
    { category = "Database"; counter = "Database Page Preread Stalls/sec"; instance = instance }
  /// Database Page Touches (Correlated)/sec: Database Page Touches (Correlated)/sec is the rate that database pages are touched within a correlation interval (default=125 ms).  [Dev Only]
  let ``Database Page Touches (Correlated)/sec`` instance =
    { category = "Database"; counter = "Database Page Touches (Correlated)/sec"; instance = instance }
  /// Database Page Touches (Non-Touch)/sec: Database Page Touches (Non-Touch)/sec is the rate that database pages are touched within a single ms (super-correlated).  [Dev Only]
  let ``Database Page Touches (Non-Touch)/sec`` instance =
    { category = "Database"; counter = "Database Page Touches (Non-Touch)/sec"; instance = instance }
  /// Database Page Touches (k=1)/sec: Database Page Touches (k=1)/sec is the rate that database pages are touched for the first time / k=1 pool.  [Dev Only]
  let ``Database Page Touches (k=1)/sec`` instance =
    { category = "Database"; counter = "Database Page Touches (k=1)/sec"; instance = instance }
  /// Database Page Touches (k=2)/sec: Database Page Touches (k=2)/sec is the rate that database pages are subsequently touched and put in the k=2 pool.  [Dev Only]
  let ``Database Page Touches (k=2)/sec`` instance =
    { category = "Database"; counter = "Database Page Touches (k=2)/sec"; instance = instance }
  /// Database Pages Coalesced Read/sec: Database Pages Coalesced Read/sec is the rate that pages are read from the database file(s) to the database cache coalesced with another page. [Dev Only]
  let ``Database Pages Coalesced Read/sec`` instance =
    { category = "Database"; counter = "Database Pages Coalesced Read/sec"; instance = instance }
  /// Database Pages Coalesced Written/sec: Database Pages Coalesced Written/sec is the rate that pages are written to the database file(s) from the database cache coalesced with another page. [Dev Only]
  let ``Database Pages Coalesced Written/sec`` instance =
    { category = "Database"; counter = "Database Pages Coalesced Written/sec"; instance = instance }
  /// Database Pages Colded (Ext)/sec: Database Pages Colded (Ext) per second is the rate at which database pages are deprioritized by sub-components other than the buffer manager to send  for early eviction.  [Dev Only]
  let ``Database Pages Colded (Ext)/sec`` instance =
    { category = "Database"; counter = "Database Pages Colded (Ext)/sec"; instance = instance }
  /// Database Pages Colded (Int)/sec: Database Pages Colded (Int) per second is the rate at which database pages are deprioritized by the buffer manager itself to maintain minimal  cache usage.  [Dev Only]
  let ``Database Pages Colded (Int)/sec`` instance =
    { category = "Database"; counter = "Database Pages Colded (Int)/sec"; instance = instance }
  /// Database Pages Dehydrated/sec: Database Pages Dehydrated/sec is the rate that pages are compressed to memory usage in the buffer manager. [Dev Only]
  let ``Database Pages Dehydrated/sec`` instance =
    { category = "Database"; counter = "Database Pages Dehydrated/sec"; instance = instance }
  /// Database Pages Dirtied (Repeatedly)/sec: Database Pages Dirtied (Repeatedly)/sec is the rate that pages are  repeatedly dirtied / redirtied in the database cache.  [Dev Only]
  let ``Database Pages Dirtied (Repeatedly)/sec`` instance =
    { category = "Database"; counter = "Database Pages Dirtied (Repeatedly)/sec"; instance = instance }
  /// Database Pages Dirtied/sec: Database Pages Dirtied/sec is the rate that pages are dirtied in the database cache.  [Dev Only]
  let ``Database Pages Dirtied/sec`` instance =
    { category = "Database"; counter = "Database Pages Dirtied/sec"; instance = instance }
  /// Database Pages Flushed (Cache Shrink)/sec: Database Pages Flushed (Cache Shrink)/sec is the rate that pages are written to the database file(s) from the database cache because the cache size  must shrink.  [Dev Only]
  let ``Database Pages Flushed (Cache Shrink)/sec`` instance =
    { category = "Database"; counter = "Database Pages Flushed (Cache Shrink)/sec"; instance = instance }
  /// Database Pages Flushed (Checkpoint Foreground)/sec: Database Pages Flushed (Checkpoint Foreground)/sec is the rate that pages are written to the database file(s) from the database cache to keep the checkpoint depth down to configured levels.  [Dev Only]
  let ``Database Pages Flushed (Checkpoint Foreground)/sec`` instance =
    { category = "Database"; counter = "Database Pages Flushed (Checkpoint Foreground)/sec"; instance = instance }
  /// Database Pages Flushed (Checkpoint)/sec: Database Pages Flushed (Checkpoint)/sec is the rate that pages are written to the database file(s) from the database cache to keep the checkpoint depth down to configured levels.  [Dev Only]
  let ``Database Pages Flushed (Checkpoint)/sec`` instance =
    { category = "Database"; counter = "Database Pages Flushed (Checkpoint)/sec"; instance = instance }
  /// Database Pages Flushed (Context Flush)/sec: Database Pages Flushed (Context Flush)/sec is the rate that pages are written to the database file(s) from the database cache due to a requested flush of a buffer context.  [Dev Only]
  let ``Database Pages Flushed (Context Flush)/sec`` instance =
    { category = "Database"; counter = "Database Pages Flushed (Context Flush)/sec"; instance = instance }
  /// Database Pages Flushed (Filthy Foreground)/sec: Database Pages Flushed (Filthy Foreground)/sec is the rate that pages are written to the database file(s) from the database cache because they are marked for filthy / immediate flush.  [Dev Only]
  let ``Database Pages Flushed (Filthy Foreground)/sec`` instance =
    { category = "Database"; counter = "Database Pages Flushed (Filthy Foreground)/sec"; instance = instance }
  /// Database Pages Flushed (Idle)/sec: Database Pages Flushed (Idle)/sec is the rate that pages are written to the database file(s) from the database cache because there is low disk activity.  [Dev Only]
  let ``Database Pages Flushed (Idle)/sec`` instance =
    { category = "Database"; counter = "Database Pages Flushed (Idle)/sec"; instance = instance }
  /// Database Pages Flushed (Scavenge)/sec: Database Pages Flushed (Scavenge)/sec is the rate that pages are written to the database file(s) from the database cache to perform available pool maintenance.  [Dev Only]
  let ``Database Pages Flushed (Scavenge)/sec`` instance =
    { category = "Database"; counter = "Database Pages Flushed (Scavenge)/sec"; instance = instance }
  /// Database Pages Flushed (Scavenge.SuperCold.Ext)/sec: Database Pages Flushed (Scavenge.SuperCold.Ext)/sec is the rate that  externally deprioritized cached pages (such as those scaned by DB maintenance)  are written to the database file(s) from the database cache to perform available pool maintenance.  [Dev Only]
  let ``Database Pages Flushed (Scavenge.SuperCold.Ext)/sec`` instance =
    { category = "Database"; counter = "Database Pages Flushed (Scavenge.SuperCold.Ext)/sec"; instance = instance }
  /// Database Pages Flushed (Scavenge.SuperCold.Int)/sec: Database Pages Flushed (Scavenge.SuperCold.Int)/sec is the rate that  internally deprioritized cached pages (such as older version pages) are  written to the database file(s) from the database cache to perform available pool maintenance.  [Dev Only]
  let ``Database Pages Flushed (Scavenge.SuperCold.Int)/sec`` instance =
    { category = "Database"; counter = "Database Pages Flushed (Scavenge.SuperCold.Int)/sec"; instance = instance }
  /// Database Pages Flushed Opportunely Clean/sec: Database Pages Flushed Opportunely Clean/sec is the rate that clean pages are opportunely written to the database file(s) from the database  cache because they happen to be betweeen two other pages that must  be written.  These additional writes are performed in the hope that the total number of IOs required to write all the dirty pages is reduced.  [Dev Only]
  let ``Database Pages Flushed Opportunely Clean/sec`` instance =
    { category = "Database"; counter = "Database Pages Flushed Opportunely Clean/sec"; instance = instance }
  /// Database Pages Flushed Opportunely/sec: Database Pages Flushed Opportunely/sec is the rate that pages are written to the database file(s) from the database cache because they happen to be near other pages that must be written.  These additional writes are performed before they must happen in the hope that the total number of IOs required to write all the pages is reduced.  [Dev Only]
  let ``Database Pages Flushed Opportunely/sec`` instance =
    { category = "Database"; counter = "Database Pages Flushed Opportunely/sec"; instance = instance }
  /// Database Pages Non-Resident Evicted (Normally)/sec: Database Pages Non-Resident Evicted (Normally)/sec is the number of pages that were paged / trimmed by the OS memory manager, and got evicted normally before being re-used or re-latched. [Dev Only]
  let ``Database Pages Non-Resident Evicted (Normally)/sec`` instance =
    { category = "Database"; counter = "Database Pages Non-Resident Evicted (Normally)/sec"; instance = instance }
  /// Database Pages Non-Resident Faulted In Average Latency: Database Pages Non-Resident Faulted In Average Latency is the average length of  time, in milliseconds, per OS Memory Manager fault operation. [Dev Only]
  let ``Database Pages Non-Resident Faulted In Average Latency`` instance =
    { category = "Database"; counter = "Database Pages Non-Resident Faulted In Average Latency"; instance = instance }
  /// Database Pages Non-Resident Re-read/sec: Database Pages Non-Resident Re-read/sec is the number of pages that could not be reclaimed by soft fault, and must be redirected to the database file as a re-read of the page. [Dev Only]
  let ``Database Pages Non-Resident Re-read/sec`` instance =
    { category = "Database"; counter = "Database Pages Non-Resident Re-read/sec"; instance = instance }
  /// Database Pages Non-Resident Reclaimed (Failed)/sec: Database Pages Non-Resident Reclaimed (Failed)/sec is the number of OS soft faults attempted and failed against database pages in the buffer cache. [Dev Only]
  let ``Database Pages Non-Resident Reclaimed (Failed)/sec`` instance =
    { category = "Database"; counter = "Database Pages Non-Resident Reclaimed (Failed)/sec"; instance = instance }
  /// Database Pages Non-Resident Reclaimed (Soft Faulted)/sec: Database Pages Non-Resident Reclaimed (Soft Faulted)/sec is the number  of OS soft faults attempted and succeeded against database pages in the buffer cache. [Dev Only]
  let ``Database Pages Non-Resident Reclaimed (Soft Faulted)/sec`` instance =
    { category = "Database"; counter = "Database Pages Non-Resident Reclaimed (Soft Faulted)/sec"; instance = instance }
  /// Database Pages Preread (Unnecessary)/sec: Database Pages Preread (Unnecessary)/sec is the rate that pages are  requested in anticipation of future use but that are already cached by the database cache.  This is non-ideal behavior that represents a waste of processing time.  [Dev Only]
  let ``Database Pages Preread (Unnecessary)/sec`` instance =
    { category = "Database"; counter = "Database Pages Preread (Unnecessary)/sec"; instance = instance }
  /// Database Pages Preread/sec: Database Pages Preread/sec is the rate that pages are read in anticipation of future use from the database file(s) into the database cache.  [Dev Only]
  let ``Database Pages Preread/sec`` instance =
    { category = "Database"; counter = "Database Pages Preread/sec"; instance = instance }
  /// Database Pages Read Async/sec: Database Pages Read Async/sec is the rate that pages are asynchronously read from the database file(s) into the database cache.  [Dev Only]
  let ``Database Pages Read Async/sec`` instance =
    { category = "Database"; counter = "Database Pages Read Async/sec"; instance = instance }
  /// Database Pages Read Sync/sec: Database Pages Read Sync/sec is the rate that pages are synchronously read from the database file(s) into the database cache.  [Dev Only]
  let ``Database Pages Read Sync/sec`` instance =
    { category = "Database"; counter = "Database Pages Read Sync/sec"; instance = instance }
  /// Database Pages Rehydrated/sec: Database Pages Rehydrated/sec is the rate that pages are uncompressed for active usage or flushing to the database. [Dev Only]
  let ``Database Pages Rehydrated/sec`` instance =
    { category = "Database"; counter = "Database Pages Rehydrated/sec"; instance = instance }
  /// Database Pages Repeatedly Read/sec: Database Pages Repeatedly Read/sec is the rate that pages are read from the database file(s) into the database cache more than once a short period of time / within history tracking.  [Dev Only]
  let ``Database Pages Repeatedly Read/sec`` instance =
    { category = "Database"; counter = "Database Pages Repeatedly Read/sec"; instance = instance }
  /// Database Pages Repeatedly Written/sec: Database Pages Repeatedly Written/sec is the rate that pages are written to the database file(s) from the database cache more than once in their lifetime in the cache.  These page writes represent extra writes above the theoretical minimum and can therefore be considered overhead.  [Dev Only]
  let ``Database Pages Repeatedly Written/sec`` instance =
    { category = "Database"; counter = "Database Pages Repeatedly Written/sec"; instance = instance }
  /// Database Pages Transferred/sec: Database Pages Transferred/sec is the rate that pages are transferred from the database file(s) to the database cache and vice versa.  [Dev Only]
  let ``Database Pages Transferred/sec`` instance =
    { category = "Database"; counter = "Database Pages Transferred/sec"; instance = instance }
  /// Database Pages Trimmed/sec: Database Pages Trimmed/sec is the number of databases pages trimmed or partially trimmed per second from the buffer cache.  Contrast with OS Memory Pages Trimmed/sec. [Dev Only]
  let ``Database Pages Trimmed/sec`` instance =
    { category = "Database"; counter = "Database Pages Trimmed/sec"; instance = instance }
  /// Database Pages Version Copied/sec: Database Pages Version Copied/sec is the rate at which pages in the database cache are being copied into new pages in the cache for the purpose of being asynchronously written while the current version of that page in the database file is still being modified.  This feature is primarily used to avoid cycles, branches, or long chains of flush order dependencies without requiring the pages involved to be synchronously written to disk.  [Dev Only]
  let ``Database Pages Version Copied/sec`` instance =
    { category = "Database"; counter = "Database Pages Version Copied/sec"; instance = instance }
  /// Database Pages Versioned/sec: Database Pages Versioned/sec is the rate at which pages in the database cache are being copied into new pages in the cache for the purpose of being asynchronously written while the current version of that page in the database file is still being modified.  This feature is primarily used to avoid cycles, branches, or long chains of flush order dependencies without requiring the pages involved to be synchronously written to disk.  [Dev Only]
  let ``Database Pages Versioned/sec`` instance =
    { category = "Database"; counter = "Database Pages Versioned/sec"; instance = instance }
  /// Database Pages Written/sec: Database Pages Written/sec is the rate that pages are written to the database file(s) from the database cache.  [Dev Only]
  let ``Database Pages Written/sec`` instance =
    { category = "Database"; counter = "Database Pages Written/sec"; instance = instance }
  /// Database Tasks Average Log Bytes: Database Tasks Average Log Bytes is the average size of the log records being generated by background database tasks.  [Dev Only]
  let ``Database Tasks Average Log Bytes`` instance =
    { category = "Database"; counter = "Database Tasks Average Log Bytes"; instance = instance }
  /// Database Tasks Log Records/sec: Database Tasks Log Records/sec is the rate at which background database tasks are generating log records.  [Dev Only]
  let ``Database Tasks Log Records/sec`` instance =
    { category = "Database"; counter = "Database Tasks Log Records/sec"; instance = instance }
  /// Database Tasks Pages Dirtied/sec: Database Tasks Pages Dirtied/sec is the rate at which background database tasks are modifying clean database pages. [Dev Only]
  let ``Database Tasks Pages Dirtied/sec`` instance =
    { category = "Database"; counter = "Database Tasks Pages Dirtied/sec"; instance = instance }
  /// Database Tasks Pages Preread/sec: Database Tasks Pages Preread/sec is the rate at which database pages are read in anticipation of future use by background database tasks.  [Dev Only]
  let ``Database Tasks Pages Preread/sec`` instance =
    { category = "Database"; counter = "Database Tasks Pages Preread/sec"; instance = instance }
  /// Database Tasks Pages Re-Dirtied/sec: Database Tasks Pages Re-Dirtied/sec is the rate at which background databases tasks are modifying database pages that already contained modifications.  [Dev Only]
  let ``Database Tasks Pages Re-Dirtied/sec`` instance =
    { category = "Database"; counter = "Database Tasks Pages Re-Dirtied/sec"; instance = instance }
  /// Database Tasks Pages Read/sec: Database Tasks Pages Read/sec is the rate of database read operations being performed by background database tasks. [Dev Only]
  let ``Database Tasks Pages Read/sec`` instance =
    { category = "Database"; counter = "Database Tasks Pages Read/sec"; instance = instance }
  /// Database Tasks Pages Referenced/sec: Database Tasks Pages Referenced/sec is the rate at which background database tasks are touching database pages. [Dev Only]
  let ``Database Tasks Pages Referenced/sec`` instance =
    { category = "Database"; counter = "Database Tasks Pages Referenced/sec"; instance = instance }
  /// Database cache lifetime: Provides a noisy estimate for the age (in seconds) of the oldest page in the database cache.  If this counter is greater than an hour (3600 seconds) during production load, then it is indicative of database cache inefficiencies.  A large value is also to be expected if the cache size is larger than needed for the load. [Dev Only]
  let ``Database cache lifetime`` instance =
    { category = "Database"; counter = "Database cache lifetime"; instance = instance }
  /// Defragmentation Tasks: Defragmentation Tasks is the count of background database defragmentation tasks that are currently executing.
  let ``Defragmentation Tasks`` instance =
    { category = "Database"; counter = "Defragmentation Tasks"; instance = instance }
  /// Defragmentation Tasks Completed/sec: Defragmentation Tasks Completed/sec is the number of background database defragmentation tasks completing execution per second. [Dev Only]
  let ``Defragmentation Tasks Completed/sec`` instance =
    { category = "Database"; counter = "Defragmentation Tasks Completed/sec"; instance = instance }
  /// Defragmentation Tasks Discarded: Defragmentation Tasks Discarded is the count of background database defragmentation tasks that could not be registered. [Dev Only]
  let ``Defragmentation Tasks Discarded`` instance =
    { category = "Database"; counter = "Defragmentation Tasks Discarded"; instance = instance }
  /// Defragmentation Tasks Pending: Defragmentation Tasks Pending is the count of background database defragmentation tasks that are currently pending.
  let ``Defragmentation Tasks Pending`` instance =
    { category = "Database"; counter = "Defragmentation Tasks Pending"; instance = instance }
  /// Defragmentation Tasks Scheduled/sec: Defragmentation Tasks Scheduled/sec is the number of background database defragmentation tasks scheduled for execution per second. [Dev Only]
  let ``Defragmentation Tasks Scheduled/sec`` instance =
    { category = "Database"; counter = "Defragmentation Tasks Scheduled/sec"; instance = instance }
  /// FCB Allocations Wait For Version Cleanup/sec: FCB Allocations Wait For Version Cleanup/sec is the number FCB allocations that must first wait for version cleanup in an attempt to free used FCBs for re-use. [Dev Only]
  let ``FCB Allocations Wait For Version Cleanup/sec`` instance =
    { category = "Database"; counter = "FCB Allocations Wait For Version Cleanup/sec"; instance = instance }
  /// FCB Async Purge Failures (Active Tasks)/sec: FCB Async Purge Failures (Active Tasks)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record having active tasks.  [Dev Only]
  let ``FCB Async Purge Failures (Active Tasks)/sec`` instance =
    { category = "Database"; counter = "FCB Async Purge Failures (Active Tasks)/sec"; instance = instance }
  /// FCB Async Purge Failures (Callbacks)/sec: FCB Async Purge Failures (Callbacks)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record having callbacks.  [Dev Only]
  let ``FCB Async Purge Failures (Callbacks)/sec`` instance =
    { category = "Database"; counter = "FCB Async Purge Failures (Callbacks)/sec"; instance = instance }
  /// FCB Async Purge Failures (Conflicts)/sec: FCB Async Purge Failures (Conflicts)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup.  The purge operation failed because exclusive ownership of the schema record could not be obtained.  [Dev Only]
  let ``FCB Async Purge Failures (Conflicts)/sec`` instance =
    { category = "Database"; counter = "FCB Async Purge Failures (Conflicts)/sec"; instance = instance }
  /// FCB Async Purge Failures (Delete Pending)/sec: FCB Async Purge Failures (Delete Pending)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record being in pending delete state.  [Dev Only]
  let ``FCB Async Purge Failures (Delete Pending)/sec`` instance =
    { category = "Database"; counter = "FCB Async Purge Failures (Delete Pending)/sec"; instance = instance }
  /// FCB Async Purge Failures (In Use)/sec: FCB Async Purge Failures (In Use)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record being in use.  [Dev Only]
  let ``FCB Async Purge Failures (In Use)/sec`` instance =
    { category = "Database"; counter = "FCB Async Purge Failures (In Use)/sec"; instance = instance }
  /// FCB Async Purge Failures (Index Outstanding)/sec: FCB Async Purge Failures (Index Outstanding)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the index of the record being outstanding.  [Dev Only]
  let ``FCB Async Purge Failures (Index Outstanding)/sec`` instance =
    { category = "Database"; counter = "FCB Async Purge Failures (Index Outstanding)/sec"; instance = instance }
  /// FCB Async Purge Failures (LV Outstanding)/sec: FCB Async Purge Failures (LV Outstanding)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the LV of the record being outstanding.  [Dev Only]
  let ``FCB Async Purge Failures (LV Outstanding)/sec`` instance =
    { category = "Database"; counter = "FCB Async Purge Failures (LV Outstanding)/sec"; instance = instance }
  /// FCB Async Purge Failures (Other)/sec: FCB Async Purge Failures (Other)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to other reasons.  [Dev Only]
  let ``FCB Async Purge Failures (Other)/sec`` instance =
    { category = "Database"; counter = "FCB Async Purge Failures (Other)/sec"; instance = instance }
  /// FCB Async Purge Failures (Outstanding Versions)/sec: FCB Async Purge Failures (Outstanding Versions)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record having outstanding versions.  [Dev Only]
  let ``FCB Async Purge Failures (Outstanding Versions)/sec`` instance =
    { category = "Database"; counter = "FCB Async Purge Failures (Outstanding Versions)/sec"; instance = instance }
  /// FCB Async Purge Failures (Sentinel)/sec: FCB Async Purge Failures (Sentinel)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record being a sentinel record.  [Dev Only]
  let ``FCB Async Purge Failures (Sentinel)/sec`` instance =
    { category = "Database"; counter = "FCB Async Purge Failures (Sentinel)/sec"; instance = instance }
  /// FCB Async Purge/sec: FCB Async Purge/sec is the number of cached schema records (FCBs) purged during asynchronous schema record cleanup. These records are purged to age out older schema definitions. [Dev Only]
  let ``FCB Async Purge/sec`` instance =
    { category = "Database"; counter = "FCB Async Purge/sec"; instance = instance }
  /// FCB Async Scan/sec: FCB Async Scan/sec is the number of cached schema records (FCBs) scanned during asynchronous schema record cleanup. These records are scanned to age out older schema definitions. [Dev Only]
  let ``FCB Async Scan/sec`` instance =
    { category = "Database"; counter = "FCB Async Scan/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Active Tasks)/sec: FCB Async Threshold Purge Failures (Active Tasks)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record having active tasks.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Active Tasks)/sec`` instance =
    { category = "Database"; counter = "FCB Async Threshold Purge Failures (Active Tasks)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Callbacks)/sec: FCB Async Threshold Purge Failures (Callbacks)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record having callbacks.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Callbacks)/sec`` instance =
    { category = "Database"; counter = "FCB Async Threshold Purge Failures (Callbacks)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Conflicts)/sec: FCB Async Threshold Purge Failures (Conflicts)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup.  The purge operation failed because exclusive ownership of the schema record could not be obtained.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Conflicts)/sec`` instance =
    { category = "Database"; counter = "FCB Async Threshold Purge Failures (Conflicts)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Delete Pending)/sec: FCB Async Threshold Purge Failures (Delete Pending)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record being pending delete.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Delete Pending)/sec`` instance =
    { category = "Database"; counter = "FCB Async Threshold Purge Failures (Delete Pending)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (In Use)/sec: FCB Async Threshold Purge Failures (In Use)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record being in use.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (In Use)/sec`` instance =
    { category = "Database"; counter = "FCB Async Threshold Purge Failures (In Use)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Index Outstanding)/sec: FCB Async Threshold Purge Failures (Index Outstanding)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the index of the record being outstanding.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Index Outstanding)/sec`` instance =
    { category = "Database"; counter = "FCB Async Threshold Purge Failures (Index Outstanding)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (LV Outstanding)/sec: FCB Async Threshold Purge Failures (LV Outstanding)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the LV of the record being outstanding.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (LV Outstanding)/sec`` instance =
    { category = "Database"; counter = "FCB Async Threshold Purge Failures (LV Outstanding)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Other)/sec: FCB Async Threshold Purge Failures (Other)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to other reasons.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Other)/sec`` instance =
    { category = "Database"; counter = "FCB Async Threshold Purge Failures (Other)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Outstanding Versions)/sec: FCB Async Threshold Purge Failures (Outstanding Versions)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record having outstanding versions.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Outstanding Versions)/sec`` instance =
    { category = "Database"; counter = "FCB Async Threshold Purge Failures (Outstanding Versions)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Sentinel)/sec: FCB Async Threshold Purge Failures (Sentinel)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record being a sentinel record.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Sentinel)/sec`` instance =
    { category = "Database"; counter = "FCB Async Threshold Purge Failures (Sentinel)/sec"; instance = instance }
  /// FCB Async Threshold-Purge/sec: FCB Async Threshold-Purge/sec is the number of cached schema records (FCBs) purged during asynchronous schema record cleanup.  Cleanup was triggered by a large number of schema records above the preferred limit.  These records are aggressively purged to age out older schema definitions.  [Dev Only]
  let ``FCB Async Threshold-Purge/sec`` instance =
    { category = "Database"; counter = "FCB Async Threshold-Purge/sec"; instance = instance }
  /// FCB Async Threshold-Scan/sec: FCB Async Threshold-Scan/sec is the number of cached schema records (FCBs) scanned during asynchronous schema record cleanup.  Cleanup was triggered by a large number of schema records above the preferred limit.  These records are aggressively scanned to age out older schema definitions.  [Dev Only]
  let ``FCB Async Threshold-Scan/sec`` instance =
    { category = "Database"; counter = "FCB Async Threshold-Scan/sec"; instance = instance }
  /// FCB Attached RCEs: FCB Attached RCEs is the number of revision control entries (RCEs)  attached to cached schema records (FCBs) [Dev Only]
  let ``FCB Attached RCEs`` instance =
    { category = "Database"; counter = "FCB Attached RCEs"; instance = instance }
  /// FCB Cache % Hit: FCB Cache % Hit is the percentage of schema records (FCBs) opened directly from the schema record cache.  No file operations were required.  [Dev Only]
  let ``FCB Cache % Hit`` instance =
    { category = "Database"; counter = "FCB Cache % Hit"; instance = instance }
  /// FCB Cache Allocated: FCB Cache Allocated is the number of cached schema records (FCBs) currently allocated.  [Dev Only]
  let ``FCB Cache Allocated`` instance =
    { category = "Database"; counter = "FCB Cache Allocated"; instance = instance }
  /// FCB Cache Allocated/sec: FCB Cache Allocated/sec is the number of cached schema records (FCBs) currently allocated per second.  [Dev Only]
  let ``FCB Cache Allocated/sec`` instance =
    { category = "Database"; counter = "FCB Cache Allocated/sec"; instance = instance }
  /// FCB Cache Available: FCB Cache Available is the number of cached schema records (FCBs) currently allocated but not in use.  These records will be used and/or purged as required.  [Dev Only]
  let ``FCB Cache Available`` instance =
    { category = "Database"; counter = "FCB Cache Available"; instance = instance }
  /// FCB Cache Maximum: FCB Cache Maximum is the absolute maximum number of the schema records (FCBs) that can exist in the cache.  [Dev Only]
  let ``FCB Cache Maximum`` instance =
    { category = "Database"; counter = "FCB Cache Maximum"; instance = instance }
  /// FCB Cache Preferred: FCB Cache Preferred is the preferred maximum number of the schema records (FCBs) that should exist in the cache.  [Dev Only]
  let ``FCB Cache Preferred`` instance =
    { category = "Database"; counter = "FCB Cache Preferred"; instance = instance }
  /// FCB Cache Stalls/sec: FCB Cache Stalls/sec is the number of stalls encountered while waiting for exclusive ownership of cached schema records (FCBs) in order to update their reference count.  [Dev Only]
  let ``FCB Cache Stalls/sec`` instance =
    { category = "Database"; counter = "FCB Cache Stalls/sec"; instance = instance }
  /// FCB Purge On Cursor Close/sec: FCB Purge On Cursor Close/sec is the number of cached schema records (FCBs) being synchronously purged when the cursor is closed (instead of leaving the schema record cached) each second.  [Dev Only]
  let ``FCB Purge On Cursor Close/sec`` instance =
    { category = "Database"; counter = "FCB Purge On Cursor Close/sec"; instance = instance }
  /// FCB Sync Purge Stalls/sec: FCB Sync Purge Stalls/sec is the number of stalls encountered while waiting for exclusive ownership of cached schema records (FCBs) in order to synchronously purge them.  [Dev Only]
  let ``FCB Sync Purge Stalls/sec`` instance =
    { category = "Database"; counter = "FCB Sync Purge Stalls/sec"; instance = instance }
  /// FCB Sync Purge/sec: FCB Sync Purge/sec is the number of cached schema records (FCBs) being synchronously purged each second.  [Dev Only]
  let ``FCB Sync Purge/sec`` instance =
    { category = "Database"; counter = "FCB Sync Purge/sec"; instance = instance }
  /// False Index Column Updates/sec: False Index Column Updates/sec is the number of times per second an attempt was made to update an index because an update to at least one of the indexed columns was detected, only to discover that none of the indexed columns had actually changed (and therefore no index update was actually required).  [Dev Only]
  let ``False Index Column Updates/sec`` instance =
    { category = "Database"; counter = "False Index Column Updates/sec"; instance = instance }
  /// False Tuple Index Column Updates/sec: False Tuple Index Column Updates/sec is the number of times per second an attempt was made to update a tuple index because an update to the tuple-indexed column was detected, only to discover that the column had not actually changed (and therefore no index update was actually required).  [Dev Only]
  let ``False Tuple Index Column Updates/sec`` instance =
    { category = "Database"; counter = "False Tuple Index Column Updates/sec"; instance = instance }
  /// Heap Allocations: Heap Allocations is the current number of memory allocations in the MP Heaps.  [Dev Only]
  let ``Heap Allocations`` instance =
    { category = "Database"; counter = "Heap Allocations"; instance = instance }
  /// Heap Allocs/sec: Heap Allocs/sec is the number of memory allocations from the MP Heaps per second.  [Dev Only]
  let ``Heap Allocs/sec`` instance =
    { category = "Database"; counter = "Heap Allocs/sec"; instance = instance }
  /// Heap Bytes Allocated: Heap Bytes Allocated is the size of all memory allocations in the MP Heaps discounting heap managemnt overhead.  [Dev Only]
  let ``Heap Bytes Allocated`` instance =
    { category = "Database"; counter = "Heap Bytes Allocated"; instance = instance }
  /// Heap Frees/sec: Heap Frees/sec is the number of memory frees to the MP Heaps per second.  [Dev Only]
  let ``Heap Frees/sec`` instance =
    { category = "Database"; counter = "Heap Frees/sec"; instance = instance }
  /// I/O Database Reads (Attached) Abnormal Latency/sec: I/O Database Reads (Attached) Abnormal Latency/sec is the rate of database read operations that take an abnormally long length of time (default is 1 minute) to be serviced by the OS.  [Dev Only]
  let ``I/O Database Reads (Attached) Abnormal Latency/sec`` instance =
    { category = "Database"; counter = "I/O Database Reads (Attached) Abnormal Latency/sec"; instance = instance }
  /// I/O Database Reads (Attached) Async Pending: I/O Database Reads (Attached) Async Pending is the number of database read operations asynchronously pending completion.  [Dev Only]
  let ``I/O Database Reads (Attached) Async Pending`` instance =
    { category = "Database"; counter = "I/O Database Reads (Attached) Async Pending"; instance = instance }
  /// I/O Database Reads (Attached) Average Bytes: I/O Database Reads (Attached) Average Bytes is the average number of bytes transferred per database read operation.  [Dev Only]
  let ``I/O Database Reads (Attached) Average Bytes`` instance =
    { category = "Database"; counter = "I/O Database Reads (Attached) Average Bytes"; instance = instance }
  /// I/O Database Reads (Attached) Average Latency: I/O Database Reads (Attached) Average Latency is the average length of time,  in milliseconds, per database read operation.
  let ``I/O Database Reads (Attached) Average Latency`` instance =
    { category = "Database"; counter = "I/O Database Reads (Attached) Average Latency"; instance = instance }
  /// I/O Database Reads (Attached) In Heap: I/O Database Reads (Attached) In Heap is the number of database read operations queued in the database engine's I/O heap and waiting to be issued.  [Dev Only]
  let ``I/O Database Reads (Attached) In Heap`` instance =
    { category = "Database"; counter = "I/O Database Reads (Attached) In Heap"; instance = instance }
  /// I/O Database Reads (Attached)/sec: I/O Database Reads (Attached)/sec is the rate of database read operations completed.
  let ``I/O Database Reads (Attached)/sec`` instance =
    { category = "Database"; counter = "I/O Database Reads (Attached)/sec"; instance = instance }
  /// I/O Database Reads (Recovery) Abnormal Latency/sec: I/O Database Reads (Recovery) Abnormal Latency/sec is the rate of database read operations that take an abnormally long length of time (default is 1 minute) to be serviced by the OS.  [Dev Only]
  let ``I/O Database Reads (Recovery) Abnormal Latency/sec`` instance =
    { category = "Database"; counter = "I/O Database Reads (Recovery) Abnormal Latency/sec"; instance = instance }
  /// I/O Database Reads (Recovery) Async Pending: I/O Database Reads (Recovery) Async Pending is the number of database read operations asynchronously pending completion.  [Dev Only]
  let ``I/O Database Reads (Recovery) Async Pending`` instance =
    { category = "Database"; counter = "I/O Database Reads (Recovery) Async Pending"; instance = instance }
  /// I/O Database Reads (Recovery) Average Bytes: I/O Database Reads (Recovery) Average Bytes is the average number of bytes transferred per database read operation.  [Dev Only]
  let ``I/O Database Reads (Recovery) Average Bytes`` instance =
    { category = "Database"; counter = "I/O Database Reads (Recovery) Average Bytes"; instance = instance }
  /// I/O Database Reads (Recovery) Average Latency: I/O Database Reads (Recovery) Average Latency is the average length of time,  in milliseconds, per database read operation.
  let ``I/O Database Reads (Recovery) Average Latency`` instance =
    { category = "Database"; counter = "I/O Database Reads (Recovery) Average Latency"; instance = instance }
  /// I/O Database Reads (Recovery) In Heap: I/O Database Reads (Recovery) In Heap is the number of database read operations queued in the database engine's I/O heap and waiting to be issued.  [Dev Only]
  let ``I/O Database Reads (Recovery) In Heap`` instance =
    { category = "Database"; counter = "I/O Database Reads (Recovery) In Heap"; instance = instance }
  /// I/O Database Reads (Recovery)/sec: I/O Database Reads (Recovery)/sec is the rate of database read operations completed.
  let ``I/O Database Reads (Recovery)/sec`` instance =
    { category = "Database"; counter = "I/O Database Reads (Recovery)/sec"; instance = instance }
  /// I/O Database Reads Abnormal Latency/sec: I/O Database Reads Abnormal Latency/sec is the rate of database read operations that take an abnormally long length of time (default is 1 minute) to be serviced by the OS.  [Dev Only]
  let ``I/O Database Reads Abnormal Latency/sec`` instance =
    { category = "Database"; counter = "I/O Database Reads Abnormal Latency/sec"; instance = instance }
  /// I/O Database Reads Async Pending: I/O Database Reads Async Pending is the number of database read operations asynchronously pending completion.  [Dev Only]
  let ``I/O Database Reads Async Pending`` instance =
    { category = "Database"; counter = "I/O Database Reads Async Pending"; instance = instance }
  /// I/O Database Reads Average Bytes: I/O Database Reads Average Bytes is the average number of bytes transferred per database read operation.  [Dev Only]
  let ``I/O Database Reads Average Bytes`` instance =
    { category = "Database"; counter = "I/O Database Reads Average Bytes"; instance = instance }
  /// I/O Database Reads Average Latency: I/O Database Reads Average Latency is the average length of time,  in milliseconds, per database read operation.
  let ``I/O Database Reads Average Latency`` instance =
    { category = "Database"; counter = "I/O Database Reads Average Latency"; instance = instance }
  /// I/O Database Reads In Heap: I/O Database Reads In Heap is the number of database read operations queued in the database engine's I/O heap and waiting to be issued.  [Dev Only]
  let ``I/O Database Reads In Heap`` instance =
    { category = "Database"; counter = "I/O Database Reads In Heap"; instance = instance }
  /// I/O Database Reads/sec: I/O Database Reads/sec is the rate of database read operations completed.
  let ``I/O Database Reads/sec`` instance =
    { category = "Database"; counter = "I/O Database Reads/sec"; instance = instance }
  /// I/O Database Writes (Attached) Abnormal Latency/sec: I/O Database Writes (Attached) Abnormal Latency/sec is the rate of database write operations that take an abnormally long length of time (default is 1 minute) to be serviced by the OS.  [Dev Only]
  let ``I/O Database Writes (Attached) Abnormal Latency/sec`` instance =
    { category = "Database"; counter = "I/O Database Writes (Attached) Abnormal Latency/sec"; instance = instance }
  /// I/O Database Writes (Attached) Async Pending: I/O Database Writes (Attached) Async Pending is the number of database write operations asynchronously pending completion.  [Dev Only]
  let ``I/O Database Writes (Attached) Async Pending`` instance =
    { category = "Database"; counter = "I/O Database Writes (Attached) Async Pending"; instance = instance }
  /// I/O Database Writes (Attached) Average Bytes: I/O Database Writes (Attached) Average Bytes is the average number of bytes transferred per database write operation.  [Dev Only]
  let ``I/O Database Writes (Attached) Average Bytes`` instance =
    { category = "Database"; counter = "I/O Database Writes (Attached) Average Bytes"; instance = instance }
  /// I/O Database Writes (Attached) Average Latency: I/O Database Writes (Attached) Average Latency is the average length of time,  in milliseconds, per database write operation.
  let ``I/O Database Writes (Attached) Average Latency`` instance =
    { category = "Database"; counter = "I/O Database Writes (Attached) Average Latency"; instance = instance }
  /// I/O Database Writes (Attached) In Heap: I/O Database Writes (Attached) In Heap is the number of database write operations queued in the database engine's I/O heap and waiting to be issued.  [Dev Only]
  let ``I/O Database Writes (Attached) In Heap`` instance =
    { category = "Database"; counter = "I/O Database Writes (Attached) In Heap"; instance = instance }
  /// I/O Database Writes (Attached)/sec: I/O Database Writes (Attached)/sec is the rate of database write operations completed.
  let ``I/O Database Writes (Attached)/sec`` instance =
    { category = "Database"; counter = "I/O Database Writes (Attached)/sec"; instance = instance }
  /// I/O Database Writes (Recovery) Abnormal Latency/sec: I/O Database Writes (Recovery) Abnormal Latency/sec is the rate of database write operations that take an abnormally long length of time (default is 1 minute) to be serviced by the OS.  [Dev Only]
  let ``I/O Database Writes (Recovery) Abnormal Latency/sec`` instance =
    { category = "Database"; counter = "I/O Database Writes (Recovery) Abnormal Latency/sec"; instance = instance }
  /// I/O Database Writes (Recovery) Async Pending: I/O Database Writes (Recovery) Async Pending is the number of database write operations asynchronously pending completion.  [Dev Only]
  let ``I/O Database Writes (Recovery) Async Pending`` instance =
    { category = "Database"; counter = "I/O Database Writes (Recovery) Async Pending"; instance = instance }
  /// I/O Database Writes (Recovery) Average Bytes: I/O Database Writes (Recovery) Average Bytes is the average number of bytes transferred per database write operation.  [Dev Only]
  let ``I/O Database Writes (Recovery) Average Bytes`` instance =
    { category = "Database"; counter = "I/O Database Writes (Recovery) Average Bytes"; instance = instance }
  /// I/O Database Writes (Recovery) Average Latency: I/O Database Writes (Recovery) Average Latency is the average length of time,  in milliseconds, per database write operation.
  let ``I/O Database Writes (Recovery) Average Latency`` instance =
    { category = "Database"; counter = "I/O Database Writes (Recovery) Average Latency"; instance = instance }
  /// I/O Database Writes (Recovery) In Heap: I/O Database Writes (Recovery) In Heap is the number of database write operations queued in the database engine's I/O heap and waiting to be issued.  [Dev Only]
  let ``I/O Database Writes (Recovery) In Heap`` instance =
    { category = "Database"; counter = "I/O Database Writes (Recovery) In Heap"; instance = instance }
  /// I/O Database Writes (Recovery)/sec: I/O Database Writes (Recovery)/sec is the rate of database write operations completed.
  let ``I/O Database Writes (Recovery)/sec`` instance =
    { category = "Database"; counter = "I/O Database Writes (Recovery)/sec"; instance = instance }
  /// I/O Database Writes Abnormal Latency/sec: I/O Database Writes Abnormal Latency/sec is the rate of database write operations that take an abnormally long length of time (default is 1 minute) to be serviced by the OS.  [Dev Only]
  let ``I/O Database Writes Abnormal Latency/sec`` instance =
    { category = "Database"; counter = "I/O Database Writes Abnormal Latency/sec"; instance = instance }
  /// I/O Database Writes Async Pending: I/O Database Writes Async Pending is the number of database write operations asynchronously pending completion.  [Dev Only]
  let ``I/O Database Writes Async Pending`` instance =
    { category = "Database"; counter = "I/O Database Writes Async Pending"; instance = instance }
  /// I/O Database Writes Average Bytes: I/O Database Writes Average Bytes is the average number of bytes transferred per database write operation.  [Dev Only]
  let ``I/O Database Writes Average Bytes`` instance =
    { category = "Database"; counter = "I/O Database Writes Average Bytes"; instance = instance }
  /// I/O Database Writes Average Latency: I/O Database Writes Average Latency is the average length of time,  in milliseconds, per database write operation.
  let ``I/O Database Writes Average Latency`` instance =
    { category = "Database"; counter = "I/O Database Writes Average Latency"; instance = instance }
  /// I/O Database Writes In Heap: I/O Database Writes In Heap is the number of database write operations queued in the database engine's I/O heap and waiting to be issued.  [Dev Only]
  let ``I/O Database Writes In Heap`` instance =
    { category = "Database"; counter = "I/O Database Writes In Heap"; instance = instance }
  /// I/O Database Writes/sec: I/O Database Writes/sec is the rate of database write operations completed.
  let ``I/O Database Writes/sec`` instance =
    { category = "Database"; counter = "I/O Database Writes/sec"; instance = instance }
  /// I/O Log Reads Abnormal Latency/sec: I/O Log Reads Abnormal Latency/sec is the rate of logfile read operations that take an abnormally long length of time (default is 1 minute) to be serviced by the OS.  [Dev Only]
  let ``I/O Log Reads Abnormal Latency/sec`` instance =
    { category = "Database"; counter = "I/O Log Reads Abnormal Latency/sec"; instance = instance }
  /// I/O Log Reads Async Pending: I/O Log Reads Async Pending is the number of logfile read operations asynchronously pending completion.  [Dev Only]
  let ``I/O Log Reads Async Pending`` instance =
    { category = "Database"; counter = "I/O Log Reads Async Pending"; instance = instance }
  /// I/O Log Reads Average Bytes: I/O Log Reads Average Bytes is the average number of bytes transferred per logfile read operation.  [Dev Only]
  let ``I/O Log Reads Average Bytes`` instance =
    { category = "Database"; counter = "I/O Log Reads Average Bytes"; instance = instance }
  /// I/O Log Reads Average Latency: I/O Log Reads Average Latency is the average length of time, in milliseconds, per logfile read operation.
  let ``I/O Log Reads Average Latency`` instance =
    { category = "Database"; counter = "I/O Log Reads Average Latency"; instance = instance }
  /// I/O Log Reads In Heap: I/O Log Reads In Heap is the number of logfile read operations queued in the database engine's I/O heap and waiting to be issued.  [Dev Only]
  let ``I/O Log Reads In Heap`` instance =
    { category = "Database"; counter = "I/O Log Reads In Heap"; instance = instance }
  /// I/O Log Reads/sec: I/O Log Reads/sec is the rate of logfile read operations completed.
  let ``I/O Log Reads/sec`` instance =
    { category = "Database"; counter = "I/O Log Reads/sec"; instance = instance }
  /// I/O Log Writes Abnormal Latency/sec: I/O Log Writes Abnormal Latency/sec is the rate of logfile write operations that take an abnormally long length of time (default is 1 minute) to be serviced by the OS.  [Dev Only]
  let ``I/O Log Writes Abnormal Latency/sec`` instance =
    { category = "Database"; counter = "I/O Log Writes Abnormal Latency/sec"; instance = instance }
  /// I/O Log Writes Async Pending: I/O Log Writes Async Pending is the number of logfile write operations asynchronously pending completion.  [Dev Only]
  let ``I/O Log Writes Async Pending`` instance =
    { category = "Database"; counter = "I/O Log Writes Async Pending"; instance = instance }
  /// I/O Log Writes Average Bytes: I/O Log Writes Average Bytes is the average number of bytes transferred per logfile write operation.  [Dev Only]
  let ``I/O Log Writes Average Bytes`` instance =
    { category = "Database"; counter = "I/O Log Writes Average Bytes"; instance = instance }
  /// I/O Log Writes Average Latency: I/O Log Writes Average Latency is the average length of time, in milliseconds, per log file write operation.
  let ``I/O Log Writes Average Latency`` instance =
    { category = "Database"; counter = "I/O Log Writes Average Latency"; instance = instance }
  /// I/O Log Writes In Heap: I/O Log Writes In Heap is the number of logfile write operations queued in the database engine's I/O heap and waiting to be issued.  [Dev Only]
  let ``I/O Log Writes In Heap`` instance =
    { category = "Database"; counter = "I/O Log Writes In Heap"; instance = instance }
  /// I/O Log Writes/sec: I/O Log Writes/sec is the rate of log file write operations completed.
  let ``I/O Log Writes/sec`` instance =
    { category = "Database"; counter = "I/O Log Writes/sec"; instance = instance }
  /// Log Buffer Bytes Committed: Log Buffer Bytes Committed is total number of committedbytes of log buffer.
  let ``Log Buffer Bytes Committed`` instance =
    { category = "Database"; counter = "Log Buffer Bytes Committed"; instance = instance }
  /// Log Buffer Bytes Free: Log Buffer Bytes Free is the amount of free space available in the log buffers.  [Dev Only]
  let ``Log Buffer Bytes Free`` instance =
    { category = "Database"; counter = "Log Buffer Bytes Free"; instance = instance }
  /// Log Buffer Bytes Used: Log Buffer Bytes Used is the amount of bytes in the log buffers that have not yet been flushed to the logs.  [Dev Only]
  let ``Log Buffer Bytes Used`` instance =
    { category = "Database"; counter = "Log Buffer Bytes Used"; instance = instance }
  /// Log Buffer Capacity Flushes/sec: Log Buffer Capacity Flushes/sec is the count of times the database log buffers must be flushed per second because they are full.  [Dev Only]
  let ``Log Buffer Capacity Flushes/sec`` instance =
    { category = "Database"; counter = "Log Buffer Capacity Flushes/sec"; instance = instance }
  /// Log Buffer Commit Flushes/sec: Log Buffer Commit Flushes/sec is the count of times the database log buffers must be flushed per second because a transaction is fully committing its changes.  [Dev Only]
  let ``Log Buffer Commit Flushes/sec`` instance =
    { category = "Database"; counter = "Log Buffer Commit Flushes/sec"; instance = instance }
  /// Log Buffer Flushes Blocked/sec: Log Buffer Flushes Blocked/sec is the count of times the database log buffers were intended to be flushed, but we skipped it due to the  log buffer being locked for and being flushed by another thread.  [Dev Only]
  let ``Log Buffer Flushes Blocked/sec`` instance =
    { category = "Database"; counter = "Log Buffer Flushes Blocked/sec"; instance = instance }
  /// Log Buffer Flushes Skipped/sec: Log Buffer Flushes Skipped/sec is the count of times the database log buffers were intended to be flushed, but we skipped it due to the  desired log data already having been flushed.  [Dev Only]
  let ``Log Buffer Flushes Skipped/sec`` instance =
    { category = "Database"; counter = "Log Buffer Flushes Skipped/sec"; instance = instance }
  /// Log Buffer Flushes/sec: Log Buffer Flushes/sec is the count of times the database log buffers must be flushed per second.  [Dev Only]
  let ``Log Buffer Flushes/sec`` instance =
    { category = "Database"; counter = "Log Buffer Flushes/sec"; instance = instance }
  /// Log Bytes Generated/sec: Log Bytes Generated per second is the rate at which data is added to the log.  This is different from Log Bytes Write per second in that each byte is generated only once whereas each byte may be written many times.
  let ``Log Bytes Generated/sec`` instance =
    { category = "Database"; counter = "Log Bytes Generated/sec"; instance = instance }
  /// Log Bytes Wasted/sec: Log Bytes Wasted/sec is the number of bytes wasted by not reusing a partially flushed sector (and instead fill it up with NOPs).  [Dev Only]
  let ``Log Bytes Wasted/sec`` instance =
    { category = "Database"; counter = "Log Bytes Wasted/sec"; instance = instance }
  /// Log Bytes Write/sec: Log Bytes Write per second is the rate bytes are written to the log.
  let ``Log Bytes Write/sec`` instance =
    { category = "Database"; counter = "Log Bytes Write/sec"; instance = instance }
  /// Log Checkpoint Depth: Log Checkpoint Depth represents the amount of work, in bytes, that will need to be redone or undone to the database file(s) if the process crashes.  [Dev Only]
  let ``Log Checkpoint Depth`` instance =
    { category = "Database"; counter = "Log Checkpoint Depth"; instance = instance }
  /// Log Checkpoint Maintenance Outstanding IO Max: Log Checkpoint Maintenance Outstanding IO Max represents how aggressive, in terms of outstanding IOs, the database engine will be to maintain the preferred checkpoint. This is a function of how far the checkpoint has fallen behind. [Dev Only]
  let ``Log Checkpoint Maintenance Outstanding IO Max`` instance =
    { category = "Database"; counter = "Log Checkpoint Maintenance Outstanding IO Max"; instance = instance }
  /// Log Full Segment Writes/sec: Log Full Segment Writes/sec is the number of times full log segments are written to the log file(s) per second. [Dev Only]
  let ``Log Full Segment Writes/sec`` instance =
    { category = "Database"; counter = "Log Full Segment Writes/sec"; instance = instance }
  /// Log Generation Checkpoint Depth: Log Generation Checkpoint Depth represents the amount of work, in count of log files, that will need to be redone or undone to the database file(s) if the process crashes.  [Dev Only]
  let ``Log Generation Checkpoint Depth`` instance =
    { category = "Database"; counter = "Log Generation Checkpoint Depth"; instance = instance }
  /// Log Partial Segment Writes/sec: Log Partial Segment Writes/sec is the number of times that a log segment that is only partially full of data is written to the log file(s) per second. [Dev Only]
  let ``Log Partial Segment Writes/sec`` instance =
    { category = "Database"; counter = "Log Partial Segment Writes/sec"; instance = instance }
  /// Log Record Stalls/sec: Log Record Stalls/sec is the number of log records that cannot be added to the log buffers per second because they are full.  If this counter is non-zero most of the time, the log buffer size may be a bottleneck.
  let ``Log Record Stalls/sec`` instance =
    { category = "Database"; counter = "Log Record Stalls/sec"; instance = instance }
  /// Log Records/sec: Log Records/sec is the count of records written to the database log buffers per second.  [Dev Only]
  let ``Log Records/sec`` instance =
    { category = "Database"; counter = "Log Records/sec"; instance = instance }
  /// Log Threads Waiting: Log Threads Waiting is the number of threads waiting for their data to be written to the log in order to complete an update of the database.  If this number is too high, the log may be a bottleneck.
  let ``Log Threads Waiting`` instance =
    { category = "Database"; counter = "Log Threads Waiting"; instance = instance }
  /// Log Writes/sec: Log Writes/sec is the number of times the log buffers are written to the log file(s) per second.  If this number approaches the maximum write rate for the media holding the log file(s), the log may be a bottleneck.
  let ``Log Writes/sec`` instance =
    { category = "Database"; counter = "Log Writes/sec"; instance = instance }
  /// Long-Value Maximum LID: Long-Value Maximum LID is the largest LID that has been used by the database engine.  [Dev Only]
  let ``Long-Value Maximum LID`` instance =
    { category = "Database"; counter = "Long-Value Maximum LID"; instance = instance }
  /// No name: No text
  let ``No name`` instance =
    { category = "Database"; counter = "No name"; instance = instance }
  /// OS Memory Pages Trimmed/sec: OS Memory Pages Trimmed/sec is the number of OS memory manager pages trimmed per second from the buffer cache.  Contrast with Database Pages Trimmed/sec. [Dev Only]
  let ``OS Memory Pages Trimmed/sec`` instance =
    { category = "Database"; counter = "OS Memory Pages Trimmed/sec"; instance = instance }
  /// Online Defrag Average Log Bytes: Online Defrag Average Log Bytes is the average size of the log records being generated by online defragmentation.  [Dev Only]
  let ``Online Defrag Average Log Bytes`` instance =
    { category = "Database"; counter = "Online Defrag Average Log Bytes"; instance = instance }
  /// Online Defrag Data Moves/sec: Data Moves/sec is the number of times per second that data is moved from one page to another by the online defragmentation process [Dev Only]
  let ``Online Defrag Data Moves/sec`` instance =
    { category = "Database"; counter = "Online Defrag Data Moves/sec"; instance = instance }
  /// Online Defrag Log Records/sec: Online Defrag Log Records/sec is the rate at which online defragmentation is generating log records.  [Dev Only]
  let ``Online Defrag Log Records/sec`` instance =
    { category = "Database"; counter = "Online Defrag Log Records/sec"; instance = instance }
  /// Online Defrag Page Moves/sec: Page Moves/sec is the number of times per second that data is moved from one page to a new page by the online defragmentation process [Dev Only]
  let ``Online Defrag Page Moves/sec`` instance =
    { category = "Database"; counter = "Online Defrag Page Moves/sec"; instance = instance }
  /// Online Defrag Pages Dirtied/sec: Online Defrag Pages Dirtied/sec is the rate at which online defragmentation is modifying clean database pages. [Dev Only]
  let ``Online Defrag Pages Dirtied/sec`` instance =
    { category = "Database"; counter = "Online Defrag Pages Dirtied/sec"; instance = instance }
  /// Online Defrag Pages Freed/sec: Pages Freed/sec is the number of pages per second that are freed from the database by the online defragmentation process [Dev Only]
  let ``Online Defrag Pages Freed/sec`` instance =
    { category = "Database"; counter = "Online Defrag Pages Freed/sec"; instance = instance }
  /// Online Defrag Pages Preread/sec: Online Defrag Pages Preread/sec is the rate at which database pages are read in anticipation of future use by online defragmentation.  [Dev Only]
  let ``Online Defrag Pages Preread/sec`` instance =
    { category = "Database"; counter = "Online Defrag Pages Preread/sec"; instance = instance }
  /// Online Defrag Pages Re-Dirtied/sec: Online Defrag Pages Re-Dirtied/sec is the rate at which online defragmentation is modifying database pages that already contained modifications.  [Dev Only]
  let ``Online Defrag Pages Re-Dirtied/sec`` instance =
    { category = "Database"; counter = "Online Defrag Pages Re-Dirtied/sec"; instance = instance }
  /// Online Defrag Pages Read/sec: Online Defrag Pages Read/sec is the rate of database read operations being performed by online defragmentation. [Dev Only]
  let ``Online Defrag Pages Read/sec`` instance =
    { category = "Database"; counter = "Online Defrag Pages Read/sec"; instance = instance }
  /// Online Defrag Pages Referenced/sec: Online Defrag Pages Referenced/sec is the rate at which online defragmentation is touching database pages.  [Dev Only]
  let ``Online Defrag Pages Referenced/sec`` instance =
    { category = "Database"; counter = "Online Defrag Pages Referenced/sec"; instance = instance }
  /// Page Bytes Committed: Page Bytes Committed is the size of all explicitly committed virtual memory backing store (page file and physical memory).  [Dev Only]
  let ``Page Bytes Committed`` instance =
    { category = "Database"; counter = "Page Bytes Committed"; instance = instance }
  /// Page Bytes Reserved: Page Bytes Reserved is the size of all explicitly reserved virtual address space.  [Dev Only]
  let ``Page Bytes Reserved`` instance =
    { category = "Database"; counter = "Page Bytes Reserved"; instance = instance }
  /// Pages Converted: Pages Converted is the number of database pages that have been converted from an older format. [Dev Only]
  let ``Pages Converted`` instance =
    { category = "Database"; counter = "Pages Converted"; instance = instance }
  /// Pages Converted/sec: Pages Converted/sec is the number of times per second a database page is converted from an older database format. [Dev Only]
  let ``Pages Converted/sec`` instance =
    { category = "Database"; counter = "Pages Converted/sec"; instance = instance }
  /// Pages Not Trimmed Unaligned (Total): Pages Not Trimmed Unaligned (Total) is the number of database pages that are not trimmed because the trim request was not on an aligned boundary that the operating system supports. For example, if the supported trim granulariy is 64k, and the requested trim range is from (64k-1 page) to (128k+1 page), then this counter is increased by two. [Dev Only]
  let ``Pages Not Trimmed Unaligned (Total)`` instance =
    { category = "Database"; counter = "Pages Not Trimmed Unaligned (Total)"; instance = instance }
  /// Pages Not Trimmed Unaligned/sec: Pages Not Trimmed Unaligned/sec is the number of database pages that are not trimmed because the trim request was not on an aligned boundary that the operating system supports. For example, if the supported trim granulariy is 64k, and the requested trim range is from (64k-1 page) to (128k+1 page), then this counter is increased by two. [Dev Only]
  let ``Pages Not Trimmed Unaligned/sec`` instance =
    { category = "Database"; counter = "Pages Not Trimmed Unaligned/sec"; instance = instance }
  /// Pages Reorganized (Dehydrate Buffer)/sec: Pages Reorganized (Dehydrate Buffer)/sec is the number of times per second a page is reorganized to minimize our in-memory buffer usage.  [Dev Only]
  let ``Pages Reorganized (Dehydrate Buffer)/sec`` instance =
    { category = "Database"; counter = "Pages Reorganized (Dehydrate Buffer)/sec"; instance = instance }
  /// Pages Reorganized (Free Space Request)/sec: Pages Reorganized (Free Space Request)/sec is the number of times per second a page was reorganized due to a free space request that could not be satisfied by the existing contiguous space on the page.  [Dev Only]
  let ``Pages Reorganized (Free Space Request)/sec`` instance =
    { category = "Database"; counter = "Pages Reorganized (Free Space Request)/sec"; instance = instance }
  /// Pages Reorganized (Other)/sec: Pages Reorganized (Other)/sec is the number of times per second a page was reorganized for some other / unknown reason.  [Dev Only]
  let ``Pages Reorganized (Other)/sec`` instance =
    { category = "Database"; counter = "Pages Reorganized (Other)/sec"; instance = instance }
  /// Pages Reorganized (Page Move Logging)/sec: Pages Reorganized (Page Move Logging)/sec is the number of times per second a page was reorganized for minimizing a page size for logging page move.  [Dev Only]
  let ``Pages Reorganized (Page Move Logging)/sec`` instance =
    { category = "Database"; counter = "Pages Reorganized (Page Move Logging)/sec"; instance = instance }
  /// Pages Trimmed (Total): Pages Trimmed (Total) is the number of database pages that are trimmed and the allocated space is released to the file system.  [Dev Only]
  let ``Pages Trimmed (Total)`` instance =
    { category = "Database"; counter = "Pages Trimmed (Total)"; instance = instance }
  /// Pages Trimmed Dirty (Total): Pages Trimmed Dirty (Total) is the number of database pages that are trimmed from the database file, but they have been modified in memory. [Dev Only]
  let ``Pages Trimmed Dirty (Total)`` instance =
    { category = "Database"; counter = "Pages Trimmed Dirty (Total)"; instance = instance }
  /// Pages Trimmed Dirty/sec: Pages Trimmed Dirty/sec is the number of database pages that are trimmed from the database file, but they have been modified in memory. [Dev Only]
  let ``Pages Trimmed Dirty/sec`` instance =
    { category = "Database"; counter = "Pages Trimmed Dirty/sec"; instance = instance }
  /// Pages Trimmed/sec: Pages Trimmed/sec is the number of database pages that are trimmed and the allocated space is released to the file system.  [Dev Only]
  let ``Pages Trimmed/sec`` instance =
    { category = "Database"; counter = "Pages Trimmed/sec"; instance = instance }
  /// Program Marker: Program Marker is a generic marker that may be set by some clients to delimit program execution, usually for debugging or testing purposes. [Dev Only]
  let ``Program Marker`` instance =
    { category = "Database"; counter = "Program Marker"; instance = instance }
  /// Record Deletes/sec: Record Deletes/sec is the rate at which records in database tables are being flagged for deletion.  [Dev Only]
  let ``Record Deletes/sec`` instance =
    { category = "Database"; counter = "Record Deletes/sec"; instance = instance }
  /// Record Escrow-Updates/sec: Record Escrow-Updates/sec is the rate at which records in database tables are being escrow-updated.  [Dev Only]
  let ``Record Escrow-Updates/sec`` instance =
    { category = "Database"; counter = "Record Escrow-Updates/sec"; instance = instance }
  /// Record Failed Compression Bytes/sec: Record Failed Compression Bytes/sec is the rate of record bytes that either failed Xpress compression or did not significantly reduce the insert/replace size (10% or less). High results are indicative of wasted cpu resources.  [Dev Only]
  let ``Record Failed Compression Bytes/sec`` instance =
    { category = "Database"; counter = "Record Failed Compression Bytes/sec"; instance = instance }
  /// Record Inserts/sec: Record Inserts/sec is the rate at which records are being inserted into database tables.  [Dev Only]
  let ``Record Inserts/sec`` instance =
    { category = "Database"; counter = "Record Inserts/sec"; instance = instance }
  /// Record Intrinsic Long-Values Updated/sec: Record Intrinsic Long-Values Updated/sec is the rate at which intrinsic long-values are added to or replaced in records of database tables.  [Dev Only]
  let ``Record Intrinsic Long-Values Updated/sec`` instance =
    { category = "Database"; counter = "Record Intrinsic Long-Values Updated/sec"; instance = instance }
  /// Record Redundant Replaces/sec: Record Redundant Replaces/sec is the rate at which records in database tables are being updated with the exact same content of the original record.  [Dev Only]
  let ``Record Redundant Replaces/sec`` instance =
    { category = "Database"; counter = "Record Redundant Replaces/sec"; instance = instance }
  /// Record Replaces/sec: Record Replaces/sec is the rate at which records in database tables are being updated.  [Dev Only]
  let ``Record Replaces/sec`` instance =
    { category = "Database"; counter = "Record Replaces/sec"; instance = instance }
  /// Record Separated Long-Values Added/sec: Record Separated Long-Values Added/sec is the rate at which separated long-values are normally added to records of database tables.  [Dev Only]
  let ``Record Separated Long-Values Added/sec`` instance =
    { category = "Database"; counter = "Record Separated Long-Values Added/sec"; instance = instance }
  /// Record Separated Long-Values All Forced/sec: Record Separated Long-Values All Forced/sec is the rate at which all intrinsic long-values are separated out of a record of a database table in order to accommodate updates to the record.  [Dev Only]
  let ``Record Separated Long-Values All Forced/sec`` instance =
    { category = "Database"; counter = "Record Separated Long-Values All Forced/sec"; instance = instance }
  /// Record Separated Long-Values Dereference All/sec: Record Separated Long-Values Dereference All/sec is the rate at which a reference is removed for all the separated long-values associated with a record of a database table.  [Dev Only]
  let ``Record Separated Long-Values Dereference All/sec`` instance =
    { category = "Database"; counter = "Record Separated Long-Values Dereference All/sec"; instance = instance }
  /// Record Separated Long-Values Forced/sec: Record Separated Long-Values Forced/sec is the rate at which separated long-values are added to records of a database table because they could not be accommodated in the record itself.  [Dev Only]
  let ``Record Separated Long-Values Forced/sec`` instance =
    { category = "Database"; counter = "Record Separated Long-Values Forced/sec"; instance = instance }
  /// Record Separated Long-Values Reference All/sec: Record Separated Long-Values Reference All/sec is the rate at which a reference is added for all the separated long-values associated with a record of a database table.  [Dev Only]
  let ``Record Separated Long-Values Reference All/sec`` instance =
    { category = "Database"; counter = "Record Separated Long-Values Reference All/sec"; instance = instance }
  /// Record Unnecessary Replaces/sec: Record Unnecessary Replaces/sec is the rate at which updates to records in database tables are being discarded because the update did not actually modify the contents of the record.  [Dev Only]
  let ``Record Unnecessary Replaces/sec`` instance =
    { category = "Database"; counter = "Record Unnecessary Replaces/sec"; instance = instance }
  /// Records Converted: Records Converted is the number of database records that have been converted from an older format [Dev Only]
  let ``Records Converted`` instance =
    { category = "Database"; counter = "Records Converted"; instance = instance }
  /// Records Converted/sec: Records Converted/sec is the number of times per second a database record is converted from an older database format. [Dev Only]
  let ``Records Converted/sec`` instance =
    { category = "Database"; counter = "Records Converted/sec"; instance = instance }
  /// Resource Manager FCB Allocated: Resource Manager FCB Allocated indicates the amount of memory in Bytes of allocated FCBs [Dev Only]
  let ``Resource Manager FCB Allocated`` instance =
    { category = "Database"; counter = "Resource Manager FCB Allocated"; instance = instance }
  /// Resource Manager FCB Allocated Used: Resource Manager FCB Allocated Used indicates the amount of memory in Bytes of allocated and used FCBs [Dev Only]
  let ``Resource Manager FCB Allocated Used`` instance =
    { category = "Database"; counter = "Resource Manager FCB Allocated Used"; instance = instance }
  /// Resource Manager FCB Quota: Resource Manager FCB Quota indicates the maximum amount of memory in Bytes for FCBs [Dev Only]
  let ``Resource Manager FCB Quota`` instance =
    { category = "Database"; counter = "Resource Manager FCB Quota"; instance = instance }
  /// Resource Manager FUCB Allocated: Resource Manager FUCB Allocated indicates the amount of memory in Bytes of allocated FUCBs [Dev Only]
  let ``Resource Manager FUCB Allocated`` instance =
    { category = "Database"; counter = "Resource Manager FUCB Allocated"; instance = instance }
  /// Resource Manager FUCB Allocated Used: Resource Manager FUCB Allocated Used indicates the amount of memory in Bytes of allocated and used FUCBs [Dev Only]
  let ``Resource Manager FUCB Allocated Used`` instance =
    { category = "Database"; counter = "Resource Manager FUCB Allocated Used"; instance = instance }
  /// Resource Manager FUCB Quota: Resource Manager FUCB Quota indicates the maximum amount of memory in Bytes for FUCBs [Dev Only]
  let ``Resource Manager FUCB Quota`` instance =
    { category = "Database"; counter = "Resource Manager FUCB Quota"; instance = instance }
  /// Resource Manager IDB Allocated: Resource Manager IDB Allocated indicates the amount of memory in Bytes of allocated IDBs [Dev Only]
  let ``Resource Manager IDB Allocated`` instance =
    { category = "Database"; counter = "Resource Manager IDB Allocated"; instance = instance }
  /// Resource Manager IDB Allocated Used: Resource Manager IDB Allocated Used indicates the amount of memory in Bytes of allocated and used IDBs [Dev Only]
  let ``Resource Manager IDB Allocated Used`` instance =
    { category = "Database"; counter = "Resource Manager IDB Allocated Used"; instance = instance }
  /// Resource Manager IDB Quota: Resource Manager IDB Quota indicates the maximum amount of memory in Bytes for IDBs [Dev Only]
  let ``Resource Manager IDB Quota`` instance =
    { category = "Database"; counter = "Resource Manager IDB Quota"; instance = instance }
  /// Resource Manager TDB Allocated: Resource Manager TDB Allocated indicates the amount of memory in Bytes of allocated TDBs [Dev Only]
  let ``Resource Manager TDB Allocated`` instance =
    { category = "Database"; counter = "Resource Manager TDB Allocated"; instance = instance }
  /// Resource Manager TDB Allocated Used: Resource Manager TDB Allocated Used indicates the amount of memory in Bytes of allocated and used TDBs [Dev Only]
  let ``Resource Manager TDB Allocated Used`` instance =
    { category = "Database"; counter = "Resource Manager TDB Allocated Used"; instance = instance }
  /// Resource Manager TDB Quota: Resource Manager TDB Quota indicates the maximum amount of memory in Bytes for TDBs [Dev Only]
  let ``Resource Manager TDB Quota`` instance =
    { category = "Database"; counter = "Resource Manager TDB Quota"; instance = instance }
  /// Secondary Index Deletes/sec: Secondary Index Deletes/sec is the rate at which entries in indexes of database tables are being flagged for deletion.  [Dev Only]
  let ``Secondary Index Deletes/sec`` instance =
    { category = "Database"; counter = "Secondary Index Deletes/sec"; instance = instance }
  /// Secondary Index Inserts/sec: Secondary Index Inserts/sec is the rate at which entries are being inserted into indexes of database tables.  [Dev Only]
  let ``Secondary Index Inserts/sec`` instance =
    { category = "Database"; counter = "Secondary Index Inserts/sec"; instance = instance }
  /// Separated Long-Value Chunk Appends/sec: Separated Long-Value Chunk Appends/sec is the rate at which chunks are appended to separated long-values of database tables.  [Dev Only]
  let ``Separated Long-Value Chunk Appends/sec`` instance =
    { category = "Database"; counter = "Separated Long-Value Chunk Appends/sec"; instance = instance }
  /// Separated Long-Value Chunk Copies/sec: Separated Long-Value Chunk Copies/sec is the rate at which existing separated long-value chunks in a database table are copied.  [Dev Only]
  let ``Separated Long-Value Chunk Copies/sec`` instance =
    { category = "Database"; counter = "Separated Long-Value Chunk Copies/sec"; instance = instance }
  /// Separated Long-Value Chunk Deletes/sec: Separated Long-Value Chunk Deletes/sec is the rate at which separated long-value chunks in a database table are flagged for deletion.  [Dev Only]
  let ``Separated Long-Value Chunk Deletes/sec`` instance =
    { category = "Database"; counter = "Separated Long-Value Chunk Deletes/sec"; instance = instance }
  /// Separated Long-Value Chunk Replaces/sec: Separated Long-Value Chunk Replaces/sec is the rate at which existing separated long-value chunks in a database table are replaced.  [Dev Only]
  let ``Separated Long-Value Chunk Replaces/sec`` instance =
    { category = "Database"; counter = "Separated Long-Value Chunk Replaces/sec"; instance = instance }
  /// Separated Long-Value Chunk Retrieves/sec: Separated Long-Value Chunk Retrieves/sec is the rate at which retrievals of a chunk of a separated long-value in a database table are performed.  [Dev Only]
  let ``Separated Long-Value Chunk Retrieves/sec`` instance =
    { category = "Database"; counter = "Separated Long-Value Chunk Retrieves/sec"; instance = instance }
  /// Separated Long-Value Chunk Seeks/sec: Separated Long-Value Chunk Seeks/sec is the rate at which seeks for a particular chunk of a separated long-value in a database table are performed.  [Dev Only]
  let ``Separated Long-Value Chunk Seeks/sec`` instance =
    { category = "Database"; counter = "Separated Long-Value Chunk Seeks/sec"; instance = instance }
  /// Separated Long-Value Copies/sec: Separated Long-Value Copies/sec is the rate at which existing separated long-values in a database table are copied.  [Dev Only]
  let ``Separated Long-Value Copies/sec`` instance =
    { category = "Database"; counter = "Separated Long-Value Copies/sec"; instance = instance }
  /// Separated Long-Value Creates/sec: Separated Long-Value Creates/sec is the rate at which new separated long-values are added to a database table.  [Dev Only]
  let ``Separated Long-Value Creates/sec`` instance =
    { category = "Database"; counter = "Separated Long-Value Creates/sec"; instance = instance }
  /// Separated Long-Value Deletes/sec: Separated Long-Value Deletes/sec is the rate at which separated long-values in a database table are flagged for deletion.  [Dev Only]
  let ``Separated Long-Value Deletes/sec`` instance =
    { category = "Database"; counter = "Separated Long-Value Deletes/sec"; instance = instance }
  /// Separated Long-Value Retrieves/sec: Separated Long-Value Retrieves/sec is the rate at which retrievals of a separated long-value in a database table are performed.  [Dev Only]
  let ``Separated Long-Value Retrieves/sec`` instance =
    { category = "Database"; counter = "Separated Long-Value Retrieves/sec"; instance = instance }
  /// Separated Long-Value Seeks/sec: Separated Long-Value Seeks/sec is the rate at which seeks for a separated long-value in a database table are performed.  [Dev Only]
  let ``Separated Long-Value Seeks/sec`` instance =
    { category = "Database"; counter = "Separated Long-Value Seeks/sec"; instance = instance }
  /// Separated Long-Value Updates/sec: Separated Long-Value Updates/sec is the rate at which existing separated long-values in a database table are modified.  [Dev Only]
  let ``Separated Long-Value Updates/sec`` instance =
    { category = "Database"; counter = "Separated Long-Value Updates/sec"; instance = instance }
  /// Sessions % Used: Sessions % Used is the percentage of database sessions currently open for use by client threads.
  let ``Sessions % Used`` instance =
    { category = "Database"; counter = "Sessions % Used"; instance = instance }
  /// Sessions In Use: Sessions In Use is the number of database sessions currently open for use by client threads.
  let ``Sessions In Use`` instance =
    { category = "Database"; counter = "Sessions In Use"; instance = instance }
  /// Streaming Backup Pages Read/sec: Streaming Backup Pages Read/sec is the rate of database read operations performed for the purpose of streaming backups.  [Dev Only]
  let ``Streaming Backup Pages Read/sec`` instance =
    { category = "Database"; counter = "Streaming Backup Pages Read/sec"; instance = instance }
  /// System Read Only Transaction Commits to Level 0/sec: System Read Only Transaction Commits to Level 0/sec is the count of fully committed transactions started internally that do not modify any data stored in the database engine.  [Dev Only]
  let ``System Read Only Transaction Commits to Level 0/sec`` instance =
    { category = "Database"; counter = "System Read Only Transaction Commits to Level 0/sec"; instance = instance }
  /// System Read Only Transaction Rollbacks to Level 0/sec: System Read Only Transaction Rollbacks to Level 0/sec is the count of aborted transactions started internally that do not modify any data stored in the database engine.  [Dev Only]
  let ``System Read Only Transaction Rollbacks to Level 0/sec`` instance =
    { category = "Database"; counter = "System Read Only Transaction Rollbacks to Level 0/sec"; instance = instance }
  /// System Read/Write Transaction Commits to Level 0 (Durable)/sec: System Read/Write Transaction Commits to Level 0 (Durable)/sec is the count of fully committed transactions started internally that modify data stored in the database engine.  [Dev Only]
  let ``System Read/Write Transaction Commits to Level 0 (Durable)/sec`` instance =
    { category = "Database"; counter = "System Read/Write Transaction Commits to Level 0 (Durable)/sec"; instance = instance }
  /// System Read/Write Transaction Commits to Level 0 (Lazy)/sec: System Read/Write Transaction Commits to Level 0 (Lazy)/sec is the count of internal transactions committed to log buffer.  [Dev Only]
  let ``System Read/Write Transaction Commits to Level 0 (Lazy)/sec`` instance =
    { category = "Database"; counter = "System Read/Write Transaction Commits to Level 0 (Lazy)/sec"; instance = instance }
  /// System Read/Write Transaction Rollbacks to Level 0/sec: System Read/Write Transaction Rollbacks to Level 0/sec is the count of aborted transactions started internally that modify data stored in the database engine.  [Dev Only]
  let ``System Read/Write Transaction Rollbacks to Level 0/sec`` instance =
    { category = "Database"; counter = "System Read/Write Transaction Rollbacks to Level 0/sec"; instance = instance }
  /// System Transaction Commits to Level 0/sec: System Transaction Commits to Level 0/sec is the count of fully committed transactions started internally that access data stored in the database engine.  [Dev Only]
  let ``System Transaction Commits to Level 0/sec`` instance =
    { category = "Database"; counter = "System Transaction Commits to Level 0/sec"; instance = instance }
  /// System Transaction Rollbacks to Level 0/sec: System Transaction Rollbacks to Level 0/sec is the count of aborted transactions started internally that access data stored in the database engine.  [Dev Only]
  let ``System Transaction Rollbacks to Level 0/sec`` instance =
    { category = "Database"; counter = "System Transaction Rollbacks to Level 0/sec"; instance = instance }
  /// Table Closes/sec: Table Closes/sec is the number of database tables closed per second.
  let ``Table Closes/sec`` instance =
    { category = "Database"; counter = "Table Closes/sec"; instance = instance }
  /// Table Open Cache % Hit: Table Open Cache % Hit is the percentage of database tables opened using cached schema information.  If this percentage is too low, the table cache size may be too small.
  let ``Table Open Cache % Hit`` instance =
    { category = "Database"; counter = "Table Open Cache % Hit"; instance = instance }
  /// Table Open Cache Hits/sec: Table Open Cache Hits/sec is the number of database tables opened using cached schema information per second.  If this rate is too low, the table cache size may be too small.
  let ``Table Open Cache Hits/sec`` instance =
    { category = "Database"; counter = "Table Open Cache Hits/sec"; instance = instance }
  /// Table Open Cache Misses/sec: Table Open Cache Misses/sec is the number of database tables opened without using cached schema information per second.  If this rate is too high, the table cache size may be too small.
  let ``Table Open Cache Misses/sec`` instance =
    { category = "Database"; counter = "Table Open Cache Misses/sec"; instance = instance }
  /// Table Open Pages Preread/sec: Table Open Pages Preread/sec is the number of database pages pre-read without using cached schema information per second.  If this rate is too high, the table cache size may be too small. [Dev Only]
  let ``Table Open Pages Preread/sec`` instance =
    { category = "Database"; counter = "Table Open Pages Preread/sec"; instance = instance }
  /// Table Open Pages Read/sec: Table Open Pages Read/sec is the number of database pages read without using cached schema information per second.  If this rate is too high, the table cache size may be too small. [Dev Only]
  let ``Table Open Pages Read/sec`` instance =
    { category = "Database"; counter = "Table Open Pages Read/sec"; instance = instance }
  /// Table Opens/sec: Table Opens/sec is the number of database tables opened per second.
  let ``Table Opens/sec`` instance =
    { category = "Database"; counter = "Table Opens/sec"; instance = instance }
  /// Tables Open: Tables Open is the number of database tables opened.
  let ``Tables Open`` instance =
    { category = "Database"; counter = "Tables Open"; instance = instance }
  /// Threads Blocked: Threads Blocked is the current number of threads whose execution has been suspended to wait for a specific event to occur or for the acquisition of a resource currently owned by another thread. [Dev Only]
  let ``Threads Blocked`` instance =
    { category = "Database"; counter = "Threads Blocked"; instance = instance }
  /// Threads Blocked/sec: Threads Blocked/sec is the rate at which the execution of threads are suspended to wait for a specific event to occur or for the acquisition of a resource currently owned by another thread. [Dev Only]
  let ``Threads Blocked/sec`` instance =
    { category = "Database"; counter = "Threads Blocked/sec"; instance = instance }
  /// User Read Only Transaction Commits to Level 0/sec: User Read Only Transaction Commits to Level 0/sec is the count of fully committed transactions started by the calling process that do not modify any data stored in the database engine.  [Dev Only]
  let ``User Read Only Transaction Commits to Level 0/sec`` instance =
    { category = "Database"; counter = "User Read Only Transaction Commits to Level 0/sec"; instance = instance }
  /// User Read Only Transaction Rollbacks to Level 0/sec: User Read Only Transaction Rollbacks to Level 0/sec is the count of aborted transactions started by the calling process that do not modify any data stored in the database engine.  [Dev Only]
  let ``User Read Only Transaction Rollbacks to Level 0/sec`` instance =
    { category = "Database"; counter = "User Read Only Transaction Rollbacks to Level 0/sec"; instance = instance }
  /// User Read/Write Transaction Commits to Level 0 (Durable)/sec: User Read/Write Transaction Commits to Level 0 (Durable)/sec is the count of fully committed transactions started by the calling process that modify data stored in the database engine.  [Dev Only]
  let ``User Read/Write Transaction Commits to Level 0 (Durable)/sec`` instance =
    { category = "Database"; counter = "User Read/Write Transaction Commits to Level 0 (Durable)/sec"; instance = instance }
  /// User Read/Write Transaction Commits to Level 0 (Lazy)/sec: User Read/Write Transaction Commits to Level 0 (Lazy)/sec is the count of transactions started by the calling process and committed to log buffer.  [Dev Only]
  let ``User Read/Write Transaction Commits to Level 0 (Lazy)/sec`` instance =
    { category = "Database"; counter = "User Read/Write Transaction Commits to Level 0 (Lazy)/sec"; instance = instance }
  /// User Read/Write Transaction Rollbacks to Level 0/sec: User Read/Write Transaction Rollbacks to Level 0/sec is the count of aborted transactions started by the calling process that modify data stored in the database engine.  [Dev Only]
  let ``User Read/Write Transaction Rollbacks to Level 0/sec`` instance =
    { category = "Database"; counter = "User Read/Write Transaction Rollbacks to Level 0/sec"; instance = instance }
  /// User Transaction Commits to Level 0/sec: User Transaction Commits to Level 0/sec is the count of fully committed transactions started by the calling process that access data stored in the database engine.  [Dev Only]
  let ``User Transaction Commits to Level 0/sec`` instance =
    { category = "Database"; counter = "User Transaction Commits to Level 0/sec"; instance = instance }
  /// User Transaction Rollbacks to Level 0/sec: User Transaction Rollbacks to Level 0/sec is the count of aborted transactions started by the calling process that access data stored in the database engine.  [Dev Only]
  let ``User Transaction Rollbacks to Level 0/sec`` instance =
    { category = "Database"; counter = "User Transaction Rollbacks to Level 0/sec"; instance = instance }
  /// User Wait All Transaction Commits/sec: User Wait All Transaction Commits/sec is the count of signals to flush all pending transactions started by the calling process that modify data stored in the database engine.  [Dev Only]
  let ``User Wait All Transaction Commits/sec`` instance =
    { category = "Database"; counter = "User Wait All Transaction Commits/sec"; instance = instance }
  /// User Wait Last Transaction Commits/sec: User Wait Last Transaction Commits/sec is the count of signals to flush a specific sessions pending transactions.  [Dev Only]
  let ``User Wait Last Transaction Commits/sec`` instance =
    { category = "Database"; counter = "User Wait Last Transaction Commits/sec"; instance = instance }
  /// VER Bucket Allocations Wait For Version Cleanup/sec: VER Bucket Allocations Wait For Version Cleanup/sec is the number of version bucket allocations that must first wait for version cleanup in an attempt to free used version buckets  for re-use. [Dev Only]
  let ``VER Bucket Allocations Wait For Version Cleanup/sec`` instance =
    { category = "Database"; counter = "VER Bucket Allocations Wait For Version Cleanup/sec"; instance = instance }
  /// Version Buckets Allocated: Version Buckets Allocated is the total number of version buckets allocated.
  let ``Version Buckets Allocated`` instance =
    { category = "Database"; counter = "Version Buckets Allocated"; instance = instance }
  /// Version Buckets Allocated for Deletes: Total number of version buckets allocated for FlagDelete RCEs  [Dev Only]
  let ``Version Buckets Allocated for Deletes`` instance =
    { category = "Database"; counter = "Version Buckets Allocated for Deletes"; instance = instance }
  /// Version Store Average RCE Bookmark Length: Average length of bookmark in RCE  [Dev Only]
  let ``Version Store Average RCE Bookmark Length`` instance =
    { category = "Database"; counter = "Version Store Average RCE Bookmark Length"; instance = instance }
  /// Version Store Cleanup Tasks Asynchronously Dispatched/sec: Number of times per second a version store clean task is dispatched asynchronously to be performed  [Dev Only]
  let ``Version Store Cleanup Tasks Asynchronously Dispatched/sec`` instance =
    { category = "Database"; counter = "Version Store Cleanup Tasks Asynchronously Dispatched/sec"; instance = instance }
  /// Version Store Cleanup Tasks Discarded/sec: Number of times per second a version store clean task was discarded due to load concerns  [Dev Only]
  let ``Version Store Cleanup Tasks Discarded/sec`` instance =
    { category = "Database"; counter = "Version Store Cleanup Tasks Discarded/sec"; instance = instance }
  /// Version Store Cleanup Tasks Failures/sec: Number of times per second a dispatched version store cleanup task fails  [Dev Only]
  let ``Version Store Cleanup Tasks Failures/sec`` instance =
    { category = "Database"; counter = "Version Store Cleanup Tasks Failures/sec"; instance = instance }
  /// Version Store Cleanup Tasks Synchronously Dispatched/sec: Number of times per second a version store clean task is performed synchronously  [Dev Only]
  let ``Version Store Cleanup Tasks Synchronously Dispatched/sec`` instance =
    { category = "Database"; counter = "Version Store Cleanup Tasks Synchronously Dispatched/sec"; instance = instance }
  /// Version Store Unnecessary Calls/sec: Number of times per second we look in the version store for a node whose version bit is set but which has no versions  [Dev Only]
  let ``Version Store Unnecessary Calls/sec`` instance =
    { category = "Database"; counter = "Version Store Unnecessary Calls/sec"; instance = instance }

  let allCounters =
    [ ``B+ Tree Append Splits/sec``
      ``B+ Tree Appends/sec``
      ``B+ Tree Creates (Total)``
      ``B+ Tree Creates/sec``
      ``B+ Tree Deletes/sec``
      ``B+ Tree Destroys (Total)``
      ``B+ Tree Destroys/sec``
      ``B+ Tree Empty Page Merges/sec``
      ``B+ Tree Failed Simple Page Cleanup Attempts/sec``
      ``B+ Tree Flag Deletes/sec``
      ``B+ Tree Inserts/sec``
      ``B+ Tree Left Merges/sec``
      ``B+ Tree Merges/sec``
      ``B+ Tree Move Nexts (Nodes Filtered)/sec``
      ``B+ Tree Move Nexts (Non-Visible Nodes Skipped)/sec``
      ``B+ Tree Move Nexts/sec``
      ``B+ Tree Move Prevs (Nodes Filtered)/sec``
      ``B+ Tree Move Prevs (Non-Visible Nodes Skipped)/sec``
      ``B+ Tree Move Prevs/sec``
      ``B+ Tree Opportune Prereads/sec``
      ``B+ Tree Page Moves/sec``
      ``B+ Tree Partial Left Merges/sec``
      ``B+ Tree Partial Merges/sec``
      ``B+ Tree Replaces/sec``
      ``B+ Tree Right Hotpoint Splits/sec``
      ``B+ Tree Right Merges/sec``
      ``B+ Tree Right Splits/sec``
      ``B+ Tree Seek Short Circuits/sec``
      ``B+ Tree Seeks/sec``
      ``B+ Tree Splits/sec``
      ``B+ Tree Unnecessary Sibling Latches/sec``
      ``B+ Tree Vertical Splits/sec``
      ``Database Cache % Available``
      ``Database Cache % Available Max``
      ``Database Cache % Available Min``
      ``Database Cache % Clean``
      ``Database Cache % Dehydrated``
      ``Database Cache % Fast Latch``
      ``Database Cache % Hit``
      ``Database Cache % Hit (Uncorrelated)``
      ``Database Cache % Pinned``
      ``Database Cache % Resident``
      ``Database Cache % Versioned``
      ``Database Cache Lifetime (K1)``
      ``Database Cache Lifetime (K2)``
      ``Database Cache Lifetime (Longest)``
      ``Database Cache Lifetime (Low)``
      ``Database Cache Lifetime (Normal)``
      ``Database Cache Lifetime (Supercold)``
      ``Database Cache Lifetime Agg Var``
      ``Database Cache Memory Committed``
      ``Database Cache Memory Committed (MB)``
      ``Database Cache Memory Reserved``
      ``Database Cache Memory Reserved (MB)``
      ``Database Cache Misses/sec``
      ``Database Cache Requests/sec``
      ``Database Cache Scan Buckets Scanned/scan``
      ``Database Cache Scan Empty Buckets Scanned/scan``
      ``Database Cache Scan Entries/scan``
      ``Database Cache Scan Found-to-Evict Range``
      ``Database Cache Scan ID Range/scan``
      ``Database Cache Scan Page Evaluated Out-of-Order/sec``
      ``Database Cache Scan Pages Evaluated/sec``
      ``Database Cache Scan Pages Moved/sec``
      ``Database Cache Scan Time (ms)/scan``
      ``Database Cache Size``
      ``Database Cache Size (MB)``
      ``Database Cache Size Effective``
      ``Database Cache Size Effective (MB)``
      ``Database Cache Size Max``
      ``Database Cache Size Min``
      ``Database Cache Size Resident``
      ``Database Cache Size Resident (MB)``
      ``Database Cache Size Target``
      ``Database Cache Size Target (MB)``
      ``Database Cache Size Unattached (MB)``
      ``Database Cache Sizing Duration``
      ``Database Cache Super Cold Attempts/sec``
      ``Database Cache Super Cold Successes/sec``
      ``Database Cache Super Colded Resources``
      ``Database Maintenance Duration``
      ``Database Maintenance IO Re-Reads Average Bytes``
      ``Database Maintenance IO Re-Reads Average Latency``
      ``Database Maintenance IO Re-Reads/sec``
      ``Database Maintenance IO Reads Average Bytes``
      ``Database Maintenance IO Reads/sec``
      ``Database Maintenance Pages Bad Checksums``
      ``Database Maintenance Pages Read``
      ``Database Maintenance Pages Read/sec``
      ``Database Maintenance Pages Zeroed``
      ``Database Maintenance Pages Zeroed/sec``
      ``Database Maintenance Throttle Setting``
      ``Database Opportune Write Issued (Total)``
      ``Database Page Allocation File Extension Async Consumed/sec``
      ``Database Page Allocation File Extension Stalls/sec``
      ``Database Page Allocation File Shrink Stalls/sec``
      ``Database Page Bad Latch Hints/sec``
      ``Database Page Evictions (Patch)/sec``
      ``Database Page Evictions (Preread Untouched)/sec``
      ``Database Page Evictions (Purge)/sec``
      ``Database Page Evictions (Scavenging)/sec``
      ``Database Page Evictions (Scavenging.SuperCold.Ext)/sec``
      ``Database Page Evictions (Scavenging.SuperCold.Int)/sec``
      ``Database Page Evictions (Shrink)/sec``
      ``Database Page Evictions (k=1)/sec``
      ``Database Page Evictions (k=2)/sec``
      ``Database Page Evictions/sec``
      ``Database Page Fast Latches/sec``
      ``Database Page Fault Stalls/sec``
      ``Database Page Faults/sec``
      ``Database Page History % Hit``
      ``Database Page History Records``
      ``Database Page Latch Conflicts/sec``
      ``Database Page Latch Stalls/sec``
      ``Database Page Latches/sec``
      ``Database Page Preread Stalls/sec``
      ``Database Page Touches (Correlated)/sec``
      ``Database Page Touches (Non-Touch)/sec``
      ``Database Page Touches (k=1)/sec``
      ``Database Page Touches (k=2)/sec``
      ``Database Pages Coalesced Read/sec``
      ``Database Pages Coalesced Written/sec``
      ``Database Pages Colded (Ext)/sec``
      ``Database Pages Colded (Int)/sec``
      ``Database Pages Dehydrated/sec``
      ``Database Pages Dirtied (Repeatedly)/sec``
      ``Database Pages Dirtied/sec``
      ``Database Pages Flushed (Cache Shrink)/sec``
      ``Database Pages Flushed (Checkpoint Foreground)/sec``
      ``Database Pages Flushed (Checkpoint)/sec``
      ``Database Pages Flushed (Context Flush)/sec``
      ``Database Pages Flushed (Filthy Foreground)/sec``
      ``Database Pages Flushed (Idle)/sec``
      ``Database Pages Flushed (Scavenge)/sec``
      ``Database Pages Flushed (Scavenge.SuperCold.Ext)/sec``
      ``Database Pages Flushed (Scavenge.SuperCold.Int)/sec``
      ``Database Pages Flushed Opportunely Clean/sec``
      ``Database Pages Flushed Opportunely/sec``
      ``Database Pages Non-Resident Evicted (Normally)/sec``
      ``Database Pages Non-Resident Faulted In Average Latency``
      ``Database Pages Non-Resident Re-read/sec``
      ``Database Pages Non-Resident Reclaimed (Failed)/sec``
      ``Database Pages Non-Resident Reclaimed (Soft Faulted)/sec``
      ``Database Pages Preread (Unnecessary)/sec``
      ``Database Pages Preread/sec``
      ``Database Pages Read Async/sec``
      ``Database Pages Read Sync/sec``
      ``Database Pages Rehydrated/sec``
      ``Database Pages Repeatedly Read/sec``
      ``Database Pages Repeatedly Written/sec``
      ``Database Pages Transferred/sec``
      ``Database Pages Trimmed/sec``
      ``Database Pages Version Copied/sec``
      ``Database Pages Versioned/sec``
      ``Database Pages Written/sec``
      ``Database Tasks Average Log Bytes``
      ``Database Tasks Log Records/sec``
      ``Database Tasks Pages Dirtied/sec``
      ``Database Tasks Pages Preread/sec``
      ``Database Tasks Pages Re-Dirtied/sec``
      ``Database Tasks Pages Read/sec``
      ``Database Tasks Pages Referenced/sec``
      ``Database cache lifetime``
      ``Defragmentation Tasks``
      ``Defragmentation Tasks Completed/sec``
      ``Defragmentation Tasks Discarded``
      ``Defragmentation Tasks Pending``
      ``Defragmentation Tasks Scheduled/sec``
      ``FCB Allocations Wait For Version Cleanup/sec``
      ``FCB Async Purge Failures (Active Tasks)/sec``
      ``FCB Async Purge Failures (Callbacks)/sec``
      ``FCB Async Purge Failures (Conflicts)/sec``
      ``FCB Async Purge Failures (Delete Pending)/sec``
      ``FCB Async Purge Failures (In Use)/sec``
      ``FCB Async Purge Failures (Index Outstanding)/sec``
      ``FCB Async Purge Failures (LV Outstanding)/sec``
      ``FCB Async Purge Failures (Other)/sec``
      ``FCB Async Purge Failures (Outstanding Versions)/sec``
      ``FCB Async Purge Failures (Sentinel)/sec``
      ``FCB Async Purge/sec``
      ``FCB Async Scan/sec``
      ``FCB Async Threshold Purge Failures (Active Tasks)/sec``
      ``FCB Async Threshold Purge Failures (Callbacks)/sec``
      ``FCB Async Threshold Purge Failures (Conflicts)/sec``
      ``FCB Async Threshold Purge Failures (Delete Pending)/sec``
      ``FCB Async Threshold Purge Failures (In Use)/sec``
      ``FCB Async Threshold Purge Failures (Index Outstanding)/sec``
      ``FCB Async Threshold Purge Failures (LV Outstanding)/sec``
      ``FCB Async Threshold Purge Failures (Other)/sec``
      ``FCB Async Threshold Purge Failures (Outstanding Versions)/sec``
      ``FCB Async Threshold Purge Failures (Sentinel)/sec``
      ``FCB Async Threshold-Purge/sec``
      ``FCB Async Threshold-Scan/sec``
      ``FCB Attached RCEs``
      ``FCB Cache % Hit``
      ``FCB Cache Allocated``
      ``FCB Cache Allocated/sec``
      ``FCB Cache Available``
      ``FCB Cache Maximum``
      ``FCB Cache Preferred``
      ``FCB Cache Stalls/sec``
      ``FCB Purge On Cursor Close/sec``
      ``FCB Sync Purge Stalls/sec``
      ``FCB Sync Purge/sec``
      ``False Index Column Updates/sec``
      ``False Tuple Index Column Updates/sec``
      ``Heap Allocations``
      ``Heap Allocs/sec``
      ``Heap Bytes Allocated``
      ``Heap Frees/sec``
      ``I/O Database Reads (Attached) Abnormal Latency/sec``
      ``I/O Database Reads (Attached) Async Pending``
      ``I/O Database Reads (Attached) Average Bytes``
      ``I/O Database Reads (Attached) Average Latency``
      ``I/O Database Reads (Attached) In Heap``
      ``I/O Database Reads (Attached)/sec``
      ``I/O Database Reads (Recovery) Abnormal Latency/sec``
      ``I/O Database Reads (Recovery) Async Pending``
      ``I/O Database Reads (Recovery) Average Bytes``
      ``I/O Database Reads (Recovery) Average Latency``
      ``I/O Database Reads (Recovery) In Heap``
      ``I/O Database Reads (Recovery)/sec``
      ``I/O Database Reads Abnormal Latency/sec``
      ``I/O Database Reads Async Pending``
      ``I/O Database Reads Average Bytes``
      ``I/O Database Reads Average Latency``
      ``I/O Database Reads In Heap``
      ``I/O Database Reads/sec``
      ``I/O Database Writes (Attached) Abnormal Latency/sec``
      ``I/O Database Writes (Attached) Async Pending``
      ``I/O Database Writes (Attached) Average Bytes``
      ``I/O Database Writes (Attached) Average Latency``
      ``I/O Database Writes (Attached) In Heap``
      ``I/O Database Writes (Attached)/sec``
      ``I/O Database Writes (Recovery) Abnormal Latency/sec``
      ``I/O Database Writes (Recovery) Async Pending``
      ``I/O Database Writes (Recovery) Average Bytes``
      ``I/O Database Writes (Recovery) Average Latency``
      ``I/O Database Writes (Recovery) In Heap``
      ``I/O Database Writes (Recovery)/sec``
      ``I/O Database Writes Abnormal Latency/sec``
      ``I/O Database Writes Async Pending``
      ``I/O Database Writes Average Bytes``
      ``I/O Database Writes Average Latency``
      ``I/O Database Writes In Heap``
      ``I/O Database Writes/sec``
      ``I/O Log Reads Abnormal Latency/sec``
      ``I/O Log Reads Async Pending``
      ``I/O Log Reads Average Bytes``
      ``I/O Log Reads Average Latency``
      ``I/O Log Reads In Heap``
      ``I/O Log Reads/sec``
      ``I/O Log Writes Abnormal Latency/sec``
      ``I/O Log Writes Async Pending``
      ``I/O Log Writes Average Bytes``
      ``I/O Log Writes Average Latency``
      ``I/O Log Writes In Heap``
      ``I/O Log Writes/sec``
      ``Log Buffer Bytes Committed``
      ``Log Buffer Bytes Free``
      ``Log Buffer Bytes Used``
      ``Log Buffer Capacity Flushes/sec``
      ``Log Buffer Commit Flushes/sec``
      ``Log Buffer Flushes Blocked/sec``
      ``Log Buffer Flushes Skipped/sec``
      ``Log Buffer Flushes/sec``
      ``Log Bytes Generated/sec``
      ``Log Bytes Wasted/sec``
      ``Log Bytes Write/sec``
      ``Log Checkpoint Depth``
      ``Log Checkpoint Maintenance Outstanding IO Max``
      ``Log Full Segment Writes/sec``
      ``Log Generation Checkpoint Depth``
      ``Log Partial Segment Writes/sec``
      ``Log Record Stalls/sec``
      ``Log Records/sec``
      ``Log Threads Waiting``
      ``Log Writes/sec``
      ``Long-Value Maximum LID``
      ``No name``
      ``OS Memory Pages Trimmed/sec``
      ``Online Defrag Average Log Bytes``
      ``Online Defrag Data Moves/sec``
      ``Online Defrag Log Records/sec``
      ``Online Defrag Page Moves/sec``
      ``Online Defrag Pages Dirtied/sec``
      ``Online Defrag Pages Freed/sec``
      ``Online Defrag Pages Preread/sec``
      ``Online Defrag Pages Re-Dirtied/sec``
      ``Online Defrag Pages Read/sec``
      ``Online Defrag Pages Referenced/sec``
      ``Page Bytes Committed``
      ``Page Bytes Reserved``
      ``Pages Converted``
      ``Pages Converted/sec``
      ``Pages Not Trimmed Unaligned (Total)``
      ``Pages Not Trimmed Unaligned/sec``
      ``Pages Reorganized (Dehydrate Buffer)/sec``
      ``Pages Reorganized (Free Space Request)/sec``
      ``Pages Reorganized (Other)/sec``
      ``Pages Reorganized (Page Move Logging)/sec``
      ``Pages Trimmed (Total)``
      ``Pages Trimmed Dirty (Total)``
      ``Pages Trimmed Dirty/sec``
      ``Pages Trimmed/sec``
      ``Program Marker``
      ``Record Deletes/sec``
      ``Record Escrow-Updates/sec``
      ``Record Failed Compression Bytes/sec``
      ``Record Inserts/sec``
      ``Record Intrinsic Long-Values Updated/sec``
      ``Record Redundant Replaces/sec``
      ``Record Replaces/sec``
      ``Record Separated Long-Values Added/sec``
      ``Record Separated Long-Values All Forced/sec``
      ``Record Separated Long-Values Dereference All/sec``
      ``Record Separated Long-Values Forced/sec``
      ``Record Separated Long-Values Reference All/sec``
      ``Record Unnecessary Replaces/sec``
      ``Records Converted``
      ``Records Converted/sec``
      ``Resource Manager FCB Allocated``
      ``Resource Manager FCB Allocated Used``
      ``Resource Manager FCB Quota``
      ``Resource Manager FUCB Allocated``
      ``Resource Manager FUCB Allocated Used``
      ``Resource Manager FUCB Quota``
      ``Resource Manager IDB Allocated``
      ``Resource Manager IDB Allocated Used``
      ``Resource Manager IDB Quota``
      ``Resource Manager TDB Allocated``
      ``Resource Manager TDB Allocated Used``
      ``Resource Manager TDB Quota``
      ``Secondary Index Deletes/sec``
      ``Secondary Index Inserts/sec``
      ``Separated Long-Value Chunk Appends/sec``
      ``Separated Long-Value Chunk Copies/sec``
      ``Separated Long-Value Chunk Deletes/sec``
      ``Separated Long-Value Chunk Replaces/sec``
      ``Separated Long-Value Chunk Retrieves/sec``
      ``Separated Long-Value Chunk Seeks/sec``
      ``Separated Long-Value Copies/sec``
      ``Separated Long-Value Creates/sec``
      ``Separated Long-Value Deletes/sec``
      ``Separated Long-Value Retrieves/sec``
      ``Separated Long-Value Seeks/sec``
      ``Separated Long-Value Updates/sec``
      ``Sessions % Used``
      ``Sessions In Use``
      ``Streaming Backup Pages Read/sec``
      ``System Read Only Transaction Commits to Level 0/sec``
      ``System Read Only Transaction Rollbacks to Level 0/sec``
      ``System Read/Write Transaction Commits to Level 0 (Durable)/sec``
      ``System Read/Write Transaction Commits to Level 0 (Lazy)/sec``
      ``System Read/Write Transaction Rollbacks to Level 0/sec``
      ``System Transaction Commits to Level 0/sec``
      ``System Transaction Rollbacks to Level 0/sec``
      ``Table Closes/sec``
      ``Table Open Cache % Hit``
      ``Table Open Cache Hits/sec``
      ``Table Open Cache Misses/sec``
      ``Table Open Pages Preread/sec``
      ``Table Open Pages Read/sec``
      ``Table Opens/sec``
      ``Tables Open``
      ``Threads Blocked``
      ``Threads Blocked/sec``
      ``User Read Only Transaction Commits to Level 0/sec``
      ``User Read Only Transaction Rollbacks to Level 0/sec``
      ``User Read/Write Transaction Commits to Level 0 (Durable)/sec``
      ``User Read/Write Transaction Commits to Level 0 (Lazy)/sec``
      ``User Read/Write Transaction Rollbacks to Level 0/sec``
      ``User Transaction Commits to Level 0/sec``
      ``User Transaction Rollbacks to Level 0/sec``
      ``User Wait All Transaction Commits/sec``
      ``User Wait Last Transaction Commits/sec``
      ``VER Bucket Allocations Wait For Version Cleanup/sec``
      ``Version Buckets Allocated``
      ``Version Buckets Allocated for Deletes``
      ``Version Store Average RCE Bookmark Length``
      ``Version Store Cleanup Tasks Asynchronously Dispatched/sec``
      ``Version Store Cleanup Tasks Discarded/sec``
      ``Version Store Cleanup Tasks Failures/sec``
      ``Version Store Cleanup Tasks Synchronously Dispatched/sec``
      ``Version Store Unnecessary Calls/sec``
    ]

/// Database ==> Instances: Instances in this process
///
/// This performance counter does not have non-instance based counters
module ``Database ==> Instances`` =

  [<Literal>]
  let Category = "Database ==> Instances"

  let PCC = getPCC Category
  /// B+ Tree Append Splits/sec: B+ Tree Append Splits/sec is the count of times a page is appended to a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Append Splits/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Append Splits/sec"; instance = instance }
  /// B+ Tree Appends/sec: B+ Tree Appends/sec is the count of times a record is appended to a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Appends/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Appends/sec"; instance = instance }
  /// B+ Tree Creates (Total): B+ Tree Creates (Total) is the total number of B+ Trees and their corresponding space trees (if any) created.  This can also be viewed as the total number of FDP creates.  [Dev Only]
  let ``B+ Tree Creates (Total)`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Creates (Total)"; instance = instance }
  /// B+ Tree Creates/sec: B+ Tree Creates/sec is the number of B+ Trees and their corresponding space trees (if any) created per second.  This can also be viewed as the number of FDP creates per second.  [Dev Only]
  let ``B+ Tree Creates/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Creates/sec"; instance = instance }
  /// B+ Tree Deletes/sec: B+ Tree Deletes/sec is the count of times a record is deleted in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Deletes/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Deletes/sec"; instance = instance }
  /// B+ Tree Destroys (Total): B+ Tree Destroys (Total) is the total number of B+ Trees and their corresponding space trees (if any) destroyed.  This can also be viewed as the total number of FDP destroys.  [Dev Only]
  let ``B+ Tree Destroys (Total)`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Destroys (Total)"; instance = instance }
  /// B+ Tree Destroys/sec: B+ Tree Destroys/sec is the number of B+ Trees and their corresponding space trees (if any) destroyed per second.  This can also be viewed as the number of FDP destroys per second.  [Dev Only]
  let ``B+ Tree Destroys/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Destroys/sec"; instance = instance }
  /// B+ Tree Empty Page Merges/sec: B+ Tree Empty Page Merges/sec is the count of empty pages removed from a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Empty Page Merges/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Empty Page Merges/sec"; instance = instance }
  /// B+ Tree Failed Simple Page Cleanup Attempts/sec: B+ Tree Failed Simple Page Cleanup Attempts/sec is the rate that attempts to reclaim deleted node space on a page are unsuccessful due to a conflict when attempting to write-latch the page. The cleanup is re-tried by locking the root of the B+ Tree.  [Dev Only]
  let ``B+ Tree Failed Simple Page Cleanup Attempts/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Failed Simple Page Cleanup Attempts/sec"; instance = instance }
  /// B+ Tree Flag Deletes/sec: B+ Tree Flag Deletes/sec is the count of times a record is flag deleted in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Flag Deletes/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Flag Deletes/sec"; instance = instance }
  /// B+ Tree Inserts/sec: B+ Tree Inserts/sec is the count of times a record is inserted in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Inserts/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Inserts/sec"; instance = instance }
  /// B+ Tree Left Merges/sec: B+ Tree Left Merges/sec is the count of pages removed from a database B+ Tree per second by moving all its records to the previous page to the left.  [Dev Only]
  let ``B+ Tree Left Merges/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Left Merges/sec"; instance = instance }
  /// B+ Tree Merges/sec: B+ Tree Merges/sec is the count of pages merged in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Merges/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Merges/sec"; instance = instance }
  /// B+ Tree Move Nexts (Nodes Filtered)/sec: B+ Tree Move Nexts (Nodes Filtered)/sec is the count of times the database engine filters records while attempting to move to the next record in a B+ Tree per second.  [Dev Only]
  let ``B+ Tree Move Nexts (Nodes Filtered)/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Move Nexts (Nodes Filtered)/sec"; instance = instance }
  /// B+ Tree Move Nexts (Non-Visible Nodes Skipped)/sec: B+ Tree Move Nexts (Non-Visible Nodes Skipped)/sec is the count of times the database engine skips non-visible records while attempting to move to the next visible record in a B+ Tree per second.  [Dev Only]
  let ``B+ Tree Move Nexts (Non-Visible Nodes Skipped)/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Move Nexts (Non-Visible Nodes Skipped)/sec"; instance = instance }
  /// B+ Tree Move Nexts/sec: B+ Tree Move Nexts/sec is the count of times the database engine moves to the next record in a B+ Tree per second.  [Dev Only]
  let ``B+ Tree Move Nexts/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Move Nexts/sec"; instance = instance }
  /// B+ Tree Move Prevs (Nodes Filtered)/sec: B+ Tree Move Prevs (Nodes Filtered)/sec is the count of times the database engine filters records while attempting to move to the previous record in a B+ Tree per second.  [Dev Only]
  let ``B+ Tree Move Prevs (Nodes Filtered)/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Move Prevs (Nodes Filtered)/sec"; instance = instance }
  /// B+ Tree Move Prevs (Non-Visible Nodes Skipped)/sec: B+ Tree Move Prevs (Non-Visible Nodes Skipped)/sec is the count of times the database engine skips non-visible records while attempting to move to the previous visible record in a B+ Tree per second.  [Dev Only]
  let ``B+ Tree Move Prevs (Non-Visible Nodes Skipped)/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Move Prevs (Non-Visible Nodes Skipped)/sec"; instance = instance }
  /// B+ Tree Move Prevs/sec: B+ Tree Move Prevs/sec is the count of times the database engine moves to the previous record in a B+ Tree per second.  [Dev Only]
  let ``B+ Tree Move Prevs/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Move Prevs/sec"; instance = instance }
  /// B+ Tree Opportune Prereads/sec: B+ Tree Opportune Prereads/sec is the number of pages per second that are preread because they are adjacent to a page read by a seek.  [Dev Only]
  let ``B+ Tree Opportune Prereads/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Opportune Prereads/sec"; instance = instance }
  /// B+ Tree Page Moves/sec: B+ Tree Page Moves/sec is the count of B+ Tree pages per second where all the records are moved to a new page. [Dev Only]
  let ``B+ Tree Page Moves/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Page Moves/sec"; instance = instance }
  /// B+ Tree Partial Left Merges/sec: B+ Tree Partial Left Merges/sec is the count of pages where some of its records are moved to a page on the left in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Partial Left Merges/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Partial Left Merges/sec"; instance = instance }
  /// B+ Tree Partial Merges/sec: B+ Tree Partial Merges/sec is the count of pages where some of its records are moved to a page on the right in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Partial Merges/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Partial Merges/sec"; instance = instance }
  /// B+ Tree Replaces/sec: B+ Tree Replaces/sec is the count of times a record is replaced in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Replaces/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Replaces/sec"; instance = instance }
  /// B+ Tree Right Hotpoint Splits/sec: B+ Tree Right Hotpoint Splits/sec is the count of times a page is split right in a database B+ Tree, but which is treated as an append at a local "hotpoint" in the B+ Tree per second.  [Dev Only]
  let ``B+ Tree Right Hotpoint Splits/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Right Hotpoint Splits/sec"; instance = instance }
  /// B+ Tree Right Merges/sec: Right Merges/sec is the count of pages removed from a database B+ Tree per second by moving all its records to the next page to the right.  [Dev Only]
  let ``B+ Tree Right Merges/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Right Merges/sec"; instance = instance }
  /// B+ Tree Right Splits/sec: B+ Tree Right Splits/sec is the count of times a page is split right in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Right Splits/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Right Splits/sec"; instance = instance }
  /// B+ Tree Seek Short Circuits/sec: B+ Tree Seek Short Circuits/sec is the count of repeated seeks to the same record in a database B+ Tree that are saved by jumping directly to the cached physical location of that record per second.  [Dev Only]
  let ``B+ Tree Seek Short Circuits/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Seek Short Circuits/sec"; instance = instance }
  /// B+ Tree Seeks/sec: B+ Tree Seeks/sec is the count of times a record is seeked to by a key in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Seeks/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Seeks/sec"; instance = instance }
  /// B+ Tree Splits/sec: B+ Tree Splits/sec is the count of times a page is appended to or split in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Splits/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Splits/sec"; instance = instance }
  /// B+ Tree Unnecessary Sibling Latches/sec: B+ Tree Unnecessary Sibling Latches/sec is the count of sibling pages latched during a database B+ Tree Delete in the hopes of performing a merge where a merge is not possible, making that latch unnecessary.  [Dev Only]
  let ``B+ Tree Unnecessary Sibling Latches/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Unnecessary Sibling Latches/sec"; instance = instance }
  /// B+ Tree Vertical Splits/sec: B+ Tree Vertical Splits/sec is the count of times a page is split vertically in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Vertical Splits/sec`` instance =
    { category = "Database ==> Instances"; counter = "B+ Tree Vertical Splits/sec"; instance = instance }
  /// Database Cache % Hit: Database Cache % Hit is the percentage of database file page requests that were fulfilled by the database cache without causing a file operation.  If this percentage is too low, the database cache size may be too small.
  let ``Database Cache % Hit`` instance =
    { category = "Database ==> Instances"; counter = "Database Cache % Hit"; instance = instance }
  /// Database Cache % Hit (Uncorrelated): Database Cache % Hit (Uncorrelated) is the percentage of uncorrelated  database file page requests that were fulfilled by the database cache.
  let ``Database Cache % Hit (Uncorrelated)`` instance =
    { category = "Database ==> Instances"; counter = "Database Cache % Hit (Uncorrelated)"; instance = instance }
  /// Database Cache Misses/sec: Database Cache Misses per second is the rate at which database file page requests were fulfilled by the database cache by causing a file operation.  If this rate is high, then the database cache size may be too small.
  let ``Database Cache Misses/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Cache Misses/sec"; instance = instance }
  /// Database Cache Requests/sec: Database Cache Requests/sec is the rate that pages are requested from the database cache.
  let ``Database Cache Requests/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Cache Requests/sec"; instance = instance }
  /// Database Cache Size (MB): Database Cache Size (MB) is the amount of system memory (in megabytes) used by the database cache manager to hold commonly used information from the database file(s) to prevent file operations.  If the database cache size seems to be too small for optimal performance and there is very little available memory on the system (see Memory/Available Bytes), adding more memory to the system may increase performance.  If there is a lot of available memory on the system and the database cache size is not growing beyond a certain point, the database cache size may be capped at an artificially low limit.  Increasing this limit may increase performance.
  let ``Database Cache Size (MB)`` instance =
    { category = "Database ==> Instances"; counter = "Database Cache Size (MB)"; instance = instance }
  /// Database Maintenance Duration: Database Maintenance Duration is the number of hours that have passed since maintenance last completed for this database.
  let ``Database Maintenance Duration`` instance =
    { category = "Database ==> Instances"; counter = "Database Maintenance Duration"; instance = instance }
  /// Database Maintenance IO Re-Reads Average Bytes: Database Maintenance IO Re-Reads Average Bytes is the approximate average size in bytes of Database Maintenance read IO for pages already cached in the buffer manager. [Dev Only]
  let ``Database Maintenance IO Re-Reads Average Bytes`` instance =
    { category = "Database ==> Instances"; counter = "Database Maintenance IO Re-Reads Average Bytes"; instance = instance }
  /// Database Maintenance IO Re-Reads Average Latency: Database Maintenance IO Re-Reads Average Latency is the approximate average latency in milli-seconds for Database Maintenance read IO for pages already cached in the buffer manager. [Dev Only]
  let ``Database Maintenance IO Re-Reads Average Latency`` instance =
    { category = "Database ==> Instances"; counter = "Database Maintenance IO Re-Reads Average Latency"; instance = instance }
  /// Database Maintenance IO Re-Reads/sec: Database Maintenance IO Re-Reads/sec is the approximate number of Database Maintenance read IO operations for pages already cached in the buffer manager generated/sec. [Dev Only]
  let ``Database Maintenance IO Re-Reads/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Maintenance IO Re-Reads/sec"; instance = instance }
  /// Database Maintenance IO Reads Average Bytes: Database Maintenance IO Reads Average Bytes is the approximate average size in bytes of Database Maintenance read IO. [Dev Only]
  let ``Database Maintenance IO Reads Average Bytes`` instance =
    { category = "Database ==> Instances"; counter = "Database Maintenance IO Reads Average Bytes"; instance = instance }
  /// Database Maintenance IO Reads/sec: Database Maintenance IO Reads/sec is the approximate number of Database Maintenance read IO operations generated/sec. [Dev Only]
  let ``Database Maintenance IO Reads/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Maintenance IO Reads/sec"; instance = instance }
  /// Database Maintenance Pages Bad Checksums: Database Maintenance Pages Bad Checksums is the number of non-correctable page checksums encountered during a database maintenance pass.
  let ``Database Maintenance Pages Bad Checksums`` instance =
    { category = "Database ==> Instances"; counter = "Database Maintenance Pages Bad Checksums"; instance = instance }
  /// Database Maintenance Pages Read: Database Maintenance Pages Read is the number of pages read by database maintenance. [Dev Only]
  let ``Database Maintenance Pages Read`` instance =
    { category = "Database ==> Instances"; counter = "Database Maintenance Pages Read"; instance = instance }
  /// Database Maintenance Pages Read/sec: Database Maintenance Pages Read/sec is the rate at which pages are read by database maintenance. [Dev Only]
  let ``Database Maintenance Pages Read/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Maintenance Pages Read/sec"; instance = instance }
  /// Database Maintenance Pages Zeroed: Database Maintenance Pages Zeroed is the number of pages zeroed/scrubbed by database maintenance. [Dev Only]
  let ``Database Maintenance Pages Zeroed`` instance =
    { category = "Database ==> Instances"; counter = "Database Maintenance Pages Zeroed"; instance = instance }
  /// Database Maintenance Pages Zeroed/sec: Database Maintenance Pages Zeroed/sec is the rate at which pages are zeroed/scrubbed by database maintenance. [Dev Only]
  let ``Database Maintenance Pages Zeroed/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Maintenance Pages Zeroed/sec"; instance = instance }
  /// Database Maintenance Throttle Setting: Database Maintenance Throttle Setting is the current Database Maintenance throttle setting. [Dev Only]
  let ``Database Maintenance Throttle Setting`` instance =
    { category = "Database ==> Instances"; counter = "Database Maintenance Throttle Setting"; instance = instance }
  /// Database Page Allocation File Extension Async Consumed/sec: Database Page Allocation File Extension Async Consumed/sec is the rate of page allocations from a database file that must be serviced by extending the database file, but which do not stall when doing doing so.  [Dev Only]
  let ``Database Page Allocation File Extension Async Consumed/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Page Allocation File Extension Async Consumed/sec"; instance = instance }
  /// Database Page Allocation File Extension Stalls/sec: Database Page Allocation File Extension Stalls/sec is the rate of page allocations from a database file that must be serviced by extending the database file and which stall when doing so.  [Dev Only]
  let ``Database Page Allocation File Extension Stalls/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Page Allocation File Extension Stalls/sec"; instance = instance }
  /// Database Page Allocation File Shrink Stalls/sec: Database Page Allocation File Shrink Stalls/sec is the rate of page releases from a database file that must be serviced by shrink the database file and which stall when doing so.  [Dev Only]
  let ``Database Page Allocation File Shrink Stalls/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Page Allocation File Shrink Stalls/sec"; instance = instance }
  /// Database Page Evictions (Patch)/sec: Database Page Evictions (Patch)/sec is the rate that cached pages are evicted due to active page patching.  [Dev Only]
  let ``Database Page Evictions (Patch)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Page Evictions (Patch)/sec"; instance = instance }
  /// Database Page Evictions (Purge)/sec: Database Page Evictions (Purge)/sec is the rate that cached pages are evicted due to purging a cached context / database.  [Dev Only]
  let ``Database Page Evictions (Purge)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Page Evictions (Purge)/sec"; instance = instance }
  /// Database Page Evictions (Scavenging)/sec: Database Page Evictions (Scavenging)/sec is the rate that cached pages are evicted due to scavenging / avail pool maintenance running.  [Dev Only]
  let ``Database Page Evictions (Scavenging)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Page Evictions (Scavenging)/sec"; instance = instance }
  /// Database Page Evictions (Shrink)/sec: Database Page Evictions (Shrink)/sec is the rate that cached pages are evicted due to the database cache shrinking.  [Dev Only]
  let ``Database Page Evictions (Shrink)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Page Evictions (Shrink)/sec"; instance = instance }
  /// Database Page Evictions (k=1)/sec: Database Page Evictions (k=1)/sec is the rate that database file pages are evicted that were of limited usefulness (k=1 pool).  [Dev Only]
  let ``Database Page Evictions (k=1)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Page Evictions (k=1)/sec"; instance = instance }
  /// Database Page Evictions (k=2)/sec: Database Page Evictions (k=2)/sec is the rate that database file pages are evicted that were of high usefulness (k=2 pool).  [Dev Only]
  let ``Database Page Evictions (k=2)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Page Evictions (k=2)/sec"; instance = instance }
  /// Database Page Preread Stalls/sec: Database Page Preread Stalls/sec is the rate that pages are read in anticipation of future use from the database file(s) into the database cache but did not complete preread before intended use.  [Dev Only]
  let ``Database Page Preread Stalls/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Page Preread Stalls/sec"; instance = instance }
  /// Database Page Touches (Correlated)/sec: Database Page Touches (Correlated)/sec is the rate that database pages are touched within a correlation interval (default=125 ms).  [Dev Only]
  let ``Database Page Touches (Correlated)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Page Touches (Correlated)/sec"; instance = instance }
  /// Database Page Touches (Non-Touch)/sec: Database Page Touches (Non-Touch)/sec is the rate that database pages are touched within a single ms (super-correlated).  [Dev Only]
  let ``Database Page Touches (Non-Touch)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Page Touches (Non-Touch)/sec"; instance = instance }
  /// Database Page Touches (k=1)/sec: Database Page Touches (k=1)/sec is the rate that database pages are touched for the first time / k=1 pool.  [Dev Only]
  let ``Database Page Touches (k=1)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Page Touches (k=1)/sec"; instance = instance }
  /// Database Page Touches (k=2)/sec: Database Page Touches (k=2)/sec is the rate that database pages are subsequently touched and put in the k=2 pool.  [Dev Only]
  let ``Database Page Touches (k=2)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Page Touches (k=2)/sec"; instance = instance }
  /// Database Pages Coalesced Read/sec: Database Pages Coalesced Read/sec is the rate that pages are read from the database file(s) to the database cache coalesced with another page. [Dev Only]
  let ``Database Pages Coalesced Read/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Coalesced Read/sec"; instance = instance }
  /// Database Pages Coalesced Written/sec: Database Pages Coalesced Written/sec is the rate that pages are written to the database file(s) from the database cache coalesced with another page. [Dev Only]
  let ``Database Pages Coalesced Written/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Coalesced Written/sec"; instance = instance }
  /// Database Pages Colded (Ext)/sec: Database Pages Colded (Ext) per second is the rate at which database pages are deprioritized by sub-components other than the buffer manager to send  for early eviction.  [Dev Only]
  let ``Database Pages Colded (Ext)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Colded (Ext)/sec"; instance = instance }
  /// Database Pages Colded (Int)/sec: Database Pages Colded (Int) per second is the rate at which database pages are deprioritized by the buffer manager itself to maintain minimal  cache usage.  [Dev Only]
  let ``Database Pages Colded (Int)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Colded (Int)/sec"; instance = instance }
  /// Database Pages Dehydrated/sec: Database Pages Dehydrated/sec is the rate that pages are compressed to memory usage in the buffer manager. [Dev Only]
  let ``Database Pages Dehydrated/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Dehydrated/sec"; instance = instance }
  /// Database Pages Dirtied (Repeatedly)/sec: Database Pages Dirtied (Repeatedly)/sec is the rate that pages are  repeatedly dirtied / redirtied in the database cache.  [Dev Only]
  let ``Database Pages Dirtied (Repeatedly)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Dirtied (Repeatedly)/sec"; instance = instance }
  /// Database Pages Dirtied/sec: Database Pages Dirtied/sec is the rate that pages are dirtied in the database cache.  [Dev Only]
  let ``Database Pages Dirtied/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Dirtied/sec"; instance = instance }
  /// Database Pages Flushed (Cache Shrink)/sec: Database Pages Flushed (Cache Shrink)/sec is the rate that pages are written to the database file(s) from the database cache because the cache size  must shrink.  [Dev Only]
  let ``Database Pages Flushed (Cache Shrink)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Flushed (Cache Shrink)/sec"; instance = instance }
  /// Database Pages Flushed (Checkpoint Foreground)/sec: Database Pages Flushed (Checkpoint Foreground)/sec is the rate that pages are written to the database file(s) from the database cache to keep the checkpoint depth down to configured levels.  [Dev Only]
  let ``Database Pages Flushed (Checkpoint Foreground)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Flushed (Checkpoint Foreground)/sec"; instance = instance }
  /// Database Pages Flushed (Checkpoint)/sec: Database Pages Flushed (Checkpoint)/sec is the rate that pages are written to the database file(s) from the database cache to keep the checkpoint depth down to configured levels.  [Dev Only]
  let ``Database Pages Flushed (Checkpoint)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Flushed (Checkpoint)/sec"; instance = instance }
  /// Database Pages Flushed (Context Flush)/sec: Database Pages Flushed (Context Flush)/sec is the rate that pages are written to the database file(s) from the database cache due to a requested flush of a buffer context.  [Dev Only]
  let ``Database Pages Flushed (Context Flush)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Flushed (Context Flush)/sec"; instance = instance }
  /// Database Pages Flushed (Filthy Foreground)/sec: Database Pages Flushed (Filthy Foreground)/sec is the rate that pages are written to the database file(s) from the database cache because they are marked for filthy / immediate flush.  [Dev Only]
  let ``Database Pages Flushed (Filthy Foreground)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Flushed (Filthy Foreground)/sec"; instance = instance }
  /// Database Pages Flushed (Idle)/sec: Database Pages Flushed (Idle)/sec is the rate that pages are written to the database file(s) from the database cache because there is low disk activity.  [Dev Only]
  let ``Database Pages Flushed (Idle)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Flushed (Idle)/sec"; instance = instance }
  /// Database Pages Flushed (Scavenge)/sec: Database Pages Flushed (Scavenge)/sec is the rate that pages are written to the database file(s) from the database cache to perform available pool maintenance.  [Dev Only]
  let ``Database Pages Flushed (Scavenge)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Flushed (Scavenge)/sec"; instance = instance }
  /// Database Pages Flushed Opportunely Clean/sec: Database Pages Flushed Opportunely Clean/sec is the rate that clean pages are opportunely written to the database file(s) from the database  cache because they happen to be betweeen two other pages that must  be written.  These additional writes are performed in the hope that the total number of IOs required to write all the dirty pages is reduced.  [Dev Only]
  let ``Database Pages Flushed Opportunely Clean/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Flushed Opportunely Clean/sec"; instance = instance }
  /// Database Pages Flushed Opportunely/sec: Database Pages Flushed Opportunely/sec is the rate that pages are written to the database file(s) from the database cache because they happen to be near other pages that must be written.  These additional writes are performed before they must happen in the hope that the total number of IOs required to write all the pages is reduced.  [Dev Only]
  let ``Database Pages Flushed Opportunely/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Flushed Opportunely/sec"; instance = instance }
  /// Database Pages Non-Resident Evicted (Normally)/sec: Database Pages Non-Resident Evicted (Normally)/sec is the number of pages that were paged / trimmed by the OS memory manager, and got evicted normally before being re-used or re-latched. [Dev Only]
  let ``Database Pages Non-Resident Evicted (Normally)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Non-Resident Evicted (Normally)/sec"; instance = instance }
  /// Database Pages Non-Resident Re-read/sec: Database Pages Non-Resident Re-read/sec is the number of pages that could not be reclaimed by soft fault, and must be redirected to the database file as a re-read of the page. [Dev Only]
  let ``Database Pages Non-Resident Re-read/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Non-Resident Re-read/sec"; instance = instance }
  /// Database Pages Non-Resident Reclaimed (Failed)/sec: Database Pages Non-Resident Reclaimed (Failed)/sec is the number of OS soft faults attempted and failed against database pages in the buffer cache. [Dev Only]
  let ``Database Pages Non-Resident Reclaimed (Failed)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Non-Resident Reclaimed (Failed)/sec"; instance = instance }
  /// Database Pages Non-Resident Reclaimed (Soft Faulted)/sec: Database Pages Non-Resident Reclaimed (Soft Faulted)/sec is the number  of OS soft faults attempted and succeeded against database pages in the buffer cache. [Dev Only]
  let ``Database Pages Non-Resident Reclaimed (Soft Faulted)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Non-Resident Reclaimed (Soft Faulted)/sec"; instance = instance }
  /// Database Pages Preread (Unnecessary)/sec: Database Pages Preread (Unnecessary)/sec is the rate that pages are  requested in anticipation of future use but that are already cached by the database cache.  This is non-ideal behavior that represents a waste of processing time.  [Dev Only]
  let ``Database Pages Preread (Unnecessary)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Preread (Unnecessary)/sec"; instance = instance }
  /// Database Pages Preread Untouched/sec: Database Pages Preread Untouched/sec is the rate that pages are read in anticipation of future use from the database file(s) into the database cache that were subsequently thrown out without being used. This is non-ideal behavior that represents a waste of I/O bandwidth and processing time.  [Dev Only]
  let ``Database Pages Preread Untouched/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Preread Untouched/sec"; instance = instance }
  /// Database Pages Preread/sec: Database Pages Preread/sec is the rate that pages are read in anticipation of future use from the database file(s) into the database cache.  [Dev Only]
  let ``Database Pages Preread/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Preread/sec"; instance = instance }
  /// Database Pages Read Async/sec: Database Pages Read Async/sec is the rate that pages are asynchronously read from the database file(s) into the database cache.  [Dev Only]
  let ``Database Pages Read Async/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Read Async/sec"; instance = instance }
  /// Database Pages Read Sync/sec: Database Pages Read Sync/sec is the rate that pages are synchronously read from the database file(s) into the database cache.  [Dev Only]
  let ``Database Pages Read Sync/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Read Sync/sec"; instance = instance }
  /// Database Pages Rehydrated/sec: Database Pages Rehydrated/sec is the rate that pages are uncompressed for active usage or flushing to the database. [Dev Only]
  let ``Database Pages Rehydrated/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Rehydrated/sec"; instance = instance }
  /// Database Pages Repeatedly Read/sec: Database Pages Repeatedly Read/sec is the rate that pages are read from the database file(s) into the database cache more than once a short period of time / within history tracking.  [Dev Only]
  let ``Database Pages Repeatedly Read/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Repeatedly Read/sec"; instance = instance }
  /// Database Pages Repeatedly Written/sec: Database Pages Repeatedly Written/sec is the rate that pages are written to the database file(s) from the database cache more than once in their lifetime in the cache.  These page writes represent extra writes above the theoretical minimum and can therefore be considered overhead.  [Dev Only]
  let ``Database Pages Repeatedly Written/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Repeatedly Written/sec"; instance = instance }
  /// Database Pages Transferred/sec: Database Pages Transferred/sec is the rate that pages are transferred from the database file(s) to the database cache and vice versa.  [Dev Only]
  let ``Database Pages Transferred/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Transferred/sec"; instance = instance }
  /// Database Pages Version Copied/sec: Database Pages Version Copied/sec is the rate at which pages in the database cache are being copied into new pages in the cache for the purpose of being asynchronously written while the current version of that page in the database file is still being modified.  This feature is primarily used to avoid cycles, branches, or long chains of flush order dependencies without requiring the pages involved to be synchronously written to disk.  [Dev Only]
  let ``Database Pages Version Copied/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Version Copied/sec"; instance = instance }
  /// Database Pages Versioned/sec: Database Pages Versioned/sec is the rate at which pages in the database cache are being copied into new pages in the cache for the purpose of being asynchronously written while the current version of that page in the database file is still being modified.  This feature is primarily used to avoid cycles, branches, or long chains of flush order dependencies without requiring the pages involved to be synchronously written to disk.  [Dev Only]
  let ``Database Pages Versioned/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Versioned/sec"; instance = instance }
  /// Database Pages Written/sec: Database Pages Written/sec is the rate that pages are written to the database file(s) from the database cache.  [Dev Only]
  let ``Database Pages Written/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Pages Written/sec"; instance = instance }
  /// Database Tasks Average Log Bytes: Database Tasks Average Log Bytes is the average size of the log records being generated by background database tasks.  [Dev Only]
  let ``Database Tasks Average Log Bytes`` instance =
    { category = "Database ==> Instances"; counter = "Database Tasks Average Log Bytes"; instance = instance }
  /// Database Tasks Log Records/sec: Database Tasks Log Records/sec is the rate at which background database tasks are generating log records.  [Dev Only]
  let ``Database Tasks Log Records/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Tasks Log Records/sec"; instance = instance }
  /// Database Tasks Pages Dirtied/sec: Database Tasks Pages Dirtied/sec is the rate at which background database tasks are modifying clean database pages. [Dev Only]
  let ``Database Tasks Pages Dirtied/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Tasks Pages Dirtied/sec"; instance = instance }
  /// Database Tasks Pages Preread/sec: Database Tasks Pages Preread/sec is the rate at which database pages are read in anticipation of future use by background database tasks.  [Dev Only]
  let ``Database Tasks Pages Preread/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Tasks Pages Preread/sec"; instance = instance }
  /// Database Tasks Pages Re-Dirtied/sec: Database Tasks Pages Re-Dirtied/sec is the rate at which background databases tasks are modifying database pages that already contained modifications.  [Dev Only]
  let ``Database Tasks Pages Re-Dirtied/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Tasks Pages Re-Dirtied/sec"; instance = instance }
  /// Database Tasks Pages Read/sec: Database Tasks Pages Read/sec is the rate of database read operations being performed by background database tasks. [Dev Only]
  let ``Database Tasks Pages Read/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Tasks Pages Read/sec"; instance = instance }
  /// Database Tasks Pages Referenced/sec: Database Tasks Pages Referenced/sec is the rate at which background database tasks are touching database pages. [Dev Only]
  let ``Database Tasks Pages Referenced/sec`` instance =
    { category = "Database ==> Instances"; counter = "Database Tasks Pages Referenced/sec"; instance = instance }
  /// Defragmentation Tasks: Defragmentation Tasks is the count of background database defragmentation tasks that are currently executing.
  let ``Defragmentation Tasks`` instance =
    { category = "Database ==> Instances"; counter = "Defragmentation Tasks"; instance = instance }
  /// Defragmentation Tasks Completed/sec: Defragmentation Tasks Completed/sec is the number of background database defragmentation tasks completing execution per second. [Dev Only]
  let ``Defragmentation Tasks Completed/sec`` instance =
    { category = "Database ==> Instances"; counter = "Defragmentation Tasks Completed/sec"; instance = instance }
  /// Defragmentation Tasks Discarded: Defragmentation Tasks Discarded is the count of background database defragmentation tasks that could not be registered. [Dev Only]
  let ``Defragmentation Tasks Discarded`` instance =
    { category = "Database ==> Instances"; counter = "Defragmentation Tasks Discarded"; instance = instance }
  /// Defragmentation Tasks Pending: Defragmentation Tasks Pending is the count of background database defragmentation tasks that are currently pending.
  let ``Defragmentation Tasks Pending`` instance =
    { category = "Database ==> Instances"; counter = "Defragmentation Tasks Pending"; instance = instance }
  /// Defragmentation Tasks Scheduled/sec: Defragmentation Tasks Scheduled/sec is the number of background database defragmentation tasks scheduled for execution per second. [Dev Only]
  let ``Defragmentation Tasks Scheduled/sec`` instance =
    { category = "Database ==> Instances"; counter = "Defragmentation Tasks Scheduled/sec"; instance = instance }
  /// FCB Allocations Wait For Version Cleanup/sec: FCB Allocations Wait For Version Cleanup/sec is the number of FCB allocations that must first wait for version cleanup in an attempt to free used FCBs for re-use. [Dev Only]
  let ``FCB Allocations Wait For Version Cleanup/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Allocations Wait For Version Cleanup/sec"; instance = instance }
  /// FCB Async Purge Failures (Active Tasks)/sec: FCB Async Purge Failures (Active Tasks)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record having active tasks.  [Dev Only]
  let ``FCB Async Purge Failures (Active Tasks)/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Purge Failures (Active Tasks)/sec"; instance = instance }
  /// FCB Async Purge Failures (Callbacks)/sec: FCB Async Purge Failures (Callbacks)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record having callbacks.  [Dev Only]
  let ``FCB Async Purge Failures (Callbacks)/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Purge Failures (Callbacks)/sec"; instance = instance }
  /// FCB Async Purge Failures (Conflicts)/sec: FCB Async Purge Failures (Conflicts)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup.  The purge operation failed because exclusive ownership of the schema record could not be obtained.  [Dev Only]
  let ``FCB Async Purge Failures (Conflicts)/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Purge Failures (Conflicts)/sec"; instance = instance }
  /// FCB Async Purge Failures (Delete Pending)/sec: FCB Async Purge Failures (Delete Pending)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record being pending delete.  [Dev Only]
  let ``FCB Async Purge Failures (Delete Pending)/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Purge Failures (Delete Pending)/sec"; instance = instance }
  /// FCB Async Purge Failures (In Use)/sec: FCB Async Purge Failures (In Use)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record being in use.  [Dev Only]
  let ``FCB Async Purge Failures (In Use)/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Purge Failures (In Use)/sec"; instance = instance }
  /// FCB Async Purge Failures (Index Outstanding)/sec: FCB Async Purge Failures (Index Outstanding)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the index of the record being outstanding.  [Dev Only]
  let ``FCB Async Purge Failures (Index Outstanding)/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Purge Failures (Index Outstanding)/sec"; instance = instance }
  /// FCB Async Purge Failures (LV Outstanding)/sec: FCB Async Purge Failures (LV Outstanding)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the LV of the record being outstanding.  [Dev Only]
  let ``FCB Async Purge Failures (LV Outstanding)/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Purge Failures (LV Outstanding)/sec"; instance = instance }
  /// FCB Async Purge Failures (Other)/sec: FCB Async Purge Failures (Other)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to other reasons.  [Dev Only]
  let ``FCB Async Purge Failures (Other)/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Purge Failures (Other)/sec"; instance = instance }
  /// FCB Async Purge Failures (Outstanding Versions)/sec: FCB Async Purge Failures (Outstanding Versions)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record having outstanding versions.  [Dev Only]
  let ``FCB Async Purge Failures (Outstanding Versions)/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Purge Failures (Outstanding Versions)/sec"; instance = instance }
  /// FCB Async Purge Failures (Sentinel)/sec: FCB Async Purge Failures (Sentinel)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record being a sentinel record.  [Dev Only]
  let ``FCB Async Purge Failures (Sentinel)/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Purge Failures (Sentinel)/sec"; instance = instance }
  /// FCB Async Purge/sec: FCB Async Purge/sec is the number of cached schema records (FCBs) purged during asynchronous schema record cleanup. These records are purged to age out older schema definitions. [Dev Only]
  let ``FCB Async Purge/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Purge/sec"; instance = instance }
  /// FCB Async Scan/sec: FCB Async Scan/sec is the number of cached schema records (FCBs) scanned during asynchronous schema record cleanup. These records are scanned to age out older schema definitions. [Dev Only]
  let ``FCB Async Scan/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Scan/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Active Tasks)/sec: FCB Async Threshold Purge Failures (Active Tasks)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record having active tasks.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Active Tasks)/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Threshold Purge Failures (Active Tasks)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Callbacks)/sec: FCB Async Threshold Purge Failures (Callbacks)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record having callbacks.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Callbacks)/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Threshold Purge Failures (Callbacks)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Conflicts)/sec: FCB Async Threshold Purge Failures (Conflicts)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup.  The purge operation failed because exclusive ownership of the schema record could not be obtained.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Conflicts)/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Threshold Purge Failures (Conflicts)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Delete Pending)/sec: FCB Async Threshold Purge Failures (Delete Pending)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record being pending delete.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Delete Pending)/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Threshold Purge Failures (Delete Pending)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (In Use)/sec: FCB Async Threshold Purge Failures (In Use)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record being in use.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (In Use)/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Threshold Purge Failures (In Use)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Index Outstanding)/sec: FCB Async Threshold Purge Failures (Index Outstanding)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the index of the record being outstanding.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Index Outstanding)/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Threshold Purge Failures (Index Outstanding)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (LV Outstanding)/sec: FCB Async Threshold Purge Failures (LV Outstanding)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the LV of the record being outstanding.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (LV Outstanding)/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Threshold Purge Failures (LV Outstanding)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Other)/sec: FCB Async Threshold Purge Failures (Other)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to other reasons.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Other)/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Threshold Purge Failures (Other)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Outstanding Versions)/sec: FCB Async Threshold Purge Failures (Outstanding Versions)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record having outstanding versions.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Outstanding Versions)/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Threshold Purge Failures (Outstanding Versions)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Sentinel)/sec: FCB Async Threshold Purge Failures (Sentinel)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record being a sentinel record.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Sentinel)/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Threshold Purge Failures (Sentinel)/sec"; instance = instance }
  /// FCB Async Threshold-Purge/sec: FCB Async Threshold-Purge/sec is the number of cached schema records (FCBs) purged during asynchronous schema record cleanup.  Cleanup was triggered by a large number of schema records above the preferred limit.  These records are aggressively purged to age out older schema definitions.  [Dev Only]
  let ``FCB Async Threshold-Purge/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Threshold-Purge/sec"; instance = instance }
  /// FCB Async Threshold-Scan/sec: FCB Async Threshold-Scan/sec is the number of cached schema records (FCBs) scanned during asynchronous schema record cleanup.  Cleanup was triggered by a large number of schema records above the preferred limit.  These records are aggressively scanned to age out older schema definitions.  [Dev Only]
  let ``FCB Async Threshold-Scan/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Async Threshold-Scan/sec"; instance = instance }
  /// FCB Attached RCEs: FCB Attached RCEs is the number of revision control entries (RCEs)  attached to cached schema records (FCBs) [Dev Only]
  let ``FCB Attached RCEs`` instance =
    { category = "Database ==> Instances"; counter = "FCB Attached RCEs"; instance = instance }
  /// FCB Cache % Hit: FCB Cache % Hit is the percentage of schema records (FCBs) opened directly from the schema record cache.  No file operations were required.  [Dev Only]
  let ``FCB Cache % Hit`` instance =
    { category = "Database ==> Instances"; counter = "FCB Cache % Hit"; instance = instance }
  /// FCB Cache Allocated: FCB Cache Allocated is the number of cached schema records (FCBs) currently allocated.  [Dev Only]
  let ``FCB Cache Allocated`` instance =
    { category = "Database ==> Instances"; counter = "FCB Cache Allocated"; instance = instance }
  /// FCB Cache Allocated/sec: FCB Cache Allocated/sec is the number of cached schema records (FCBs) currently allocated per second.  [Dev Only]
  let ``FCB Cache Allocated/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Cache Allocated/sec"; instance = instance }
  /// FCB Cache Allocation Average Latency (ms): FCB Cache Allocation Average Latency (ms) is the average latency in allocating cached schema records (FCBs).  [Dev Only]
  let ``FCB Cache Allocation Average Latency (ms)`` instance =
    { category = "Database ==> Instances"; counter = "FCB Cache Allocation Average Latency (ms)"; instance = instance }
  /// FCB Cache Allocations Failed: FCB Cache Allocations Failed is the number of schema records (FCBs) attempts that fail to allocate. [Dev Only]
  let ``FCB Cache Allocations Failed`` instance =
    { category = "Database ==> Instances"; counter = "FCB Cache Allocations Failed"; instance = instance }
  /// FCB Cache Available: FCB Cache Available is the number of cached schema records (FCBs) currently allocated but not in use.  These records will be used and/or purged as required.  [Dev Only]
  let ``FCB Cache Available`` instance =
    { category = "Database ==> Instances"; counter = "FCB Cache Available"; instance = instance }
  /// FCB Cache Maximum: FCB Cache Maximum is the absolute maximum number of the schema records (FCBs) that can exist in the cache.  [Dev Only]
  let ``FCB Cache Maximum`` instance =
    { category = "Database ==> Instances"; counter = "FCB Cache Maximum"; instance = instance }
  /// FCB Cache Preferred: FCB Cache Preferred is the preferred maximum number of the schema records (FCBs) that should exist in the cache.  [Dev Only]
  let ``FCB Cache Preferred`` instance =
    { category = "Database ==> Instances"; counter = "FCB Cache Preferred"; instance = instance }
  /// FCB Cache Stalls/sec: FCB Cache Stalls/sec is the number of stalls encountered while waiting for exclusive ownership of cached schema records (FCBs) in order to update their reference count.  [Dev Only]
  let ``FCB Cache Stalls/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Cache Stalls/sec"; instance = instance }
  /// FCB Purge On Cursor Close/sec: FCB Purge On Cursor Close/sec is the number of cached schema records (FCBs) being synchronously purged when the cursor is closed (instead of leaving the schema record cached) each second.  [Dev Only]
  let ``FCB Purge On Cursor Close/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Purge On Cursor Close/sec"; instance = instance }
  /// FCB Sync Purge Stalls/sec: FCB Sync Purge Stalls/sec is the number of stalls encountered while waiting for exclusive ownership of cached schema records (FCBs) in order to synchronously purge them.  [Dev Only]
  let ``FCB Sync Purge Stalls/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Sync Purge Stalls/sec"; instance = instance }
  /// FCB Sync Purge/sec: FCB Sync Purge/sec is the number of cached schema records (FCBs) being synchronously purged each second.  [Dev Only]
  let ``FCB Sync Purge/sec`` instance =
    { category = "Database ==> Instances"; counter = "FCB Sync Purge/sec"; instance = instance }
  /// False Index Column Updates/sec: False Index Column Updates/sec is the number of times per second an attempt was made to update an index because an update to at least one of the indexed columns was detected, only to discover that none of the indexed columns had actually changed (and therefore no index update was actually required).  [Dev Only]
  let ``False Index Column Updates/sec`` instance =
    { category = "Database ==> Instances"; counter = "False Index Column Updates/sec"; instance = instance }
  /// False Tuple Index Column Updates/sec: False Tuple Index Column Updates/sec is the number of times per second an attempt was made to update a tuple index because an update to the tuple-indexed column was detected, only to discover that the column had not actually changed (and therefore no index update was actually required).  [Dev Only]
  let ``False Tuple Index Column Updates/sec`` instance =
    { category = "Database ==> Instances"; counter = "False Tuple Index Column Updates/sec"; instance = instance }
  /// I/O Database Reads (Attached) Abnormal Latency/sec: I/O Database Reads (Attached) Abnormal Latency/sec is the rate of database read operations that take an abnormally long length of time (default is 1 minute) to be serviced by the OS.  [Dev Only]
  let ``I/O Database Reads (Attached) Abnormal Latency/sec`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Reads (Attached) Abnormal Latency/sec"; instance = instance }
  /// I/O Database Reads (Attached) Async Pending: I/O Database Reads (Attached) Async Pending is the number of database read operations asynchronously pending completion.  [Dev Only]
  let ``I/O Database Reads (Attached) Async Pending`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Reads (Attached) Async Pending"; instance = instance }
  /// I/O Database Reads (Attached) Average Bytes: I/O Database Reads (Attached) Average Bytes is the average number of bytes transferred per database read operation.  [Dev Only]
  let ``I/O Database Reads (Attached) Average Bytes`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Reads (Attached) Average Bytes"; instance = instance }
  /// I/O Database Reads (Attached) Average Latency: I/O Database Reads (Attached) Average Latency is the average length of time,  in milliseconds, per database read operation.
  let ``I/O Database Reads (Attached) Average Latency`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Reads (Attached) Average Latency"; instance = instance }
  /// I/O Database Reads (Attached) In Heap: I/O Database Reads (Attached) In Heap is the number of database read operations queued in the database engine's I/O heap and waiting to be issued.  [Dev Only]
  let ``I/O Database Reads (Attached) In Heap`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Reads (Attached) In Heap"; instance = instance }
  /// I/O Database Reads (Attached)/sec: I/O Database Reads (Attached)/sec is the rate of database read operations completed.
  let ``I/O Database Reads (Attached)/sec`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Reads (Attached)/sec"; instance = instance }
  /// I/O Database Reads (Recovery) Abnormal Latency/sec: I/O Database Reads (Recovery) Abnormal Latency/sec is the rate of database read operations that take an abnormally long length of time (default is 1 minute) to be serviced by the OS.  [Dev Only]
  let ``I/O Database Reads (Recovery) Abnormal Latency/sec`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Reads (Recovery) Abnormal Latency/sec"; instance = instance }
  /// I/O Database Reads (Recovery) Async Pending: I/O Database Reads (Recovery) Async Pending is the number of database read operations asynchronously pending completion.  [Dev Only]
  let ``I/O Database Reads (Recovery) Async Pending`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Reads (Recovery) Async Pending"; instance = instance }
  /// I/O Database Reads (Recovery) Average Bytes: I/O Database Reads (Recovery) Average Bytes is the average number of bytes transferred per database read operation.  [Dev Only]
  let ``I/O Database Reads (Recovery) Average Bytes`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Reads (Recovery) Average Bytes"; instance = instance }
  /// I/O Database Reads (Recovery) Average Latency: I/O Database Reads (Recovery) Average Latency is the average length of time,  in milliseconds, per database read operation.
  let ``I/O Database Reads (Recovery) Average Latency`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Reads (Recovery) Average Latency"; instance = instance }
  /// I/O Database Reads (Recovery) In Heap: I/O Database Reads (Recovery) In Heap is the number of database read operations queued in the database engine's I/O heap and waiting to be issued.  [Dev Only]
  let ``I/O Database Reads (Recovery) In Heap`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Reads (Recovery) In Heap"; instance = instance }
  /// I/O Database Reads (Recovery)/sec: I/O Database Reads (Recovery)/sec is the rate of database read operations completed.
  let ``I/O Database Reads (Recovery)/sec`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Reads (Recovery)/sec"; instance = instance }
  /// I/O Database Reads Abnormal Latency/sec: I/O Database Reads Abnormal Latency/sec is the rate of database read operations that take an abnormally long length of time (default is 1 minute) to be serviced by the OS.  [Dev Only]
  let ``I/O Database Reads Abnormal Latency/sec`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Reads Abnormal Latency/sec"; instance = instance }
  /// I/O Database Reads Async Pending: I/O Database Reads Async Pending is the number of database read operations asynchronously pending completion.  [Dev Only]
  let ``I/O Database Reads Async Pending`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Reads Async Pending"; instance = instance }
  /// I/O Database Reads Average Bytes: I/O Database Reads Average Bytes is the average number of bytes transferred per database read operation.  [Dev Only]
  let ``I/O Database Reads Average Bytes`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Reads Average Bytes"; instance = instance }
  /// I/O Database Reads Average Latency: I/O Database Reads Average Latency is the average length of time,  in milliseconds, per database read operation.
  let ``I/O Database Reads Average Latency`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Reads Average Latency"; instance = instance }
  /// I/O Database Reads In Heap: I/O Database Reads In Heap is the number of database read operations queued in the database engine's I/O heap and waiting to be issued.  [Dev Only]
  let ``I/O Database Reads In Heap`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Reads In Heap"; instance = instance }
  /// I/O Database Reads/sec: I/O Database Reads/sec is the rate of database read operations completed.
  let ``I/O Database Reads/sec`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Reads/sec"; instance = instance }
  /// I/O Database Writes (Attached) Abnormal Latency/sec: I/O Database Writes (Attached) Abnormal Latency/sec is the rate of database write operations that take an abnormally long length of time (default is 1 minute) to be serviced by the OS.  [Dev Only]
  let ``I/O Database Writes (Attached) Abnormal Latency/sec`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Writes (Attached) Abnormal Latency/sec"; instance = instance }
  /// I/O Database Writes (Attached) Async Pending: I/O Database Writes (Attached) Async Pending is the number of database write operations asynchronously pending completion.  [Dev Only]
  let ``I/O Database Writes (Attached) Async Pending`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Writes (Attached) Async Pending"; instance = instance }
  /// I/O Database Writes (Attached) Average Bytes: I/O Database Writes (Attached) Average Bytes is the average number of bytes transferred per database write operation.  [Dev Only]
  let ``I/O Database Writes (Attached) Average Bytes`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Writes (Attached) Average Bytes"; instance = instance }
  /// I/O Database Writes (Attached) Average Latency: I/O Database Writes (Attached) Average Latency is the average length of time,  in milliseconds, per database write operation.
  let ``I/O Database Writes (Attached) Average Latency`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Writes (Attached) Average Latency"; instance = instance }
  /// I/O Database Writes (Attached) In Heap: I/O Database Writes (Attached) In Heap is the number of database write operations queued in the database engine's I/O heap and waiting to be issued.  [Dev Only]
  let ``I/O Database Writes (Attached) In Heap`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Writes (Attached) In Heap"; instance = instance }
  /// I/O Database Writes (Attached)/sec: I/O Database Writes (Attached)/sec is the rate of database write operations completed.
  let ``I/O Database Writes (Attached)/sec`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Writes (Attached)/sec"; instance = instance }
  /// I/O Database Writes (Recovery) Abnormal Latency/sec: I/O Database Writes (Recovery) Abnormal Latency/sec is the rate of database write operations that take an abnormally long length of time (default is 1 minute) to be serviced by the OS.  [Dev Only]
  let ``I/O Database Writes (Recovery) Abnormal Latency/sec`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Writes (Recovery) Abnormal Latency/sec"; instance = instance }
  /// I/O Database Writes (Recovery) Async Pending: I/O Database Writes (Recovery) Async Pending is the number of database write operations asynchronously pending completion.  [Dev Only]
  let ``I/O Database Writes (Recovery) Async Pending`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Writes (Recovery) Async Pending"; instance = instance }
  /// I/O Database Writes (Recovery) Average Bytes: I/O Database Writes (Recovery) Average Bytes is the average number of bytes transferred per database write operation.  [Dev Only]
  let ``I/O Database Writes (Recovery) Average Bytes`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Writes (Recovery) Average Bytes"; instance = instance }
  /// I/O Database Writes (Recovery) Average Latency: I/O Database Writes (Recovery) Average Latency is the average length of time,  in milliseconds, per database write operation.
  let ``I/O Database Writes (Recovery) Average Latency`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Writes (Recovery) Average Latency"; instance = instance }
  /// I/O Database Writes (Recovery) In Heap: I/O Database Writes (Recovery) In Heap is the number of database write operations queued in the database engine's I/O heap and waiting to be issued.  [Dev Only]
  let ``I/O Database Writes (Recovery) In Heap`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Writes (Recovery) In Heap"; instance = instance }
  /// I/O Database Writes (Recovery)/sec: I/O Database Writes (Recovery)/sec is the rate of database write operations completed.
  let ``I/O Database Writes (Recovery)/sec`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Writes (Recovery)/sec"; instance = instance }
  /// I/O Database Writes Abnormal Latency/sec: I/O Database Writes Abnormal Latency/sec is the rate of database write operations that take an abnormally long length of time (default is 1 minute) to be serviced by the OS.  [Dev Only]
  let ``I/O Database Writes Abnormal Latency/sec`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Writes Abnormal Latency/sec"; instance = instance }
  /// I/O Database Writes Async Pending: I/O Database Writes Async Pending is the number of database write operations asynchronously pending completion.  [Dev Only]
  let ``I/O Database Writes Async Pending`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Writes Async Pending"; instance = instance }
  /// I/O Database Writes Average Bytes: I/O Database Writes Average Bytes is the average number of bytes transferred per database write operation.  [Dev Only]
  let ``I/O Database Writes Average Bytes`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Writes Average Bytes"; instance = instance }
  /// I/O Database Writes Average Latency: I/O Database Writes Average Latency is the average length of time,  in milliseconds, per database write operation.
  let ``I/O Database Writes Average Latency`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Writes Average Latency"; instance = instance }
  /// I/O Database Writes In Heap: I/O Database Writes In Heap is the number of database write operations queued in the database engine's I/O heap and waiting to be issued.  [Dev Only]
  let ``I/O Database Writes In Heap`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Writes In Heap"; instance = instance }
  /// I/O Database Writes/sec: I/O Database Writes/sec is the rate of database write operations completed.
  let ``I/O Database Writes/sec`` instance =
    { category = "Database ==> Instances"; counter = "I/O Database Writes/sec"; instance = instance }
  /// I/O Log Reads Abnormal Latency/sec: I/O Log Reads Abnormal Latency/sec is the rate of logfile read operations that take an abnormally long length of time (default is 1 minute) to be serviced by the OS.  [Dev Only]
  let ``I/O Log Reads Abnormal Latency/sec`` instance =
    { category = "Database ==> Instances"; counter = "I/O Log Reads Abnormal Latency/sec"; instance = instance }
  /// I/O Log Reads Async Pending: I/O Log Reads Async Pending is the number of logfile read operations asynchronously pending completion.  [Dev Only]
  let ``I/O Log Reads Async Pending`` instance =
    { category = "Database ==> Instances"; counter = "I/O Log Reads Async Pending"; instance = instance }
  /// I/O Log Reads Average Bytes: I/O Log Reads Average Bytes is the average number of bytes transferred per logfile read operation.  [Dev Only]
  let ``I/O Log Reads Average Bytes`` instance =
    { category = "Database ==> Instances"; counter = "I/O Log Reads Average Bytes"; instance = instance }
  /// I/O Log Reads Average Latency: I/O Log Reads Average Latency is the average length of time, in milliseconds, per logfile read operation.
  let ``I/O Log Reads Average Latency`` instance =
    { category = "Database ==> Instances"; counter = "I/O Log Reads Average Latency"; instance = instance }
  /// I/O Log Reads In Heap: I/O Log Reads In Heap is the number of logfile read operations queued in the database engine's I/O heap and waiting to be issued.  [Dev Only]
  let ``I/O Log Reads In Heap`` instance =
    { category = "Database ==> Instances"; counter = "I/O Log Reads In Heap"; instance = instance }
  /// I/O Log Reads/sec: I/O Log Reads/sec is the rate of logfile read operations completed.
  let ``I/O Log Reads/sec`` instance =
    { category = "Database ==> Instances"; counter = "I/O Log Reads/sec"; instance = instance }
  /// I/O Log Writes Abnormal Latency/sec: I/O Log Writes Abnormal Latency/sec is the rate of logfile write operations that take an abnormally long length of time (default is 1 minute) to be serviced by the OS.  [Dev Only]
  let ``I/O Log Writes Abnormal Latency/sec`` instance =
    { category = "Database ==> Instances"; counter = "I/O Log Writes Abnormal Latency/sec"; instance = instance }
  /// I/O Log Writes Async Pending: I/O Log Writes Async Pending is the number of logfile write operations asynchronously pending completion.  [Dev Only]
  let ``I/O Log Writes Async Pending`` instance =
    { category = "Database ==> Instances"; counter = "I/O Log Writes Async Pending"; instance = instance }
  /// I/O Log Writes Average Bytes: I/O Log Writes Average Bytes is the average number of bytes transferred per logfile write operation.  [Dev Only]
  let ``I/O Log Writes Average Bytes`` instance =
    { category = "Database ==> Instances"; counter = "I/O Log Writes Average Bytes"; instance = instance }
  /// I/O Log Writes Average Latency: I/O Log Writes Average Latency is the average length of time, in milliseconds, per log file write operation.
  let ``I/O Log Writes Average Latency`` instance =
    { category = "Database ==> Instances"; counter = "I/O Log Writes Average Latency"; instance = instance }
  /// I/O Log Writes In Heap: I/O Log Writes In Heap is the number of logfile write operations queued in the database engine's I/O heap and waiting to be issued.  [Dev Only]
  let ``I/O Log Writes In Heap`` instance =
    { category = "Database ==> Instances"; counter = "I/O Log Writes In Heap"; instance = instance }
  /// I/O Log Writes/sec: I/O Log Writes/sec is the rate of log file write operations completed.
  let ``I/O Log Writes/sec`` instance =
    { category = "Database ==> Instances"; counter = "I/O Log Writes/sec"; instance = instance }
  /// Instance Status: Instance Status indicates the current runtime state of the instance. Values are 1 (recovery redo), 2 (recovery undo), 3 (runtime),  4 (shutdown), 5 (error).  [Dev Only]
  let ``Instance Status`` instance =
    { category = "Database ==> Instances"; counter = "Instance Status"; instance = instance }
  /// Log Buffer Bytes Committed: Log Buffer Bytes Committed is total number of committedbytes of log buffer.
  let ``Log Buffer Bytes Committed`` instance =
    { category = "Database ==> Instances"; counter = "Log Buffer Bytes Committed"; instance = instance }
  /// Log Buffer Bytes Free: Log Buffer Bytes Free is the amount of free space available in the log buffers.  [Dev Only]
  let ``Log Buffer Bytes Free`` instance =
    { category = "Database ==> Instances"; counter = "Log Buffer Bytes Free"; instance = instance }
  /// Log Buffer Bytes Used: Log Buffer Bytes Used is the amount of bytes in the log buffers that have not yet been flushed to the logs.  [Dev Only]
  let ``Log Buffer Bytes Used`` instance =
    { category = "Database ==> Instances"; counter = "Log Buffer Bytes Used"; instance = instance }
  /// Log Buffer Capacity Flushes/sec: Log Buffer Capacity Flushes/sec is the count of times the database log buffers must be flushed per second because they are full.  [Dev Only]
  let ``Log Buffer Capacity Flushes/sec`` instance =
    { category = "Database ==> Instances"; counter = "Log Buffer Capacity Flushes/sec"; instance = instance }
  /// Log Buffer Commit Flushes/sec: Log Buffer Commit Flushes/sec is the count of times the database log buffers must be flushed per second because a transaction is fully committing its changes.  [Dev Only]
  let ``Log Buffer Commit Flushes/sec`` instance =
    { category = "Database ==> Instances"; counter = "Log Buffer Commit Flushes/sec"; instance = instance }
  /// Log Buffer Flushes Blocked/sec: Log Buffer Flushes Blocked/sec is the count of times the database log buffers were intended to be flushed, but we skipped it due to the  log buffer being locked for and being flushed by another thread.  [Dev Only]
  let ``Log Buffer Flushes Blocked/sec`` instance =
    { category = "Database ==> Instances"; counter = "Log Buffer Flushes Blocked/sec"; instance = instance }
  /// Log Buffer Flushes Skipped/sec: Log Buffer Flushes Skipped/sec is the count of times the database log buffers were intended to be flushed, but we skipped it due to the  desired log data already having been flushed.  [Dev Only]
  let ``Log Buffer Flushes Skipped/sec`` instance =
    { category = "Database ==> Instances"; counter = "Log Buffer Flushes Skipped/sec"; instance = instance }
  /// Log Buffer Flushes/sec: Log Buffer Flushes/sec is the count of times the database log buffers must be flushed per second.  [Dev Only]
  let ``Log Buffer Flushes/sec`` instance =
    { category = "Database ==> Instances"; counter = "Log Buffer Flushes/sec"; instance = instance }
  /// Log Buffer Size: Log Buffer Size is the amount of memory, in bytes, allocated for the database log buffers.  [Dev Only]
  let ``Log Buffer Size`` instance =
    { category = "Database ==> Instances"; counter = "Log Buffer Size"; instance = instance }
  /// Log Bytes Generated/sec: Log Bytes Generated per second is the rate at which data is added to the log.  This is different from Log Bytes Write per second in that each byte is generated only once whereas each byte may be written many times.
  let ``Log Bytes Generated/sec`` instance =
    { category = "Database ==> Instances"; counter = "Log Bytes Generated/sec"; instance = instance }
  /// Log Bytes Wasted/sec: Log Bytes Wasted/sec is the number of bytes wasted by not reusing a partially flushed sector (and instead fill it up with NOPs). [Dev Only]
  let ``Log Bytes Wasted/sec`` instance =
    { category = "Database ==> Instances"; counter = "Log Bytes Wasted/sec"; instance = instance }
  /// Log Bytes Write/sec: Log Bytes Write per second is the rate bytes are written to the log.
  let ``Log Bytes Write/sec`` instance =
    { category = "Database ==> Instances"; counter = "Log Bytes Write/sec"; instance = instance }
  /// Log Checkpoint Depth: Log Checkpoint Depth represents the amount of work, in bytes, that will need to be redone or undone to the database file(s) if the process crashes.  [Dev Only]
  let ``Log Checkpoint Depth`` instance =
    { category = "Database ==> Instances"; counter = "Log Checkpoint Depth"; instance = instance }
  /// Log Checkpoint Depth as a % of Target: Log Checkpoint Depth as a % of Target is an expression of the current checkpoint depth in terms of a percentage of the checkpoint depth target.  For example, if the current checkpoint depth is 5 generations and the checkpoint depth target is 4 generations then this will be reported as 125% of target.
  let ``Log Checkpoint Depth as a % of Target`` instance =
    { category = "Database ==> Instances"; counter = "Log Checkpoint Depth as a % of Target"; instance = instance }
  /// Log Checkpoint Maintenance Outstanding IO Max: Log Checkpoint Maintenance Outstanding IO Max represents how aggressive, in terms of outstanding IOs, the database engine will be to maintain the preferred checkpoint. This is a function of how far the checkpoint has fallen behind. [Dev Only]
  let ``Log Checkpoint Maintenance Outstanding IO Max`` instance =
    { category = "Database ==> Instances"; counter = "Log Checkpoint Maintenance Outstanding IO Max"; instance = instance }
  /// Log File Current Generation: Log File Current Generation gives the generation number of the current log file of an instance.
  let ``Log File Current Generation`` instance =
    { category = "Database ==> Instances"; counter = "Log File Current Generation"; instance = instance }
  /// Log File Size: Log File Size is the size, in bytes, of the database log files.  [Dev Only]
  let ``Log File Size`` instance =
    { category = "Database ==> Instances"; counter = "Log File Size"; instance = instance }
  /// Log Files Generated: Log Files Generated represents the total number of log files generated by an instance since that instance was last initialized.
  let ``Log Files Generated`` instance =
    { category = "Database ==> Instances"; counter = "Log Files Generated"; instance = instance }
  /// Log Files Generated Prematurely: Log Files Generated Prematurely represents the total number of log files generated by an instance since that instance was last initialized and that have not been entirely filled with useful data.  Under certain conditions the database engine will choose to switch to a new log file before it has been completely filled with useful data.
  let ``Log Files Generated Prematurely`` instance =
    { category = "Database ==> Instances"; counter = "Log Files Generated Prematurely"; instance = instance }
  /// Log Full Segment Writes/sec: Log Full Segment Writes/sec is the number of times full log segments are written to the log file(s) per second.  [Dev Only]
  let ``Log Full Segment Writes/sec`` instance =
    { category = "Database ==> Instances"; counter = "Log Full Segment Writes/sec"; instance = instance }
  /// Log Generation Checkpoint Depth: Log Generation Checkpoint Depth represents the amount of work, in count of log files, that will need to be redone or undone to the database file(s) if the process crashes.
  let ``Log Generation Checkpoint Depth`` instance =
    { category = "Database ==> Instances"; counter = "Log Generation Checkpoint Depth"; instance = instance }
  /// Log Generation Checkpoint Depth Max: Log Generation Checkpoint Depth Max represents the maximum allowable amount of work, in number of log files, that may be redone or undone to the database file(s) if the process crashes.
  let ``Log Generation Checkpoint Depth Max`` instance =
    { category = "Database ==> Instances"; counter = "Log Generation Checkpoint Depth Max"; instance = instance }
  /// Log Generation Checkpoint Depth Target: Log Generation Checkpoint Depth Target represents the ideal target for the amount of work, in number of log files, that may be redone or undone to the database file(s) if the process crashes.
  let ``Log Generation Checkpoint Depth Target`` instance =
    { category = "Database ==> Instances"; counter = "Log Generation Checkpoint Depth Target"; instance = instance }
  /// Log Generation Loss Resiliency Depth: Log Generation Loss Resiliency Depth represents the amount of work, in number of log files, that may be lost while still allowing the database file(s) to recover (with data loss) if the process crashes.
  let ``Log Generation Loss Resiliency Depth`` instance =
    { category = "Database ==> Instances"; counter = "Log Generation Loss Resiliency Depth"; instance = instance }
  /// Log Partial Segment Writes/sec: Log Partial Segment Writes/sec is the number of times that a log segment that is only partially full of data is written to the log file(s) per second.  [Dev Only]
  let ``Log Partial Segment Writes/sec`` instance =
    { category = "Database ==> Instances"; counter = "Log Partial Segment Writes/sec"; instance = instance }
  /// Log Record Stalls/sec: Log Record Stalls/sec is the number of log records that cannot be added to the log buffers per second because they are full.  If this counter is non-zero most of the time, the log buffer size may be a bottleneck.
  let ``Log Record Stalls/sec`` instance =
    { category = "Database ==> Instances"; counter = "Log Record Stalls/sec"; instance = instance }
  /// Log Records/sec: Log Records/sec is the count of records written to the database log buffers per second.  [Dev Only]
  let ``Log Records/sec`` instance =
    { category = "Database ==> Instances"; counter = "Log Records/sec"; instance = instance }
  /// Log Threads Waiting: Log Threads Waiting is the number of threads waiting for their data to be written to the log in order to complete an update of the database.  If this number is too high, the log may be a bottleneck.
  let ``Log Threads Waiting`` instance =
    { category = "Database ==> Instances"; counter = "Log Threads Waiting"; instance = instance }
  /// Log Writes/sec: Log Writes/sec is the number of times the log buffers are written to the log file(s) per second.  If this number approaches the maximum write rate for the media holding the log file(s), the log may be a bottleneck.
  let ``Log Writes/sec`` instance =
    { category = "Database ==> Instances"; counter = "Log Writes/sec"; instance = instance }
  /// Long-Value Maximum LID: Long-Value Maximum LID is the largest LID that has been used by the database engine for this instance.  [Dev Only]
  let ``Long-Value Maximum LID`` instance =
    { category = "Database ==> Instances"; counter = "Long-Value Maximum LID"; instance = instance }
  /// No name: No text
  let ``No name`` instance =
    { category = "Database ==> Instances"; counter = "No name"; instance = instance }
  /// Online Defrag Average Log Bytes: Online Defrag Average Log Bytes is the average size of the log records being generated by online defragmentation.  [Dev Only]
  let ``Online Defrag Average Log Bytes`` instance =
    { category = "Database ==> Instances"; counter = "Online Defrag Average Log Bytes"; instance = instance }
  /// Online Defrag Data Moves/sec: Data Moves/sec is the number of times per second that data is moved from one page to another by the online defragmentation process [Dev Only]
  let ``Online Defrag Data Moves/sec`` instance =
    { category = "Database ==> Instances"; counter = "Online Defrag Data Moves/sec"; instance = instance }
  /// Online Defrag Log Records/sec: Online Defrag Log Records/sec is the rate at which online defragmentation is generating log records.  [Dev Only]
  let ``Online Defrag Log Records/sec`` instance =
    { category = "Database ==> Instances"; counter = "Online Defrag Log Records/sec"; instance = instance }
  /// Online Defrag Page Moves/sec: Page Moves/sec is the number of times per second that data is moved from one page to a new page by the online defragmentation process [Dev Only]
  let ``Online Defrag Page Moves/sec`` instance =
    { category = "Database ==> Instances"; counter = "Online Defrag Page Moves/sec"; instance = instance }
  /// Online Defrag Pages Dirtied/sec: Online Defrag Pages Dirtied/sec is the rate at which online defragmentation is modifying clean database pages. [Dev Only]
  let ``Online Defrag Pages Dirtied/sec`` instance =
    { category = "Database ==> Instances"; counter = "Online Defrag Pages Dirtied/sec"; instance = instance }
  /// Online Defrag Pages Freed/sec: Pages Freed/sec is the number of pages per second that are freed from the database by the online defragmentation process [Dev Only]
  let ``Online Defrag Pages Freed/sec`` instance =
    { category = "Database ==> Instances"; counter = "Online Defrag Pages Freed/sec"; instance = instance }
  /// Online Defrag Pages Preread/sec: Online Defrag Pages Preread/sec is the rate at which database pages are read in anticipation of future use by online defragmentation.  [Dev Only]
  let ``Online Defrag Pages Preread/sec`` instance =
    { category = "Database ==> Instances"; counter = "Online Defrag Pages Preread/sec"; instance = instance }
  /// Online Defrag Pages Re-Dirtied/sec: Online Defrag Pages Re-Dirtied/sec is the rate at which online defragmentation is modifying database pages that already contained modifications.  [Dev Only]
  let ``Online Defrag Pages Re-Dirtied/sec`` instance =
    { category = "Database ==> Instances"; counter = "Online Defrag Pages Re-Dirtied/sec"; instance = instance }
  /// Online Defrag Pages Read/sec: Online Defrag Pages Read/sec is the rate of database read operations being performed by online defragmentation. [Dev Only]
  let ``Online Defrag Pages Read/sec`` instance =
    { category = "Database ==> Instances"; counter = "Online Defrag Pages Read/sec"; instance = instance }
  /// Online Defrag Pages Referenced/sec: Online Defrag Pages Referenced/sec is the rate at which online defragmentation is touching database pages.  [Dev Only]
  let ``Online Defrag Pages Referenced/sec`` instance =
    { category = "Database ==> Instances"; counter = "Online Defrag Pages Referenced/sec"; instance = instance }
  /// Pages Converted: Pages Converted is the number of database pages that have been converted from an older format. [Dev Only]
  let ``Pages Converted`` instance =
    { category = "Database ==> Instances"; counter = "Pages Converted"; instance = instance }
  /// Pages Converted/sec: Pages Converted/sec is the number of times per second a database page is converted from an older database format. [Dev Only]
  let ``Pages Converted/sec`` instance =
    { category = "Database ==> Instances"; counter = "Pages Converted/sec"; instance = instance }
  /// Pages Not Trimmed Unaligned (Total): Pages Not Trimmed Unaligned (Total) is the number of database pages that are not trimmed because the trim request was not on an aligned boundary that the operating system supports. For example, if the supported trim granulariy is 64k, and the requested trim range is from (64k-1 page) to (128k+1 page), then this counter is increased by two. [Dev Only]
  let ``Pages Not Trimmed Unaligned (Total)`` instance =
    { category = "Database ==> Instances"; counter = "Pages Not Trimmed Unaligned (Total)"; instance = instance }
  /// Pages Not Trimmed Unaligned/sec: Pages Not Trimmed Unaligned/sec is the number of database pages that are not trimmed because the trim request was not on an aligned boundary that the operating system supports. For example, if the supported trim granulariy is 64k, and the requested trim range is from (64k-1 page) to (128k+1 page), then this counter is increased by two. [Dev Only]
  let ``Pages Not Trimmed Unaligned/sec`` instance =
    { category = "Database ==> Instances"; counter = "Pages Not Trimmed Unaligned/sec"; instance = instance }
  /// Pages Reorganized (Dehydrate Buffer)/sec: Pages Reorganized (Dehydrate Buffer)/sec is the number of times per second a page is reorganized to minimize our in-memory buffer usage.  [Dev Only]
  let ``Pages Reorganized (Dehydrate Buffer)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Pages Reorganized (Dehydrate Buffer)/sec"; instance = instance }
  /// Pages Reorganized (Free Space Request)/sec: Pages Reorganized (Free Space Request)/sec is the number of times per second a page was reorganized due to a free space request that could not be satisfied by the existing contiguous space on the page.  [Dev Only]
  let ``Pages Reorganized (Free Space Request)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Pages Reorganized (Free Space Request)/sec"; instance = instance }
  /// Pages Reorganized (Other)/sec: Pages Reorganized (Other)/sec is the number of times per second a page was reorganized for some other / unknown reason.  [Dev Only]
  let ``Pages Reorganized (Other)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Pages Reorganized (Other)/sec"; instance = instance }
  /// Pages Reorganized (Page Move Logging)/sec: Pages Reorganized (Page Move Logging)/sec is the number of times per second a page was reorganized for minimizing a page size for logging page move.  [Dev Only]
  let ``Pages Reorganized (Page Move Logging)/sec`` instance =
    { category = "Database ==> Instances"; counter = "Pages Reorganized (Page Move Logging)/sec"; instance = instance }
  /// Pages Trimmed (Total): Pages Trimmed (Total) is the number of database pages that are trimmed and the allocated space is released to the file system.  [Dev Only]
  let ``Pages Trimmed (Total)`` instance =
    { category = "Database ==> Instances"; counter = "Pages Trimmed (Total)"; instance = instance }
  /// Pages Trimmed Dirty (Total): Pages Trimmed Dirty (Total) is the number of database pages that are trimmed from the database file, but they have been modified in memory. [Dev Only]
  let ``Pages Trimmed Dirty (Total)`` instance =
    { category = "Database ==> Instances"; counter = "Pages Trimmed Dirty (Total)"; instance = instance }
  /// Pages Trimmed Dirty/sec: Pages Trimmed Dirty/sec is the number of database pages that are trimmed from the database file, but they have been modified in memory. [Dev Only]
  let ``Pages Trimmed Dirty/sec`` instance =
    { category = "Database ==> Instances"; counter = "Pages Trimmed Dirty/sec"; instance = instance }
  /// Pages Trimmed/sec: Pages Trimmed/sec is the number of database pages that are trimmed and the allocated space is released to the file system.  [Dev Only]
  let ``Pages Trimmed/sec`` instance =
    { category = "Database ==> Instances"; counter = "Pages Trimmed/sec"; instance = instance }
  /// Record Deletes/sec: Record Deletes/sec is the rate at which records in database tables are being flagged for deletion.  [Dev Only]
  let ``Record Deletes/sec`` instance =
    { category = "Database ==> Instances"; counter = "Record Deletes/sec"; instance = instance }
  /// Record Escrow-Updates/sec: Record Escrow-Updates/sec is the rate at which records in database tables are being escrow-updated.  [Dev Only]
  let ``Record Escrow-Updates/sec`` instance =
    { category = "Database ==> Instances"; counter = "Record Escrow-Updates/sec"; instance = instance }
  /// Record Failed Compression Bytes/sec: Record Failed Compression Bytes/sec is the rate of record bytes that either failed Xpress compression or did not significantly reduce the insert/replace size (10% or less). High results are indicative of wasted cpu resources.  [Dev Only]
  let ``Record Failed Compression Bytes/sec`` instance =
    { category = "Database ==> Instances"; counter = "Record Failed Compression Bytes/sec"; instance = instance }
  /// Record Inserts/sec: Record Inserts/sec is the rate at which records are being inserted into database tables.  [Dev Only]
  let ``Record Inserts/sec`` instance =
    { category = "Database ==> Instances"; counter = "Record Inserts/sec"; instance = instance }
  /// Record Intrinsic Long-Values Updated/sec: Record Intrinsic Long-Values Updated/sec is the rate at which intrinsic long-values are added to or replaced in records of database tables.  [Dev Only]
  let ``Record Intrinsic Long-Values Updated/sec`` instance =
    { category = "Database ==> Instances"; counter = "Record Intrinsic Long-Values Updated/sec"; instance = instance }
  /// Record Redundant Replaces/sec: Record Redundant Replaces/sec is the rate at which records in database tables are being updated with the exact same content of the original record.  [Dev Only]
  let ``Record Redundant Replaces/sec`` instance =
    { category = "Database ==> Instances"; counter = "Record Redundant Replaces/sec"; instance = instance }
  /// Record Replaces/sec: Record Replaces/sec is the rate at which records in database tables are being updated.  [Dev Only]
  let ``Record Replaces/sec`` instance =
    { category = "Database ==> Instances"; counter = "Record Replaces/sec"; instance = instance }
  /// Record Separated Long-Values Added/sec: Record Separated Long-Values Added/sec is the rate at which separated long-values are normally added to records of database tables.  [Dev Only]
  let ``Record Separated Long-Values Added/sec`` instance =
    { category = "Database ==> Instances"; counter = "Record Separated Long-Values Added/sec"; instance = instance }
  /// Record Separated Long-Values All Forced/sec: Record Separated Long-Values All Forced/sec is the rate at which all intrinsic long-values are separated out of a record of a database table in order to accommodate updates to the record.  [Dev Only]
  let ``Record Separated Long-Values All Forced/sec`` instance =
    { category = "Database ==> Instances"; counter = "Record Separated Long-Values All Forced/sec"; instance = instance }
  /// Record Separated Long-Values Dereference All/sec: Record Separated Long-Values Dereference All/sec is the rate at which a reference is removed for all the separated long-values associated with a record of a database table.  [Dev Only]
  let ``Record Separated Long-Values Dereference All/sec`` instance =
    { category = "Database ==> Instances"; counter = "Record Separated Long-Values Dereference All/sec"; instance = instance }
  /// Record Separated Long-Values Forced/sec: Record Separated Long-Values Forced/sec is the rate at which separated long-values are added to records of a database table because they could not be accommodated in the record itself.  [Dev Only]
  let ``Record Separated Long-Values Forced/sec`` instance =
    { category = "Database ==> Instances"; counter = "Record Separated Long-Values Forced/sec"; instance = instance }
  /// Record Separated Long-Values Reference All/sec: Record Separated Long-Values Reference All/sec is the rate at which a reference is added for all the separated long-values associated with a record of a database table.  [Dev Only]
  let ``Record Separated Long-Values Reference All/sec`` instance =
    { category = "Database ==> Instances"; counter = "Record Separated Long-Values Reference All/sec"; instance = instance }
  /// Record Unnecessary Replaces/sec: Record Unnecessary Replaces/sec is the rate at which updates to records in database tables are being discarded because the update did not actually modify the contents of the record.  [Dev Only]
  let ``Record Unnecessary Replaces/sec`` instance =
    { category = "Database ==> Instances"; counter = "Record Unnecessary Replaces/sec"; instance = instance }
  /// Records Converted: Records Converted is the number of database records that have been converted from an older format. [Dev Only]
  let ``Records Converted`` instance =
    { category = "Database ==> Instances"; counter = "Records Converted"; instance = instance }
  /// Records Converted/sec: Records Converted/sec is the number of times per second a database record is converted from an older database format. [Dev Only]
  let ``Records Converted/sec`` instance =
    { category = "Database ==> Instances"; counter = "Records Converted/sec"; instance = instance }
  /// Secondary Index Deletes/sec: Secondary Index Deletes/sec is the rate at which entries in indexes of database tables are being flagged for deletion.  [Dev Only]
  let ``Secondary Index Deletes/sec`` instance =
    { category = "Database ==> Instances"; counter = "Secondary Index Deletes/sec"; instance = instance }
  /// Secondary Index Inserts/sec: Secondary Index Inserts/sec is the rate at which entries are being inserted into indexes of database tables.  [Dev Only]
  let ``Secondary Index Inserts/sec`` instance =
    { category = "Database ==> Instances"; counter = "Secondary Index Inserts/sec"; instance = instance }
  /// Separated Long-Value Chunk Appends/sec: Separated Long-Value Chunk Appends/sec is the rate at which chunks are appended to separated long-values of database tables.  [Dev Only]
  let ``Separated Long-Value Chunk Appends/sec`` instance =
    { category = "Database ==> Instances"; counter = "Separated Long-Value Chunk Appends/sec"; instance = instance }
  /// Separated Long-Value Chunk Copies/sec: Separated Long-Value Chunk Copies/sec is the rate at which existing separated long-value chunks in a database table are copied.  [Dev Only]
  let ``Separated Long-Value Chunk Copies/sec`` instance =
    { category = "Database ==> Instances"; counter = "Separated Long-Value Chunk Copies/sec"; instance = instance }
  /// Separated Long-Value Chunk Deletes/sec: Separated Long-Value Chunk Deletes/sec is the rate at which separated long-value chunks in a database table are flagged for deletion.  [Dev Only]
  let ``Separated Long-Value Chunk Deletes/sec`` instance =
    { category = "Database ==> Instances"; counter = "Separated Long-Value Chunk Deletes/sec"; instance = instance }
  /// Separated Long-Value Chunk Replaces/sec: Separated Long-Value Chunk Replaces/sec is the rate at which existing separated long-value chunks in a database table are replaced.  [Dev Only]
  let ``Separated Long-Value Chunk Replaces/sec`` instance =
    { category = "Database ==> Instances"; counter = "Separated Long-Value Chunk Replaces/sec"; instance = instance }
  /// Separated Long-Value Chunk Retrieves/sec: Separated Long-Value Chunk Retrieves/sec is the rate at which retrievals of a chunk of a separated long-value in a database table are performed.  [Dev Only]
  let ``Separated Long-Value Chunk Retrieves/sec`` instance =
    { category = "Database ==> Instances"; counter = "Separated Long-Value Chunk Retrieves/sec"; instance = instance }
  /// Separated Long-Value Chunk Seeks/sec: Separated Long-Value Chunk Seeks/sec is the rate at which seeks for a particular chunk of a separated long-value in a database table are performed.  [Dev Only]
  let ``Separated Long-Value Chunk Seeks/sec`` instance =
    { category = "Database ==> Instances"; counter = "Separated Long-Value Chunk Seeks/sec"; instance = instance }
  /// Separated Long-Value Copies/sec: Separated Long-Value Copies/sec is the rate at which existing separated long-values in a database table are copied.  [Dev Only]
  let ``Separated Long-Value Copies/sec`` instance =
    { category = "Database ==> Instances"; counter = "Separated Long-Value Copies/sec"; instance = instance }
  /// Separated Long-Value Creates/sec: Separated Long-Value Creates/sec is the rate at which new separated long-values are added to a database table.  [Dev Only]
  let ``Separated Long-Value Creates/sec`` instance =
    { category = "Database ==> Instances"; counter = "Separated Long-Value Creates/sec"; instance = instance }
  /// Separated Long-Value Deletes/sec: Separated Long-Value Deletes/sec is the rate at which separated long-values in a database table are flagged for deletion.  [Dev Only]
  let ``Separated Long-Value Deletes/sec`` instance =
    { category = "Database ==> Instances"; counter = "Separated Long-Value Deletes/sec"; instance = instance }
  /// Separated Long-Value Retrieves/sec: Separated Long-Value Retrieves/sec is the rate at which retrievals of a separated long-value in a database table are performed.  [Dev Only]
  let ``Separated Long-Value Retrieves/sec`` instance =
    { category = "Database ==> Instances"; counter = "Separated Long-Value Retrieves/sec"; instance = instance }
  /// Separated Long-Value Seeks/sec: Separated Long-Value Seeks/sec is the rate at which seeks for a separated long-value in a database table are performed.  [Dev Only]
  let ``Separated Long-Value Seeks/sec`` instance =
    { category = "Database ==> Instances"; counter = "Separated Long-Value Seeks/sec"; instance = instance }
  /// Separated Long-Value Updates/sec: Separated Long-Value Updates/sec is the rate at which existing separated long-values in a database table are modified.  [Dev Only]
  let ``Separated Long-Value Updates/sec`` instance =
    { category = "Database ==> Instances"; counter = "Separated Long-Value Updates/sec"; instance = instance }
  /// Sessions % Used: Sessions % Used is the percentage of database sessions currently open for use by client threads.
  let ``Sessions % Used`` instance =
    { category = "Database ==> Instances"; counter = "Sessions % Used"; instance = instance }
  /// Sessions In Use: Sessions In Use is the number of database sessions currently open for use by client threads.
  let ``Sessions In Use`` instance =
    { category = "Database ==> Instances"; counter = "Sessions In Use"; instance = instance }
  /// Streaming Backup Pages Read/sec: Streaming Backup Pages Read/sec is the rate of database read operations performed for the purpose of streaming backups.
  let ``Streaming Backup Pages Read/sec`` instance =
    { category = "Database ==> Instances"; counter = "Streaming Backup Pages Read/sec"; instance = instance }
  /// System Read Only Transaction Commits to Level 0/sec: System Read Only Transaction Commits to Level 0/sec is the count of fully committed transactions started internally that do not modify any data stored in the database engine.  [Dev Only]
  let ``System Read Only Transaction Commits to Level 0/sec`` instance =
    { category = "Database ==> Instances"; counter = "System Read Only Transaction Commits to Level 0/sec"; instance = instance }
  /// System Read Only Transaction Rollbacks to Level 0/sec: System Read Only Transaction Rollbacks to Level 0/sec is the count of aborted transactions started internally that do not modify any data stored in the database engine.  [Dev Only]
  let ``System Read Only Transaction Rollbacks to Level 0/sec`` instance =
    { category = "Database ==> Instances"; counter = "System Read Only Transaction Rollbacks to Level 0/sec"; instance = instance }
  /// System Read/Write Transaction Commits to Level 0 (Durable)/sec: System Read/Write Transaction Commits to Level 0 (Durable)/sec is the count of fully committed transactions started internally that modify data stored in the database engine.  [Dev Only]
  let ``System Read/Write Transaction Commits to Level 0 (Durable)/sec`` instance =
    { category = "Database ==> Instances"; counter = "System Read/Write Transaction Commits to Level 0 (Durable)/sec"; instance = instance }
  /// System Read/Write Transaction Commits to Level 0 (Lazy)/sec: System Read/Write Transaction Commits to Level 0 (Lazy)/sec is the count of internal transactions committed to log buffer.  [Dev Only]
  let ``System Read/Write Transaction Commits to Level 0 (Lazy)/sec`` instance =
    { category = "Database ==> Instances"; counter = "System Read/Write Transaction Commits to Level 0 (Lazy)/sec"; instance = instance }
  /// System Read/Write Transaction Rollbacks to Level 0/sec: System Read/Write Transaction Rollbacks to Level 0/sec is the count of aborted transactions started internally that modify data stored in the database engine.  [Dev Only]
  let ``System Read/Write Transaction Rollbacks to Level 0/sec`` instance =
    { category = "Database ==> Instances"; counter = "System Read/Write Transaction Rollbacks to Level 0/sec"; instance = instance }
  /// System Transaction Commits to Level 0/sec: System Transaction Commits to Level 0/sec is the count of fully committed transactions started internally that access data stored in the database engine.  [Dev Only]
  let ``System Transaction Commits to Level 0/sec`` instance =
    { category = "Database ==> Instances"; counter = "System Transaction Commits to Level 0/sec"; instance = instance }
  /// System Transaction Rollbacks to Level 0/sec: System Transaction Rollbacks to Level 0/sec is the count of aborted transactions started internally that access data stored in the database engine.  [Dev Only]
  let ``System Transaction Rollbacks to Level 0/sec`` instance =
    { category = "Database ==> Instances"; counter = "System Transaction Rollbacks to Level 0/sec"; instance = instance }
  /// Table Closes/sec: Table Closes/sec is the number of database tables closed per second.
  let ``Table Closes/sec`` instance =
    { category = "Database ==> Instances"; counter = "Table Closes/sec"; instance = instance }
  /// Table Open Cache % Hit: Table Open Cache % Hit is the percentage of database tables opened using cached schema information.  If this percentage is too low, the table cache size may be too small.
  let ``Table Open Cache % Hit`` instance =
    { category = "Database ==> Instances"; counter = "Table Open Cache % Hit"; instance = instance }
  /// Table Open Cache Hits/sec: Table Open Cache Hits/sec is the number of database tables opened using cached schema information per second.  If this rate is too low, the table cache size may be too small.
  let ``Table Open Cache Hits/sec`` instance =
    { category = "Database ==> Instances"; counter = "Table Open Cache Hits/sec"; instance = instance }
  /// Table Open Cache Misses/sec: Table Open Cache Misses/sec is the number of database tables opened without using cached schema information per second.  If this rate is too high, the table cache size may be too small.
  let ``Table Open Cache Misses/sec`` instance =
    { category = "Database ==> Instances"; counter = "Table Open Cache Misses/sec"; instance = instance }
  /// Table Open Pages Preread/sec: Table Open Pages Preread/sec is the number of database pages pre-read without using cached schema information per second.  If this rate is too high, the table cache size may be too small. [Dev Only]
  let ``Table Open Pages Preread/sec`` instance =
    { category = "Database ==> Instances"; counter = "Table Open Pages Preread/sec"; instance = instance }
  /// Table Open Pages Read/sec: Table Open Pages Read/sec is the number of database pages read without using cached schema information per second.  If this rate is too high, the table cache size may be too small. [Dev Only]
  let ``Table Open Pages Read/sec`` instance =
    { category = "Database ==> Instances"; counter = "Table Open Pages Read/sec"; instance = instance }
  /// Table Opens/sec: Table Opens/sec is the number of database tables opened per second.
  let ``Table Opens/sec`` instance =
    { category = "Database ==> Instances"; counter = "Table Opens/sec"; instance = instance }
  /// Tables Open: Tables Open is the number of database tables opened.
  let ``Tables Open`` instance =
    { category = "Database ==> Instances"; counter = "Tables Open"; instance = instance }
  /// User Read Only Transaction Commits to Level 0/sec: User Read Only Transaction Commits to Level 0/sec is the count of fully committed transactions started by the calling process that do not modify any data stored in the database engine.  [Dev Only]
  let ``User Read Only Transaction Commits to Level 0/sec`` instance =
    { category = "Database ==> Instances"; counter = "User Read Only Transaction Commits to Level 0/sec"; instance = instance }
  /// User Read Only Transaction Rollbacks to Level 0/sec: User Read Only Transaction Rollbacks to Level 0/sec is the count of aborted transactions started by the calling process that do not modify any data stored in the database engine.  [Dev Only]
  let ``User Read Only Transaction Rollbacks to Level 0/sec`` instance =
    { category = "Database ==> Instances"; counter = "User Read Only Transaction Rollbacks to Level 0/sec"; instance = instance }
  /// User Read/Write Transaction Commits to Level 0 (Durable)/sec: User Read/Write Transaction Commits to Level 0 (Durable)/sec is the count of fully committed transactions started by the calling process that modify data stored in the database engine.  [Dev Only]
  let ``User Read/Write Transaction Commits to Level 0 (Durable)/sec`` instance =
    { category = "Database ==> Instances"; counter = "User Read/Write Transaction Commits to Level 0 (Durable)/sec"; instance = instance }
  /// User Read/Write Transaction Commits to Level 0 (Lazy)/sec: User Read/Write Transaction Commits to Level 0 (Lazy)/sec is the count of transactions started by the calling process and committed to log buffer.  [Dev Only]
  let ``User Read/Write Transaction Commits to Level 0 (Lazy)/sec`` instance =
    { category = "Database ==> Instances"; counter = "User Read/Write Transaction Commits to Level 0 (Lazy)/sec"; instance = instance }
  /// User Read/Write Transaction Rollbacks to Level 0/sec: User Read/Write Transaction Rollbacks to Level 0/sec is the count of aborted transactions started by the calling process that modify data stored in the database engine.  [Dev Only]
  let ``User Read/Write Transaction Rollbacks to Level 0/sec`` instance =
    { category = "Database ==> Instances"; counter = "User Read/Write Transaction Rollbacks to Level 0/sec"; instance = instance }
  /// User Transaction Commits to Level 0/sec: User Transaction Commits to Level 0/sec is the count of fully committed transactions started by the calling process that access data stored in the database engine.  [Dev Only]
  let ``User Transaction Commits to Level 0/sec`` instance =
    { category = "Database ==> Instances"; counter = "User Transaction Commits to Level 0/sec"; instance = instance }
  /// User Transaction Rollbacks to Level 0/sec: User Transaction Rollbacks to Level 0/sec is the count of aborted transactions started by the calling process that access data stored in the database engine.  [Dev Only]
  let ``User Transaction Rollbacks to Level 0/sec`` instance =
    { category = "Database ==> Instances"; counter = "User Transaction Rollbacks to Level 0/sec"; instance = instance }
  /// User Wait All Transaction Commits/sec: User Wait All Transaction Commits/sec is the count of signals to flush all pending transactions started by the calling process that modify data stored in the database engine.  [Dev Only]
  let ``User Wait All Transaction Commits/sec`` instance =
    { category = "Database ==> Instances"; counter = "User Wait All Transaction Commits/sec"; instance = instance }
  /// User Wait Last Transaction Commits/sec: User Wait Last Transaction Commits/sec is the count of signals to flush a specific sessions pending transactions.  [Dev Only]
  let ``User Wait Last Transaction Commits/sec`` instance =
    { category = "Database ==> Instances"; counter = "User Wait Last Transaction Commits/sec"; instance = instance }
  /// VER Bucket Allocations Wait For Version Cleanup/sec: VER Bucket Allocations Wait For Version Cleanup/sec is the number of version bucket allocations that must first wait for version cleanup in an attempt to free used version buckets  for re-use. [Dev Only]
  let ``VER Bucket Allocations Wait For Version Cleanup/sec`` instance =
    { category = "Database ==> Instances"; counter = "VER Bucket Allocations Wait For Version Cleanup/sec"; instance = instance }
  /// Version buckets allocated: Total number of version buckets allocated
  let ``Version buckets allocated`` instance =
    { category = "Database ==> Instances"; counter = "Version buckets allocated"; instance = instance }
  /// Version buckets allocated for deletes: Total number of version buckets allocated for FlagDelete RCEs  [Dev Only]
  let ``Version buckets allocated for deletes`` instance =
    { category = "Database ==> Instances"; counter = "Version buckets allocated for deletes"; instance = instance }
  /// Version store average RCE bookmark length: Average length of bookmark in RCE  [Dev Only]
  let ``Version store average RCE bookmark length`` instance =
    { category = "Database ==> Instances"; counter = "Version store average RCE bookmark length"; instance = instance }
  /// Version store cleanup tasks asynchronously dispatched/sec: Number of times per second a version store clean task is dispatched asynchronously to be performed  [Dev Only]
  let ``Version store cleanup tasks asynchronously dispatched/sec`` instance =
    { category = "Database ==> Instances"; counter = "Version store cleanup tasks asynchronously dispatched/sec"; instance = instance }
  /// Version store cleanup tasks discarded/sec: Number of times per second a version store clean task was discarded due to load concerns  [Dev Only]
  let ``Version store cleanup tasks discarded/sec`` instance =
    { category = "Database ==> Instances"; counter = "Version store cleanup tasks discarded/sec"; instance = instance }
  /// Version store cleanup tasks failures/sec: Number of times per second a dispatched version store cleanup task fails  [Dev Only]
  let ``Version store cleanup tasks failures/sec`` instance =
    { category = "Database ==> Instances"; counter = "Version store cleanup tasks failures/sec"; instance = instance }
  /// Version store cleanup tasks synchronously dispatched/sec: Number of times per second a version store clean task is performed synchronously  [Dev Only]
  let ``Version store cleanup tasks synchronously dispatched/sec`` instance =
    { category = "Database ==> Instances"; counter = "Version store cleanup tasks synchronously dispatched/sec"; instance = instance }
  /// Version store unnecessary calls/sec: Number of times per second we look in the version store for a node whose version bit is set but which has no versions  [Dev Only]
  let ``Version store unnecessary calls/sec`` instance =
    { category = "Database ==> Instances"; counter = "Version store unnecessary calls/sec"; instance = instance }

  let allCounters =
    [ ``B+ Tree Append Splits/sec``
      ``B+ Tree Appends/sec``
      ``B+ Tree Creates (Total)``
      ``B+ Tree Creates/sec``
      ``B+ Tree Deletes/sec``
      ``B+ Tree Destroys (Total)``
      ``B+ Tree Destroys/sec``
      ``B+ Tree Empty Page Merges/sec``
      ``B+ Tree Failed Simple Page Cleanup Attempts/sec``
      ``B+ Tree Flag Deletes/sec``
      ``B+ Tree Inserts/sec``
      ``B+ Tree Left Merges/sec``
      ``B+ Tree Merges/sec``
      ``B+ Tree Move Nexts (Nodes Filtered)/sec``
      ``B+ Tree Move Nexts (Non-Visible Nodes Skipped)/sec``
      ``B+ Tree Move Nexts/sec``
      ``B+ Tree Move Prevs (Nodes Filtered)/sec``
      ``B+ Tree Move Prevs (Non-Visible Nodes Skipped)/sec``
      ``B+ Tree Move Prevs/sec``
      ``B+ Tree Opportune Prereads/sec``
      ``B+ Tree Page Moves/sec``
      ``B+ Tree Partial Left Merges/sec``
      ``B+ Tree Partial Merges/sec``
      ``B+ Tree Replaces/sec``
      ``B+ Tree Right Hotpoint Splits/sec``
      ``B+ Tree Right Merges/sec``
      ``B+ Tree Right Splits/sec``
      ``B+ Tree Seek Short Circuits/sec``
      ``B+ Tree Seeks/sec``
      ``B+ Tree Splits/sec``
      ``B+ Tree Unnecessary Sibling Latches/sec``
      ``B+ Tree Vertical Splits/sec``
      ``Database Cache % Hit``
      ``Database Cache % Hit (Uncorrelated)``
      ``Database Cache Misses/sec``
      ``Database Cache Requests/sec``
      ``Database Cache Size (MB)``
      ``Database Maintenance Duration``
      ``Database Maintenance IO Re-Reads Average Bytes``
      ``Database Maintenance IO Re-Reads Average Latency``
      ``Database Maintenance IO Re-Reads/sec``
      ``Database Maintenance IO Reads Average Bytes``
      ``Database Maintenance IO Reads/sec``
      ``Database Maintenance Pages Bad Checksums``
      ``Database Maintenance Pages Read``
      ``Database Maintenance Pages Read/sec``
      ``Database Maintenance Pages Zeroed``
      ``Database Maintenance Pages Zeroed/sec``
      ``Database Maintenance Throttle Setting``
      ``Database Page Allocation File Extension Async Consumed/sec``
      ``Database Page Allocation File Extension Stalls/sec``
      ``Database Page Allocation File Shrink Stalls/sec``
      ``Database Page Evictions (Patch)/sec``
      ``Database Page Evictions (Purge)/sec``
      ``Database Page Evictions (Scavenging)/sec``
      ``Database Page Evictions (Shrink)/sec``
      ``Database Page Evictions (k=1)/sec``
      ``Database Page Evictions (k=2)/sec``
      ``Database Page Preread Stalls/sec``
      ``Database Page Touches (Correlated)/sec``
      ``Database Page Touches (Non-Touch)/sec``
      ``Database Page Touches (k=1)/sec``
      ``Database Page Touches (k=2)/sec``
      ``Database Pages Coalesced Read/sec``
      ``Database Pages Coalesced Written/sec``
      ``Database Pages Colded (Ext)/sec``
      ``Database Pages Colded (Int)/sec``
      ``Database Pages Dehydrated/sec``
      ``Database Pages Dirtied (Repeatedly)/sec``
      ``Database Pages Dirtied/sec``
      ``Database Pages Flushed (Cache Shrink)/sec``
      ``Database Pages Flushed (Checkpoint Foreground)/sec``
      ``Database Pages Flushed (Checkpoint)/sec``
      ``Database Pages Flushed (Context Flush)/sec``
      ``Database Pages Flushed (Filthy Foreground)/sec``
      ``Database Pages Flushed (Idle)/sec``
      ``Database Pages Flushed (Scavenge)/sec``
      ``Database Pages Flushed Opportunely Clean/sec``
      ``Database Pages Flushed Opportunely/sec``
      ``Database Pages Non-Resident Evicted (Normally)/sec``
      ``Database Pages Non-Resident Re-read/sec``
      ``Database Pages Non-Resident Reclaimed (Failed)/sec``
      ``Database Pages Non-Resident Reclaimed (Soft Faulted)/sec``
      ``Database Pages Preread (Unnecessary)/sec``
      ``Database Pages Preread Untouched/sec``
      ``Database Pages Preread/sec``
      ``Database Pages Read Async/sec``
      ``Database Pages Read Sync/sec``
      ``Database Pages Rehydrated/sec``
      ``Database Pages Repeatedly Read/sec``
      ``Database Pages Repeatedly Written/sec``
      ``Database Pages Transferred/sec``
      ``Database Pages Version Copied/sec``
      ``Database Pages Versioned/sec``
      ``Database Pages Written/sec``
      ``Database Tasks Average Log Bytes``
      ``Database Tasks Log Records/sec``
      ``Database Tasks Pages Dirtied/sec``
      ``Database Tasks Pages Preread/sec``
      ``Database Tasks Pages Re-Dirtied/sec``
      ``Database Tasks Pages Read/sec``
      ``Database Tasks Pages Referenced/sec``
      ``Defragmentation Tasks``
      ``Defragmentation Tasks Completed/sec``
      ``Defragmentation Tasks Discarded``
      ``Defragmentation Tasks Pending``
      ``Defragmentation Tasks Scheduled/sec``
      ``FCB Allocations Wait For Version Cleanup/sec``
      ``FCB Async Purge Failures (Active Tasks)/sec``
      ``FCB Async Purge Failures (Callbacks)/sec``
      ``FCB Async Purge Failures (Conflicts)/sec``
      ``FCB Async Purge Failures (Delete Pending)/sec``
      ``FCB Async Purge Failures (In Use)/sec``
      ``FCB Async Purge Failures (Index Outstanding)/sec``
      ``FCB Async Purge Failures (LV Outstanding)/sec``
      ``FCB Async Purge Failures (Other)/sec``
      ``FCB Async Purge Failures (Outstanding Versions)/sec``
      ``FCB Async Purge Failures (Sentinel)/sec``
      ``FCB Async Purge/sec``
      ``FCB Async Scan/sec``
      ``FCB Async Threshold Purge Failures (Active Tasks)/sec``
      ``FCB Async Threshold Purge Failures (Callbacks)/sec``
      ``FCB Async Threshold Purge Failures (Conflicts)/sec``
      ``FCB Async Threshold Purge Failures (Delete Pending)/sec``
      ``FCB Async Threshold Purge Failures (In Use)/sec``
      ``FCB Async Threshold Purge Failures (Index Outstanding)/sec``
      ``FCB Async Threshold Purge Failures (LV Outstanding)/sec``
      ``FCB Async Threshold Purge Failures (Other)/sec``
      ``FCB Async Threshold Purge Failures (Outstanding Versions)/sec``
      ``FCB Async Threshold Purge Failures (Sentinel)/sec``
      ``FCB Async Threshold-Purge/sec``
      ``FCB Async Threshold-Scan/sec``
      ``FCB Attached RCEs``
      ``FCB Cache % Hit``
      ``FCB Cache Allocated``
      ``FCB Cache Allocated/sec``
      ``FCB Cache Allocation Average Latency (ms)``
      ``FCB Cache Allocations Failed``
      ``FCB Cache Available``
      ``FCB Cache Maximum``
      ``FCB Cache Preferred``
      ``FCB Cache Stalls/sec``
      ``FCB Purge On Cursor Close/sec``
      ``FCB Sync Purge Stalls/sec``
      ``FCB Sync Purge/sec``
      ``False Index Column Updates/sec``
      ``False Tuple Index Column Updates/sec``
      ``I/O Database Reads (Attached) Abnormal Latency/sec``
      ``I/O Database Reads (Attached) Async Pending``
      ``I/O Database Reads (Attached) Average Bytes``
      ``I/O Database Reads (Attached) Average Latency``
      ``I/O Database Reads (Attached) In Heap``
      ``I/O Database Reads (Attached)/sec``
      ``I/O Database Reads (Recovery) Abnormal Latency/sec``
      ``I/O Database Reads (Recovery) Async Pending``
      ``I/O Database Reads (Recovery) Average Bytes``
      ``I/O Database Reads (Recovery) Average Latency``
      ``I/O Database Reads (Recovery) In Heap``
      ``I/O Database Reads (Recovery)/sec``
      ``I/O Database Reads Abnormal Latency/sec``
      ``I/O Database Reads Async Pending``
      ``I/O Database Reads Average Bytes``
      ``I/O Database Reads Average Latency``
      ``I/O Database Reads In Heap``
      ``I/O Database Reads/sec``
      ``I/O Database Writes (Attached) Abnormal Latency/sec``
      ``I/O Database Writes (Attached) Async Pending``
      ``I/O Database Writes (Attached) Average Bytes``
      ``I/O Database Writes (Attached) Average Latency``
      ``I/O Database Writes (Attached) In Heap``
      ``I/O Database Writes (Attached)/sec``
      ``I/O Database Writes (Recovery) Abnormal Latency/sec``
      ``I/O Database Writes (Recovery) Async Pending``
      ``I/O Database Writes (Recovery) Average Bytes``
      ``I/O Database Writes (Recovery) Average Latency``
      ``I/O Database Writes (Recovery) In Heap``
      ``I/O Database Writes (Recovery)/sec``
      ``I/O Database Writes Abnormal Latency/sec``
      ``I/O Database Writes Async Pending``
      ``I/O Database Writes Average Bytes``
      ``I/O Database Writes Average Latency``
      ``I/O Database Writes In Heap``
      ``I/O Database Writes/sec``
      ``I/O Log Reads Abnormal Latency/sec``
      ``I/O Log Reads Async Pending``
      ``I/O Log Reads Average Bytes``
      ``I/O Log Reads Average Latency``
      ``I/O Log Reads In Heap``
      ``I/O Log Reads/sec``
      ``I/O Log Writes Abnormal Latency/sec``
      ``I/O Log Writes Async Pending``
      ``I/O Log Writes Average Bytes``
      ``I/O Log Writes Average Latency``
      ``I/O Log Writes In Heap``
      ``I/O Log Writes/sec``
      ``Instance Status``
      ``Log Buffer Bytes Committed``
      ``Log Buffer Bytes Free``
      ``Log Buffer Bytes Used``
      ``Log Buffer Capacity Flushes/sec``
      ``Log Buffer Commit Flushes/sec``
      ``Log Buffer Flushes Blocked/sec``
      ``Log Buffer Flushes Skipped/sec``
      ``Log Buffer Flushes/sec``
      ``Log Buffer Size``
      ``Log Bytes Generated/sec``
      ``Log Bytes Wasted/sec``
      ``Log Bytes Write/sec``
      ``Log Checkpoint Depth``
      ``Log Checkpoint Depth as a % of Target``
      ``Log Checkpoint Maintenance Outstanding IO Max``
      ``Log File Current Generation``
      ``Log File Size``
      ``Log Files Generated``
      ``Log Files Generated Prematurely``
      ``Log Full Segment Writes/sec``
      ``Log Generation Checkpoint Depth``
      ``Log Generation Checkpoint Depth Max``
      ``Log Generation Checkpoint Depth Target``
      ``Log Generation Loss Resiliency Depth``
      ``Log Partial Segment Writes/sec``
      ``Log Record Stalls/sec``
      ``Log Records/sec``
      ``Log Threads Waiting``
      ``Log Writes/sec``
      ``Long-Value Maximum LID``
      ``No name``
      ``Online Defrag Average Log Bytes``
      ``Online Defrag Data Moves/sec``
      ``Online Defrag Log Records/sec``
      ``Online Defrag Page Moves/sec``
      ``Online Defrag Pages Dirtied/sec``
      ``Online Defrag Pages Freed/sec``
      ``Online Defrag Pages Preread/sec``
      ``Online Defrag Pages Re-Dirtied/sec``
      ``Online Defrag Pages Read/sec``
      ``Online Defrag Pages Referenced/sec``
      ``Pages Converted``
      ``Pages Converted/sec``
      ``Pages Not Trimmed Unaligned (Total)``
      ``Pages Not Trimmed Unaligned/sec``
      ``Pages Reorganized (Dehydrate Buffer)/sec``
      ``Pages Reorganized (Free Space Request)/sec``
      ``Pages Reorganized (Other)/sec``
      ``Pages Reorganized (Page Move Logging)/sec``
      ``Pages Trimmed (Total)``
      ``Pages Trimmed Dirty (Total)``
      ``Pages Trimmed Dirty/sec``
      ``Pages Trimmed/sec``
      ``Record Deletes/sec``
      ``Record Escrow-Updates/sec``
      ``Record Failed Compression Bytes/sec``
      ``Record Inserts/sec``
      ``Record Intrinsic Long-Values Updated/sec``
      ``Record Redundant Replaces/sec``
      ``Record Replaces/sec``
      ``Record Separated Long-Values Added/sec``
      ``Record Separated Long-Values All Forced/sec``
      ``Record Separated Long-Values Dereference All/sec``
      ``Record Separated Long-Values Forced/sec``
      ``Record Separated Long-Values Reference All/sec``
      ``Record Unnecessary Replaces/sec``
      ``Records Converted``
      ``Records Converted/sec``
      ``Secondary Index Deletes/sec``
      ``Secondary Index Inserts/sec``
      ``Separated Long-Value Chunk Appends/sec``
      ``Separated Long-Value Chunk Copies/sec``
      ``Separated Long-Value Chunk Deletes/sec``
      ``Separated Long-Value Chunk Replaces/sec``
      ``Separated Long-Value Chunk Retrieves/sec``
      ``Separated Long-Value Chunk Seeks/sec``
      ``Separated Long-Value Copies/sec``
      ``Separated Long-Value Creates/sec``
      ``Separated Long-Value Deletes/sec``
      ``Separated Long-Value Retrieves/sec``
      ``Separated Long-Value Seeks/sec``
      ``Separated Long-Value Updates/sec``
      ``Sessions % Used``
      ``Sessions In Use``
      ``Streaming Backup Pages Read/sec``
      ``System Read Only Transaction Commits to Level 0/sec``
      ``System Read Only Transaction Rollbacks to Level 0/sec``
      ``System Read/Write Transaction Commits to Level 0 (Durable)/sec``
      ``System Read/Write Transaction Commits to Level 0 (Lazy)/sec``
      ``System Read/Write Transaction Rollbacks to Level 0/sec``
      ``System Transaction Commits to Level 0/sec``
      ``System Transaction Rollbacks to Level 0/sec``
      ``Table Closes/sec``
      ``Table Open Cache % Hit``
      ``Table Open Cache Hits/sec``
      ``Table Open Cache Misses/sec``
      ``Table Open Pages Preread/sec``
      ``Table Open Pages Read/sec``
      ``Table Opens/sec``
      ``Tables Open``
      ``User Read Only Transaction Commits to Level 0/sec``
      ``User Read Only Transaction Rollbacks to Level 0/sec``
      ``User Read/Write Transaction Commits to Level 0 (Durable)/sec``
      ``User Read/Write Transaction Commits to Level 0 (Lazy)/sec``
      ``User Read/Write Transaction Rollbacks to Level 0/sec``
      ``User Transaction Commits to Level 0/sec``
      ``User Transaction Rollbacks to Level 0/sec``
      ``User Wait All Transaction Commits/sec``
      ``User Wait Last Transaction Commits/sec``
      ``VER Bucket Allocations Wait For Version Cleanup/sec``
      ``Version buckets allocated``
      ``Version buckets allocated for deletes``
      ``Version store average RCE bookmark length``
      ``Version store cleanup tasks asynchronously dispatched/sec``
      ``Version store cleanup tasks discarded/sec``
      ``Version store cleanup tasks failures/sec``
      ``Version store cleanup tasks synchronously dispatched/sec``
      ``Version store unnecessary calls/sec``
    ]

/// Database ==> TableClasses: Statistics for the ESE high performance embedded database management system by Table Class.
///
/// This performance counter does not have non-instance based counters
module ``Database ==> TableClasses`` =

  [<Literal>]
  let Category = "Database ==> TableClasses"

  let PCC = getPCC Category
  /// B+ Tree Append Splits/sec: B+ Tree Append Splits/sec is the count of times a page is appended to a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Append Splits/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Append Splits/sec"; instance = instance }
  /// B+ Tree Appends/sec: B+ Tree Appends/sec is the count of times a record is appended to a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Appends/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Appends/sec"; instance = instance }
  /// B+ Tree Creates (Total): B+ Tree Creates (Total) is the total number of B+ Trees and their corresponding space trees (if any) created.  This can also be viewed as the total number of FDP creates.  [Dev Only]
  let ``B+ Tree Creates (Total)`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Creates (Total)"; instance = instance }
  /// B+ Tree Creates/sec: B+ Tree Creates/sec is the number of B+ Trees and their corresponding space trees (if any) created per second.  This can also be viewed as the number of FDP creates per second.  [Dev Only]
  let ``B+ Tree Creates/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Creates/sec"; instance = instance }
  /// B+ Tree Deletes/sec: B+ Tree Deletes/sec is the count of times a record is deleted in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Deletes/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Deletes/sec"; instance = instance }
  /// B+ Tree Destroys (Total): B+ Tree Destroys (Total) is the total number of B+ Trees and their corresponding space trees (if any) destroyed.  This can also be viewed as the total number of FDP destroys.  [Dev Only]
  let ``B+ Tree Destroys (Total)`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Destroys (Total)"; instance = instance }
  /// B+ Tree Destroys/sec: B+ Tree Destroys/sec is the number of B+ Trees and their corresponding space trees (if any) destroyed per second.  This can also be viewed as the number of FDP destroys per second.  [Dev Only]
  let ``B+ Tree Destroys/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Destroys/sec"; instance = instance }
  /// B+ Tree Empty Page Merges/sec: B+ Tree Empty Page Merges/sec is the count of empty pages removed from a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Empty Page Merges/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Empty Page Merges/sec"; instance = instance }
  /// B+ Tree Failed Simple Page Cleanup Attempts/sec: B+ Tree Failed Simple Page Cleanup Attempts/sec is the rate that attempts to reclaim deleted node space on a page are unsuccessful due to a conflict when attempting to write-latch the page. The cleanup is re-tried by locking the root of the B+ Tree.  [Dev Only]
  let ``B+ Tree Failed Simple Page Cleanup Attempts/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Failed Simple Page Cleanup Attempts/sec"; instance = instance }
  /// B+ Tree Flag Deletes/sec: B+ Tree Flag Deletes/sec is the count of times a record is flag deleted in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Flag Deletes/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Flag Deletes/sec"; instance = instance }
  /// B+ Tree Inserts/sec: B+ Tree Inserts/sec is the count of times a record is inserted in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Inserts/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Inserts/sec"; instance = instance }
  /// B+ Tree Left Merges/sec: B+ Tree Left Merges/sec is the count of pages removed from a database B+ Tree per second by moving all its records to the previous page to the left.  [Dev Only]
  let ``B+ Tree Left Merges/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Left Merges/sec"; instance = instance }
  /// B+ Tree Merges/sec: B+ Tree Merges/sec is the count of pages merged in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Merges/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Merges/sec"; instance = instance }
  /// B+ Tree Move Nexts (Nodes Filtered)/sec: B+ Tree Move Nexts (Nodes Filtered)/sec is the count of times the database engine filters records while attempting to move to the next record in a B+ Tree per second.  [Dev Only]
  let ``B+ Tree Move Nexts (Nodes Filtered)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Move Nexts (Nodes Filtered)/sec"; instance = instance }
  /// B+ Tree Move Nexts (Non-Visible Nodes Skipped)/sec: B+ Tree Move Nexts (Non-Visible Nodes Skipped)/sec is the count of times the database engine skips non-visible records while attempting to move to the next visible record in a B+ Tree per second.  [Dev Only]
  let ``B+ Tree Move Nexts (Non-Visible Nodes Skipped)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Move Nexts (Non-Visible Nodes Skipped)/sec"; instance = instance }
  /// B+ Tree Move Nexts/sec: B+ Tree Move Nexts/sec is the count of times the database engine moves to the next record in a B+ Tree per second.  [Dev Only]
  let ``B+ Tree Move Nexts/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Move Nexts/sec"; instance = instance }
  /// B+ Tree Move Prevs (Nodes Filtered)/sec: B+ Tree Move Prevs (Nodes Filtered)/sec is the count of times the database engine filters records while attempting to move to the previous record in a B+ Tree per second.  [Dev Only]
  let ``B+ Tree Move Prevs (Nodes Filtered)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Move Prevs (Nodes Filtered)/sec"; instance = instance }
  /// B+ Tree Move Prevs (Non-Visible Nodes Skipped)/sec: B+ Tree Move Prevs (Non-Visible Nodes Skipped)/sec is the count of times the database engine skips non-visible records while attempting to move to the previous visible record in a B+ Tree per second.  [Dev Only]
  let ``B+ Tree Move Prevs (Non-Visible Nodes Skipped)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Move Prevs (Non-Visible Nodes Skipped)/sec"; instance = instance }
  /// B+ Tree Move Prevs/sec: B+ Tree Move Prevs/sec is the count of times the database engine moves to the previous record in a B+ Tree per second.  [Dev Only]
  let ``B+ Tree Move Prevs/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Move Prevs/sec"; instance = instance }
  /// B+ Tree Opportune Prereads/sec: B+ Tree Opportune Prereads/sec is the number of pages per second that are preread because they are adjacent to a page read by a seek.  [Dev Only]
  let ``B+ Tree Opportune Prereads/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Opportune Prereads/sec"; instance = instance }
  /// B+ Tree Page Moves/sec: B+ Tree Page Moves/sec is the count of B+ Tree pages per second where all the records are moved to a new page. [Dev Only]
  let ``B+ Tree Page Moves/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Page Moves/sec"; instance = instance }
  /// B+ Tree Partial Left Merges/sec: B+ Tree Partial Left Merges/sec is the count of pages where some of its records are moved to a page on the left in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Partial Left Merges/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Partial Left Merges/sec"; instance = instance }
  /// B+ Tree Partial Merges/sec: B+ Tree Partial Merges/sec is the count of pages where some of its records are moved to a page on the right in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Partial Merges/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Partial Merges/sec"; instance = instance }
  /// B+ Tree Replaces/sec: B+ Tree Replaces/sec is the count of times a record is replaced in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Replaces/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Replaces/sec"; instance = instance }
  /// B+ Tree Right Hotpoint Splits/sec: B+ Tree Right Hotpoint Splits/sec is the count of times a page is split right in a database B+ Tree, but which is treated as an append at a local "hotpoint" in the B+ Tree per second.  [Dev Only]
  let ``B+ Tree Right Hotpoint Splits/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Right Hotpoint Splits/sec"; instance = instance }
  /// B+ Tree Right Merges/sec: Right Merges/sec is the count of pages removed from a database B+ Tree per second by moving all its records to the next page to the right.  [Dev Only]
  let ``B+ Tree Right Merges/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Right Merges/sec"; instance = instance }
  /// B+ Tree Right Splits/sec: B+ Tree Right Splits/sec is the count of times a page is split right in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Right Splits/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Right Splits/sec"; instance = instance }
  /// B+ Tree Seek Short Circuits/sec: B+ Tree Seek Short Circuits/sec is the count of repeated seeks to the same record in a database B+ Tree that are saved by jumping directly to the cached physical location of that record per second.  [Dev Only]
  let ``B+ Tree Seek Short Circuits/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Seek Short Circuits/sec"; instance = instance }
  /// B+ Tree Seeks/sec: B+ Tree Seeks/sec is the count of times a record is seeked to by a key in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Seeks/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Seeks/sec"; instance = instance }
  /// B+ Tree Splits/sec: B+ Tree Splits/sec is the count of times a page is appended to or split in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Splits/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Splits/sec"; instance = instance }
  /// B+ Tree Unnecessary Sibling Latches/sec: B+ Tree Unnecessary Sibling Latches/sec is the count of sibling pages latched during a database B+ Tree Delete in the hopes of performing a merge where a merge is not possible, making that latch unnecessary.  [Dev Only]
  let ``B+ Tree Unnecessary Sibling Latches/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Unnecessary Sibling Latches/sec"; instance = instance }
  /// B+ Tree Vertical Splits/sec: B+ Tree Vertical Splits/sec is the count of times a page is split vertically in a database B+ Tree per second.  [Dev Only]
  let ``B+ Tree Vertical Splits/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "B+ Tree Vertical Splits/sec"; instance = instance }
  /// Database Cache % Hit: Database Cache % Hit is the percentage of database file page requests that were fulfilled by the database cache without causing a file operation.  If this percentage is too low, the database cache size may be too small.
  let ``Database Cache % Hit`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Cache % Hit"; instance = instance }
  /// Database Cache % Hit (Uncorrelated): Database Cache % Hit (Uncorrelated) is the percentage of uncorrelated  database file page requests that were fulfilled by the database cache.
  let ``Database Cache % Hit (Uncorrelated)`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Cache % Hit (Uncorrelated)"; instance = instance }
  /// Database Cache Misses/sec: Database Cache Misses per second is the rate at which database file page requests were fulfilled by the database cache by causing a file operation.  If this rate is high, then the database cache size may be too small.
  let ``Database Cache Misses/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Cache Misses/sec"; instance = instance }
  /// Database Cache Requests/sec: Database Cache Requests/sec is the rate that pages are requested from the database cache.
  let ``Database Cache Requests/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Cache Requests/sec"; instance = instance }
  /// Database Cache Size: Database Cache Size is the amount of system memory used by the database cache manager to hold commonly used information from the database file(s) to prevent file operations.  If the database cache size seems to be too small for optimal performance and there is very little available memory on the system (see Memory/Available Bytes), adding more memory to the system may increase performance.  If there is a lot of available memory on the system and the database cache size is not growing beyond a certain point, the database cache size may be capped at an artificially low limit.  Increasing this limit may increase performance.
  let ``Database Cache Size`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Cache Size"; instance = instance }
  /// Database Cache Size (MB): Database Cache Size (MB) is the amount of system memory (in megabytes) used by the database cache manager to hold commonly used information from the database file(s) to prevent file operations.  If the database cache size seems to be too small for optimal performance and there is very little available memory on the system (see Memory/Available Bytes), adding more memory to the system may increase performance.  If there is a lot of available memory on the system and the database cache size is not growing beyond a certain point, the database cache size may be capped at an artificially low limit.  Increasing this limit may increase performance.
  let ``Database Cache Size (MB)`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Cache Size (MB)"; instance = instance }
  /// Database Page Evictions (Patch)/sec: Database Page Evictions (Patch)/sec is the rate that cached pages are evicted due to active page patching.  [Dev Only]
  let ``Database Page Evictions (Patch)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Page Evictions (Patch)/sec"; instance = instance }
  /// Database Page Evictions (Purge)/sec: Database Page Evictions (Purge)/sec is the rate that cached pages are evicted due to purging a cached context / database.  [Dev Only]
  let ``Database Page Evictions (Purge)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Page Evictions (Purge)/sec"; instance = instance }
  /// Database Page Evictions (Scavenging)/sec: Database Page Evictions (Scavenging)/sec is the rate that cached pages are evicted due to scavenging / avail pool maintenance running.  [Dev Only]
  let ``Database Page Evictions (Scavenging)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Page Evictions (Scavenging)/sec"; instance = instance }
  /// Database Page Evictions (Shrink)/sec: Database Page Evictions (Shrink)/sec is the rate that cached pages are evicted due to the database cache shrinking.  [Dev Only]
  let ``Database Page Evictions (Shrink)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Page Evictions (Shrink)/sec"; instance = instance }
  /// Database Page Evictions (k=1)/sec: Database Page Evictions (k=1)/sec is the rate that database file pages are evicted that were of limited usefulness (k=1 pool).  [Dev Only]
  let ``Database Page Evictions (k=1)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Page Evictions (k=1)/sec"; instance = instance }
  /// Database Page Evictions (k=2)/sec: Database Page Evictions (k=2)/sec is the rate that database file pages are evicted that were of high usefulness (k=2 pool).  [Dev Only]
  let ``Database Page Evictions (k=2)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Page Evictions (k=2)/sec"; instance = instance }
  /// Database Page Preread Stalls/sec: Database Page Preread Stalls/sec is the rate that pages are read in anticipation of future use from the database file(s) into the database cache but did not complete preread before intended use.  [Dev Only]
  let ``Database Page Preread Stalls/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Page Preread Stalls/sec"; instance = instance }
  /// Database Page Touches (Correlated)/sec: Database Page Touches (Correlated)/sec is the rate that database pages are touched within a correlation interval (default=125 ms).  [Dev Only]
  let ``Database Page Touches (Correlated)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Page Touches (Correlated)/sec"; instance = instance }
  /// Database Page Touches (Non-Touch)/sec: Database Page Touches (Non-Touch)/sec is the rate that database pages are touched within a single ms (super-correlated).  [Dev Only]
  let ``Database Page Touches (Non-Touch)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Page Touches (Non-Touch)/sec"; instance = instance }
  /// Database Page Touches (k=1)/sec: Database Page Touches (k=1)/sec is the rate that database pages are touched for the first time / k=1 pool.  [Dev Only]
  let ``Database Page Touches (k=1)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Page Touches (k=1)/sec"; instance = instance }
  /// Database Page Touches (k=2)/sec: Database Page Touches (k=2)/sec is the rate that database pages are subsequently touched and put in the k=2 pool.  [Dev Only]
  let ``Database Page Touches (k=2)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Page Touches (k=2)/sec"; instance = instance }
  /// Database Pages Coalesced Read/sec: Database Pages Coalesced Read/sec is the rate that pages are read from the database file(s) to the database cache coalesced with another page. [Dev Only]
  let ``Database Pages Coalesced Read/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Coalesced Read/sec"; instance = instance }
  /// Database Pages Coalesced Written/sec: Database Pages Coalesced Written/sec is the rate that pages are written to the database file(s) from the database cache coalesced with another page. [Dev Only]
  let ``Database Pages Coalesced Written/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Coalesced Written/sec"; instance = instance }
  /// Database Pages Colded (Ext)/sec: Database Pages Colded (Ext) per second is the rate at which database pages are deprioritized by sub-components other than the buffer manager to send  for early eviction.  [Dev Only]
  let ``Database Pages Colded (Ext)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Colded (Ext)/sec"; instance = instance }
  /// Database Pages Colded (Int)/sec: Database Pages Colded (Int) per second is the rate at which database pages are deprioritized by the buffer manager itself to maintain minimal  cache usage.  [Dev Only]
  let ``Database Pages Colded (Int)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Colded (Int)/sec"; instance = instance }
  /// Database Pages Dehydrated/sec: Database Pages Dehydrated/sec is the rate that pages are compressed to memory usage in the buffer manager. [Dev Only]
  let ``Database Pages Dehydrated/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Dehydrated/sec"; instance = instance }
  /// Database Pages Dirtied (Repeatedly)/sec: Database Pages Dirtied (Repeatedly)/sec is the rate that pages are  repeatedly dirtied / redirtied in the database cache.  [Dev Only]
  let ``Database Pages Dirtied (Repeatedly)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Dirtied (Repeatedly)/sec"; instance = instance }
  /// Database Pages Dirtied/sec: Database Pages Dirtied/sec is the rate that pages are dirtied in the database cache.  [Dev Only]
  let ``Database Pages Dirtied/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Dirtied/sec"; instance = instance }
  /// Database Pages Flushed (Cache Shrink)/sec: Database Pages Flushed (Cache Shrink)/sec is the rate that pages are written to the database file(s) from the database cache because the cache size  must shrink.  [Dev Only]
  let ``Database Pages Flushed (Cache Shrink)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Flushed (Cache Shrink)/sec"; instance = instance }
  /// Database Pages Flushed (Checkpoint Foreground)/sec: Database Pages Flushed (Checkpoint Foreground)/sec is the rate that pages are written to the database file(s) from the database cache to keep the checkpoint depth down to configured levels.  [Dev Only]
  let ``Database Pages Flushed (Checkpoint Foreground)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Flushed (Checkpoint Foreground)/sec"; instance = instance }
  /// Database Pages Flushed (Checkpoint)/sec: Database Pages Flushed (Checkpoint)/sec is the rate that pages are written to the database file(s) from the database cache to keep the checkpoint depth down to configured levels.  [Dev Only]
  let ``Database Pages Flushed (Checkpoint)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Flushed (Checkpoint)/sec"; instance = instance }
  /// Database Pages Flushed (Context Flush)/sec: Database Pages Flushed (Context Flush)/sec is the rate that pages are written to the database file(s) from the database cache due to a requested flush of a buffer context.  [Dev Only]
  let ``Database Pages Flushed (Context Flush)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Flushed (Context Flush)/sec"; instance = instance }
  /// Database Pages Flushed (Filthy Foreground)/sec: Database Pages Flushed (Filthy Foreground)/sec is the rate that pages are written to the database file(s) from the database cache because they are marked for filthy / immediate flush.  [Dev Only]
  let ``Database Pages Flushed (Filthy Foreground)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Flushed (Filthy Foreground)/sec"; instance = instance }
  /// Database Pages Flushed (Idle)/sec: Database Pages Flushed (Idle)/sec is the rate that pages are written to the database file(s) from the database cache because there is low disk activity.  [Dev Only]
  let ``Database Pages Flushed (Idle)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Flushed (Idle)/sec"; instance = instance }
  /// Database Pages Flushed (Scavenge)/sec: Database Pages Flushed (Scavenge)/sec is the rate that pages are written to the database file(s) from the database cache to perform available pool maintenance.  [Dev Only]
  let ``Database Pages Flushed (Scavenge)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Flushed (Scavenge)/sec"; instance = instance }
  /// Database Pages Flushed Opportunely Clean/sec: Database Pages Flushed Opportunely Clean/sec is the rate that clean pages are opportunely written to the database file(s) from the database  cache because they happen to be betweeen two other pages that must  be written.  These additional writes are performed in the hope that the total number of IOs required to write all the dirty pages is reduced.  [Dev Only]
  let ``Database Pages Flushed Opportunely Clean/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Flushed Opportunely Clean/sec"; instance = instance }
  /// Database Pages Flushed Opportunely/sec: Database Pages Flushed Opportunely/sec is the rate that pages are written to the database file(s) from the database cache because they happen to be near other pages that must be written.  These additional writes are performed before they must happen in the hope that the total number of IOs required to write all the pages is reduced.  [Dev Only]
  let ``Database Pages Flushed Opportunely/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Flushed Opportunely/sec"; instance = instance }
  /// Database Pages Non-Resident Evicted (Normally)/sec: Database Pages Non-Resident Evicted (Normally)/sec is the number of pages that were paged / trimmed by the OS memory manager, and got evicted normally before being re-used or re-latched. [Dev Only]
  let ``Database Pages Non-Resident Evicted (Normally)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Non-Resident Evicted (Normally)/sec"; instance = instance }
  /// Database Pages Non-Resident Re-read/sec: Database Pages Non-Resident Re-read/sec is the number of pages that could not be reclaimed by soft fault, and must be redirected to the database file as a re-read of the page. [Dev Only]
  let ``Database Pages Non-Resident Re-read/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Non-Resident Re-read/sec"; instance = instance }
  /// Database Pages Non-Resident Reclaimed (Failed)/sec: Database Pages Non-Resident Reclaimed (Failed)/sec is the number of OS soft faults attempted and failed against database pages in the buffer cache. [Dev Only]
  let ``Database Pages Non-Resident Reclaimed (Failed)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Non-Resident Reclaimed (Failed)/sec"; instance = instance }
  /// Database Pages Non-Resident Reclaimed (Soft Faulted)/sec: Database Pages Non-Resident Reclaimed (Soft Faulted)/sec is the number  of OS soft faults attempted and succeeded against database pages in the buffer cache. [Dev Only]
  let ``Database Pages Non-Resident Reclaimed (Soft Faulted)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Non-Resident Reclaimed (Soft Faulted)/sec"; instance = instance }
  /// Database Pages Preread (Unnecessary)/sec: Database Pages Preread (Unnecessary)/sec is the rate that pages are  requested in anticipation of future use but that are already cached by the database cache.  This is non-ideal behavior that represents a waste of processing time.  [Dev Only]
  let ``Database Pages Preread (Unnecessary)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Preread (Unnecessary)/sec"; instance = instance }
  /// Database Pages Preread Untouched/sec: Database Pages Preread Untouched/sec is the rate that pages are read in anticipation of future use from the database file(s) into the database cache that were subsequently thrown out without being used. This is non-ideal behavior that represents a waste of I/O bandwidth and processing time .  [Dev Only]
  let ``Database Pages Preread Untouched/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Preread Untouched/sec"; instance = instance }
  /// Database Pages Preread/sec: Database Pages Preread/sec is the rate that pages are read in anticipation of future use from the database file(s) into the database cache.  [Dev Only]
  let ``Database Pages Preread/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Preread/sec"; instance = instance }
  /// Database Pages Read Async/sec: Database Pages Read Async/sec is the rate that pages are asynchronously read from the database file(s) into the database cache.  [Dev Only]
  let ``Database Pages Read Async/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Read Async/sec"; instance = instance }
  /// Database Pages Read Sync/sec: Database Pages Read Sync/sec is the rate that pages are synchronously read from the database file(s) into the database cache.  [Dev Only]
  let ``Database Pages Read Sync/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Read Sync/sec"; instance = instance }
  /// Database Pages Rehydrated/sec: Database Pages Rehydrated/sec is the rate that pages are uncompressed for active usage or flushing to the database. [Dev Only]
  let ``Database Pages Rehydrated/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Rehydrated/sec"; instance = instance }
  /// Database Pages Repeatedly Read/sec: Database Pages Repeatedly Read/sec is the rate that pages are read from the database file(s) into the database cache more than once a short period of time / within history tracking.  [Dev Only]
  let ``Database Pages Repeatedly Read/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Repeatedly Read/sec"; instance = instance }
  /// Database Pages Repeatedly Written/sec: Database Pages Repeatedly Written/sec is the rate that pages are written to the database file(s) from the database cache more than once in their lifetime in the cache.  These page writes represent extra writes above the theoretical minimum and can therefore be considered overhead.  [Dev Only]
  let ``Database Pages Repeatedly Written/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Repeatedly Written/sec"; instance = instance }
  /// Database Pages Transferred/sec: Database Pages Transferred/sec is the rate that pages are transferred from the database file(s) to the database cache and vice versa.  [Dev Only]
  let ``Database Pages Transferred/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Transferred/sec"; instance = instance }
  /// Database Pages Version Copied/sec: Database Pages Version Copied/sec is the rate at which pages in the database cache are being copied into new pages in the cache for the purpose of being asynchronously written while the current version of that page in the database file is still being modified.  This feature is primarily used to avoid cycles, branches, or long chains of flush order dependencies without requiring the pages involved to be synchronously written to disk.  [Dev Only]
  let ``Database Pages Version Copied/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Version Copied/sec"; instance = instance }
  /// Database Pages Versioned/sec: Database Pages Versioned/sec is the rate at which pages in the database cache are being copied into new pages in the cache for the purpose of being asynchronously written while the current version of that page in the database file is still being modified.  This feature is primarily used to avoid cycles, branches, or long chains of flush order dependencies without requiring the pages involved to be synchronously written to disk.  [Dev Only]
  let ``Database Pages Versioned/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Versioned/sec"; instance = instance }
  /// Database Pages Written/sec: Database Pages Written/sec is the rate that pages are written to the database file(s) from the database cache.  [Dev Only]
  let ``Database Pages Written/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Database Pages Written/sec"; instance = instance }
  /// FCB Async Purge Failures (Active Tasks)/sec: FCB Async Purge Failures (Active Tasks)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record having active tasks.  [Dev Only]
  let ``FCB Async Purge Failures (Active Tasks)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Purge Failures (Active Tasks)/sec"; instance = instance }
  /// FCB Async Purge Failures (Callbacks)/sec: FCB Async Purge Failures (Callbacks)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record having callbacks.  [Dev Only]
  let ``FCB Async Purge Failures (Callbacks)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Purge Failures (Callbacks)/sec"; instance = instance }
  /// FCB Async Purge Failures (Conflicts)/sec: FCB Async Purge Failures (Conflicts)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup.  The purge operation failed because exclusive ownership of the schema record could not be obtained.  [Dev Only]
  let ``FCB Async Purge Failures (Conflicts)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Purge Failures (Conflicts)/sec"; instance = instance }
  /// FCB Async Purge Failures (Delete Pending)/sec: FCB Async Purge Failures (Delete Pending)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record being pending delete.  [Dev Only]
  let ``FCB Async Purge Failures (Delete Pending)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Purge Failures (Delete Pending)/sec"; instance = instance }
  /// FCB Async Purge Failures (In Use)/sec: FCB Async Purge Failures (In Use)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record being in use.  [Dev Only]
  let ``FCB Async Purge Failures (In Use)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Purge Failures (In Use)/sec"; instance = instance }
  /// FCB Async Purge Failures (Index Outstanding)/sec: FCB Async Purge Failures (Index Outstanding)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the index of the record being outstanding.  [Dev Only]
  let ``FCB Async Purge Failures (Index Outstanding)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Purge Failures (Index Outstanding)/sec"; instance = instance }
  /// FCB Async Purge Failures (LV Outstanding)/sec: FCB Async Purge Failures (LV Outstanding)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the LV of the record being outstanding.  [Dev Only]
  let ``FCB Async Purge Failures (LV Outstanding)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Purge Failures (LV Outstanding)/sec"; instance = instance }
  /// FCB Async Purge Failures (Other)/sec: FCB Async Purge Failures (Other)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to other reasons.  [Dev Only]
  let ``FCB Async Purge Failures (Other)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Purge Failures (Other)/sec"; instance = instance }
  /// FCB Async Purge Failures (Outstanding Versions)/sec: FCB Async Purge Failures (Outstanding Versions)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record having outstanding versions.  [Dev Only]
  let ``FCB Async Purge Failures (Outstanding Versions)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Purge Failures (Outstanding Versions)/sec"; instance = instance }
  /// FCB Async Purge Failures (Sentinel)/sec: FCB Async Purge Failures (Sentinel)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record being a sentinel record.  [Dev Only]
  let ``FCB Async Purge Failures (Sentinel)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Purge Failures (Sentinel)/sec"; instance = instance }
  /// FCB Async Purge/sec: FCB Async Purge/sec is the number of cached schema records (FCBs) purged during asynchronous schema record cleanup. These records are purged to age out older schema definitions. [Dev Only]
  let ``FCB Async Purge/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Purge/sec"; instance = instance }
  /// FCB Async Scan/sec: FCB Async Scan/sec is the number of cached schema records (FCBs) scanned during asynchronous schema record cleanup. These records are scanned to age out older schema definitions. [Dev Only]
  let ``FCB Async Scan/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Scan/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Active Tasks)/sec: FCB Async Threshold Purge Failures (Active Tasks)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record having active tasks.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Active Tasks)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Threshold Purge Failures (Active Tasks)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Callbacks)/sec: FCB Async Threshold Purge Failures (Callbacks)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record having callbacks.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Callbacks)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Threshold Purge Failures (Callbacks)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Conflicts)/sec: FCB Async Threshold Purge Failures (Conflicts)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup.  The purge operation failed because exclusive ownership of the schema record could not be obtained.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Conflicts)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Threshold Purge Failures (Conflicts)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Delete Pending)/sec: FCB Async Threshold Purge Failures (Delete Pending)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record being pending delete.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Delete Pending)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Threshold Purge Failures (Delete Pending)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (In Use)/sec: FCB Async Threshold Purge Failures (In Use)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record being in use.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (In Use)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Threshold Purge Failures (In Use)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Index Outstanding)/sec: FCB Async Threshold Purge Failures (Index Outstanding)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the index of the record being outstanding.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Index Outstanding)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Threshold Purge Failures (Index Outstanding)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (LV Outstanding)/sec: FCB Async Threshold Purge Failures (LV Outstanding)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the LV of the record being outstanding.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (LV Outstanding)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Threshold Purge Failures (LV Outstanding)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Other)/sec: FCB Async Threshold Purge Failures (Other)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to other reasons.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Other)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Threshold Purge Failures (Other)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Outstanding Versions)/sec: FCB Async Threshold Purge Failures (Outstanding Versions)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record having outstanding versions.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Outstanding Versions)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Threshold Purge Failures (Outstanding Versions)/sec"; instance = instance }
  /// FCB Async Threshold Purge Failures (Sentinel)/sec: FCB Async Threshold Purge Failures (Sentinel)/sec is the number of failed purge attempts on cached schema records (FCBs) during asynchronous schema record cleanup due to the record being a sentinel record.  [Dev Only]
  let ``FCB Async Threshold Purge Failures (Sentinel)/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Threshold Purge Failures (Sentinel)/sec"; instance = instance }
  /// FCB Async Threshold-Purge/sec: FCB Async Threshold-Purge/sec is the number of cached schema records (FCBs) purged during asynchronous schema record cleanup.  Cleanup was triggered by a large number of schema records above the preferred limit.  These records are aggressively purged to age out older schema definitions.  [Dev Only]
  let ``FCB Async Threshold-Purge/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Threshold-Purge/sec"; instance = instance }
  /// FCB Async Threshold-Scan/sec: FCB Async Threshold-Scan/sec is the number of cached schema records (FCBs) scanned during asynchronous schema record cleanup.  Cleanup was triggered by a large number of schema records above the preferred limit.  These records are aggressively scanned to age out older schema definitions.  [Dev Only]
  let ``FCB Async Threshold-Scan/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Async Threshold-Scan/sec"; instance = instance }
  /// FCB Sync Purge/sec: FCB Sync Purge/sec is the number of cached schema records (FCBs) being synchronously purged each second.  [Dev Only]
  let ``FCB Sync Purge/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "FCB Sync Purge/sec"; instance = instance }
  /// False Index Column Updates/sec: False Index Column Updates/sec is the number of times per second an attempt was made to update an index because an update to at least one of the indexed columns was detected, only to discover that none of the indexed columns had actually changed (and therefore no index update was actually required).  [Dev Only]
  let ``False Index Column Updates/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "False Index Column Updates/sec"; instance = instance }
  /// False Tuple Index Column Updates/sec: False Tuple Index Column Updates/sec is the number of times per second an attempt was made to update a tuple index because an update to the tuple-indexed column was detected, only to discover that the column had not actually changed (and therefore no index update was actually required).  [Dev Only]
  let ``False Tuple Index Column Updates/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "False Tuple Index Column Updates/sec"; instance = instance }
  /// Long-Value Maximum LID: Long-Value Maximum LID is the largest LID that has been used by the database engine for this table class.  [Dev Only]
  let ``Long-Value Maximum LID`` instance =
    { category = "Database ==> TableClasses"; counter = "Long-Value Maximum LID"; instance = instance }
  /// No name: No text
  let ``No name`` instance =
    { category = "Database ==> TableClasses"; counter = "No name"; instance = instance }
  /// Record Deletes/sec: Record Deletes/sec is the rate at which records in database tables are being flagged for deletion.  [Dev Only]
  let ``Record Deletes/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Record Deletes/sec"; instance = instance }
  /// Record Escrow-Updates/sec: Record Escrow-Updates/sec is the rate at which records in database tables are being escrow-updated.  [Dev Only]
  let ``Record Escrow-Updates/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Record Escrow-Updates/sec"; instance = instance }
  /// Record Inserts/sec: Record Inserts/sec is the rate at which records are being inserted into database tables.  [Dev Only]
  let ``Record Inserts/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Record Inserts/sec"; instance = instance }
  /// Record Intrinsic Long-Values Updated/sec: Record Intrinsic Long-Values Updated/sec is the rate at which intrinsic long-values are added to or replaced in records of database tables.  [Dev Only]
  let ``Record Intrinsic Long-Values Updated/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Record Intrinsic Long-Values Updated/sec"; instance = instance }
  /// Record Redundant Replaces/sec: Record Redundant Replaces/sec is the rate at which records in database tables are being updated with the exact same content of the original record.  [Dev Only]
  let ``Record Redundant Replaces/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Record Redundant Replaces/sec"; instance = instance }
  /// Record Replaces/sec: Record Replaces/sec is the rate at which records in database tables are being updated.  [Dev Only]
  let ``Record Replaces/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Record Replaces/sec"; instance = instance }
  /// Record Separated Long-Values Added/sec: Record Separated Long-Values Added/sec is the rate at which separated long-values are normally added to records of database tables.  [Dev Only]
  let ``Record Separated Long-Values Added/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Record Separated Long-Values Added/sec"; instance = instance }
  /// Record Separated Long-Values All Forced/sec: Record Separated Long-Values All Forced/sec is the rate at which all intrinsic long-values are separated out of a record of a database table in order to accommodate updates to the record.  [Dev Only]
  let ``Record Separated Long-Values All Forced/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Record Separated Long-Values All Forced/sec"; instance = instance }
  /// Record Separated Long-Values Dereference All/sec: Record Separated Long-Values Dereference All/sec is the rate at which a reference is removed for all the separated long-values associated with a record of a database table.  [Dev Only]
  let ``Record Separated Long-Values Dereference All/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Record Separated Long-Values Dereference All/sec"; instance = instance }
  /// Record Separated Long-Values Forced/sec: Record Separated Long-Values Forced/sec is the rate at which separated long-values are added to records of a database table because they could not be accommodated in the record itself.  [Dev Only]
  let ``Record Separated Long-Values Forced/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Record Separated Long-Values Forced/sec"; instance = instance }
  /// Record Separated Long-Values Reference All/sec: Record Separated Long-Values Reference All/sec is the rate at which a reference is added for all the separated long-values associated with a record of a database table.  [Dev Only]
  let ``Record Separated Long-Values Reference All/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Record Separated Long-Values Reference All/sec"; instance = instance }
  /// Record Unnecessary Replaces/sec: Record Unnecessary Replaces/sec is the rate at which updates to records in database tables are being discarded because the update did not actually modify the contents of the record.  [Dev Only]
  let ``Record Unnecessary Replaces/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Record Unnecessary Replaces/sec"; instance = instance }
  /// Secondary Index Deletes/sec: Secondary Index Deletes/sec is the rate at which entries in indexes of database tables are being flagged for deletion.  [Dev Only]
  let ``Secondary Index Deletes/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Secondary Index Deletes/sec"; instance = instance }
  /// Secondary Index Inserts/sec: Secondary Index Inserts/sec is the rate at which entries are being inserted into indexes of database tables.  [Dev Only]
  let ``Secondary Index Inserts/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Secondary Index Inserts/sec"; instance = instance }
  /// Separated Long-Value Chunk Appends/sec: Separated Long-Value Chunk Appends/sec is the rate at which chunks are appended to separated long-values of database tables.  [Dev Only]
  let ``Separated Long-Value Chunk Appends/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Separated Long-Value Chunk Appends/sec"; instance = instance }
  /// Separated Long-Value Chunk Copies/sec: Separated Long-Value Chunk Copies/sec is the rate at which existing separated long-value chunks in a database table are copied.  [Dev Only]
  let ``Separated Long-Value Chunk Copies/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Separated Long-Value Chunk Copies/sec"; instance = instance }
  /// Separated Long-Value Chunk Deletes/sec: Separated Long-Value Chunk Deletes/sec is the rate at which separated long-value chunks in a database table are flagged for deletion.  [Dev Only]
  let ``Separated Long-Value Chunk Deletes/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Separated Long-Value Chunk Deletes/sec"; instance = instance }
  /// Separated Long-Value Chunk Replaces/sec: Separated Long-Value Chunk Replaces/sec is the rate at which existing separated long-value chunks in a database table are replaced.  [Dev Only]
  let ``Separated Long-Value Chunk Replaces/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Separated Long-Value Chunk Replaces/sec"; instance = instance }
  /// Separated Long-Value Chunk Retrieves/sec: Separated Long-Value Chunk Retrieves/sec is the rate at which retrievals of a chunk of a separated long-value in a database table are performed.  [Dev Only]
  let ``Separated Long-Value Chunk Retrieves/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Separated Long-Value Chunk Retrieves/sec"; instance = instance }
  /// Separated Long-Value Chunk Seeks/sec: Separated Long-Value Chunk Seeks/sec is the rate at which seeks for a particular chunk of a separated long-value in a database table are performed.  [Dev Only]
  let ``Separated Long-Value Chunk Seeks/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Separated Long-Value Chunk Seeks/sec"; instance = instance }
  /// Separated Long-Value Copies/sec: Separated Long-Value Copies/sec is the rate at which existing separated long-values in a database table are copied.  [Dev Only]
  let ``Separated Long-Value Copies/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Separated Long-Value Copies/sec"; instance = instance }
  /// Separated Long-Value Creates/sec: Separated Long-Value Creates/sec is the rate at which new separated long-values are added to a database table.  [Dev Only]
  let ``Separated Long-Value Creates/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Separated Long-Value Creates/sec"; instance = instance }
  /// Separated Long-Value Deletes/sec: Separated Long-Value Deletes/sec is the rate at which separated long-values in a database table are flagged for deletion.  [Dev Only]
  let ``Separated Long-Value Deletes/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Separated Long-Value Deletes/sec"; instance = instance }
  /// Separated Long-Value Retrieves/sec: Separated Long-Value Retrieves/sec is the rate at which retrievals of a separated long-value in a database table are performed.  [Dev Only]
  let ``Separated Long-Value Retrieves/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Separated Long-Value Retrieves/sec"; instance = instance }
  /// Separated Long-Value Seeks/sec: Separated Long-Value Seeks/sec is the rate at which seeks for a separated long-value in a database table are performed.  [Dev Only]
  let ``Separated Long-Value Seeks/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Separated Long-Value Seeks/sec"; instance = instance }
  /// Separated Long-Value Updates/sec: Separated Long-Value Updates/sec is the rate at which existing separated long-values in a database table are modified.  [Dev Only]
  let ``Separated Long-Value Updates/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Separated Long-Value Updates/sec"; instance = instance }
  /// Table Open Pages Preread/sec: Table Open Pages Preread/sec is the number of database pages pre-read without using cached schema information per second.  If this rate is too high, the table cache size may be too small. [Dev Only]
  let ``Table Open Pages Preread/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Table Open Pages Preread/sec"; instance = instance }
  /// Table Open Pages Read/sec: Table Open Pages Read/sec is the number of database pages read without using cached schema information per second.  If this rate is too high, the table cache size may be too small. [Dev Only]
  let ``Table Open Pages Read/sec`` instance =
    { category = "Database ==> TableClasses"; counter = "Table Open Pages Read/sec"; instance = instance }

  let allCounters =
    [ ``B+ Tree Append Splits/sec``
      ``B+ Tree Appends/sec``
      ``B+ Tree Creates (Total)``
      ``B+ Tree Creates/sec``
      ``B+ Tree Deletes/sec``
      ``B+ Tree Destroys (Total)``
      ``B+ Tree Destroys/sec``
      ``B+ Tree Empty Page Merges/sec``
      ``B+ Tree Failed Simple Page Cleanup Attempts/sec``
      ``B+ Tree Flag Deletes/sec``
      ``B+ Tree Inserts/sec``
      ``B+ Tree Left Merges/sec``
      ``B+ Tree Merges/sec``
      ``B+ Tree Move Nexts (Nodes Filtered)/sec``
      ``B+ Tree Move Nexts (Non-Visible Nodes Skipped)/sec``
      ``B+ Tree Move Nexts/sec``
      ``B+ Tree Move Prevs (Nodes Filtered)/sec``
      ``B+ Tree Move Prevs (Non-Visible Nodes Skipped)/sec``
      ``B+ Tree Move Prevs/sec``
      ``B+ Tree Opportune Prereads/sec``
      ``B+ Tree Page Moves/sec``
      ``B+ Tree Partial Left Merges/sec``
      ``B+ Tree Partial Merges/sec``
      ``B+ Tree Replaces/sec``
      ``B+ Tree Right Hotpoint Splits/sec``
      ``B+ Tree Right Merges/sec``
      ``B+ Tree Right Splits/sec``
      ``B+ Tree Seek Short Circuits/sec``
      ``B+ Tree Seeks/sec``
      ``B+ Tree Splits/sec``
      ``B+ Tree Unnecessary Sibling Latches/sec``
      ``B+ Tree Vertical Splits/sec``
      ``Database Cache % Hit``
      ``Database Cache % Hit (Uncorrelated)``
      ``Database Cache Misses/sec``
      ``Database Cache Requests/sec``
      ``Database Cache Size``
      ``Database Cache Size (MB)``
      ``Database Page Evictions (Patch)/sec``
      ``Database Page Evictions (Purge)/sec``
      ``Database Page Evictions (Scavenging)/sec``
      ``Database Page Evictions (Shrink)/sec``
      ``Database Page Evictions (k=1)/sec``
      ``Database Page Evictions (k=2)/sec``
      ``Database Page Preread Stalls/sec``
      ``Database Page Touches (Correlated)/sec``
      ``Database Page Touches (Non-Touch)/sec``
      ``Database Page Touches (k=1)/sec``
      ``Database Page Touches (k=2)/sec``
      ``Database Pages Coalesced Read/sec``
      ``Database Pages Coalesced Written/sec``
      ``Database Pages Colded (Ext)/sec``
      ``Database Pages Colded (Int)/sec``
      ``Database Pages Dehydrated/sec``
      ``Database Pages Dirtied (Repeatedly)/sec``
      ``Database Pages Dirtied/sec``
      ``Database Pages Flushed (Cache Shrink)/sec``
      ``Database Pages Flushed (Checkpoint Foreground)/sec``
      ``Database Pages Flushed (Checkpoint)/sec``
      ``Database Pages Flushed (Context Flush)/sec``
      ``Database Pages Flushed (Filthy Foreground)/sec``
      ``Database Pages Flushed (Idle)/sec``
      ``Database Pages Flushed (Scavenge)/sec``
      ``Database Pages Flushed Opportunely Clean/sec``
      ``Database Pages Flushed Opportunely/sec``
      ``Database Pages Non-Resident Evicted (Normally)/sec``
      ``Database Pages Non-Resident Re-read/sec``
      ``Database Pages Non-Resident Reclaimed (Failed)/sec``
      ``Database Pages Non-Resident Reclaimed (Soft Faulted)/sec``
      ``Database Pages Preread (Unnecessary)/sec``
      ``Database Pages Preread Untouched/sec``
      ``Database Pages Preread/sec``
      ``Database Pages Read Async/sec``
      ``Database Pages Read Sync/sec``
      ``Database Pages Rehydrated/sec``
      ``Database Pages Repeatedly Read/sec``
      ``Database Pages Repeatedly Written/sec``
      ``Database Pages Transferred/sec``
      ``Database Pages Version Copied/sec``
      ``Database Pages Versioned/sec``
      ``Database Pages Written/sec``
      ``FCB Async Purge Failures (Active Tasks)/sec``
      ``FCB Async Purge Failures (Callbacks)/sec``
      ``FCB Async Purge Failures (Conflicts)/sec``
      ``FCB Async Purge Failures (Delete Pending)/sec``
      ``FCB Async Purge Failures (In Use)/sec``
      ``FCB Async Purge Failures (Index Outstanding)/sec``
      ``FCB Async Purge Failures (LV Outstanding)/sec``
      ``FCB Async Purge Failures (Other)/sec``
      ``FCB Async Purge Failures (Outstanding Versions)/sec``
      ``FCB Async Purge Failures (Sentinel)/sec``
      ``FCB Async Purge/sec``
      ``FCB Async Scan/sec``
      ``FCB Async Threshold Purge Failures (Active Tasks)/sec``
      ``FCB Async Threshold Purge Failures (Callbacks)/sec``
      ``FCB Async Threshold Purge Failures (Conflicts)/sec``
      ``FCB Async Threshold Purge Failures (Delete Pending)/sec``
      ``FCB Async Threshold Purge Failures (In Use)/sec``
      ``FCB Async Threshold Purge Failures (Index Outstanding)/sec``
      ``FCB Async Threshold Purge Failures (LV Outstanding)/sec``
      ``FCB Async Threshold Purge Failures (Other)/sec``
      ``FCB Async Threshold Purge Failures (Outstanding Versions)/sec``
      ``FCB Async Threshold Purge Failures (Sentinel)/sec``
      ``FCB Async Threshold-Purge/sec``
      ``FCB Async Threshold-Scan/sec``
      ``FCB Sync Purge/sec``
      ``False Index Column Updates/sec``
      ``False Tuple Index Column Updates/sec``
      ``Long-Value Maximum LID``
      ``No name``
      ``Record Deletes/sec``
      ``Record Escrow-Updates/sec``
      ``Record Inserts/sec``
      ``Record Intrinsic Long-Values Updated/sec``
      ``Record Redundant Replaces/sec``
      ``Record Replaces/sec``
      ``Record Separated Long-Values Added/sec``
      ``Record Separated Long-Values All Forced/sec``
      ``Record Separated Long-Values Dereference All/sec``
      ``Record Separated Long-Values Forced/sec``
      ``Record Separated Long-Values Reference All/sec``
      ``Record Unnecessary Replaces/sec``
      ``Secondary Index Deletes/sec``
      ``Secondary Index Inserts/sec``
      ``Separated Long-Value Chunk Appends/sec``
      ``Separated Long-Value Chunk Copies/sec``
      ``Separated Long-Value Chunk Deletes/sec``
      ``Separated Long-Value Chunk Replaces/sec``
      ``Separated Long-Value Chunk Retrieves/sec``
      ``Separated Long-Value Chunk Seeks/sec``
      ``Separated Long-Value Copies/sec``
      ``Separated Long-Value Creates/sec``
      ``Separated Long-Value Deletes/sec``
      ``Separated Long-Value Retrieves/sec``
      ``Separated Long-Value Seeks/sec``
      ``Separated Long-Value Updates/sec``
      ``Table Open Pages Preread/sec``
      ``Table Open Pages Read/sec``
    ]

/// Distributed Routing Table: The Distributed Routing Table (DRT) performance object consists of counters that monitor the local DRT cache as well as counters that measure the rates at which DRT protocol messages are sent and received.
///
/// This performance counter does not have instance based counters
module ``Distributed Routing Table`` =

  [<Literal>]
  let Category = "Distributed Routing Table"

  let PCC = getPCC Category
  /// Ack Messages Received/second: -
  let ``Ack Messages Received/second`` instance =
    { category = "Distributed Routing Table"; counter = "Ack Messages Received/second"; instance = instance }
  /// Ack Messages Sent/second: -
  let ``Ack Messages Sent/second`` instance =
    { category = "Distributed Routing Table"; counter = "Ack Messages Sent/second"; instance = instance }
  /// Advertise Messages Received/second: -
  let ``Advertise Messages Received/second`` instance =
    { category = "Distributed Routing Table"; counter = "Advertise Messages Received/second"; instance = instance }
  /// Advertise Messages Sent/second: -
  let ``Advertise Messages Sent/second`` instance =
    { category = "Distributed Routing Table"; counter = "Advertise Messages Sent/second"; instance = instance }
  /// Authority Messages Received/second: -
  let ``Authority Messages Received/second`` instance =
    { category = "Distributed Routing Table"; counter = "Authority Messages Received/second"; instance = instance }
  /// Authority Sent/second: -
  let ``Authority Sent/second`` instance =
    { category = "Distributed Routing Table"; counter = "Authority Sent/second"; instance = instance }
  /// Average Bytes/second Received: -
  let ``Average Bytes/second Received`` instance =
    { category = "Distributed Routing Table"; counter = "Average Bytes/second Received"; instance = instance }
  /// Average Bytes/second Sent: -
  let ``Average Bytes/second Sent`` instance =
    { category = "Distributed Routing Table"; counter = "Average Bytes/second Sent"; instance = instance }
  /// Cache Entries: -
  let ``Cache Entries`` instance =
    { category = "Distributed Routing Table"; counter = "Cache Entries"; instance = instance }
  /// Estimated cloud size: -
  let ``Estimated cloud size`` instance =
    { category = "Distributed Routing Table"; counter = "Estimated cloud size"; instance = instance }
  /// Flood Messages Received/second: -
  let ``Flood Messages Received/second`` instance =
    { category = "Distributed Routing Table"; counter = "Flood Messages Received/second"; instance = instance }
  /// Flood Messages Sent/second: -
  let ``Flood Messages Sent/second`` instance =
    { category = "Distributed Routing Table"; counter = "Flood Messages Sent/second"; instance = instance }
  /// Inquire Messages Received/second: -
  let ``Inquire Messages Received/second`` instance =
    { category = "Distributed Routing Table"; counter = "Inquire Messages Received/second"; instance = instance }
  /// Inquire Messages Sent/second: -
  let ``Inquire Messages Sent/second`` instance =
    { category = "Distributed Routing Table"; counter = "Inquire Messages Sent/second"; instance = instance }
  /// Lookup Messages Received/second: -
  let ``Lookup Messages Received/second`` instance =
    { category = "Distributed Routing Table"; counter = "Lookup Messages Received/second"; instance = instance }
  /// Lookup Messages Sent/second: -
  let ``Lookup Messages Sent/second`` instance =
    { category = "Distributed Routing Table"; counter = "Lookup Messages Sent/second"; instance = instance }
  /// Receive Failures: -
  let ``Receive Failures`` instance =
    { category = "Distributed Routing Table"; counter = "Receive Failures"; instance = instance }
  /// Registrations: -
  let ``Registrations`` instance =
    { category = "Distributed Routing Table"; counter = "Registrations"; instance = instance }
  /// Request Messages Received/second: -
  let ``Request Messages Received/second`` instance =
    { category = "Distributed Routing Table"; counter = "Request Messages Received/second"; instance = instance }
  /// Request Messages Sent/second: -
  let ``Request Messages Sent/second`` instance =
    { category = "Distributed Routing Table"; counter = "Request Messages Sent/second"; instance = instance }
  /// Searches: -
  let ``Searches`` instance =
    { category = "Distributed Routing Table"; counter = "Searches"; instance = instance }
  /// Send Failures: -
  let ``Send Failures`` instance =
    { category = "Distributed Routing Table"; counter = "Send Failures"; instance = instance }
  /// Solicit Messages Received/second: -
  let ``Solicit Messages Received/second`` instance =
    { category = "Distributed Routing Table"; counter = "Solicit Messages Received/second"; instance = instance }
  /// Solicit Messages Sent/second: -
  let ``Solicit Messages Sent/second`` instance =
    { category = "Distributed Routing Table"; counter = "Solicit Messages Sent/second"; instance = instance }
  /// Stale Cache Entries: -
  let ``Stale Cache Entries`` instance =
    { category = "Distributed Routing Table"; counter = "Stale Cache Entries"; instance = instance }
  /// Unrecognized Messages Received: -
  let ``Unrecognized Messages Received`` instance =
    { category = "Distributed Routing Table"; counter = "Unrecognized Messages Received"; instance = instance }

  let allCounters =
    [ ``Ack Messages Received/second``
      ``Ack Messages Sent/second``
      ``Advertise Messages Received/second``
      ``Advertise Messages Sent/second``
      ``Authority Messages Received/second``
      ``Authority Sent/second``
      ``Average Bytes/second Received``
      ``Average Bytes/second Sent``
      ``Cache Entries``
      ``Estimated cloud size``
      ``Flood Messages Received/second``
      ``Flood Messages Sent/second``
      ``Inquire Messages Received/second``
      ``Inquire Messages Sent/second``
      ``Lookup Messages Received/second``
      ``Lookup Messages Sent/second``
      ``Receive Failures``
      ``Registrations``
      ``Request Messages Received/second``
      ``Request Messages Sent/second``
      ``Searches``
      ``Send Failures``
      ``Solicit Messages Received/second``
      ``Solicit Messages Sent/second``
      ``Stale Cache Entries``
      ``Unrecognized Messages Received``
    ]

/// Event Tracing for Windows: The counters in this collection refer to system-wide metrics about the performance of the Event Tracing for Windows subsystem.
///
/// This performance counter does not have instance based counters
module ``Event Tracing for Windows`` =

  [<Literal>]
  let Category = "Event Tracing for Windows"

  let PCC = getPCC Category
  /// Total Memory Usage --- Non-Paged Pool: Current size of non-paged memory allocated for the buffers associated with all active sessions (in bytes).
  let ``Total Memory Usage --- Non-Paged Pool`` =
    { category = "Event Tracing for Windows"; counter = "Total Memory Usage --- Non-Paged Pool"; instance = NotApplicable }
  /// Total Memory Usage --- Paged Pool: Current size of paged memory allocated for the buffers associated with all active sessions (in bytes).
  let ``Total Memory Usage --- Paged Pool`` =
    { category = "Event Tracing for Windows"; counter = "Total Memory Usage --- Paged Pool"; instance = NotApplicable }
  /// Total Number of Active Sessions: Number of ETW tracing sessions currently active.
  let ``Total Number of Active Sessions`` =
    { category = "Event Tracing for Windows"; counter = "Total Number of Active Sessions"; instance = NotApplicable }
  /// Total Number of Distinct Disabled Providers: Number of unique tracing providers that are registered with the tracing subsystem but are not actively enabled to any trace session; multiple registered instances of a provider are counted only once.
  let ``Total Number of Distinct Disabled Providers`` =
    { category = "Event Tracing for Windows"; counter = "Total Number of Distinct Disabled Providers"; instance = NotApplicable }
  /// Total Number of Distinct Enabled Providers: Number of distinct event providers that are enabled to ETW sessions; multiple instances of a provider are counted only once.
  let ``Total Number of Distinct Enabled Providers`` =
    { category = "Event Tracing for Windows"; counter = "Total Number of Distinct Enabled Providers"; instance = NotApplicable }
  /// Total Number of Distinct Pre-Enabled Providers: Number of unique tracing providers that have been enabled to a trace session but have not yet registered with ETW.
  let ``Total Number of Distinct Pre-Enabled Providers`` =
    { category = "Event Tracing for Windows"; counter = "Total Number of Distinct Pre-Enabled Providers"; instance = NotApplicable }

  let allCounters =
    [ ``Total Memory Usage --- Non-Paged Pool``
      ``Total Memory Usage --- Paged Pool``
      ``Total Number of Active Sessions``
      ``Total Number of Distinct Disabled Providers``
      ``Total Number of Distinct Enabled Providers``
      ``Total Number of Distinct Pre-Enabled Providers``
    ]

/// Event Tracing for Windows Session: The counters in this collection are related to individual Event Tracing for Windows sessions.
///
/// This performance counter does not have non-instance based counters
module ``Event Tracing for Windows Session`` =

  [<Literal>]
  let Category = "Event Tracing for Windows Session"

  let PCC = getPCC Category
  /// Buffer Memory Usage -- Non-Paged Pool: Current size of non-paged memory allocated for the buffers associated with this session (in bytes).
  let ``Buffer Memory Usage -- Non-Paged Pool`` instance =
    { category = "Event Tracing for Windows Session"; counter = "Buffer Memory Usage -- Non-Paged Pool"; instance = instance }
  /// Buffer Memory Usage -- Paged Pool: Current size of paged memory allocated for the buffers associated with this session (in bytes).
  let ``Buffer Memory Usage -- Paged Pool`` instance =
    { category = "Event Tracing for Windows Session"; counter = "Buffer Memory Usage -- Paged Pool"; instance = instance }
  /// Events Logged per sec: Rate at which events are logged to this session by providers that are enabled to this session (events/sec).
  let ``Events Logged per sec`` instance =
    { category = "Event Tracing for Windows Session"; counter = "Events Logged per sec"; instance = instance }
  /// Events Lost: Total number of events that were not successfully logged since the start of the tracing session.  Events are lost due to limited space in the session's buffers.  To avoid lost events, consider increasing the buffer size or the number of buffers.
  let ``Events Lost`` instance =
    { category = "Event Tracing for Windows Session"; counter = "Events Lost"; instance = instance }
  /// Number of Real-Time Consumers: Number of consumers currently reading events from this session in real-time mode.
  let ``Number of Real-Time Consumers`` instance =
    { category = "Event Tracing for Windows Session"; counter = "Number of Real-Time Consumers"; instance = instance }

  let allCounters =
    [ ``Buffer Memory Usage -- Non-Paged Pool``
      ``Buffer Memory Usage -- Paged Pool``
      ``Events Logged per sec``
      ``Events Lost``
      ``Number of Real-Time Consumers``
    ]

/// F-Secure Email Scanning: Performance counters for F-Secure Anti-Virus Email Scanning
///
/// This performance counter does not have instance based counters
module ``F-Secure Email Scanning`` =

  [<Literal>]
  let Category = "F-Secure Email Scanning"

  let PCC = getPCC Category
  /// # of IMAP4 sessions: Total number of IMAP4 sessions handled since scanner startup.
  let ``# of IMAP4 sessions`` =
    { category = "F-Secure Email Scanning"; counter = "# of IMAP4 sessions"; instance = NotApplicable }
  /// # of POP3 connections: Total number of POP3 connections handled since scanner startup.
  let ``# of POP3 connections`` =
    { category = "F-Secure Email Scanning"; counter = "# of POP3 connections"; instance = NotApplicable }
  /// # of SMTP connections: Total number of POP3 connections handled since scanner startup.
  let ``# of SMTP connections`` =
    { category = "F-Secure Email Scanning"; counter = "# of SMTP connections"; instance = NotApplicable }
  /// # of blocked scan requests: Total number of scan requests blocked since scanner startup.
  let ``# of blocked scan requests`` =
    { category = "F-Secure Email Scanning"; counter = "# of blocked scan requests"; instance = NotApplicable }
  /// # of disinfected scan requests: Total number of scan requests disinfected since scanner startup.
  let ``# of disinfected scan requests`` =
    { category = "F-Secure Email Scanning"; counter = "# of disinfected scan requests"; instance = NotApplicable }
  /// # of failed scan requests: Total number of scan requests failed since scanner startup.
  let ``# of failed scan requests`` =
    { category = "F-Secure Email Scanning"; counter = "# of failed scan requests"; instance = NotApplicable }
  /// # of scan requests: Total number of scan requests executed since scanner startup.
  let ``# of scan requests`` =
    { category = "F-Secure Email Scanning"; counter = "# of scan requests"; instance = NotApplicable }
  /// Active connections (kernel): Number of active kernel connections.
  let ``Active connections (kernel)`` =
    { category = "F-Secure Email Scanning"; counter = "Active connections (kernel)"; instance = NotApplicable }
  /// Memory allocation failures (kernel): Number of failed memory allocations from kernel heap.
  let ``Memory allocation failures (kernel)`` =
    { category = "F-Secure Email Scanning"; counter = "Memory allocation failures (kernel)"; instance = NotApplicable }
  /// Memory blocks allocated: Number of memory blocks allocated.
  let ``Memory blocks allocated`` =
    { category = "F-Secure Email Scanning"; counter = "Memory blocks allocated"; instance = NotApplicable }
  /// Memory blocks allocated (kernel): Number of kernel memory blocks allocated.
  let ``Memory blocks allocated (kernel)`` =
    { category = "F-Secure Email Scanning"; counter = "Memory blocks allocated (kernel)"; instance = NotApplicable }
  /// Memory bytes allocated: Number of bytes allocated from heap.
  let ``Memory bytes allocated`` =
    { category = "F-Secure Email Scanning"; counter = "Memory bytes allocated"; instance = NotApplicable }
  /// Memory bytes allocated (kernel): Number of bytes allocated from kernel heap.
  let ``Memory bytes allocated (kernel)`` =
    { category = "F-Secure Email Scanning"; counter = "Memory bytes allocated (kernel)"; instance = NotApplicable }

  let allCounters =
    [ ``# of IMAP4 sessions``
      ``# of POP3 connections``
      ``# of SMTP connections``
      ``# of blocked scan requests``
      ``# of disinfected scan requests``
      ``# of failed scan requests``
      ``# of scan requests``
      ``Active connections (kernel)``
      ``Memory allocation failures (kernel)``
      ``Memory blocks allocated``
      ``Memory blocks allocated (kernel)``
      ``Memory bytes allocated``
      ``Memory bytes allocated (kernel)``
    ]

/// Fax Service: Fax Service Counter Set
///
/// This performance counter does not have instance based counters
module ``Fax Service`` =

  [<Literal>]
  let Category = "Fax Service"

  let PCC = getPCC Category
  /// Bytes received: Number of bytes received.
  let ``Bytes received`` =
    { category = "Fax Service"; counter = "Bytes received"; instance = NotApplicable }
  /// Bytes sent: Number of bytes sent.
  let ``Bytes sent`` =
    { category = "Fax Service"; counter = "Bytes sent"; instance = NotApplicable }
  /// Failed faxes transmissions: Number of faxes that failed.
  let ``Failed faxes transmissions`` =
    { category = "Fax Service"; counter = "Failed faxes transmissions"; instance = NotApplicable }
  /// Failed outgoing connections: Number of outgoing connections that failed.
  let ``Failed outgoing connections`` =
    { category = "Fax Service"; counter = "Failed outgoing connections"; instance = NotApplicable }
  /// Failed receptions: Number of faxes that service failed to receive.
  let ``Failed receptions`` =
    { category = "Fax Service"; counter = "Failed receptions"; instance = NotApplicable }
  /// Faxes sent: Number of faxes successfully sent.
  let ``Faxes sent`` =
    { category = "Fax Service"; counter = "Faxes sent"; instance = NotApplicable }
  /// Minutes receiving: Number of minutes that the service received faxes.
  let ``Minutes receiving`` =
    { category = "Fax Service"; counter = "Minutes receiving"; instance = NotApplicable }
  /// Minutes sending: Number of minutes that the service spent in sending successfully transmitted faxes.
  let ``Minutes sending`` =
    { category = "Fax Service"; counter = "Minutes sending"; instance = NotApplicable }
  /// Pages sent: Number of pages sent.
  let ``Pages sent`` =
    { category = "Fax Service"; counter = "Pages sent"; instance = NotApplicable }
  /// Received faxes: Number of successfully received faxes.
  let ``Received faxes`` =
    { category = "Fax Service"; counter = "Received faxes"; instance = NotApplicable }
  /// Received pages: Number of pages received.
  let ``Received pages`` =
    { category = "Fax Service"; counter = "Received pages"; instance = NotApplicable }
  /// Total bytes: Total number of bytes sent and received.
  let ``Total bytes`` =
    { category = "Fax Service"; counter = "Total bytes"; instance = NotApplicable }
  /// Total faxes sent and received: Total number of faxes sent and received.
  let ``Total faxes sent and received`` =
    { category = "Fax Service"; counter = "Total faxes sent and received"; instance = NotApplicable }
  /// Total minutes sending and receiving: Total number of minutes that the service sent and received faxes.
  let ``Total minutes sending and receiving`` =
    { category = "Fax Service"; counter = "Total minutes sending and receiving"; instance = NotApplicable }
  /// Total pages: Total number of pages sent and received.
  let ``Total pages`` =
    { category = "Fax Service"; counter = "Total pages"; instance = NotApplicable }

  let allCounters =
    [ ``Bytes received``
      ``Bytes sent``
      ``Failed faxes transmissions``
      ``Failed outgoing connections``
      ``Failed receptions``
      ``Faxes sent``
      ``Minutes receiving``
      ``Minutes sending``
      ``Pages sent``
      ``Received faxes``
      ``Received pages``
      ``Total bytes``
      ``Total faxes sent and received``
      ``Total minutes sending and receiving``
      ``Total pages``
    ]

/// FileSystem Disk Activity: The FileSystem Disk Activity performance counter set consists of counters that measure the aspect of filesystem's IO Activity.  This counter set measures the number of bytes filesystem read from and wrote to the disk drive.
///
/// This performance counter does not have non-instance based counters
module ``FileSystem Disk Activity`` =

  [<Literal>]
  let Category = "FileSystem Disk Activity"

  let PCC = getPCC Category
  /// FileSystem Bytes Read: Total Bytes Read by the FileSystem from disk drive
  let ``FileSystem Bytes Read`` instance =
    { category = "FileSystem Disk Activity"; counter = "FileSystem Bytes Read"; instance = instance }
  /// FileSystem Bytes Written: Total Bytes Written by the FileSystem from disk drive
  let ``FileSystem Bytes Written`` instance =
    { category = "FileSystem Disk Activity"; counter = "FileSystem Bytes Written"; instance = instance }

  let allCounters =
    [ ``FileSystem Bytes Read``
      ``FileSystem Bytes Written``
    ]

/// Generic IKEv1, AuthIP, and IKEv2: Generic IKEv1, AuthIP, and IKEv2 is the set of Internet Protocol security (IPsec) Internet Key Exchange Version 1 (IKEv1), Authenticated IP (AuthIP), and Internet Key Exchange Version 2 (IKEv2) counters that are generic and do not apply to a specific Internet Protocol version.
///
/// This performance counter does not have instance based counters
module ``Generic IKEv1_ AuthIP_ and IKEv2`` =

  [<Literal>]
  let Category = "Generic IKEv1, AuthIP, and IKEv2"

  let PCC = getPCC Category
  /// AuthIP Main Mode Negotiation Time: AuthIP Main Mode Negotiation Time is the number of milliseconds taken for the last Authenticated IP main mode security association negotiated.
  let ``AuthIP Main Mode Negotiation Time`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "AuthIP Main Mode Negotiation Time"; instance = NotApplicable }
  /// AuthIP Quick Mode Negotiation Time: AuthIP Quick Mode Negotiation Time is the number of milliseconds taken for the last Authenticated IP quick mode security association negotiated.
  let ``AuthIP Quick Mode Negotiation Time`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "AuthIP Quick Mode Negotiation Time"; instance = NotApplicable }
  /// Extended Mode Negotiation Time: Extended Mode Negotiation Time is the number of milliseconds taken for the last extended mode security association negotiated.
  let ``Extended Mode Negotiation Time`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "Extended Mode Negotiation Time"; instance = NotApplicable }
  /// Failed Negotiations: Failed Negotiations is the number of failed negotiations for IKEv1, AuthIP, and IKEv2 since IPsec was last started.
  let ``Failed Negotiations`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "Failed Negotiations"; instance = NotApplicable }
  /// Failed Negotiations/sec: Failed Negotiations per Second is the rate of failed negotiations attempted for IKEv1, AuthIP, and IKEv2.
  let ``Failed Negotiations/sec`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "Failed Negotiations/sec"; instance = NotApplicable }
  /// IKEv1 Main Mode Negotiation Time: IKEv1 Main Mode Negotiation Time is the number of milliseconds taken for the last IKEv1 main mode security association negotiated.
  let ``IKEv1 Main Mode Negotiation Time`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "IKEv1 Main Mode Negotiation Time"; instance = NotApplicable }
  /// IKEv1 Quick Mode Negotiation Time: IKEv1 Quick Mode Negotiation Time is the number of milliseconds taken for the last IKEv1 quick mode security association negotiated.
  let ``IKEv1 Quick Mode Negotiation Time`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "IKEv1 Quick Mode Negotiation Time"; instance = NotApplicable }
  /// IKEv2 Main Mode Negotiation Time: IKEv2 Main Mode Negotiation Time is the number of milliseconds taken for the last IKEv2 main mode security association negotiated.
  let ``IKEv2 Main Mode Negotiation Time`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "IKEv2 Main Mode Negotiation Time"; instance = NotApplicable }
  /// IKEv2 Quick Mode Negotiation Time: IKEv2 Quick Mode Negotiation Time is the number of milliseconds taken for the last IKEv2 quick mode security association negotiated.
  let ``IKEv2 Quick Mode Negotiation Time`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "IKEv2 Quick Mode Negotiation Time"; instance = NotApplicable }
  /// Invalid Packets Received/sec: Invalid Packets Received per Second is the rate at which invalid IPsec packets are being received.
  let ``Invalid Packets Received/sec`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "Invalid Packets Received/sec"; instance = NotApplicable }
  /// Packets Received/sec: Packets Received per Second is the rate at which validated IPsec packets are being received.
  let ``Packets Received/sec`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "Packets Received/sec"; instance = NotApplicable }
  /// Successful Negotiations: Successful Negotiations is the number of negotiations completed for IKEv1, AuthIP, and IKEv2 since IPsec was last started.
  let ``Successful Negotiations`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "Successful Negotiations"; instance = NotApplicable }
  /// Successful Negotiations/sec: Successful Negotiations per Second is the rate of negotiations completed for IKEv1, AuthIP, and IKEv2.
  let ``Successful Negotiations/sec`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "Successful Negotiations/sec"; instance = NotApplicable }

  let allCounters =
    [ ``AuthIP Main Mode Negotiation Time``
      ``AuthIP Quick Mode Negotiation Time``
      ``Extended Mode Negotiation Time``
      ``Failed Negotiations``
      ``Failed Negotiations/sec``
      ``IKEv1 Main Mode Negotiation Time``
      ``IKEv1 Quick Mode Negotiation Time``
      ``IKEv2 Main Mode Negotiation Time``
      ``IKEv2 Quick Mode Negotiation Time``
      ``Invalid Packets Received/sec``
      ``Packets Received/sec``
      ``Successful Negotiations``
      ``Successful Negotiations/sec``
    ]

/// HTTP Service: Set of HTTP service counters
///
/// This performance counter does not have instance based counters
module ``HTTP Service`` =

  [<Literal>]
  let Category = "HTTP Service"

  let PCC = getPCC Category
  /// CurrentUrisCached: Total number of URIs currently cached by the kernel
  let ``CurrentUrisCached`` =
    { category = "HTTP Service"; counter = "CurrentUrisCached"; instance = NotApplicable }
  /// TotalFlushedUris: Total number of URIs that have been removed from the kernel URI cache since service startup
  let ``TotalFlushedUris`` =
    { category = "HTTP Service"; counter = "TotalFlushedUris"; instance = NotApplicable }
  /// TotalUrisCached: Total number of URIs added to the kernel since service startup
  let ``TotalUrisCached`` =
    { category = "HTTP Service"; counter = "TotalUrisCached"; instance = NotApplicable }
  /// UriCacheFlushes: Total number of kernel URI cache flushes (complete or partial) since service startup
  let ``UriCacheFlushes`` =
    { category = "HTTP Service"; counter = "UriCacheFlushes"; instance = NotApplicable }
  /// UriCacheHits: Total number of successful lookups in the kernel URI cache
  let ``UriCacheHits`` =
    { category = "HTTP Service"; counter = "UriCacheHits"; instance = NotApplicable }
  /// UriCacheMisses: Total number of unsuccessful lookups in the kernel URI cache
  let ``UriCacheMisses`` =
    { category = "HTTP Service"; counter = "UriCacheMisses"; instance = NotApplicable }

  let allCounters =
    [ ``CurrentUrisCached``
      ``TotalFlushedUris``
      ``TotalUrisCached``
      ``UriCacheFlushes``
      ``UriCacheHits``
      ``UriCacheMisses``
    ]

/// Hyper-V Dynamic Memory Balancer: This counter set represents the statistics for the Microsoft Dynamic Memory Balancer.
///
/// This performance counter does not have non-instance based counters
module ``Hyper-V Dynamic Memory Balancer`` =

  [<Literal>]
  let Category = "Hyper-V Dynamic Memory Balancer"

  let PCC = getPCC Category
  /// Available Memory: This counter represents the amount of memory left on the node.
  let ``Available Memory`` instance =
    { category = "Hyper-V Dynamic Memory Balancer"; counter = "Available Memory"; instance = instance }
  /// Average Pressure: This counter represents the average system pressure on the balancer node among all balanced objects.
  let ``Average Pressure`` instance =
    { category = "Hyper-V Dynamic Memory Balancer"; counter = "Average Pressure"; instance = instance }

  let allCounters =
    [ ``Available Memory``
      ``Average Pressure``
    ]

/// Hyper-V Dynamic Memory Integration Service: This counter set represents the statistics for Dynamic Memory Integration Services
///
/// This performance counter does not have instance based counters
module ``Hyper-V Dynamic Memory Integration Service`` =

  [<Literal>]
  let Category = "Hyper-V Dynamic Memory Integration Service"

  let PCC = getPCC Category
  /// Maximum Memory, Mbytes: 
  let ``Maximum Memory, Mbytes`` =
    { category = "Hyper-V Dynamic Memory Integration Service"; counter = "Maximum Memory, Mbytes"; instance = NotApplicable }

  let allCounters =
    [ ``Maximum Memory, Mbytes``

    ]

/// Hyper-V Dynamic Memory VM: This counter set represents the memory statistics for a Virtual Machine.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Dynamic Memory VM`` =

  [<Literal>]
  let Category = "Hyper-V Dynamic Memory VM"

  let PCC = getPCC Category
  /// Average Pressure: -
  let ``Average Pressure`` instance =
    { category = "Hyper-V Dynamic Memory VM"; counter = "Average Pressure"; instance = instance }
  /// Current Pressure: -
  let ``Current Pressure`` instance =
    { category = "Hyper-V Dynamic Memory VM"; counter = "Current Pressure"; instance = instance }
  /// Guest Visible Physical Memory: -
  let ``Guest Visible Physical Memory`` instance =
    { category = "Hyper-V Dynamic Memory VM"; counter = "Guest Visible Physical Memory"; instance = instance }
  /// Maximum Pressure: -
  let ``Maximum Pressure`` instance =
    { category = "Hyper-V Dynamic Memory VM"; counter = "Maximum Pressure"; instance = instance }
  /// Minimum Pressure: -
  let ``Minimum Pressure`` instance =
    { category = "Hyper-V Dynamic Memory VM"; counter = "Minimum Pressure"; instance = instance }
  /// Physical Memory: -
  let ``Physical Memory`` instance =
    { category = "Hyper-V Dynamic Memory VM"; counter = "Physical Memory"; instance = instance }
  /// Smart Paging Working Set Size: -
  let ``Smart Paging Working Set Size`` instance =
    { category = "Hyper-V Dynamic Memory VM"; counter = "Smart Paging Working Set Size"; instance = instance }

  let allCounters =
    [ ``Average Pressure``
      ``Current Pressure``
      ``Guest Visible Physical Memory``
      ``Maximum Pressure``
      ``Minimum Pressure``
      ``Physical Memory``
      ``Smart Paging Working Set Size``
    ]

/// Hyper-V Hypervisor: Information on the hypervisor.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Hypervisor`` =

  [<Literal>]
  let Category = "Hyper-V Hypervisor"

  let PCC = getPCC Category
  /// Logical Processors: The number of logical processors present in the system.
  let ``Logical Processors`` =
    { category = "Hyper-V Hypervisor"; counter = "Logical Processors"; instance = NotApplicable }
  /// Monitored Notifications: The number of monitored notifications registered with the hypervisor.
  let ``Monitored Notifications`` =
    { category = "Hyper-V Hypervisor"; counter = "Monitored Notifications"; instance = NotApplicable }
  /// Partitions: The number of partitions (virtual machines) present in the system.
  let ``Partitions`` =
    { category = "Hyper-V Hypervisor"; counter = "Partitions"; instance = NotApplicable }
  /// Total Pages: The number of bootstrap and deposited pages in the hypervisor.
  let ``Total Pages`` =
    { category = "Hyper-V Hypervisor"; counter = "Total Pages"; instance = NotApplicable }
  /// Virtual Processors: The number of virtual processors present in the system.
  let ``Virtual Processors`` =
    { category = "Hyper-V Hypervisor"; counter = "Virtual Processors"; instance = NotApplicable }

  let allCounters =
    [ ``Logical Processors``
      ``Monitored Notifications``
      ``Partitions``
      ``Total Pages``
      ``Virtual Processors``
    ]

/// Hyper-V Hypervisor Logical Processor: Information on logical processors.
///
/// This performance counter does not have non-instance based counters
module ``Hyper-V Hypervisor Logical Processor`` =

  [<Literal>]
  let Category = "Hyper-V Hypervisor Logical Processor"

  let PCC = getPCC Category
  /// % C1 Time: % C1 Time is the percentage of time the processor spends in the C1 low-power idle state. % C1 Time is a subset of the total processor idle time.
  let ``% C1 Time`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "% C1 Time"; instance = instance }
  /// % C2 Time: % C2 Time is the percentage of time the processor spends in the C2 low-power idle state. % C2 Time is a subset of the total processor idle time.
  let ``% C2 Time`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "% C2 Time"; instance = instance }
  /// % C3 Time: % C3 Time is the percentage of time the processor spends in the C3 low-power idle state. % C3 Time is a subset of the total processor idle time.
  let ``% C3 Time`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "% C3 Time"; instance = instance }
  /// % Guest Run Time: The percentage of time spent by the processor in guest code.
  let ``% Guest Run Time`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "% Guest Run Time"; instance = instance }
  /// % Hypervisor Run Time: The percentage of time spent by the processor in hypervisor code.
  let ``% Hypervisor Run Time`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "% Hypervisor Run Time"; instance = instance }
  /// % Idle Time: The percentage of time spent by the processor in an idle state.
  let ``% Idle Time`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "% Idle Time"; instance = instance }
  /// % Total Run Time: The percentage of time spent by the processor in guest and hypervisor code.
  let ``% Total Run Time`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "% Total Run Time"; instance = instance }
  /// % of Max Frequency: % of Maximum Frequency is the percentage of the current processor's maximum frequency.
  let ``% of Max Frequency`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "% of Max Frequency"; instance = instance }
  /// C1 Transitions/sec: C1 Transitions/sec is the rate that CPU enters the C1 low-power idle state.
  let ``C1 Transitions/sec`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "C1 Transitions/sec"; instance = instance }
  /// C2 Transitions/sec: C2 Transitions/sec is the rate that CPU enters the C2 low-power idle state.
  let ``C2 Transitions/sec`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "C2 Transitions/sec"; instance = instance }
  /// C3 Transitions/sec: C3 Transitions/sec is the rate that CPU enters the C3 low-power idle state.
  let ``C3 Transitions/sec`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "C3 Transitions/sec"; instance = instance }
  /// Context Switches/sec: The rate of virtual processor context switches on the processor.
  let ``Context Switches/sec`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "Context Switches/sec"; instance = instance }
  /// Frequency: Processor Frequency is the frequency of the current processor in megahertz.
  let ``Frequency`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "Frequency"; instance = instance }
  /// Hardware Interrupts/sec: The rate of hardware interrupts on the processor (excluding hypervisor interrupts).
  let ``Hardware Interrupts/sec`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "Hardware Interrupts/sec"; instance = instance }
  /// Inter-Processor Interrupts Sent/sec: The rate of hypervisor inter-processor interrupts sent by the processor.
  let ``Inter-Processor Interrupts Sent/sec`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "Inter-Processor Interrupts Sent/sec"; instance = instance }
  /// Inter-Processor Interrupts/sec: The rate of hypervisor inter-processor interrupts delivered to the processor.
  let ``Inter-Processor Interrupts/sec`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "Inter-Processor Interrupts/sec"; instance = instance }
  /// Monitor Transition Cost: The hardware cost of transitions into the hypervisor.
  let ``Monitor Transition Cost`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "Monitor Transition Cost"; instance = instance }
  /// Parking Status: Parking Status represents whether a processor is parked or not.
  let ``Parking Status`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "Parking Status"; instance = instance }
  /// Processor State Flags: Processor State Flags
  let ``Processor State Flags`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "Processor State Flags"; instance = instance }
  /// Root Vp Index: Index of the root virtual processor that is affinity bound to this logical processor.  A value that is greater than the maximum possible root VP index indicates no binding.
  let ``Root Vp Index`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "Root Vp Index"; instance = instance }
  /// Scheduler Interrupts/sec: The rate of hypervisor scheduler interrupts on the processor.
  let ``Scheduler Interrupts/sec`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "Scheduler Interrupts/sec"; instance = instance }
  /// Timer Interrupts/sec: The rate of hypervisor timer interrupts on the processor.
  let ``Timer Interrupts/sec`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "Timer Interrupts/sec"; instance = instance }
  /// Total Interrupts/sec: The rate of hardware and hypervisor interrupts/sec.
  let ``Total Interrupts/sec`` instance =
    { category = "Hyper-V Hypervisor Logical Processor"; counter = "Total Interrupts/sec"; instance = instance }

  let allCounters =
    [ ``% C1 Time``
      ``% C2 Time``
      ``% C3 Time``
      ``% Guest Run Time``
      ``% Hypervisor Run Time``
      ``% Idle Time``
      ``% Total Run Time``
      ``% of Max Frequency``
      ``C1 Transitions/sec``
      ``C2 Transitions/sec``
      ``C3 Transitions/sec``
      ``Context Switches/sec``
      ``Frequency``
      ``Hardware Interrupts/sec``
      ``Inter-Processor Interrupts Sent/sec``
      ``Inter-Processor Interrupts/sec``
      ``Monitor Transition Cost``
      ``Parking Status``
      ``Processor State Flags``
      ``Root Vp Index``
      ``Scheduler Interrupts/sec``
      ``Timer Interrupts/sec``
      ``Total Interrupts/sec``
    ]

/// Hyper-V Hypervisor Partition: Information on virtual machines
///
/// This performance counter does not have instance based counters
module ``Hyper-V Hypervisor Partition`` =

  [<Literal>]
  let Category = "Hyper-V Hypervisor Partition"

  let PCC = getPCC Category
  /// 1G GPA pages: -
  let ``1G GPA pages`` instance =
    { category = "Hyper-V Hypervisor Partition"; counter = "1G GPA pages"; instance = instance }
  /// 1G device pages: -
  let ``1G device pages`` instance =
    { category = "Hyper-V Hypervisor Partition"; counter = "1G device pages"; instance = instance }
  /// 2M GPA pages: -
  let ``2M GPA pages`` instance =
    { category = "Hyper-V Hypervisor Partition"; counter = "2M GPA pages"; instance = instance }
  /// 2M device pages: -
  let ``2M device pages`` instance =
    { category = "Hyper-V Hypervisor Partition"; counter = "2M device pages"; instance = instance }
  /// 4K GPA pages: -
  let ``4K GPA pages`` instance =
    { category = "Hyper-V Hypervisor Partition"; counter = "4K GPA pages"; instance = instance }
  /// 4K device pages: -
  let ``4K device pages`` instance =
    { category = "Hyper-V Hypervisor Partition"; counter = "4K device pages"; instance = instance }
  /// Address Spaces: -
  let ``Address Spaces`` instance =
    { category = "Hyper-V Hypervisor Partition"; counter = "Address Spaces"; instance = instance }
  /// Attached Devices: -
  let ``Attached Devices`` instance =
    { category = "Hyper-V Hypervisor Partition"; counter = "Attached Devices"; instance = instance }
  /// Deposited Pages: -
  let ``Deposited Pages`` instance =
    { category = "Hyper-V Hypervisor Partition"; counter = "Deposited Pages"; instance = instance }
  /// Device DMA Errors: -
  let ``Device DMA Errors`` instance =
    { category = "Hyper-V Hypervisor Partition"; counter = "Device DMA Errors"; instance = instance }
  /// Device Interrupt Errors: -
  let ``Device Interrupt Errors`` instance =
    { category = "Hyper-V Hypervisor Partition"; counter = "Device Interrupt Errors"; instance = instance }
  /// Device Interrupt Mappings: -
  let ``Device Interrupt Mappings`` instance =
    { category = "Hyper-V Hypervisor Partition"; counter = "Device Interrupt Mappings"; instance = instance }
  /// Device Interrupt Throttle Events: -
  let ``Device Interrupt Throttle Events`` instance =
    { category = "Hyper-V Hypervisor Partition"; counter = "Device Interrupt Throttle Events"; instance = instance }
  /// GPA Pages: -
  let ``GPA Pages`` instance =
    { category = "Hyper-V Hypervisor Partition"; counter = "GPA Pages"; instance = instance }
  /// GPA Space Modifications/sec: -
  let ``GPA Space Modifications/sec`` instance =
    { category = "Hyper-V Hypervisor Partition"; counter = "GPA Space Modifications/sec"; instance = instance }
  /// I/O TLB Flush Cost: -
  let ``I/O TLB Flush Cost`` instance =
    { category = "Hyper-V Hypervisor Partition"; counter = "I/O TLB Flush Cost"; instance = instance }
  /// I/O TLB Flushes/sec: -
  let ``I/O TLB Flushes/sec`` instance =
    { category = "Hyper-V Hypervisor Partition"; counter = "I/O TLB Flushes/sec"; instance = instance }
  /// Recommended Virtual TLB Size: -
  let ``Recommended Virtual TLB Size`` instance =
    { category = "Hyper-V Hypervisor Partition"; counter = "Recommended Virtual TLB Size"; instance = instance }
  /// Skipped Timer Ticks: -
  let ``Skipped Timer Ticks`` instance =
    { category = "Hyper-V Hypervisor Partition"; counter = "Skipped Timer Ticks"; instance = instance }
  /// Virtual Processors: -
  let ``Virtual Processors`` instance =
    { category = "Hyper-V Hypervisor Partition"; counter = "Virtual Processors"; instance = instance }
  /// Virtual TLB Flush Entires/sec: -
  let ``Virtual TLB Flush Entires/sec`` instance =
    { category = "Hyper-V Hypervisor Partition"; counter = "Virtual TLB Flush Entires/sec"; instance = instance }
  /// Virtual TLB Pages: -
  let ``Virtual TLB Pages`` instance =
    { category = "Hyper-V Hypervisor Partition"; counter = "Virtual TLB Pages"; instance = instance }

  let allCounters =
    [ ``1G GPA pages``
      ``1G device pages``
      ``2M GPA pages``
      ``2M device pages``
      ``4K GPA pages``
      ``4K device pages``
      ``Address Spaces``
      ``Attached Devices``
      ``Deposited Pages``
      ``Device DMA Errors``
      ``Device Interrupt Errors``
      ``Device Interrupt Mappings``
      ``Device Interrupt Throttle Events``
      ``GPA Pages``
      ``GPA Space Modifications/sec``
      ``I/O TLB Flush Cost``
      ``I/O TLB Flushes/sec``
      ``Recommended Virtual TLB Size``
      ``Skipped Timer Ticks``
      ``Virtual Processors``
      ``Virtual TLB Flush Entires/sec``
      ``Virtual TLB Pages``
    ]

/// Hyper-V Hypervisor Root Partition: Information on virtual machines
///
/// This performance counter does not have non-instance based counters
module ``Hyper-V Hypervisor Root Partition`` =

  [<Literal>]
  let Category = "Hyper-V Hypervisor Root Partition"

  let PCC = getPCC Category
  /// 1G GPA pages: The number of 1G pages present in the GPA space of the partition.
  let ``1G GPA pages`` instance =
    { category = "Hyper-V Hypervisor Root Partition"; counter = "1G GPA pages"; instance = instance }
  /// 1G device pages: The number of 1G pages present in the device space of the partition.
  let ``1G device pages`` instance =
    { category = "Hyper-V Hypervisor Root Partition"; counter = "1G device pages"; instance = instance }
  /// 2M GPA pages: The number of 2M pages present in the GPA space of the partition.
  let ``2M GPA pages`` instance =
    { category = "Hyper-V Hypervisor Root Partition"; counter = "2M GPA pages"; instance = instance }
  /// 2M device pages: The number of 2M pages present in the device space of the partition.
  let ``2M device pages`` instance =
    { category = "Hyper-V Hypervisor Root Partition"; counter = "2M device pages"; instance = instance }
  /// 4K GPA pages: The number of 4K pages present in the GPA space of the partition.
  let ``4K GPA pages`` instance =
    { category = "Hyper-V Hypervisor Root Partition"; counter = "4K GPA pages"; instance = instance }
  /// 4K device pages: The number of 4K pages present in the device space of the partition.
  let ``4K device pages`` instance =
    { category = "Hyper-V Hypervisor Root Partition"; counter = "4K device pages"; instance = instance }
  /// Address Spaces: The number of address spaces in the virtual TLB of the partition.
  let ``Address Spaces`` instance =
    { category = "Hyper-V Hypervisor Root Partition"; counter = "Address Spaces"; instance = instance }
  /// Attached Devices: The number of devices attached to the partition.
  let ``Attached Devices`` instance =
    { category = "Hyper-V Hypervisor Root Partition"; counter = "Attached Devices"; instance = instance }
  /// Deposited Pages: The number of pages deposited into the partition.
  let ``Deposited Pages`` instance =
    { category = "Hyper-V Hypervisor Root Partition"; counter = "Deposited Pages"; instance = instance }
  /// Device DMA Errors: An indicator of illegal DMA requests generated by all devices assigned to the partition.
  let ``Device DMA Errors`` instance =
    { category = "Hyper-V Hypervisor Root Partition"; counter = "Device DMA Errors"; instance = instance }
  /// Device Interrupt Errors: An indicator of illegal interrupt requests generated by all devices assigned to the partition.
  let ``Device Interrupt Errors`` instance =
    { category = "Hyper-V Hypervisor Root Partition"; counter = "Device Interrupt Errors"; instance = instance }
  /// Device Interrupt Mappings: The number of device interrupt mappings used by the partition.
  let ``Device Interrupt Mappings`` instance =
    { category = "Hyper-V Hypervisor Root Partition"; counter = "Device Interrupt Mappings"; instance = instance }
  /// Device Interrupt Throttle Events: The number of times an interrupt from a device assigned to the partition was temporarily throttled because the device was generating too many interrupts.
  let ``Device Interrupt Throttle Events`` instance =
    { category = "Hyper-V Hypervisor Root Partition"; counter = "Device Interrupt Throttle Events"; instance = instance }
  /// GPA Pages: The number of pages present in the GPA space of the partition (zero for root partition).
  let ``GPA Pages`` instance =
    { category = "Hyper-V Hypervisor Root Partition"; counter = "GPA Pages"; instance = instance }
  /// GPA Space Modifications/sec: The rate of modifications to the GPA space of the partition.
  let ``GPA Space Modifications/sec`` instance =
    { category = "Hyper-V Hypervisor Root Partition"; counter = "GPA Space Modifications/sec"; instance = instance }
  /// I/O TLB Flush Cost: The average time (in nanoseconds) spent processing an I/O TLB flush.
  let ``I/O TLB Flush Cost`` instance =
    { category = "Hyper-V Hypervisor Root Partition"; counter = "I/O TLB Flush Cost"; instance = instance }
  /// I/O TLB Flushes/sec: The rate of flushes of I/O TLBs of the partition.
  let ``I/O TLB Flushes/sec`` instance =
    { category = "Hyper-V Hypervisor Root Partition"; counter = "I/O TLB Flushes/sec"; instance = instance }
  /// Recommended Virtual TLB Size: The recommended number of pages to be deposited for the virtual TLB.
  let ``Recommended Virtual TLB Size`` instance =
    { category = "Hyper-V Hypervisor Root Partition"; counter = "Recommended Virtual TLB Size"; instance = instance }
  /// Skipped Timer Ticks: The number of timer interrupts skipped for the partition.
  let ``Skipped Timer Ticks`` instance =
    { category = "Hyper-V Hypervisor Root Partition"; counter = "Skipped Timer Ticks"; instance = instance }
  /// Virtual Processors: The number of virtual processors present in the partition.
  let ``Virtual Processors`` instance =
    { category = "Hyper-V Hypervisor Root Partition"; counter = "Virtual Processors"; instance = instance }
  /// Virtual TLB Flush Entires/sec: The rate of flushes of the entire virtual TLB.
  let ``Virtual TLB Flush Entires/sec`` instance =
    { category = "Hyper-V Hypervisor Root Partition"; counter = "Virtual TLB Flush Entires/sec"; instance = instance }
  /// Virtual TLB Pages: The number of pages used by the virtual TLB of the partition.
  let ``Virtual TLB Pages`` instance =
    { category = "Hyper-V Hypervisor Root Partition"; counter = "Virtual TLB Pages"; instance = instance }

  let allCounters =
    [ ``1G GPA pages``
      ``1G device pages``
      ``2M GPA pages``
      ``2M device pages``
      ``4K GPA pages``
      ``4K device pages``
      ``Address Spaces``
      ``Attached Devices``
      ``Deposited Pages``
      ``Device DMA Errors``
      ``Device Interrupt Errors``
      ``Device Interrupt Mappings``
      ``Device Interrupt Throttle Events``
      ``GPA Pages``
      ``GPA Space Modifications/sec``
      ``I/O TLB Flush Cost``
      ``I/O TLB Flushes/sec``
      ``Recommended Virtual TLB Size``
      ``Skipped Timer Ticks``
      ``Virtual Processors``
      ``Virtual TLB Flush Entires/sec``
      ``Virtual TLB Pages``
    ]

/// Hyper-V Hypervisor Root Virtual Processor: Information on virtual processors
///
/// This performance counter does not have non-instance based counters
module ``Hyper-V Hypervisor Root Virtual Processor`` =

  [<Literal>]
  let Category = "Hyper-V Hypervisor Root Virtual Processor"

  let PCC = getPCC Category
  /// % Guest Run Time: The percentage of time spent by the virtual processor in guest code.
  let ``% Guest Run Time`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "% Guest Run Time"; instance = instance }
  /// % Hypervisor Run Time: The percentage of time spent by the virtual processor in hypervisor code.
  let ``% Hypervisor Run Time`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "% Hypervisor Run Time"; instance = instance }
  /// % Remote Run Time: The percentage of time spent by the virtual processor running on a remote node.
  let ``% Remote Run Time`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "% Remote Run Time"; instance = instance }
  /// % Total Run Time: The percentage of time spent by the virtual processor in guest and hypervisor code.
  let ``% Total Run Time`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "% Total Run Time"; instance = instance }
  /// APIC EOI Accesses/sec: The rate of APIC EOI register writes by guest code on the virtual processor.
  let ``APIC EOI Accesses/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "APIC EOI Accesses/sec"; instance = instance }
  /// APIC IPIs Sent/sec: The rate of APIC inter-processor interrupts (including to self) sent by the virtual processor.
  let ``APIC IPIs Sent/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "APIC IPIs Sent/sec"; instance = instance }
  /// APIC MMIO Accesses/sec: The rate of APIC MMIO register accesses by guest code on the virtual processor.
  let ``APIC MMIO Accesses/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "APIC MMIO Accesses/sec"; instance = instance }
  /// APIC Self IPIs Sent/sec: The rate of APIC interrupts sent by the virtual processor to itself.
  let ``APIC Self IPIs Sent/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "APIC Self IPIs Sent/sec"; instance = instance }
  /// APIC TPR Accesses/sec: The rate of APIC TPR accesses by guest code on the virtual processor.
  let ``APIC TPR Accesses/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "APIC TPR Accesses/sec"; instance = instance }
  /// Address Domain Flushes/sec: The rate of explicit flushes of the virtual TLB by guest code on the virtual processor.
  let ``Address Domain Flushes/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Address Domain Flushes/sec"; instance = instance }
  /// Address Space Evictions/sec: The rate of address space evictions in the virtual TLB.
  let ``Address Space Evictions/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Address Space Evictions/sec"; instance = instance }
  /// Address Space Flushes/sec: The rate of explicit flushes of one address space by guest code on the virtual processor.
  let ``Address Space Flushes/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Address Space Flushes/sec"; instance = instance }
  /// Address Space Switches/sec: The rate of address space switches by guest code on the virtual processor.
  let ``Address Space Switches/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Address Space Switches/sec"; instance = instance }
  /// CPU Wait Time Per Dispatch: The average time (in nanoseconds) spent waiting for a virtual processor to be dispatched onto a logical processor.
  let ``CPU Wait Time Per Dispatch`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "CPU Wait Time Per Dispatch"; instance = instance }
  /// CPUID Instructions Cost: The average time (in nanoseconds) spent processing a CPUID instruction.
  let ``CPUID Instructions Cost`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "CPUID Instructions Cost"; instance = instance }
  /// CPUID Instructions/sec: The rate of CPUID instructions executed by guest code on the virtual processor.
  let ``CPUID Instructions/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "CPUID Instructions/sec"; instance = instance }
  /// Control Register Accesses Cost: The average time (in nanoseconds) spent processing a control register access.
  let ``Control Register Accesses Cost`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Control Register Accesses Cost"; instance = instance }
  /// Control Register Accesses/sec: The rate of control register accesses by guest code on the virtual processor.
  let ``Control Register Accesses/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Control Register Accesses/sec"; instance = instance }
  /// Debug Register Accesses Cost: The average time (in nanoseconds) spent handling a debug register access.
  let ``Debug Register Accesses Cost`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Debug Register Accesses Cost"; instance = instance }
  /// Debug Register Accesses/sec: The rate of debug register accesses by guest code on the virtual processor.
  let ``Debug Register Accesses/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Debug Register Accesses/sec"; instance = instance }
  /// Emulated Instructions Cost: The average time (in nanoseconds) spent emulating an instruction.
  let ``Emulated Instructions Cost`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Emulated Instructions Cost"; instance = instance }
  /// Emulated Instructions/sec: The rate of emulated instructions while executing guest code on the virtual processor.
  let ``Emulated Instructions/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Emulated Instructions/sec"; instance = instance }
  /// External Interrupts Cost: The average time (in nanoseconds) spent processing an external interrupt.
  let ``External Interrupts Cost`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "External Interrupts Cost"; instance = instance }
  /// External Interrupts/sec: The rate of external interrupts received by the hypervisor while executing guest code on the virtual processor.
  let ``External Interrupts/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "External Interrupts/sec"; instance = instance }
  /// GPA Space Hypercalls/sec: The rate of Guest Physical Address Space hypercalls made by guest code on the virtual processor.
  let ``GPA Space Hypercalls/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "GPA Space Hypercalls/sec"; instance = instance }
  /// Global GVA Range Flushes/sec: The rate of explicit flushes of a virtual address range in all address spaces by guest code on the virtual processor.
  let ``Global GVA Range Flushes/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Global GVA Range Flushes/sec"; instance = instance }
  /// Guest Page Table Maps/sec: The rate of map operations for guest page table pages.
  let ``Guest Page Table Maps/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Guest Page Table Maps/sec"; instance = instance }
  /// HLT Instructions Cost: The average time (in nanoseconds) spent processing a HLT instruction.
  let ``HLT Instructions Cost`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "HLT Instructions Cost"; instance = instance }
  /// HLT Instructions/sec: The rate of HLT instructions executed by guest code on the virtual processor.
  let ``HLT Instructions/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "HLT Instructions/sec"; instance = instance }
  /// Hardware Interrupts/sec: The rate of hardware interrupts from attached devices on the virtual processor.
  let ``Hardware Interrupts/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Hardware Interrupts/sec"; instance = instance }
  /// Hypercalls Cost: The average time (in nanoseconds) spent processing a hypercall.
  let ``Hypercalls Cost`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Hypercalls Cost"; instance = instance }
  /// Hypercalls/sec: The rate of hypercalls made by guest code on the virtual processor.
  let ``Hypercalls/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Hypercalls/sec"; instance = instance }
  /// IO Instructions Cost: The average time (in nanoseconds) spent processing an IO instruction.
  let ``IO Instructions Cost`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "IO Instructions Cost"; instance = instance }
  /// IO Instructions/sec: The rate of IO instructions executed by guest code on the virtual processor.
  let ``IO Instructions/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "IO Instructions/sec"; instance = instance }
  /// IO Intercept Messages/sec: The rate of IO intercept messages sent to the parent partition.
  let ``IO Intercept Messages/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "IO Intercept Messages/sec"; instance = instance }
  /// Large Page TLB Fills/sec: The rate of virtual TLB misses on large pages.
  let ``Large Page TLB Fills/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Large Page TLB Fills/sec"; instance = instance }
  /// Local Flushed GVA Ranges/sec: The rate of explicit flushes of a virtual address range in one address space by guest code on the virtual processor.
  let ``Local Flushed GVA Ranges/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Local Flushed GVA Ranges/sec"; instance = instance }
  /// Logical Processor Dispatches/sec: The rate of dispatches of this virtual processor onto logical processors.
  let ``Logical Processor Dispatches/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Logical Processor Dispatches/sec"; instance = instance }
  /// Logical Processor Hypercalls/sec: The rate of Logical Processor hypercalls made by guest code on the virtual processor.
  let ``Logical Processor Hypercalls/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Logical Processor Hypercalls/sec"; instance = instance }
  /// Logical Processor Migrations/sec: The rate of migrations by the virtual processor to a different logical processor.
  let ``Logical Processor Migrations/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Logical Processor Migrations/sec"; instance = instance }
  /// Long Spin Wait Hypercalls/sec: The rate of Long Spin Wait hypercalls made by guest code on the virtual processor.
  let ``Long Spin Wait Hypercalls/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Long Spin Wait Hypercalls/sec"; instance = instance }
  /// MSR Accesses Cost: The average time (in nanoseconds) spent processing an MSR instruction.
  let ``MSR Accesses Cost`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "MSR Accesses Cost"; instance = instance }
  /// MSR Accesses/sec: The rate of MSR instructions executed by guest code on the virtual processor.
  let ``MSR Accesses/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "MSR Accesses/sec"; instance = instance }
  /// MWAIT Instructions Cost: The average time (in nanoseconds) spent processing an MWAIT instruction.
  let ``MWAIT Instructions Cost`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "MWAIT Instructions Cost"; instance = instance }
  /// MWAIT Instructions/sec: The rate of MWAIT instructions executed by guest code on the virtual processor.
  let ``MWAIT Instructions/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "MWAIT Instructions/sec"; instance = instance }
  /// Memory Intercept Messages/sec: The rate of memory intercept messages sent to the parent partition.
  let ``Memory Intercept Messages/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Memory Intercept Messages/sec"; instance = instance }
  /// Nested Page Fault Intercepts Cost: The average time (in nanoseconds) spent processing a nested page fault intercept.
  let ``Nested Page Fault Intercepts Cost`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Nested Page Fault Intercepts Cost"; instance = instance }
  /// Nested Page Fault Intercepts/sec: The rate of nested page fault exceptions intercepted by the hypervisor while executing the guest virtual processor.
  let ``Nested Page Fault Intercepts/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Nested Page Fault Intercepts/sec"; instance = instance }
  /// Other Hypercalls/sec: The rate of other hypercalls made by guest code on the virtual processor.
  let ``Other Hypercalls/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Other Hypercalls/sec"; instance = instance }
  /// Other Intercepts Cost: The average time (in nanoseconds) spent processing other intercepts.
  let ``Other Intercepts Cost`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Other Intercepts Cost"; instance = instance }
  /// Other Intercepts/sec: The rate of other intercepts triggered by guest code on the virtual processor.
  let ``Other Intercepts/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Other Intercepts/sec"; instance = instance }
  /// Other Messages/sec: The rate of other intercept messages sent to the parent partition.
  let ``Other Messages/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Other Messages/sec"; instance = instance }
  /// Page Fault Intercepts Cost: The average time (in nanoseconds) spent processing a page fault intercept.
  let ``Page Fault Intercepts Cost`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Page Fault Intercepts Cost"; instance = instance }
  /// Page Fault Intercepts/sec: The rate of page fault exceptions intercepted by the hypervisor while executing guest code on the virtual processor.
  let ``Page Fault Intercepts/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Page Fault Intercepts/sec"; instance = instance }
  /// Page Invalidations Cost: The average time (in nanoseconds) spent processing an INVLPG instruction.
  let ``Page Invalidations Cost`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Page Invalidations Cost"; instance = instance }
  /// Page Invalidations/sec: The rate of INVLPG instructions executed by guest code on the virtual processor.
  let ``Page Invalidations/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Page Invalidations/sec"; instance = instance }
  /// Page Table Allocations/sec: The rate of page table allocations in the virtual TLB.
  let ``Page Table Allocations/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Page Table Allocations/sec"; instance = instance }
  /// Page Table Evictions/sec: The rate of page table evictions in the virtual TLB.
  let ``Page Table Evictions/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Page Table Evictions/sec"; instance = instance }
  /// Page Table Reclamations/sec: The rate of reclamations of unreferenced page tables in the virtual TLB.
  let ``Page Table Reclamations/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Page Table Reclamations/sec"; instance = instance }
  /// Page Table Resets/sec: The rate of page table resets in the virtual TLB.
  let ``Page Table Resets/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Page Table Resets/sec"; instance = instance }
  /// Page Table Validations/sec: The rate of page table validations to remove stale entries in the virtual TLB.
  let ``Page Table Validations/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Page Table Validations/sec"; instance = instance }
  /// Page Table Write Intercepts/sec: The rate of write intercepts on guest page tables by guest code on the virtual processor.
  let ``Page Table Write Intercepts/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Page Table Write Intercepts/sec"; instance = instance }
  /// Pending Interrupts Cost: The average time (in nanoseconds) spent processing a pending interrupt intercept.
  let ``Pending Interrupts Cost`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Pending Interrupts Cost"; instance = instance }
  /// Pending Interrupts/sec: The rate of intercepts due to a task priority (TPR) reduction by guest code on the virtual processor.
  let ``Pending Interrupts/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Pending Interrupts/sec"; instance = instance }
  /// Reflected Guest Page Faults/sec: The rate of page fault exceptions delivered to the guest.
  let ``Reflected Guest Page Faults/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Reflected Guest Page Faults/sec"; instance = instance }
  /// Small Page TLB Fills/sec: The rate of virtual TLB misses on 4K pages.
  let ``Small Page TLB Fills/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Small Page TLB Fills/sec"; instance = instance }
  /// Synthetic Interrupt Hypercalls/sec: The rate of Synthetic Interrupt hypercalls made by guest code on the virtual processor.
  let ``Synthetic Interrupt Hypercalls/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Synthetic Interrupt Hypercalls/sec"; instance = instance }
  /// Synthetic Interrupts/sec: The rate of synthetic interrupts delivered to the virtual processor.
  let ``Synthetic Interrupts/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Synthetic Interrupts/sec"; instance = instance }
  /// Total Intercepts Cost: The average time (in nanoseconds) spent handling a hypervisor intercept.
  let ``Total Intercepts Cost`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Total Intercepts Cost"; instance = instance }
  /// Total Intercepts/sec: The rate of hypervisor intercepts messages.
  let ``Total Intercepts/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Total Intercepts/sec"; instance = instance }
  /// Total Messages/sec: The rate of total messages sent to the parent partition.
  let ``Total Messages/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Total Messages/sec"; instance = instance }
  /// Virtual Interrupt Hypercalls/sec: The rate of Virtual Interrupt hypercalls made by guest code on the virtual processor.
  let ``Virtual Interrupt Hypercalls/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Virtual Interrupt Hypercalls/sec"; instance = instance }
  /// Virtual Interrupts/sec: The rate of interrupts (including synthetic interrupts) delivered to the virtual processor.
  let ``Virtual Interrupts/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Virtual Interrupts/sec"; instance = instance }
  /// Virtual MMU Hypercalls/sec: The rate of Virtual MMU hypercalls made by guest code on the virtual processor.
  let ``Virtual MMU Hypercalls/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Virtual MMU Hypercalls/sec"; instance = instance }
  /// Virtual Processor Hypercalls/sec: The rate of Virtual Processor hypercalls made by guest code on the virtual processor.
  let ``Virtual Processor Hypercalls/sec`` instance =
    { category = "Hyper-V Hypervisor Root Virtual Processor"; counter = "Virtual Processor Hypercalls/sec"; instance = instance }

  let allCounters =
    [ ``% Guest Run Time``
      ``% Hypervisor Run Time``
      ``% Remote Run Time``
      ``% Total Run Time``
      ``APIC EOI Accesses/sec``
      ``APIC IPIs Sent/sec``
      ``APIC MMIO Accesses/sec``
      ``APIC Self IPIs Sent/sec``
      ``APIC TPR Accesses/sec``
      ``Address Domain Flushes/sec``
      ``Address Space Evictions/sec``
      ``Address Space Flushes/sec``
      ``Address Space Switches/sec``
      ``CPU Wait Time Per Dispatch``
      ``CPUID Instructions Cost``
      ``CPUID Instructions/sec``
      ``Control Register Accesses Cost``
      ``Control Register Accesses/sec``
      ``Debug Register Accesses Cost``
      ``Debug Register Accesses/sec``
      ``Emulated Instructions Cost``
      ``Emulated Instructions/sec``
      ``External Interrupts Cost``
      ``External Interrupts/sec``
      ``GPA Space Hypercalls/sec``
      ``Global GVA Range Flushes/sec``
      ``Guest Page Table Maps/sec``
      ``HLT Instructions Cost``
      ``HLT Instructions/sec``
      ``Hardware Interrupts/sec``
      ``Hypercalls Cost``
      ``Hypercalls/sec``
      ``IO Instructions Cost``
      ``IO Instructions/sec``
      ``IO Intercept Messages/sec``
      ``Large Page TLB Fills/sec``
      ``Local Flushed GVA Ranges/sec``
      ``Logical Processor Dispatches/sec``
      ``Logical Processor Hypercalls/sec``
      ``Logical Processor Migrations/sec``
      ``Long Spin Wait Hypercalls/sec``
      ``MSR Accesses Cost``
      ``MSR Accesses/sec``
      ``MWAIT Instructions Cost``
      ``MWAIT Instructions/sec``
      ``Memory Intercept Messages/sec``
      ``Nested Page Fault Intercepts Cost``
      ``Nested Page Fault Intercepts/sec``
      ``Other Hypercalls/sec``
      ``Other Intercepts Cost``
      ``Other Intercepts/sec``
      ``Other Messages/sec``
      ``Page Fault Intercepts Cost``
      ``Page Fault Intercepts/sec``
      ``Page Invalidations Cost``
      ``Page Invalidations/sec``
      ``Page Table Allocations/sec``
      ``Page Table Evictions/sec``
      ``Page Table Reclamations/sec``
      ``Page Table Resets/sec``
      ``Page Table Validations/sec``
      ``Page Table Write Intercepts/sec``
      ``Pending Interrupts Cost``
      ``Pending Interrupts/sec``
      ``Reflected Guest Page Faults/sec``
      ``Small Page TLB Fills/sec``
      ``Synthetic Interrupt Hypercalls/sec``
      ``Synthetic Interrupts/sec``
      ``Total Intercepts Cost``
      ``Total Intercepts/sec``
      ``Total Messages/sec``
      ``Virtual Interrupt Hypercalls/sec``
      ``Virtual Interrupts/sec``
      ``Virtual MMU Hypercalls/sec``
      ``Virtual Processor Hypercalls/sec``
    ]

/// Hyper-V Hypervisor Virtual Processor: Information on virtual processors
///
/// This performance counter does not have instance based counters
module ``Hyper-V Hypervisor Virtual Processor`` =

  [<Literal>]
  let Category = "Hyper-V Hypervisor Virtual Processor"

  let PCC = getPCC Category
  /// % Guest Run Time: -
  let ``% Guest Run Time`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "% Guest Run Time"; instance = instance }
  /// % Hypervisor Run Time: -
  let ``% Hypervisor Run Time`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "% Hypervisor Run Time"; instance = instance }
  /// % Remote Run Time: -
  let ``% Remote Run Time`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "% Remote Run Time"; instance = instance }
  /// % Total Run Time: -
  let ``% Total Run Time`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "% Total Run Time"; instance = instance }
  /// APIC EOI Accesses/sec: -
  let ``APIC EOI Accesses/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "APIC EOI Accesses/sec"; instance = instance }
  /// APIC IPIs Sent/sec: -
  let ``APIC IPIs Sent/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "APIC IPIs Sent/sec"; instance = instance }
  /// APIC MMIO Accesses/sec: -
  let ``APIC MMIO Accesses/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "APIC MMIO Accesses/sec"; instance = instance }
  /// APIC Self IPIs Sent/sec: -
  let ``APIC Self IPIs Sent/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "APIC Self IPIs Sent/sec"; instance = instance }
  /// APIC TPR Accesses/sec: -
  let ``APIC TPR Accesses/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "APIC TPR Accesses/sec"; instance = instance }
  /// Address Domain Flushes/sec: -
  let ``Address Domain Flushes/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Address Domain Flushes/sec"; instance = instance }
  /// Address Space Evictions/sec: -
  let ``Address Space Evictions/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Address Space Evictions/sec"; instance = instance }
  /// Address Space Flushes/sec: -
  let ``Address Space Flushes/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Address Space Flushes/sec"; instance = instance }
  /// Address Space Switches/sec: -
  let ``Address Space Switches/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Address Space Switches/sec"; instance = instance }
  /// CPU Wait Time Per Dispatch: -
  let ``CPU Wait Time Per Dispatch`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "CPU Wait Time Per Dispatch"; instance = instance }
  /// CPUID Instructions Cost: -
  let ``CPUID Instructions Cost`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "CPUID Instructions Cost"; instance = instance }
  /// CPUID Instructions/sec: -
  let ``CPUID Instructions/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "CPUID Instructions/sec"; instance = instance }
  /// Control Register Accesses Cost: -
  let ``Control Register Accesses Cost`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Control Register Accesses Cost"; instance = instance }
  /// Control Register Accesses/sec: -
  let ``Control Register Accesses/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Control Register Accesses/sec"; instance = instance }
  /// Debug Register Accesses Cost: -
  let ``Debug Register Accesses Cost`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Debug Register Accesses Cost"; instance = instance }
  /// Debug Register Accesses/sec: -
  let ``Debug Register Accesses/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Debug Register Accesses/sec"; instance = instance }
  /// Emulated Instructions Cost: -
  let ``Emulated Instructions Cost`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Emulated Instructions Cost"; instance = instance }
  /// Emulated Instructions/sec: -
  let ``Emulated Instructions/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Emulated Instructions/sec"; instance = instance }
  /// External Interrupts Cost: -
  let ``External Interrupts Cost`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "External Interrupts Cost"; instance = instance }
  /// External Interrupts/sec: -
  let ``External Interrupts/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "External Interrupts/sec"; instance = instance }
  /// GPA Space Hypercalls/sec: -
  let ``GPA Space Hypercalls/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "GPA Space Hypercalls/sec"; instance = instance }
  /// Global GVA Range Flushes/sec: -
  let ``Global GVA Range Flushes/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Global GVA Range Flushes/sec"; instance = instance }
  /// Guest Page Table Maps/sec: -
  let ``Guest Page Table Maps/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Guest Page Table Maps/sec"; instance = instance }
  /// HLT Instructions Cost: -
  let ``HLT Instructions Cost`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "HLT Instructions Cost"; instance = instance }
  /// HLT Instructions/sec: -
  let ``HLT Instructions/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "HLT Instructions/sec"; instance = instance }
  /// Hardware Interrupts/sec: -
  let ``Hardware Interrupts/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Hardware Interrupts/sec"; instance = instance }
  /// Hypercalls Cost: -
  let ``Hypercalls Cost`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Hypercalls Cost"; instance = instance }
  /// Hypercalls/sec: -
  let ``Hypercalls/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Hypercalls/sec"; instance = instance }
  /// IO Instructions Cost: -
  let ``IO Instructions Cost`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "IO Instructions Cost"; instance = instance }
  /// IO Instructions/sec: -
  let ``IO Instructions/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "IO Instructions/sec"; instance = instance }
  /// IO Intercept Messages/sec: -
  let ``IO Intercept Messages/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "IO Intercept Messages/sec"; instance = instance }
  /// Large Page TLB Fills/sec: -
  let ``Large Page TLB Fills/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Large Page TLB Fills/sec"; instance = instance }
  /// Local Flushed GVA Ranges/sec: -
  let ``Local Flushed GVA Ranges/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Local Flushed GVA Ranges/sec"; instance = instance }
  /// Logical Processor Dispatches/sec: -
  let ``Logical Processor Dispatches/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Logical Processor Dispatches/sec"; instance = instance }
  /// Logical Processor Hypercalls/sec: -
  let ``Logical Processor Hypercalls/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Logical Processor Hypercalls/sec"; instance = instance }
  /// Logical Processor Migrations/sec: -
  let ``Logical Processor Migrations/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Logical Processor Migrations/sec"; instance = instance }
  /// Long Spin Wait Hypercalls/sec: -
  let ``Long Spin Wait Hypercalls/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Long Spin Wait Hypercalls/sec"; instance = instance }
  /// MSR Accesses Cost: -
  let ``MSR Accesses Cost`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "MSR Accesses Cost"; instance = instance }
  /// MSR Accesses/sec: -
  let ``MSR Accesses/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "MSR Accesses/sec"; instance = instance }
  /// MWAIT Instructions Cost: -
  let ``MWAIT Instructions Cost`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "MWAIT Instructions Cost"; instance = instance }
  /// MWAIT Instructions/sec: -
  let ``MWAIT Instructions/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "MWAIT Instructions/sec"; instance = instance }
  /// Memory Intercept Messages/sec: -
  let ``Memory Intercept Messages/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Memory Intercept Messages/sec"; instance = instance }
  /// Nested Page Fault Intercepts Cost: -
  let ``Nested Page Fault Intercepts Cost`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Nested Page Fault Intercepts Cost"; instance = instance }
  /// Nested Page Fault Intercepts/sec: -
  let ``Nested Page Fault Intercepts/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Nested Page Fault Intercepts/sec"; instance = instance }
  /// Other Hypercalls/sec: -
  let ``Other Hypercalls/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Other Hypercalls/sec"; instance = instance }
  /// Other Intercepts Cost: -
  let ``Other Intercepts Cost`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Other Intercepts Cost"; instance = instance }
  /// Other Intercepts/sec: -
  let ``Other Intercepts/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Other Intercepts/sec"; instance = instance }
  /// Other Messages/sec: -
  let ``Other Messages/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Other Messages/sec"; instance = instance }
  /// Page Fault Intercepts Cost: -
  let ``Page Fault Intercepts Cost`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Page Fault Intercepts Cost"; instance = instance }
  /// Page Fault Intercepts/sec: -
  let ``Page Fault Intercepts/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Page Fault Intercepts/sec"; instance = instance }
  /// Page Invalidations Cost: -
  let ``Page Invalidations Cost`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Page Invalidations Cost"; instance = instance }
  /// Page Invalidations/sec: -
  let ``Page Invalidations/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Page Invalidations/sec"; instance = instance }
  /// Page Table Allocations/sec: -
  let ``Page Table Allocations/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Page Table Allocations/sec"; instance = instance }
  /// Page Table Evictions/sec: -
  let ``Page Table Evictions/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Page Table Evictions/sec"; instance = instance }
  /// Page Table Reclamations/sec: -
  let ``Page Table Reclamations/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Page Table Reclamations/sec"; instance = instance }
  /// Page Table Resets/sec: -
  let ``Page Table Resets/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Page Table Resets/sec"; instance = instance }
  /// Page Table Validations/sec: -
  let ``Page Table Validations/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Page Table Validations/sec"; instance = instance }
  /// Page Table Write Intercepts/sec: -
  let ``Page Table Write Intercepts/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Page Table Write Intercepts/sec"; instance = instance }
  /// Pending Interrupts Cost: -
  let ``Pending Interrupts Cost`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Pending Interrupts Cost"; instance = instance }
  /// Pending Interrupts/sec: -
  let ``Pending Interrupts/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Pending Interrupts/sec"; instance = instance }
  /// Reflected Guest Page Faults/sec: -
  let ``Reflected Guest Page Faults/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Reflected Guest Page Faults/sec"; instance = instance }
  /// Small Page TLB Fills/sec: -
  let ``Small Page TLB Fills/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Small Page TLB Fills/sec"; instance = instance }
  /// Synthetic Interrupt Hypercalls/sec: -
  let ``Synthetic Interrupt Hypercalls/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Synthetic Interrupt Hypercalls/sec"; instance = instance }
  /// Synthetic Interrupts/sec: -
  let ``Synthetic Interrupts/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Synthetic Interrupts/sec"; instance = instance }
  /// Total Intercepts Cost: -
  let ``Total Intercepts Cost`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Total Intercepts Cost"; instance = instance }
  /// Total Intercepts/sec: -
  let ``Total Intercepts/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Total Intercepts/sec"; instance = instance }
  /// Total Messages/sec: -
  let ``Total Messages/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Total Messages/sec"; instance = instance }
  /// Virtual Interrupt Hypercalls/sec: -
  let ``Virtual Interrupt Hypercalls/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Virtual Interrupt Hypercalls/sec"; instance = instance }
  /// Virtual Interrupts/sec: -
  let ``Virtual Interrupts/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Virtual Interrupts/sec"; instance = instance }
  /// Virtual MMU Hypercalls/sec: -
  let ``Virtual MMU Hypercalls/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Virtual MMU Hypercalls/sec"; instance = instance }
  /// Virtual Processor Hypercalls/sec: -
  let ``Virtual Processor Hypercalls/sec`` instance =
    { category = "Hyper-V Hypervisor Virtual Processor"; counter = "Virtual Processor Hypercalls/sec"; instance = instance }

  let allCounters =
    [ ``% Guest Run Time``
      ``% Hypervisor Run Time``
      ``% Remote Run Time``
      ``% Total Run Time``
      ``APIC EOI Accesses/sec``
      ``APIC IPIs Sent/sec``
      ``APIC MMIO Accesses/sec``
      ``APIC Self IPIs Sent/sec``
      ``APIC TPR Accesses/sec``
      ``Address Domain Flushes/sec``
      ``Address Space Evictions/sec``
      ``Address Space Flushes/sec``
      ``Address Space Switches/sec``
      ``CPU Wait Time Per Dispatch``
      ``CPUID Instructions Cost``
      ``CPUID Instructions/sec``
      ``Control Register Accesses Cost``
      ``Control Register Accesses/sec``
      ``Debug Register Accesses Cost``
      ``Debug Register Accesses/sec``
      ``Emulated Instructions Cost``
      ``Emulated Instructions/sec``
      ``External Interrupts Cost``
      ``External Interrupts/sec``
      ``GPA Space Hypercalls/sec``
      ``Global GVA Range Flushes/sec``
      ``Guest Page Table Maps/sec``
      ``HLT Instructions Cost``
      ``HLT Instructions/sec``
      ``Hardware Interrupts/sec``
      ``Hypercalls Cost``
      ``Hypercalls/sec``
      ``IO Instructions Cost``
      ``IO Instructions/sec``
      ``IO Intercept Messages/sec``
      ``Large Page TLB Fills/sec``
      ``Local Flushed GVA Ranges/sec``
      ``Logical Processor Dispatches/sec``
      ``Logical Processor Hypercalls/sec``
      ``Logical Processor Migrations/sec``
      ``Long Spin Wait Hypercalls/sec``
      ``MSR Accesses Cost``
      ``MSR Accesses/sec``
      ``MWAIT Instructions Cost``
      ``MWAIT Instructions/sec``
      ``Memory Intercept Messages/sec``
      ``Nested Page Fault Intercepts Cost``
      ``Nested Page Fault Intercepts/sec``
      ``Other Hypercalls/sec``
      ``Other Intercepts Cost``
      ``Other Intercepts/sec``
      ``Other Messages/sec``
      ``Page Fault Intercepts Cost``
      ``Page Fault Intercepts/sec``
      ``Page Invalidations Cost``
      ``Page Invalidations/sec``
      ``Page Table Allocations/sec``
      ``Page Table Evictions/sec``
      ``Page Table Reclamations/sec``
      ``Page Table Resets/sec``
      ``Page Table Validations/sec``
      ``Page Table Write Intercepts/sec``
      ``Pending Interrupts Cost``
      ``Pending Interrupts/sec``
      ``Reflected Guest Page Faults/sec``
      ``Small Page TLB Fills/sec``
      ``Synthetic Interrupt Hypercalls/sec``
      ``Synthetic Interrupts/sec``
      ``Total Intercepts Cost``
      ``Total Intercepts/sec``
      ``Total Messages/sec``
      ``Virtual Interrupt Hypercalls/sec``
      ``Virtual Interrupts/sec``
      ``Virtual MMU Hypercalls/sec``
      ``Virtual Processor Hypercalls/sec``
    ]

/// Hyper-V Legacy Network Adapter: Performance counters for a virtual machine's Ethernet controller.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Legacy Network Adapter`` =

  [<Literal>]
  let Category = "Hyper-V Legacy Network Adapter"

  let PCC = getPCC Category
  /// Bytes Dropped: -
  let ``Bytes Dropped`` instance =
    { category = "Hyper-V Legacy Network Adapter"; counter = "Bytes Dropped"; instance = instance }
  /// Bytes Received/sec: -
  let ``Bytes Received/sec`` instance =
    { category = "Hyper-V Legacy Network Adapter"; counter = "Bytes Received/sec"; instance = instance }
  /// Bytes Sent/sec: -
  let ``Bytes Sent/sec`` instance =
    { category = "Hyper-V Legacy Network Adapter"; counter = "Bytes Sent/sec"; instance = instance }
  /// Frames Dropped: -
  let ``Frames Dropped`` instance =
    { category = "Hyper-V Legacy Network Adapter"; counter = "Frames Dropped"; instance = instance }
  /// Frames Received/sec: -
  let ``Frames Received/sec`` instance =
    { category = "Hyper-V Legacy Network Adapter"; counter = "Frames Received/sec"; instance = instance }
  /// Frames Sent/sec: -
  let ``Frames Sent/sec`` instance =
    { category = "Hyper-V Legacy Network Adapter"; counter = "Frames Sent/sec"; instance = instance }

  let allCounters =
    [ ``Bytes Dropped``
      ``Bytes Received/sec``
      ``Bytes Sent/sec``
      ``Frames Dropped``
      ``Frames Received/sec``
      ``Frames Sent/sec``
    ]

/// Hyper-V Replica VM: This counter set represents the Hyper-V Replica statistics for a virtual machine.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Replica VM`` =

  [<Literal>]
  let Category = "Hyper-V Replica VM"

  let PCC = getPCC Category
  /// Average Replication Latency: -
  let ``Average Replication Latency`` instance =
    { category = "Hyper-V Replica VM"; counter = "Average Replication Latency"; instance = instance }
  /// Average Replication Size: -
  let ``Average Replication Size`` instance =
    { category = "Hyper-V Replica VM"; counter = "Average Replication Size"; instance = instance }
  /// Compression Efficiency: -
  let ``Compression Efficiency`` instance =
    { category = "Hyper-V Replica VM"; counter = "Compression Efficiency"; instance = instance }
  /// Last Replication Size: -
  let ``Last Replication Size`` instance =
    { category = "Hyper-V Replica VM"; counter = "Last Replication Size"; instance = instance }
  /// Network Bytes Recv: -
  let ``Network Bytes Recv`` instance =
    { category = "Hyper-V Replica VM"; counter = "Network Bytes Recv"; instance = instance }
  /// Network Bytes Sent: -
  let ``Network Bytes Sent`` instance =
    { category = "Hyper-V Replica VM"; counter = "Network Bytes Sent"; instance = instance }
  /// Replication Count: -
  let ``Replication Count`` instance =
    { category = "Hyper-V Replica VM"; counter = "Replication Count"; instance = instance }
  /// Replication Latency: -
  let ``Replication Latency`` instance =
    { category = "Hyper-V Replica VM"; counter = "Replication Latency"; instance = instance }
  /// Resynchronized Bytes: -
  let ``Resynchronized Bytes`` instance =
    { category = "Hyper-V Replica VM"; counter = "Resynchronized Bytes"; instance = instance }

  let allCounters =
    [ ``Average Replication Latency``
      ``Average Replication Size``
      ``Compression Efficiency``
      ``Last Replication Size``
      ``Network Bytes Recv``
      ``Network Bytes Sent``
      ``Replication Count``
      ``Replication Latency``
      ``Resynchronized Bytes``
    ]


/// Hyper-V VM Live Migration: Performance counters for a virtual machine's live migration.
///
/// This performance counter does not have instance based counters
module ``Hyper-V VM Live Migration`` =

  [<Literal>]
  let Category = "Hyper-V VM Live Migration"

  let PCC = getPCC Category
  /// Compressor: Bytes to be Compressed: -
  let ``Compressor: Bytes to be Compressed`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "Compressor: Bytes to be Compressed"; instance = instance }
  /// Compressor: Compressed Bytes Sent: -
  let ``Compressor: Compressed Bytes Sent`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "Compressor: Compressed Bytes Sent"; instance = instance }
  /// Compressor: Compressed Bytes Sent/sec: -
  let ``Compressor: Compressed Bytes Sent/sec`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "Compressor: Compressed Bytes Sent/sec"; instance = instance }
  /// Compressor: Enabled Threads: -
  let ``Compressor: Enabled Threads`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "Compressor: Enabled Threads"; instance = instance }
  /// Compressor: Maximum Threads: -
  let ``Compressor: Maximum Threads`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "Compressor: Maximum Threads"; instance = instance }
  /// Memory Walker: Bytes Read/sec: -
  let ``Memory Walker: Bytes Read/sec`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "Memory Walker: Bytes Read/sec"; instance = instance }
  /// Memory Walker: Bytes Sent for Compression: -
  let ``Memory Walker: Bytes Sent for Compression`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "Memory Walker: Bytes Sent for Compression"; instance = instance }
  /// Memory Walker: Bytes Sent for Compression/sec: -
  let ``Memory Walker: Bytes Sent for Compression/sec`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "Memory Walker: Bytes Sent for Compression/sec"; instance = instance }
  /// Memory Walker: Maximum Threads: -
  let ``Memory Walker: Maximum Threads`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "Memory Walker: Maximum Threads"; instance = instance }
  /// Memory Walker: Uncompressed Bytes Sent: -
  let ``Memory Walker: Uncompressed Bytes Sent`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "Memory Walker: Uncompressed Bytes Sent"; instance = instance }
  /// Memory Walker: Uncompressed Bytes Sent/sec: -
  let ``Memory Walker: Uncompressed Bytes Sent/sec`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "Memory Walker: Uncompressed Bytes Sent/sec"; instance = instance }
  /// Receiver: Bytes Pending Decompression: -
  let ``Receiver: Bytes Pending Decompression`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "Receiver: Bytes Pending Decompression"; instance = instance }
  /// Receiver: Bytes Pending Write: -
  let ``Receiver: Bytes Pending Write`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "Receiver: Bytes Pending Write"; instance = instance }
  /// Receiver: Bytes Written/sec: -
  let ``Receiver: Bytes Written/sec`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "Receiver: Bytes Written/sec"; instance = instance }
  /// Receiver: Compressed Bytes Received/sec: -
  let ``Receiver: Compressed Bytes Received/sec`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "Receiver: Compressed Bytes Received/sec"; instance = instance }
  /// Receiver: Decompressed Bytes/sec: -
  let ``Receiver: Decompressed Bytes/sec`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "Receiver: Decompressed Bytes/sec"; instance = instance }
  /// Receiver: Maximum Threadpool Thread Count: -
  let ``Receiver: Maximum Threadpool Thread Count`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "Receiver: Maximum Threadpool Thread Count"; instance = instance }
  /// Receiver: Uncompressed Bytes Received/sec: -
  let ``Receiver: Uncompressed Bytes Received/sec`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "Receiver: Uncompressed Bytes Received/sec"; instance = instance }
  /// SMB Transport: Bytes Sent: -
  let ``SMB Transport: Bytes Sent`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "SMB Transport: Bytes Sent"; instance = instance }
  /// SMB Transport: Bytes Sent/sec: -
  let ``SMB Transport: Bytes Sent/sec`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "SMB Transport: Bytes Sent/sec"; instance = instance }
  /// SMB Transport: Pending Send Bytes: -
  let ``SMB Transport: Pending Send Bytes`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "SMB Transport: Pending Send Bytes"; instance = instance }
  /// SMB Transport: Pending Send Count: -
  let ``SMB Transport: Pending Send Count`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "SMB Transport: Pending Send Count"; instance = instance }
  /// TCP Transport: Bytes Pending Processing: -
  let ``TCP Transport: Bytes Pending Processing`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "TCP Transport: Bytes Pending Processing"; instance = instance }
  /// TCP Transport: Bytes Pending Send: -
  let ``TCP Transport: Bytes Pending Send`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "TCP Transport: Bytes Pending Send"; instance = instance }
  /// TCP Transport: Bytes Received/sec: -
  let ``TCP Transport: Bytes Received/sec`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "TCP Transport: Bytes Received/sec"; instance = instance }
  /// TCP Transport: Bytes Sent/sec: -
  let ``TCP Transport: Bytes Sent/sec`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "TCP Transport: Bytes Sent/sec"; instance = instance }
  /// TCP Transport: Pending Send Count: -
  let ``TCP Transport: Pending Send Count`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "TCP Transport: Pending Send Count"; instance = instance }
  /// TCP Transport: Posted Receive Buffer Count: -
  let ``TCP Transport: Posted Receive Buffer Count`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "TCP Transport: Posted Receive Buffer Count"; instance = instance }
  /// TCP Transport: Total buffer count: -
  let ``TCP Transport: Total buffer count`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "TCP Transport: Total buffer count"; instance = instance }
  /// Transfer Pass: Is blackout: -
  let ``Transfer Pass: Is blackout`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "Transfer Pass: Is blackout"; instance = instance }
  /// Transfer Pass: Number: -
  let ``Transfer Pass: Number`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "Transfer Pass: Number"; instance = instance }
  /// Transfer pass: CPU Cap: -
  let ``Transfer pass: CPU Cap`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "Transfer pass: CPU Cap"; instance = instance }
  /// Transfer pass: Dirty Page Count: -
  let ``Transfer pass: Dirty Page Count`` instance =
    { category = "Hyper-V VM Live Migration"; counter = "Transfer pass: Dirty Page Count"; instance = instance }

  let allCounters =
    [ ``Compressor: Bytes to be Compressed``
      ``Compressor: Compressed Bytes Sent``
      ``Compressor: Compressed Bytes Sent/sec``
      ``Compressor: Enabled Threads``
      ``Compressor: Maximum Threads``
      ``Memory Walker: Bytes Read/sec``
      ``Memory Walker: Bytes Sent for Compression``
      ``Memory Walker: Bytes Sent for Compression/sec``
      ``Memory Walker: Maximum Threads``
      ``Memory Walker: Uncompressed Bytes Sent``
      ``Memory Walker: Uncompressed Bytes Sent/sec``
      ``Receiver: Bytes Pending Decompression``
      ``Receiver: Bytes Pending Write``
      ``Receiver: Bytes Written/sec``
      ``Receiver: Compressed Bytes Received/sec``
      ``Receiver: Decompressed Bytes/sec``
      ``Receiver: Maximum Threadpool Thread Count``
      ``Receiver: Uncompressed Bytes Received/sec``
      ``SMB Transport: Bytes Sent``
      ``SMB Transport: Bytes Sent/sec``
      ``SMB Transport: Pending Send Bytes``
      ``SMB Transport: Pending Send Count``
      ``TCP Transport: Bytes Pending Processing``
      ``TCP Transport: Bytes Pending Send``
      ``TCP Transport: Bytes Received/sec``
      ``TCP Transport: Bytes Sent/sec``
      ``TCP Transport: Pending Send Count``
      ``TCP Transport: Posted Receive Buffer Count``
      ``TCP Transport: Total buffer count``
      ``Transfer Pass: Is blackout``
      ``Transfer Pass: Number``
      ``Transfer pass: CPU Cap``
      ``Transfer pass: Dirty Page Count``
    ]

/// Hyper-V VM Remoting: Performance counters for a virtual machine's remoting system.
///
/// This performance counter does not have instance based counters
module ``Hyper-V VM Remoting`` =

  [<Literal>]
  let Category = "Hyper-V VM Remoting"

  let PCC = getPCC Category
  /// Connected Clients: -
  let ``Connected Clients`` instance =
    { category = "Hyper-V VM Remoting"; counter = "Connected Clients"; instance = instance }
  /// Updated Pixels/sec: -
  let ``Updated Pixels/sec`` instance =
    { category = "Hyper-V VM Remoting"; counter = "Updated Pixels/sec"; instance = instance }

  let allCounters =
    [ ``Connected Clients``
      ``Updated Pixels/sec``
    ]

/// Hyper-V VM Save, Snapshot, and Restore: Performance counters for a virtual machine's save, snapshot, and restore systems.
///
/// This performance counter does not have instance based counters
module ``Hyper-V VM Save_ Snapshot_ and Restore`` =

  [<Literal>]
  let Category = "Hyper-V VM Save, Snapshot, and Restore"

  let PCC = getPCC Category
  /// Operation Time: -
  let ``Operation Time`` instance =
    { category = "Hyper-V VM Save, Snapshot, and Restore"; counter = "Operation Time"; instance = instance }
  /// Requests Active: -
  let ``Requests Active`` instance =
    { category = "Hyper-V VM Save, Snapshot, and Restore"; counter = "Requests Active"; instance = instance }
  /// Requests Dispatched: -
  let ``Requests Dispatched`` instance =
    { category = "Hyper-V VM Save, Snapshot, and Restore"; counter = "Requests Dispatched"; instance = instance }
  /// Requests High Priority: -
  let ``Requests High Priority`` instance =
    { category = "Hyper-V VM Save, Snapshot, and Restore"; counter = "Requests High Priority"; instance = instance }
  /// Requests Processed: -
  let ``Requests Processed`` instance =
    { category = "Hyper-V VM Save, Snapshot, and Restore"; counter = "Requests Processed"; instance = instance }
  /// Threads Spawned: -
  let ``Threads Spawned`` instance =
    { category = "Hyper-V VM Save, Snapshot, and Restore"; counter = "Threads Spawned"; instance = instance }

  let allCounters =
    [ ``Operation Time``
      ``Requests Active``
      ``Requests Dispatched``
      ``Requests High Priority``
      ``Requests Processed``
      ``Threads Spawned``
    ]


/// Hyper-V VM Vid Numa Node: The perf counters for a numa node.
///
/// This performance counter does not have non-instance based counters
module ``Hyper-V VM Vid Numa Node`` =

  [<Literal>]
  let Category = "Hyper-V VM Vid Numa Node"

  let PCC = getPCC Category
  /// PageCount: The number of physical pages detected on this NUMA node.
  let ``PageCount`` instance =
    { category = "Hyper-V VM Vid Numa Node"; counter = "PageCount"; instance = instance }
  /// ProcessorCount: The number of logical processors detected on this NUMA node.
  let ``ProcessorCount`` instance =
    { category = "Hyper-V VM Vid Numa Node"; counter = "ProcessorCount"; instance = instance }

  let allCounters =
    [ ``PageCount``
      ``ProcessorCount``
    ]

/// Hyper-V VM Vid Partition: These are the perf counters for a VID partition object.
///
/// This performance counter does not have instance based counters
module ``Hyper-V VM Vid Partition`` =

  [<Literal>]
  let Category = "Hyper-V VM Vid Partition"

  let PCC = getPCC Category
  /// Physical Pages Allocated: -
  let ``Physical Pages Allocated`` instance =
    { category = "Hyper-V VM Vid Partition"; counter = "Physical Pages Allocated"; instance = instance }
  /// Preferred NUMA Node Index: -
  let ``Preferred NUMA Node Index`` instance =
    { category = "Hyper-V VM Vid Partition"; counter = "Preferred NUMA Node Index"; instance = instance }
  /// Remote Physical Pages: -
  let ``Remote Physical Pages`` instance =
    { category = "Hyper-V VM Vid Partition"; counter = "Remote Physical Pages"; instance = instance }

  let allCounters =
    [ ``Physical Pages Allocated``
      ``Preferred NUMA Node Index``
      ``Remote Physical Pages``
    ]


/// Hyper-V Virtual IDE Controller (Emulated): Performance counters for a virtual machine's IDE Controller.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Virtual IDE Controller (Emulated)`` =

  [<Literal>]
  let Category = "Hyper-V Virtual IDE Controller (Emulated)"

  let PCC = getPCC Category
  /// Read Bytes/sec: -
  let ``Read Bytes/sec`` instance =
    { category = "Hyper-V Virtual IDE Controller (Emulated)"; counter = "Read Bytes/sec"; instance = instance }
  /// Read Sectors/sec: -
  let ``Read Sectors/sec`` instance =
    { category = "Hyper-V Virtual IDE Controller (Emulated)"; counter = "Read Sectors/sec"; instance = instance }
  /// Write Bytes/sec: -
  let ``Write Bytes/sec`` instance =
    { category = "Hyper-V Virtual IDE Controller (Emulated)"; counter = "Write Bytes/sec"; instance = instance }
  /// Written Sectors/sec: -
  let ``Written Sectors/sec`` instance =
    { category = "Hyper-V Virtual IDE Controller (Emulated)"; counter = "Written Sectors/sec"; instance = instance }

  let allCounters =
    [ ``Read Bytes/sec``
      ``Read Sectors/sec``
      ``Write Bytes/sec``
      ``Written Sectors/sec``
    ]

/// Hyper-V Virtual Machine Bus: This counter set represents the statistics for the virtual machine bus.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Virtual Machine Bus`` =

  [<Literal>]
  let Category = "Hyper-V Virtual Machine Bus"

  let PCC = getPCC Category
  /// Interrupts Received/sec: This counter represents the rate of interrupts received.
  let ``Interrupts Received/sec`` =
    { category = "Hyper-V Virtual Machine Bus"; counter = "Interrupts Received/sec"; instance = NotApplicable }
  /// Interrupts Sent/sec: This counter represents the rate of interrupts sent.
  let ``Interrupts Sent/sec`` =
    { category = "Hyper-V Virtual Machine Bus"; counter = "Interrupts Sent/sec"; instance = NotApplicable }
  /// Throttle Events: This counter represents the total number of times that any partition has been throttled, which is to say that its interrupts were disabled.
  let ``Throttle Events`` =
    { category = "Hyper-V Virtual Machine Bus"; counter = "Throttle Events"; instance = NotApplicable }

  let allCounters =
    [ ``Interrupts Received/sec``
      ``Interrupts Sent/sec``
      ``Throttle Events``
    ]

/// Hyper-V Virtual Machine Health Summary: This counter set represents the health summary statistics for the Virtual Machine Management Service.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Virtual Machine Health Summary`` =

  [<Literal>]
  let Category = "Hyper-V Virtual Machine Health Summary"

  let PCC = getPCC Category
  /// Health Critical: This counter represents the number of virtual machines with critical health.
  let ``Health Critical`` =
    { category = "Hyper-V Virtual Machine Health Summary"; counter = "Health Critical"; instance = NotApplicable }
  /// Health Ok: This counter represents the number of virtual machines with ok health.
  let ``Health Ok`` =
    { category = "Hyper-V Virtual Machine Health Summary"; counter = "Health Ok"; instance = NotApplicable }

  let allCounters =
    [ ``Health Critical``
      ``Health Ok``
    ]

/// Hyper-V Virtual Network Adapter: This counter set represents the statistics for the Microsoft Hyper-V network adapter.
///
/// This performance counter does not have non-instance based counters
module ``Hyper-V Virtual Network Adapter`` =

  [<Literal>]
  let Category = "Hyper-V Virtual Network Adapter"

  let PCC = getPCC Category
  /// Broadcast Packets Received/sec: This counter represents the total number of broadcast packets received per second by the network adapter.
  let ``Broadcast Packets Received/sec`` instance =
    { category = "Hyper-V Virtual Network Adapter"; counter = "Broadcast Packets Received/sec"; instance = instance }
  /// Broadcast Packets Sent/sec: This counter represents the total number of broadcast packets sent per second by the network adapter.
  let ``Broadcast Packets Sent/sec`` instance =
    { category = "Hyper-V Virtual Network Adapter"; counter = "Broadcast Packets Sent/sec"; instance = instance }
  /// Bytes Received/sec: This counter represents the total number of bytes received per second by the network adapter.
  let ``Bytes Received/sec`` instance =
    { category = "Hyper-V Virtual Network Adapter"; counter = "Bytes Received/sec"; instance = instance }
  /// Bytes Sent/sec: This counter represents the total number of bytes sent per second by the network adapter.
  let ``Bytes Sent/sec`` instance =
    { category = "Hyper-V Virtual Network Adapter"; counter = "Bytes Sent/sec"; instance = instance }
  /// Bytes/sec: This counter represents the total number of bytes per second traversing the network adapter.
  let ``Bytes/sec`` instance =
    { category = "Hyper-V Virtual Network Adapter"; counter = "Bytes/sec"; instance = instance }
  /// Directed Packets Received/sec: This counter represents the total number of directed packets received per second by the network adapter.
  let ``Directed Packets Received/sec`` instance =
    { category = "Hyper-V Virtual Network Adapter"; counter = "Directed Packets Received/sec"; instance = instance }
  /// Directed Packets Sent/sec: This counter represents the total number of directed packets sent per second by the network adapter.
  let ``Directed Packets Sent/sec`` instance =
    { category = "Hyper-V Virtual Network Adapter"; counter = "Directed Packets Sent/sec"; instance = instance }
  /// Dropped Packets Incoming/sec: This counter represents the total number of dropped packets per second in the incoming direction of the network adapter.
  let ``Dropped Packets Incoming/sec`` instance =
    { category = "Hyper-V Virtual Network Adapter"; counter = "Dropped Packets Incoming/sec"; instance = instance }
  /// Dropped Packets Outgoing/sec: This counter represents the total number of dropped packets per second in the outgoing direction of the network adapter.
  let ``Dropped Packets Outgoing/sec`` instance =
    { category = "Hyper-V Virtual Network Adapter"; counter = "Dropped Packets Outgoing/sec"; instance = instance }
  /// Extensions Dropped Packets Incoming/sec: This counter represents the total number of dropped packets per second by switch extensions in the incoming direction of the network adapter.
  let ``Extensions Dropped Packets Incoming/sec`` instance =
    { category = "Hyper-V Virtual Network Adapter"; counter = "Extensions Dropped Packets Incoming/sec"; instance = instance }
  /// Extensions Dropped Packets Outgoing/sec: This counter represents the total number of dropped packets per second by switch extensions in the outgoing direction of the network adapter.
  let ``Extensions Dropped Packets Outgoing/sec`` instance =
    { category = "Hyper-V Virtual Network Adapter"; counter = "Extensions Dropped Packets Outgoing/sec"; instance = instance }
  /// IPsec offload Bytes Receive/sec: This counter represents the total number of Psec offload bytes received per second by the network adapter.
  let ``IPsec offload Bytes Receive/sec`` instance =
    { category = "Hyper-V Virtual Network Adapter"; counter = "IPsec offload Bytes Receive/sec"; instance = instance }
  /// IPsec offload Bytes Sent/sec: This counter represents the total number of Psec offload bytes sent per second by the network adapter.
  let ``IPsec offload Bytes Sent/sec`` instance =
    { category = "Hyper-V Virtual Network Adapter"; counter = "IPsec offload Bytes Sent/sec"; instance = instance }
  /// Multicast Packets Received/sec: This counter represents the total number of multicast packets received per second by the network adapter.
  let ``Multicast Packets Received/sec`` instance =
    { category = "Hyper-V Virtual Network Adapter"; counter = "Multicast Packets Received/sec"; instance = instance }
  /// Multicast Packets Sent/sec: This counter represents the total number of multicast packets sent per second by the network adapter.
  let ``Multicast Packets Sent/sec`` instance =
    { category = "Hyper-V Virtual Network Adapter"; counter = "Multicast Packets Sent/sec"; instance = instance }
  /// Packets Received/sec: This counter represents the total number of packets received per second by the network adapter.
  let ``Packets Received/sec`` instance =
    { category = "Hyper-V Virtual Network Adapter"; counter = "Packets Received/sec"; instance = instance }
  /// Packets Sent/sec: This counter represents the total number of packets sent per second by the network adapter.
  let ``Packets Sent/sec`` instance =
    { category = "Hyper-V Virtual Network Adapter"; counter = "Packets Sent/sec"; instance = instance }
  /// Packets/sec: This counter represents the total number of packets per second traversing the network adapter.
  let ``Packets/sec`` instance =
    { category = "Hyper-V Virtual Network Adapter"; counter = "Packets/sec"; instance = instance }

  let allCounters =
    [ ``Broadcast Packets Received/sec``
      ``Broadcast Packets Sent/sec``
      ``Bytes Received/sec``
      ``Bytes Sent/sec``
      ``Bytes/sec``
      ``Directed Packets Received/sec``
      ``Directed Packets Sent/sec``
      ``Dropped Packets Incoming/sec``
      ``Dropped Packets Outgoing/sec``
      ``Extensions Dropped Packets Incoming/sec``
      ``Extensions Dropped Packets Outgoing/sec``
      ``IPsec offload Bytes Receive/sec``
      ``IPsec offload Bytes Sent/sec``
      ``Multicast Packets Received/sec``
      ``Multicast Packets Sent/sec``
      ``Packets Received/sec``
      ``Packets Sent/sec``
      ``Packets/sec``
    ]

/// Hyper-V Virtual Storage Device: This counter set represents the statistics for a virtual storage device.
///
/// This performance counter does not have instance based counters
module ``Hyper-V Virtual Storage Device`` =

  [<Literal>]
  let Category = "Hyper-V Virtual Storage Device"

  let PCC = getPCC Category
  /// Error Count: -
  let ``Error Count`` instance =
    { category = "Hyper-V Virtual Storage Device"; counter = "Error Count"; instance = instance }
  /// Flush Count: -
  let ``Flush Count`` instance =
    { category = "Hyper-V Virtual Storage Device"; counter = "Flush Count"; instance = instance }
  /// Normalized Throughput: -
  let ``Normalized Throughput`` instance =
    { category = "Hyper-V Virtual Storage Device"; counter = "Normalized Throughput"; instance = instance }
  /// Queue Length: -
  let ``Queue Length`` instance =
    { category = "Hyper-V Virtual Storage Device"; counter = "Queue Length"; instance = instance }
  /// Quota Replenishment Rate: -
  let ``Quota Replenishment Rate`` instance =
    { category = "Hyper-V Virtual Storage Device"; counter = "Quota Replenishment Rate"; instance = instance }
  /// Read Bytes/sec: -
  let ``Read Bytes/sec`` instance =
    { category = "Hyper-V Virtual Storage Device"; counter = "Read Bytes/sec"; instance = instance }
  /// Read Count: -
  let ``Read Count`` instance =
    { category = "Hyper-V Virtual Storage Device"; counter = "Read Count"; instance = instance }
  /// Read Operations/Sec: -
  let ``Read Operations/Sec`` instance =
    { category = "Hyper-V Virtual Storage Device"; counter = "Read Operations/Sec"; instance = instance }
  /// Write Bytes/sec: -
  let ``Write Bytes/sec`` instance =
    { category = "Hyper-V Virtual Storage Device"; counter = "Write Bytes/sec"; instance = instance }
  /// Write Count: -
  let ``Write Count`` instance =
    { category = "Hyper-V Virtual Storage Device"; counter = "Write Count"; instance = instance }
  /// Write Operations/Sec: -
  let ``Write Operations/Sec`` instance =
    { category = "Hyper-V Virtual Storage Device"; counter = "Write Operations/Sec"; instance = instance }

  let allCounters =
    [ ``Error Count``
      ``Flush Count``
      ``Normalized Throughput``
      ``Queue Length``
      ``Quota Replenishment Rate``
      ``Read Bytes/sec``
      ``Read Count``
      ``Read Operations/Sec``
      ``Write Bytes/sec``
      ``Write Count``
      ``Write Operations/Sec``
    ]

/// Hyper-V Virtual Switch: This counter set represents the statistics for the Microsoft Hyper-V switch.
///
/// This performance counter does not have non-instance based counters
module ``Hyper-V Virtual Switch`` =

  [<Literal>]
  let Category = "Hyper-V Virtual Switch"

  let PCC = getPCC Category
  /// Broadcast Packets Received/sec: This counter represents the total number of broadcast packets received per second by the virtual switch.
  let ``Broadcast Packets Received/sec`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Broadcast Packets Received/sec"; instance = instance }
  /// Broadcast Packets Sent/sec: This counter represents the total number of broadcast packets sent per second by the virtual switch.
  let ``Broadcast Packets Sent/sec`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Broadcast Packets Sent/sec"; instance = instance }
  /// Bytes Received/sec: This counter represents the total number of bytes received per second by the virtual switch.
  let ``Bytes Received/sec`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Bytes Received/sec"; instance = instance }
  /// Bytes Sent/sec: This counter represents the total number of bytes sent per second by the virtual switch.
  let ``Bytes Sent/sec`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Bytes Sent/sec"; instance = instance }
  /// Bytes/sec: This counter represents the total number of bytes per second traversing the virtual switch.
  let ``Bytes/sec`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Bytes/sec"; instance = instance }
  /// Directed Packets Received/sec: This counter represents the total number of directed packets received per second by the virtual switch.
  let ``Directed Packets Received/sec`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Directed Packets Received/sec"; instance = instance }
  /// Directed Packets Sent/sec: This counter represents the total number of directed packets sent per second by the virtual switch.
  let ``Directed Packets Sent/sec`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Directed Packets Sent/sec"; instance = instance }
  /// Dropped Packets Incoming/sec: This counter represents the total number of packet dropped per second by the virtual switch in the incoming direction.
  let ``Dropped Packets Incoming/sec`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Dropped Packets Incoming/sec"; instance = instance }
  /// Dropped Packets Outgoing/sec: This counter represents the total number of packet dropped per second by the virtual switch in the outgoing direction.
  let ``Dropped Packets Outgoing/sec`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Dropped Packets Outgoing/sec"; instance = instance }
  /// Extensions Dropped Packets Incoming/sec: This counter represents the total number of packet dropped per second by the virtual switch extensions in the incoming direction.
  let ``Extensions Dropped Packets Incoming/sec`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Extensions Dropped Packets Incoming/sec"; instance = instance }
  /// Extensions Dropped Packets Outgoing/sec: This counter represents the total number of packet dropped per second by the virtual switch extensions in the outgoing direction.
  let ``Extensions Dropped Packets Outgoing/sec`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Extensions Dropped Packets Outgoing/sec"; instance = instance }
  /// Learned Mac Addresses: This counter represents the total number of learned MAC addresses of the virtual switch.
  let ``Learned Mac Addresses`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Learned Mac Addresses"; instance = instance }
  /// Learned Mac Addresses/sec: This counter represents the total number MAC addresses learned per second by the virtual switch.
  let ``Learned Mac Addresses/sec`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Learned Mac Addresses/sec"; instance = instance }
  /// Multicast Packets Received/sec: This counter represents the total number of multicast packets received per second by the virtual switch.
  let ``Multicast Packets Received/sec`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Multicast Packets Received/sec"; instance = instance }
  /// Multicast Packets Sent/sec: This counter represents the total number of multicast packets sent per second by the virtual switch.
  let ``Multicast Packets Sent/sec`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Multicast Packets Sent/sec"; instance = instance }
  /// Number of Send Channel Moves/sec: This counter represents the total number of send channel moves per second on this virtual switch.
  let ``Number of Send Channel Moves/sec`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Number of Send Channel Moves/sec"; instance = instance }
  /// Number of VMQ Moves/sec: This counter represents the total number of VMQ moves per second on this virtual switch.
  let ``Number of VMQ Moves/sec`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Number of VMQ Moves/sec"; instance = instance }
  /// Packets Flooded: This counter represents the total number of packets flooded by the virtual switch.
  let ``Packets Flooded`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Packets Flooded"; instance = instance }
  /// Packets Flooded/sec: This counter represents the total number of packets flooded per second by the virtual switch.
  let ``Packets Flooded/sec`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Packets Flooded/sec"; instance = instance }
  /// Packets Received/sec: This counter represents the total number of packets received per second by the virtual switch.
  let ``Packets Received/sec`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Packets Received/sec"; instance = instance }
  /// Packets Sent/sec: This counter represents the total number of packets sent per second by the virtual switch.
  let ``Packets Sent/sec`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Packets Sent/sec"; instance = instance }
  /// Packets/sec: This counter represents the total number of packets per second traversing the virtual switch.
  let ``Packets/sec`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Packets/sec"; instance = instance }
  /// Purged Mac Addresses: This counter represents the total number of purged MAC addresses of the virtual switch.
  let ``Purged Mac Addresses`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Purged Mac Addresses"; instance = instance }
  /// Purged Mac Addresses/sec: This counter represents the total number MAC addresses purged per second by the virtual switch.
  let ``Purged Mac Addresses/sec`` instance =
    { category = "Hyper-V Virtual Switch"; counter = "Purged Mac Addresses/sec"; instance = instance }

  let allCounters =
    [ ``Broadcast Packets Received/sec``
      ``Broadcast Packets Sent/sec``
      ``Bytes Received/sec``
      ``Bytes Sent/sec``
      ``Bytes/sec``
      ``Directed Packets Received/sec``
      ``Directed Packets Sent/sec``
      ``Dropped Packets Incoming/sec``
      ``Dropped Packets Outgoing/sec``
      ``Extensions Dropped Packets Incoming/sec``
      ``Extensions Dropped Packets Outgoing/sec``
      ``Learned Mac Addresses``
      ``Learned Mac Addresses/sec``
      ``Multicast Packets Received/sec``
      ``Multicast Packets Sent/sec``
      ``Number of Send Channel Moves/sec``
      ``Number of VMQ Moves/sec``
      ``Packets Flooded``
      ``Packets Flooded/sec``
      ``Packets Received/sec``
      ``Packets Sent/sec``
      ``Packets/sec``
      ``Purged Mac Addresses``
      ``Purged Mac Addresses/sec``
    ]

/// Hyper-V Virtual Switch Port: This counter set represents the statistics for the Microsoft Hyper-V switch port.
///
/// This performance counter does not have non-instance based counters
module ``Hyper-V Virtual Switch Port`` =

  [<Literal>]
  let Category = "Hyper-V Virtual Switch Port"

  let PCC = getPCC Category
  /// Broadcast Packets Received/sec: This counter represents the total number of broadcast packets received per second by the virtual switch port.
  let ``Broadcast Packets Received/sec`` instance =
    { category = "Hyper-V Virtual Switch Port"; counter = "Broadcast Packets Received/sec"; instance = instance }
  /// Broadcast Packets Sent/sec: This counter represents the total number of broadcast packets sent per second by the virtual switch port.
  let ``Broadcast Packets Sent/sec`` instance =
    { category = "Hyper-V Virtual Switch Port"; counter = "Broadcast Packets Sent/sec"; instance = instance }
  /// Bytes Received/sec: This counter represents the total number of bytes received per second by the virtual switch port.
  let ``Bytes Received/sec`` instance =
    { category = "Hyper-V Virtual Switch Port"; counter = "Bytes Received/sec"; instance = instance }
  /// Bytes Sent/sec: This counter represents the total number of bytes sent per second by the virtual switch port.
  let ``Bytes Sent/sec`` instance =
    { category = "Hyper-V Virtual Switch Port"; counter = "Bytes Sent/sec"; instance = instance }
  /// Bytes/sec: This counter represents the total number of bytes per second traversing the virtual switch port.
  let ``Bytes/sec`` instance =
    { category = "Hyper-V Virtual Switch Port"; counter = "Bytes/sec"; instance = instance }
  /// Directed Packets Received/sec: This counter represents the total number of directed packets received per second by the virtual switch port.
  let ``Directed Packets Received/sec`` instance =
    { category = "Hyper-V Virtual Switch Port"; counter = "Directed Packets Received/sec"; instance = instance }
  /// Directed Packets Sent/sec: This counter represents the total number of directed packets sent per second by the virtual switch port.
  let ``Directed Packets Sent/sec`` instance =
    { category = "Hyper-V Virtual Switch Port"; counter = "Directed Packets Sent/sec"; instance = instance }
  /// Dropped Packets Incoming/sec: This counter represents the total number of dropped packets per second in the incoming direction of the virtual switch port.
  let ``Dropped Packets Incoming/sec`` instance =
    { category = "Hyper-V Virtual Switch Port"; counter = "Dropped Packets Incoming/sec"; instance = instance }
  /// Dropped Packets Outgoing/sec: This counter represents the total number of dropped packets per second in the outgoing direction of the virtual switch port.
  let ``Dropped Packets Outgoing/sec`` instance =
    { category = "Hyper-V Virtual Switch Port"; counter = "Dropped Packets Outgoing/sec"; instance = instance }
  /// Extensions Dropped Packets Incoming/sec: This counter represents the total number of dropped packets per second by the switch extensions in the incoming direction of the virtual switch port.
  let ``Extensions Dropped Packets Incoming/sec`` instance =
    { category = "Hyper-V Virtual Switch Port"; counter = "Extensions Dropped Packets Incoming/sec"; instance = instance }
  /// Extensions Dropped Packets Outgoing/sec: This counter represents the total number of dropped packets per second by the switch extensions in the outgoing direction of the virtual switch port.
  let ``Extensions Dropped Packets Outgoing/sec`` instance =
    { category = "Hyper-V Virtual Switch Port"; counter = "Extensions Dropped Packets Outgoing/sec"; instance = instance }
  /// IPsec SAs Offloaded : This counter represents the total number of IPsec Security Associations currently offloaded by the virtual switch port.
  let ``IPsec SAs Offloaded `` instance =
    { category = "Hyper-V Virtual Switch Port"; counter = "IPsec SAs Offloaded "; instance = instance }
  /// IPsec offload Bytes Receive/sec: This counter represents the total number of IPsec offload bytes received per second by the virtual switch port.
  let ``IPsec offload Bytes Receive/sec`` instance =
    { category = "Hyper-V Virtual Switch Port"; counter = "IPsec offload Bytes Receive/sec"; instance = instance }
  /// IPsec offload Bytes Sent/sec: This counter represents the total number of IPsec offload bytes sent per second by the virtual switch port.
  let ``IPsec offload Bytes Sent/sec`` instance =
    { category = "Hyper-V Virtual Switch Port"; counter = "IPsec offload Bytes Sent/sec"; instance = instance }
  /// Multicast Packets Received/sec: This counter represents the total number of multicast packets received per second by the virtual switch port.
  let ``Multicast Packets Received/sec`` instance =
    { category = "Hyper-V Virtual Switch Port"; counter = "Multicast Packets Received/sec"; instance = instance }
  /// Multicast Packets Sent/sec: This counter represents the total number of multicast packets sent per second by the virtual switch port.
  let ``Multicast Packets Sent/sec`` instance =
    { category = "Hyper-V Virtual Switch Port"; counter = "Multicast Packets Sent/sec"; instance = instance }
  /// Packets Received/sec: This counter represents the total number of packets received per second by the virtual switch port.
  let ``Packets Received/sec`` instance =
    { category = "Hyper-V Virtual Switch Port"; counter = "Packets Received/sec"; instance = instance }
  /// Packets Sent/sec: This counter represents the total number of packets sent per second by the virtual switch port.
  let ``Packets Sent/sec`` instance =
    { category = "Hyper-V Virtual Switch Port"; counter = "Packets Sent/sec"; instance = instance }
  /// Packets/sec: This counter represents the total number of packets per second traversing the virtual switch port.
  let ``Packets/sec`` instance =
    { category = "Hyper-V Virtual Switch Port"; counter = "Packets/sec"; instance = instance }

  let allCounters =
    [ ``Broadcast Packets Received/sec``
      ``Broadcast Packets Sent/sec``
      ``Bytes Received/sec``
      ``Bytes Sent/sec``
      ``Bytes/sec``
      ``Directed Packets Received/sec``
      ``Directed Packets Sent/sec``
      ``Dropped Packets Incoming/sec``
      ``Dropped Packets Outgoing/sec``
      ``Extensions Dropped Packets Incoming/sec``
      ``Extensions Dropped Packets Outgoing/sec``
      ``IPsec SAs Offloaded ``
      ``IPsec offload Bytes Receive/sec``
      ``IPsec offload Bytes Sent/sec``
      ``Multicast Packets Received/sec``
      ``Multicast Packets Sent/sec``
      ``Packets Received/sec``
      ``Packets Sent/sec``
      ``Packets/sec``
    ]

/// Hyper-V Virtual Switch Processor: This counter set represents the statistics for the Microsoft Hyper-V switch processor.
///
/// This performance counter does not have non-instance based counters
module ``Hyper-V Virtual Switch Processor`` =

  [<Literal>]
  let Category = "Hyper-V Virtual Switch Processor"

  let PCC = getPCC Category
  /// Number of Transmit Completes/sec: This counter represents the number of transmit completes per second targeting on the virtual switch processor.
  let ``Number of Transmit Completes/sec`` instance =
    { category = "Hyper-V Virtual Switch Processor"; counter = "Number of Transmit Completes/sec"; instance = instance }
  /// Number of VMQs: This counter represents the number of VMQs targeting on the virtual switch processor.
  let ``Number of VMQs`` instance =
    { category = "Hyper-V Virtual Switch Processor"; counter = "Number of VMQs"; instance = instance }
  /// Packets from External/sec: This counter represents the number of packets from the external NIC that enter the virtual switch per second on the virtual switch processor.
  let ``Packets from External/sec`` instance =
    { category = "Hyper-V Virtual Switch Processor"; counter = "Packets from External/sec"; instance = instance }
  /// Packets from Internal/sec: This counter represents the number of packets from the VM/host that enter the virtual switch per second on the virtual switch processor.
  let ``Packets from Internal/sec`` instance =
    { category = "Hyper-V Virtual Switch Processor"; counter = "Packets from Internal/sec"; instance = instance }

  let allCounters =
    [ ``Number of Transmit Completes/sec``
      ``Number of VMQs``
      ``Packets from External/sec``
      ``Packets from Internal/sec``
    ]

/// ICMP: The ICMP performance object consists of counters that measure the rates at which messages are sent and received by using ICMP protocols.  It also includes counters that monitor ICMP protocol errors.
///
/// This performance counter does not have instance based counters
module ``ICMP`` =

  [<Literal>]
  let Category = "ICMP"

  let PCC = getPCC Category
  /// Messages Outbound Errors: Messages Outbound Errors is the number of ICMP messages that were not send due to problems within ICMP, such as lack of buffers.  This value does not include errors discovered outside the ICMP layer, such as those recording the failure of IP to route the resultant datagram.  In some implementations, none of the error types are included in the value of this counter.
  let ``Messages Outbound Errors`` =
    { category = "ICMP"; counter = "Messages Outbound Errors"; instance = NotApplicable }
  /// Messages Received Errors: Messages Received Errors is the number of ICMP messages that the entity received but had errors, such as bad ICMP checksums, bad length, etc.
  let ``Messages Received Errors`` =
    { category = "ICMP"; counter = "Messages Received Errors"; instance = NotApplicable }
  /// Messages Received/sec: Messages Received/sec is the rate, in incidents per second at which ICMP messages were received. The rate includes messages received in error.
  let ``Messages Received/sec`` =
    { category = "ICMP"; counter = "Messages Received/sec"; instance = NotApplicable }
  /// Messages Sent/sec: Messages Sent/sec is the rate, in incidents per second, at which the server attempted to send. The rate includes those messages sent in error.
  let ``Messages Sent/sec`` =
    { category = "ICMP"; counter = "Messages Sent/sec"; instance = NotApplicable }
  /// Messages/sec: Messages/sec is the total rate, in incidents per second, at which ICMP messages were sent and received by the entity. The rate includes messages received or sent in error.
  let ``Messages/sec`` =
    { category = "ICMP"; counter = "Messages/sec"; instance = NotApplicable }
  /// Received Address Mask: Received Address Mask is the number of ICMP Address Mask Request messages received.
  let ``Received Address Mask`` =
    { category = "ICMP"; counter = "Received Address Mask"; instance = NotApplicable }
  /// Received Address Mask Reply: Received Address Mask Reply is the number of ICMP Address Mask Reply messages received.
  let ``Received Address Mask Reply`` =
    { category = "ICMP"; counter = "Received Address Mask Reply"; instance = NotApplicable }
  /// Received Dest. Unreachable: Received Destination Unreachable is the number of ICMP Destination Unreachable messages received.
  let ``Received Dest. Unreachable`` =
    { category = "ICMP"; counter = "Received Dest. Unreachable"; instance = NotApplicable }
  /// Received Echo Reply/sec: Received Echo Reply/sec is the rate, in incidents per second, at which ICMP Echo Reply messages were received.
  let ``Received Echo Reply/sec`` =
    { category = "ICMP"; counter = "Received Echo Reply/sec"; instance = NotApplicable }
  /// Received Echo/sec: Received Echo/sec is the rate, in incidents per second, at which ICMP Echo messages were received.
  let ``Received Echo/sec`` =
    { category = "ICMP"; counter = "Received Echo/sec"; instance = NotApplicable }
  /// Received Parameter Problem: Received Parameter Problem is the number of ICMP Parameter Problem messages received.
  let ``Received Parameter Problem`` =
    { category = "ICMP"; counter = "Received Parameter Problem"; instance = NotApplicable }
  /// Received Redirect/sec: Received Redirect/sec is the rate, in incidents per second, at which ICMP Redirect messages were received.
  let ``Received Redirect/sec`` =
    { category = "ICMP"; counter = "Received Redirect/sec"; instance = NotApplicable }
  /// Received Source Quench: Received Source Quench is the number of ICMP Source Quench messages received.
  let ``Received Source Quench`` =
    { category = "ICMP"; counter = "Received Source Quench"; instance = NotApplicable }
  /// Received Time Exceeded: Received Time Exceeded is the number of ICMP Time Exceeded messages received.
  let ``Received Time Exceeded`` =
    { category = "ICMP"; counter = "Received Time Exceeded"; instance = NotApplicable }
  /// Received Timestamp Reply/sec: Received Timestamp Reply/sec is the rate of ICMP Timestamp Reply messages received.
  let ``Received Timestamp Reply/sec`` =
    { category = "ICMP"; counter = "Received Timestamp Reply/sec"; instance = NotApplicable }
  /// Received Timestamp/sec: Received Timestamp/sec is the rate, in incidents per second at which ICMP Timestamp Request messages were received.
  let ``Received Timestamp/sec`` =
    { category = "ICMP"; counter = "Received Timestamp/sec"; instance = NotApplicable }
  /// Sent Address Mask: Sent Address Mask is the number of ICMP Address Mask Request messages sent.
  let ``Sent Address Mask`` =
    { category = "ICMP"; counter = "Sent Address Mask"; instance = NotApplicable }
  /// Sent Address Mask Reply: Sent Address Mask Reply is the number of ICMP Address Mask Reply messages sent.
  let ``Sent Address Mask Reply`` =
    { category = "ICMP"; counter = "Sent Address Mask Reply"; instance = NotApplicable }
  /// Sent Destination Unreachable: Sent Destination Unreachable is the number of ICMP Destination Unreachable messages sent.
  let ``Sent Destination Unreachable`` =
    { category = "ICMP"; counter = "Sent Destination Unreachable"; instance = NotApplicable }
  /// Sent Echo Reply/sec: Sent Echo Reply/sec is the rate, in incidents per second, at which ICMP Echo Reply messages were sent.
  let ``Sent Echo Reply/sec`` =
    { category = "ICMP"; counter = "Sent Echo Reply/sec"; instance = NotApplicable }
  /// Sent Echo/sec: Sent Echo/sec is the rate of ICMP Echo messages sent.
  let ``Sent Echo/sec`` =
    { category = "ICMP"; counter = "Sent Echo/sec"; instance = NotApplicable }
  /// Sent Parameter Problem: Sent Parameter Problem is the number of ICMP Parameter Problem messages sent.
  let ``Sent Parameter Problem`` =
    { category = "ICMP"; counter = "Sent Parameter Problem"; instance = NotApplicable }
  /// Sent Redirect/sec: Sent Redirect/sec is the rate, in incidents per second, at which ICMP Redirect messages were sent.
  let ``Sent Redirect/sec`` =
    { category = "ICMP"; counter = "Sent Redirect/sec"; instance = NotApplicable }
  /// Sent Source Quench: Sent Source Quench is the number of ICMP Source Quench messages sent.
  let ``Sent Source Quench`` =
    { category = "ICMP"; counter = "Sent Source Quench"; instance = NotApplicable }
  /// Sent Time Exceeded: Sent Time Exceeded is the number of ICMP Time Exceeded messages sent.
  let ``Sent Time Exceeded`` =
    { category = "ICMP"; counter = "Sent Time Exceeded"; instance = NotApplicable }
  /// Sent Timestamp Reply/sec: Sent Timestamp Reply/sec is the rate, in incidents per second,  at which ICMP Timestamp Reply messages were sent.
  let ``Sent Timestamp Reply/sec`` =
    { category = "ICMP"; counter = "Sent Timestamp Reply/sec"; instance = NotApplicable }
  /// Sent Timestamp/sec: Sent Timestamp/sec is the rate, in incidents per second, at which ICMP Timestamp Request messages were sent.
  let ``Sent Timestamp/sec`` =
    { category = "ICMP"; counter = "Sent Timestamp/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Messages Outbound Errors``
      ``Messages Received Errors``
      ``Messages Received/sec``
      ``Messages Sent/sec``
      ``Messages/sec``
      ``Received Address Mask``
      ``Received Address Mask Reply``
      ``Received Dest. Unreachable``
      ``Received Echo Reply/sec``
      ``Received Echo/sec``
      ``Received Parameter Problem``
      ``Received Redirect/sec``
      ``Received Source Quench``
      ``Received Time Exceeded``
      ``Received Timestamp Reply/sec``
      ``Received Timestamp/sec``
      ``Sent Address Mask``
      ``Sent Address Mask Reply``
      ``Sent Destination Unreachable``
      ``Sent Echo Reply/sec``
      ``Sent Echo/sec``
      ``Sent Parameter Problem``
      ``Sent Redirect/sec``
      ``Sent Source Quench``
      ``Sent Time Exceeded``
      ``Sent Timestamp Reply/sec``
      ``Sent Timestamp/sec``
    ]

/// ICMPv6: The ICMP performance object consists of counters that measure the rates at which messages are sent and received by using ICMP protocols.  It also includes counters that monitor ICMP protocol errors.
///
/// This performance counter does not have instance based counters
module ``ICMPv6`` =

  [<Literal>]
  let Category = "ICMPv6"

  let PCC = getPCC Category
  /// Messages Outbound Errors: Messages Outbound Errors is the number of ICMP messages that were not send due to problems within ICMP, such as lack of buffers.  This value does not include errors discovered outside the ICMP layer, such as those recording the failure of IP to route the resultant datagram.  In some implementations, none of the error types are included in the value of this counter.
  let ``Messages Outbound Errors`` =
    { category = "ICMPv6"; counter = "Messages Outbound Errors"; instance = NotApplicable }
  /// Messages Received Errors: Messages Received Errors is the number of ICMP messages that the entity received but had errors, such as bad ICMP checksums, bad length, etc.
  let ``Messages Received Errors`` =
    { category = "ICMPv6"; counter = "Messages Received Errors"; instance = NotApplicable }
  /// Messages Received/sec: Messages Received/sec is the rate, in incidents per second at which ICMP messages were received. The rate includes messages received in error.
  let ``Messages Received/sec`` =
    { category = "ICMPv6"; counter = "Messages Received/sec"; instance = NotApplicable }
  /// Messages Sent/sec: Messages Sent/sec is the rate, in incidents per second, at which the server attempted to send. The rate includes those messages sent in error.
  let ``Messages Sent/sec`` =
    { category = "ICMPv6"; counter = "Messages Sent/sec"; instance = NotApplicable }
  /// Messages/sec: Messages/sec is the total rate, in incidents per second, at which ICMP messages were sent and received by the entity. The rate includes messages received or sent in error.
  let ``Messages/sec`` =
    { category = "ICMPv6"; counter = "Messages/sec"; instance = NotApplicable }
  /// Received Dest. Unreachable: Received Destination Unreachable is the number of ICMP Destination Unreachable messages received.
  let ``Received Dest. Unreachable`` =
    { category = "ICMPv6"; counter = "Received Dest. Unreachable"; instance = NotApplicable }
  /// Received Echo Reply/sec: Received Echo Reply/sec is the rate, in incidents per second, at which ICMP Echo Reply messages were received.
  let ``Received Echo Reply/sec`` =
    { category = "ICMPv6"; counter = "Received Echo Reply/sec"; instance = NotApplicable }
  /// Received Echo/sec: Received Echo/sec is the rate, in incidents per second, at which ICMP Echo messages were received.
  let ``Received Echo/sec`` =
    { category = "ICMPv6"; counter = "Received Echo/sec"; instance = NotApplicable }
  /// Received Membership Query: Received Membership Query is the number of packets received thatquery their membership to a group.
  let ``Received Membership Query`` =
    { category = "ICMPv6"; counter = "Received Membership Query"; instance = NotApplicable }
  /// Received Membership Reduction: Received Membership Reduction is the number of packets received thatcancelled their membership to a group.
  let ``Received Membership Reduction`` =
    { category = "ICMPv6"; counter = "Received Membership Reduction"; instance = NotApplicable }
  /// Received Membership Report: Received Membership Report is the number of packets received thatreport their membership to a group.
  let ``Received Membership Report`` =
    { category = "ICMPv6"; counter = "Received Membership Report"; instance = NotApplicable }
  /// Received Neighbor Advert: Received Neighbor Advert is the number of packets received thatadvert a neighbor.
  let ``Received Neighbor Advert`` =
    { category = "ICMPv6"; counter = "Received Neighbor Advert"; instance = NotApplicable }
  /// Received Neighbor Solicit: Received Neighbor Solicit is the number of packets received thatsolicit a neighbor.
  let ``Received Neighbor Solicit`` =
    { category = "ICMPv6"; counter = "Received Neighbor Solicit"; instance = NotApplicable }
  /// Received Packet Too Big: Received Packet Too Big is the number of received packets thatare larger than anticipated.
  let ``Received Packet Too Big`` =
    { category = "ICMPv6"; counter = "Received Packet Too Big"; instance = NotApplicable }
  /// Received Parameter Problem: Received Parameter Problem is the number of ICMP Parameter Problem messages received.
  let ``Received Parameter Problem`` =
    { category = "ICMPv6"; counter = "Received Parameter Problem"; instance = NotApplicable }
  /// Received Redirect/sec: Received Redirect/sec is the rate, in incidents per second, at which ICMP Redirect messages were received.
  let ``Received Redirect/sec`` =
    { category = "ICMPv6"; counter = "Received Redirect/sec"; instance = NotApplicable }
  /// Received Router Advert: Received Router Advert is the number of packets received thatadvert the router.
  let ``Received Router Advert`` =
    { category = "ICMPv6"; counter = "Received Router Advert"; instance = NotApplicable }
  /// Received Router Solicit: Received Router Solicit is the number of packets received thatsolicit the router.
  let ``Received Router Solicit`` =
    { category = "ICMPv6"; counter = "Received Router Solicit"; instance = NotApplicable }
  /// Received Time Exceeded: Received Time Exceeded is the number of ICMP Time Exceeded messages received.
  let ``Received Time Exceeded`` =
    { category = "ICMPv6"; counter = "Received Time Exceeded"; instance = NotApplicable }
  /// Sent Destination Unreachable: Sent Destination Unreachable is the number of ICMP Destination Unreachable messages sent.
  let ``Sent Destination Unreachable`` =
    { category = "ICMPv6"; counter = "Sent Destination Unreachable"; instance = NotApplicable }
  /// Sent Echo Reply/sec: Sent Echo Reply/sec is the rate, in incidents per second, at which ICMP Echo Reply messages were sent.
  let ``Sent Echo Reply/sec`` =
    { category = "ICMPv6"; counter = "Sent Echo Reply/sec"; instance = NotApplicable }
  /// Sent Echo/sec: Sent Echo/sec is the rate of ICMP Echo messages sent.
  let ``Sent Echo/sec`` =
    { category = "ICMPv6"; counter = "Sent Echo/sec"; instance = NotApplicable }
  /// Sent Membership Query: Sent Membership Query is the number of packets sent thatquery their membership to a group.
  let ``Sent Membership Query`` =
    { category = "ICMPv6"; counter = "Sent Membership Query"; instance = NotApplicable }
  /// Sent Membership Reduction: Sent Membership Reduction is the number of packets sent thatcancelled their membership to a group.
  let ``Sent Membership Reduction`` =
    { category = "ICMPv6"; counter = "Sent Membership Reduction"; instance = NotApplicable }
  /// Sent Membership Report: Sent Membership Report is the number of packets sent thatreport their membership to a group.
  let ``Sent Membership Report`` =
    { category = "ICMPv6"; counter = "Sent Membership Report"; instance = NotApplicable }
  /// Sent Neighbor Advert: Sent Neighbor Advert is the number of packets sent thatadvert a neighbor.
  let ``Sent Neighbor Advert`` =
    { category = "ICMPv6"; counter = "Sent Neighbor Advert"; instance = NotApplicable }
  /// Sent Neighbor Solicit: Sent Neighbor Solicit is the number of packets sent thatsolicit a neighbor.
  let ``Sent Neighbor Solicit`` =
    { category = "ICMPv6"; counter = "Sent Neighbor Solicit"; instance = NotApplicable }
  /// Sent Packet Too Big: Sent Packet Too Big is the number of sent packets thatare larger than anticipated.
  let ``Sent Packet Too Big`` =
    { category = "ICMPv6"; counter = "Sent Packet Too Big"; instance = NotApplicable }
  /// Sent Parameter Problem: Sent Parameter Problem is the number of ICMP Parameter Problem messages sent.
  let ``Sent Parameter Problem`` =
    { category = "ICMPv6"; counter = "Sent Parameter Problem"; instance = NotApplicable }
  /// Sent Redirect/sec: Sent Redirect/sec is the rate, in incidents per second, at which ICMP Redirect messages were sent.
  let ``Sent Redirect/sec`` =
    { category = "ICMPv6"; counter = "Sent Redirect/sec"; instance = NotApplicable }
  /// Sent Router Advert: Sent Router Advert is the number of packets sent thatadvert the router.
  let ``Sent Router Advert`` =
    { category = "ICMPv6"; counter = "Sent Router Advert"; instance = NotApplicable }
  /// Sent Router Solicit: Sent Router Solicit is the number of packets sent thatsolicit the router.
  let ``Sent Router Solicit`` =
    { category = "ICMPv6"; counter = "Sent Router Solicit"; instance = NotApplicable }
  /// Sent Time Exceeded: Sent Time Exceeded is the number of ICMP Time Exceeded messages sent.
  let ``Sent Time Exceeded`` =
    { category = "ICMPv6"; counter = "Sent Time Exceeded"; instance = NotApplicable }

  let allCounters =
    [ ``Messages Outbound Errors``
      ``Messages Received Errors``
      ``Messages Received/sec``
      ``Messages Sent/sec``
      ``Messages/sec``
      ``Received Dest. Unreachable``
      ``Received Echo Reply/sec``
      ``Received Echo/sec``
      ``Received Membership Query``
      ``Received Membership Reduction``
      ``Received Membership Report``
      ``Received Neighbor Advert``
      ``Received Neighbor Solicit``
      ``Received Packet Too Big``
      ``Received Parameter Problem``
      ``Received Redirect/sec``
      ``Received Router Advert``
      ``Received Router Solicit``
      ``Received Time Exceeded``
      ``Sent Destination Unreachable``
      ``Sent Echo Reply/sec``
      ``Sent Echo/sec``
      ``Sent Membership Query``
      ``Sent Membership Reduction``
      ``Sent Membership Report``
      ``Sent Neighbor Advert``
      ``Sent Neighbor Solicit``
      ``Sent Packet Too Big``
      ``Sent Parameter Problem``
      ``Sent Redirect/sec``
      ``Sent Router Advert``
      ``Sent Router Solicit``
      ``Sent Time Exceeded``
    ]

/// IPHTTPS Global: Statistics of IPHTTPS server on this machine.
///
/// This performance counter does not have non-instance based counters
module ``IPHTTPS Global`` =

  [<Literal>]
  let Category = "IPHTTPS Global"

  let PCC = getPCC Category
  /// Drops - Neighbor resolution timeouts: Total packets dropped waiting for neighbor resolution.
  let ``Drops - Neighbor resolution timeouts`` instance =
    { category = "IPHTTPS Global"; counter = "Drops - Neighbor resolution timeouts"; instance = instance }
  /// Errors - Authentication Errors: Total authentication errors.
  let ``Errors - Authentication Errors`` instance =
    { category = "IPHTTPS Global"; counter = "Errors - Authentication Errors"; instance = instance }
  /// Errors - Receive errors on the server: Total receive errors on the server.
  let ``Errors - Receive errors on the server`` instance =
    { category = "IPHTTPS Global"; counter = "Errors - Receive errors on the server"; instance = instance }
  /// Errors - Transmit errors on the server: Total transmit errors on the server.
  let ``Errors - Transmit errors on the server`` instance =
    { category = "IPHTTPS Global"; counter = "Errors - Transmit errors on the server"; instance = instance }
  /// In - Total bytes received: Total bytes received on the IPHTTPS server.
  let ``In - Total bytes received`` instance =
    { category = "IPHTTPS Global"; counter = "In - Total bytes received"; instance = instance }
  /// In - Total packets received: Total packets received on the server.
  let ``In - Total packets received`` instance =
    { category = "IPHTTPS Global"; counter = "In - Total packets received"; instance = instance }
  /// Out - Total bytes forwarded: Total bytes forwarded at link layer.
  let ``Out - Total bytes forwarded`` instance =
    { category = "IPHTTPS Global"; counter = "Out - Total bytes forwarded"; instance = instance }
  /// Out - Total bytes sent: Total bytes sent on the IPHTTPS server.
  let ``Out - Total bytes sent`` instance =
    { category = "IPHTTPS Global"; counter = "Out - Total bytes sent"; instance = instance }
  /// Out - Total packets sent: Total packets sent from the server.
  let ``Out - Total packets sent`` instance =
    { category = "IPHTTPS Global"; counter = "Out - Total packets sent"; instance = instance }
  /// Sessions - Total sessions: Total number of sessions on the server.
  let ``Sessions - Total sessions`` instance =
    { category = "IPHTTPS Global"; counter = "Sessions - Total sessions"; instance = instance }

  let allCounters =
    [ ``Drops - Neighbor resolution timeouts``
      ``Errors - Authentication Errors``
      ``Errors - Receive errors on the server``
      ``Errors - Transmit errors on the server``
      ``In - Total bytes received``
      ``In - Total packets received``
      ``Out - Total bytes forwarded``
      ``Out - Total bytes sent``
      ``Out - Total packets sent``
      ``Sessions - Total sessions``
    ]

/// IPHTTPS Session: Per session statistics on this IPHTTPS server.
///
/// This performance counter does not have instance based counters
module ``IPHTTPS Session`` =

  [<Literal>]
  let Category = "IPHTTPS Session"

  let PCC = getPCC Category
  /// Bytes received on this session: -
  let ``Bytes received on this session`` instance =
    { category = "IPHTTPS Session"; counter = "Bytes received on this session"; instance = instance }
  /// Bytes sent on this session: -
  let ``Bytes sent on this session`` instance =
    { category = "IPHTTPS Session"; counter = "Bytes sent on this session"; instance = instance }
  /// Duration - Duration of the session (Seconds): -
  let ``Duration - Duration of the session (Seconds)`` instance =
    { category = "IPHTTPS Session"; counter = "Duration - Duration of the session (Seconds)"; instance = instance }
  /// Errors - Receive errors on this session: -
  let ``Errors - Receive errors on this session`` instance =
    { category = "IPHTTPS Session"; counter = "Errors - Receive errors on this session"; instance = instance }
  /// Errors - Transmit errors on this session: -
  let ``Errors - Transmit errors on this session`` instance =
    { category = "IPHTTPS Session"; counter = "Errors - Transmit errors on this session"; instance = instance }
  /// Packets received on this session: -
  let ``Packets received on this session`` instance =
    { category = "IPHTTPS Session"; counter = "Packets received on this session"; instance = instance }
  /// Packets sent on this session: -
  let ``Packets sent on this session`` instance =
    { category = "IPHTTPS Session"; counter = "Packets sent on this session"; instance = instance }

  let allCounters =
    [ ``Bytes received on this session``
      ``Bytes sent on this session``
      ``Duration - Duration of the session (Seconds)``
      ``Errors - Receive errors on this session``
      ``Errors - Transmit errors on this session``
      ``Packets received on this session``
      ``Packets sent on this session``
    ]

/// IPsec AuthIP IPv4: IPsec AuthIP IPv4 is the set of Internet Protocol security (IPsec) Authenticated IP (AuthIP) counters that apply to traffic and connections over Internet Protocol version 4.
///
/// This performance counter does not have instance based counters
module ``IPsec AuthIP IPv4`` =

  [<Literal>]
  let Category = "IPsec AuthIP IPv4"

  let PCC = getPCC Category
  /// Active Extended Mode SAs: Active Extended Mode SAs is the number of currently active extended mode security associations.
  let ``Active Extended Mode SAs`` =
    { category = "IPsec AuthIP IPv4"; counter = "Active Extended Mode SAs"; instance = NotApplicable }
  /// Active Main Mode SAs: Active Main Mode SAs is the number of currently active main mode security associations.
  let ``Active Main Mode SAs`` =
    { category = "IPsec AuthIP IPv4"; counter = "Active Main Mode SAs"; instance = NotApplicable }
  /// Active Quick Mode SAs: Active Quick Mode SAs is the number of currently active quick mode security associations.
  let ``Active Quick Mode SAs`` =
    { category = "IPsec AuthIP IPv4"; counter = "Active Quick Mode SAs"; instance = NotApplicable }
  /// Extended Mode Negotiations: Extended Mode Negotiations is the number of extended mode negotiations attempted since IPsec was last started.
  let ``Extended Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Extended Mode Negotiations"; instance = NotApplicable }
  /// Extended Mode Negotiations/sec: Extended Mode Negotiations per Second is the rate at which extended mode negotiations are being attempted.
  let ``Extended Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv4"; counter = "Extended Mode Negotiations/sec"; instance = NotApplicable }
  /// Extended Mode SAs That Used Impersonation: Extended Mode SAs That Used Impersonation is the number of extended mode security associations completed using impersonation since IPsec was last started.
  let ``Extended Mode SAs That Used Impersonation`` =
    { category = "IPsec AuthIP IPv4"; counter = "Extended Mode SAs That Used Impersonation"; instance = NotApplicable }
  /// Failed Extended Mode Negotiations: Failed Extended Mode Negotiations is the number of failed extended mode negotiations since IPsec was last started.
  let ``Failed Extended Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Failed Extended Mode Negotiations"; instance = NotApplicable }
  /// Failed Extended Mode Negotiations/sec: Failed Extended Mode Negotiations per Second is the rate of failed extended mode negotiations.
  let ``Failed Extended Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv4"; counter = "Failed Extended Mode Negotiations/sec"; instance = NotApplicable }
  /// Failed Main Mode Negotiations: Failed Main Mode Negotiations is the number of failed main mode negotiations since IPsec was last started.
  let ``Failed Main Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Failed Main Mode Negotiations"; instance = NotApplicable }
  /// Failed Main Mode Negotiations/sec: Failed Main Mode Negotiations per Second is the rate of failed main mode negotiations.
  let ``Failed Main Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv4"; counter = "Failed Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations: Failed Quick Mode Negotiations is the number of failed quick mode negotiations since IPsec was last started.
  let ``Failed Quick Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Failed Quick Mode Negotiations"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations/sec: Failed Quick Mode Negotiations per Second is the rate of failed quick mode negotiations.
  let ``Failed Quick Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv4"; counter = "Failed Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received: Main Mode Negotiation Requests Received is the number of main mode negotiations initiated by a peer since IPsec was last started.
  let ``Main Mode Negotiation Requests Received`` =
    { category = "IPsec AuthIP IPv4"; counter = "Main Mode Negotiation Requests Received"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received/sec: Main Mode Negotiation Requests Received per Second is the rate of main mode negotiations initiated by a peer.
  let ``Main Mode Negotiation Requests Received/sec`` =
    { category = "IPsec AuthIP IPv4"; counter = "Main Mode Negotiation Requests Received/sec"; instance = NotApplicable }
  /// Main Mode Negotiations: Main Mode Negotiations is the number of main mode negotiations attempted since IPsec was last started.
  let ``Main Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Main Mode Negotiations"; instance = NotApplicable }
  /// Main Mode Negotiations/sec: Main Mode Negotiations per Second is the rate at which main mode negotiations are being attempted.
  let ``Main Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv4"; counter = "Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Main Mode SAs That Used Impersonation: Main Mode SAs That Used Impersonation is the number of main mode security associations completed using impersonation since IPsec was last started.
  let ``Main Mode SAs That Used Impersonation`` =
    { category = "IPsec AuthIP IPv4"; counter = "Main Mode SAs That Used Impersonation"; instance = NotApplicable }
  /// Main Mode SAs That Used Impersonation/sec: Main Mode SAs That Used Impersonation per Second is the rate of main mode security associations completed using impersonation.
  let ``Main Mode SAs That Used Impersonation/sec`` =
    { category = "IPsec AuthIP IPv4"; counter = "Main Mode SAs That Used Impersonation/sec"; instance = NotApplicable }
  /// Pending Extended Mode Negotiations: Pending Extended Mode Negotiations is the number of pending extended mode negotiations.
  let ``Pending Extended Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Pending Extended Mode Negotiations"; instance = NotApplicable }
  /// Pending Main Mode Negotiations: Pending Main Mode Negotiations is the number of pending main mode negotiations.
  let ``Pending Main Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Pending Main Mode Negotiations"; instance = NotApplicable }
  /// Pending Quick Mode Negotiations: Pending Quick Mode Negotiations is the number of pending quick mode negotiations.
  let ``Pending Quick Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Pending Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations: Quick Mode Negotiations is the number of quick mode negotiations attempted since IPsec was last started.
  let ``Quick Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations/sec: Quick Mode Negotiations per Second is the rate at which quick mode negotiations are being attempted.
  let ``Quick Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv4"; counter = "Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Extended Mode Negotiations: Successful Extended Mode Negotiations is the number of extended mode negotiations completed since IPsec was last started.
  let ``Successful Extended Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Successful Extended Mode Negotiations"; instance = NotApplicable }
  /// Successful Extended Mode Negotiations/sec: Successful Extended Mode Negotiations per Second is the rate of extended mode negotiations completed.
  let ``Successful Extended Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv4"; counter = "Successful Extended Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Main Mode Negotiations: Successful Main Mode Negotiations is the number of main mode negotiations completed since IPsec was last started.
  let ``Successful Main Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Successful Main Mode Negotiations"; instance = NotApplicable }
  /// Successful Main Mode Negotiations/sec: Successful Main Mode Negotiations per Second is the rate of main mode negotiations completed.
  let ``Successful Main Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv4"; counter = "Successful Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations: Successful Quick Mode Negotiations is the number of quick mode negotiations completed since IPsec was last started.
  let ``Successful Quick Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Successful Quick Mode Negotiations"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations/sec: Successful Quick Mode Negotiations per Second is the rate of quick mode negotiations completed.
  let ``Successful Quick Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv4"; counter = "Successful Quick Mode Negotiations/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Active Extended Mode SAs``
      ``Active Main Mode SAs``
      ``Active Quick Mode SAs``
      ``Extended Mode Negotiations``
      ``Extended Mode Negotiations/sec``
      ``Extended Mode SAs That Used Impersonation``
      ``Failed Extended Mode Negotiations``
      ``Failed Extended Mode Negotiations/sec``
      ``Failed Main Mode Negotiations``
      ``Failed Main Mode Negotiations/sec``
      ``Failed Quick Mode Negotiations``
      ``Failed Quick Mode Negotiations/sec``
      ``Main Mode Negotiation Requests Received``
      ``Main Mode Negotiation Requests Received/sec``
      ``Main Mode Negotiations``
      ``Main Mode Negotiations/sec``
      ``Main Mode SAs That Used Impersonation``
      ``Main Mode SAs That Used Impersonation/sec``
      ``Pending Extended Mode Negotiations``
      ``Pending Main Mode Negotiations``
      ``Pending Quick Mode Negotiations``
      ``Quick Mode Negotiations``
      ``Quick Mode Negotiations/sec``
      ``Successful Extended Mode Negotiations``
      ``Successful Extended Mode Negotiations/sec``
      ``Successful Main Mode Negotiations``
      ``Successful Main Mode Negotiations/sec``
      ``Successful Quick Mode Negotiations``
      ``Successful Quick Mode Negotiations/sec``
    ]

/// IPsec AuthIP IPv6: IPsec AuthIP IPv6 is the set of Internet Protocol security (IPsec) Authenticated IP (AuthIP) counters that apply to traffic and connections over Internet Protocol version 6.
///
/// This performance counter does not have instance based counters
module ``IPsec AuthIP IPv6`` =

  [<Literal>]
  let Category = "IPsec AuthIP IPv6"

  let PCC = getPCC Category
  /// Active Extended Mode SAs: Active Extended Mode SAs is the number of currently active extended mode security associations.
  let ``Active Extended Mode SAs`` =
    { category = "IPsec AuthIP IPv6"; counter = "Active Extended Mode SAs"; instance = NotApplicable }
  /// Active Main Mode SAs: Active Main Mode SAs is the number of currently active main mode security associations.
  let ``Active Main Mode SAs`` =
    { category = "IPsec AuthIP IPv6"; counter = "Active Main Mode SAs"; instance = NotApplicable }
  /// Active Quick Mode SAs: Active Quick Mode SAs is the number of currently active quick mode security associations.
  let ``Active Quick Mode SAs`` =
    { category = "IPsec AuthIP IPv6"; counter = "Active Quick Mode SAs"; instance = NotApplicable }
  /// Extended Mode Negotiations: Extended Mode Negotiations is the number of extended mode negotiations attempted since IPsec was last started.
  let ``Extended Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Extended Mode Negotiations"; instance = NotApplicable }
  /// Extended Mode Negotiations/sec: Extended Mode Negotiations per Second is the rate at which extended mode negotiations are being attempted.
  let ``Extended Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv6"; counter = "Extended Mode Negotiations/sec"; instance = NotApplicable }
  /// Extended Mode SAs That Used Impersonation: Extended Mode SAs That Used Impersonation is the number of extended mode security associations completed using impersonation since IPsec was last started.
  let ``Extended Mode SAs That Used Impersonation`` =
    { category = "IPsec AuthIP IPv6"; counter = "Extended Mode SAs That Used Impersonation"; instance = NotApplicable }
  /// Failed Extended Mode Negotiations: Failed Extended Mode Negotiations is the number of failed extended mode negotiations since IPsec was last started.
  let ``Failed Extended Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Failed Extended Mode Negotiations"; instance = NotApplicable }
  /// Failed Extended Mode Negotiations/sec: Failed Extended Mode Negotiations per Second is the rate of failed extended mode negotiations.
  let ``Failed Extended Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv6"; counter = "Failed Extended Mode Negotiations/sec"; instance = NotApplicable }
  /// Failed Main Mode Negotiations: Failed Main Mode Negotiations is the number of failed main mode negotiations since IPsec was last started.
  let ``Failed Main Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Failed Main Mode Negotiations"; instance = NotApplicable }
  /// Failed Main Mode Negotiations/sec: Failed Main Mode Negotiations per Second is the rate of failed main mode negotiations.
  let ``Failed Main Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv6"; counter = "Failed Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations: Failed Quick Mode Negotiations is the number of failed quick mode negotiations since IPsec was last started.
  let ``Failed Quick Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Failed Quick Mode Negotiations"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations/sec: Failed Quick Mode Negotiations per Second is the rate of failed quick mode negotiations.
  let ``Failed Quick Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv6"; counter = "Failed Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received: Main Mode Negotiation Requests Received is the number of main mode negotiations initiated by a peer since IPsec was last started.
  let ``Main Mode Negotiation Requests Received`` =
    { category = "IPsec AuthIP IPv6"; counter = "Main Mode Negotiation Requests Received"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received/sec: Main Mode Negotiation Requests Received per Second is the rate of main mode negotiations initiated by a peer.
  let ``Main Mode Negotiation Requests Received/sec`` =
    { category = "IPsec AuthIP IPv6"; counter = "Main Mode Negotiation Requests Received/sec"; instance = NotApplicable }
  /// Main Mode Negotiations: Main Mode Negotiations is the number of main mode negotiations attempted since IPsec was last started.
  let ``Main Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Main Mode Negotiations"; instance = NotApplicable }
  /// Main Mode Negotiations/sec: Main Mode Negotiations per Second is the rate at which main mode negotiations are being attempted.
  let ``Main Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv6"; counter = "Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Main Mode SAs That Used Impersonation: Main Mode SAs That Used Impersonation is the number of main mode security associations completed using impersonation since IPsec was last started.
  let ``Main Mode SAs That Used Impersonation`` =
    { category = "IPsec AuthIP IPv6"; counter = "Main Mode SAs That Used Impersonation"; instance = NotApplicable }
  /// Main Mode SAs That Used Impersonation/sec: Main Mode SAs That Used Impersonation per Second is the rate of main mode security associations completed using impersonation.
  let ``Main Mode SAs That Used Impersonation/sec`` =
    { category = "IPsec AuthIP IPv6"; counter = "Main Mode SAs That Used Impersonation/sec"; instance = NotApplicable }
  /// Pending Extended Mode Negotiations: Pending Extended Mode Negotiations is the number of pending extended mode negotiations.
  let ``Pending Extended Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Pending Extended Mode Negotiations"; instance = NotApplicable }
  /// Pending Main Mode Negotiations: Pending Main Mode Negotiations is the number of pending main mode negotiations.
  let ``Pending Main Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Pending Main Mode Negotiations"; instance = NotApplicable }
  /// Pending Quick Mode Negotiations: Pending Quick Mode Negotiations is the number of pending quick mode negotiations.
  let ``Pending Quick Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Pending Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations: Quick Mode Negotiations is the number of quick mode negotiations attempted since IPsec was last started.
  let ``Quick Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations/sec: Quick Mode Negotiations per Second is the rate at which quick mode negotiations are being attempted.
  let ``Quick Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv6"; counter = "Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Extended Mode Negotiations: Successful Extended Mode Negotiations is the number of extended mode negotiations completed since IPsec was last started.
  let ``Successful Extended Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Successful Extended Mode Negotiations"; instance = NotApplicable }
  /// Successful Extended Mode Negotiations/sec: Successful Extended Mode Negotiations per Second is the rate of extended mode negotiations completed.
  let ``Successful Extended Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv6"; counter = "Successful Extended Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Main Mode Negotiations: Successful Main Mode Negotiations is the number of main mode negotiations completed since IPsec was last started.
  let ``Successful Main Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Successful Main Mode Negotiations"; instance = NotApplicable }
  /// Successful Main Mode Negotiations/sec: Successful Main Mode Negotiations per Second is the rate of main mode negotiations completed.
  let ``Successful Main Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv6"; counter = "Successful Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations: Successful Quick Mode Negotiations is the number of quick mode negotiations completed since IPsec was last started.
  let ``Successful Quick Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Successful Quick Mode Negotiations"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations/sec: Successful Quick Mode Negotiations per Second is the rate of quick mode negotiations completed.
  let ``Successful Quick Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv6"; counter = "Successful Quick Mode Negotiations/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Active Extended Mode SAs``
      ``Active Main Mode SAs``
      ``Active Quick Mode SAs``
      ``Extended Mode Negotiations``
      ``Extended Mode Negotiations/sec``
      ``Extended Mode SAs That Used Impersonation``
      ``Failed Extended Mode Negotiations``
      ``Failed Extended Mode Negotiations/sec``
      ``Failed Main Mode Negotiations``
      ``Failed Main Mode Negotiations/sec``
      ``Failed Quick Mode Negotiations``
      ``Failed Quick Mode Negotiations/sec``
      ``Main Mode Negotiation Requests Received``
      ``Main Mode Negotiation Requests Received/sec``
      ``Main Mode Negotiations``
      ``Main Mode Negotiations/sec``
      ``Main Mode SAs That Used Impersonation``
      ``Main Mode SAs That Used Impersonation/sec``
      ``Pending Extended Mode Negotiations``
      ``Pending Main Mode Negotiations``
      ``Pending Quick Mode Negotiations``
      ``Quick Mode Negotiations``
      ``Quick Mode Negotiations/sec``
      ``Successful Extended Mode Negotiations``
      ``Successful Extended Mode Negotiations/sec``
      ``Successful Main Mode Negotiations``
      ``Successful Main Mode Negotiations/sec``
      ``Successful Quick Mode Negotiations``
      ``Successful Quick Mode Negotiations/sec``
    ]

/// IPsec Connections: IPsec Connections is the set of Internet Protocol security (IPsec) counters that apply to IPsec encapsulated connections.
///
/// This performance counter does not have instance based counters
module ``IPsec Connections`` =

  [<Literal>]
  let Category = "IPsec Connections"

  let PCC = getPCC Category
  /// Max number of connections since boot: Max number of connections since boot
  let ``Max number of connections since boot`` =
    { category = "IPsec Connections"; counter = "Max number of connections since boot"; instance = NotApplicable }
  /// Number of failed authentications: Number of failed authentications
  let ``Number of failed authentications`` =
    { category = "IPsec Connections"; counter = "Number of failed authentications"; instance = NotApplicable }
  /// Total Bytes In since start: Total Bytes In since boot
  let ``Total Bytes In since start`` =
    { category = "IPsec Connections"; counter = "Total Bytes In since start"; instance = NotApplicable }
  /// Total Bytes Out since start: Total Bytes Out since boot
  let ``Total Bytes Out since start`` =
    { category = "IPsec Connections"; counter = "Total Bytes Out since start"; instance = NotApplicable }
  /// Total Number current Connections: Total Number current Connections
  let ``Total Number current Connections`` =
    { category = "IPsec Connections"; counter = "Total Number current Connections"; instance = NotApplicable }
  /// Total number of cumulative connections since boot: Total number of cumulative connections since boot
  let ``Total number of cumulative connections since boot`` =
    { category = "IPsec Connections"; counter = "Total number of cumulative connections since boot"; instance = NotApplicable }

  let allCounters =
    [ ``Max number of connections since boot``
      ``Number of failed authentications``
      ``Total Bytes In since start``
      ``Total Bytes Out since start``
      ``Total Number current Connections``
      ``Total number of cumulative connections since boot``
    ]

/// IPsec Driver: IPsec Driver is the set of Internet Protocol security (IPsec) driver counters that apply to traffic over Internet Protocol version 4 and Internet Protocol version 6.
///
/// This performance counter does not have instance based counters
module ``IPsec Driver`` =

  [<Literal>]
  let Category = "IPsec Driver"

  let PCC = getPCC Category
  /// Active Security Associations: Active Security Associations is the number of active quick mode security associations.
  let ``Active Security Associations`` =
    { category = "IPsec Driver"; counter = "Active Security Associations"; instance = NotApplicable }
  /// Bytes Received in Transport Mode/sec: Bytes Received in Transport Mode per Second is the rate of bytes received using transport mode.
  let ``Bytes Received in Transport Mode/sec`` =
    { category = "IPsec Driver"; counter = "Bytes Received in Transport Mode/sec"; instance = NotApplicable }
  /// Bytes Received in Tunnel Mode/sec: Bytes Received in Tunnel Mode per Second is the rate of bytes received using tunnel mode.
  let ``Bytes Received in Tunnel Mode/sec`` =
    { category = "IPsec Driver"; counter = "Bytes Received in Tunnel Mode/sec"; instance = NotApplicable }
  /// Bytes Sent in Transport Mode/sec: Bytes Sent in Transport Mode per Second is the rate of bytes sent using transport mode.
  let ``Bytes Sent in Transport Mode/sec`` =
    { category = "IPsec Driver"; counter = "Bytes Sent in Transport Mode/sec"; instance = NotApplicable }
  /// Bytes Sent in Tunnel Mode/sec: Bytes Sent in Tunnel Mode per Second is the rate of bytes sent using tunnel mode.
  let ``Bytes Sent in Tunnel Mode/sec`` =
    { category = "IPsec Driver"; counter = "Bytes Sent in Tunnel Mode/sec"; instance = NotApplicable }
  /// Inbound Packets Dropped/sec: Inbound Packets Dropped per Second is the rate of inbound packets dropped by IPsec.
  let ``Inbound Packets Dropped/sec`` =
    { category = "IPsec Driver"; counter = "Inbound Packets Dropped/sec"; instance = NotApplicable }
  /// Inbound Packets Received/sec: Inbound Packets Received per Second is the rate of inbound packets successfully processed by IPsec.
  let ``Inbound Packets Received/sec`` =
    { category = "IPsec Driver"; counter = "Inbound Packets Received/sec"; instance = NotApplicable }
  /// Incorrect SPI Packets: Incorrect SPI packets is the number of packets for which the Security Parameter Index (SPI) was incorrect since the computer was last started. A large number of packets with bad SPIs within a short amount of time might indicate a packet spoofing attack.
  let ``Incorrect SPI Packets`` =
    { category = "IPsec Driver"; counter = "Incorrect SPI Packets"; instance = NotApplicable }
  /// Incorrect SPI Packets/sec: Incorrect SPI packets per Second is the rate of packets for which the Security Parameter Index (SPI) was incorrect since the computer was last started. A large number of packets with bad SPIs within a short amount of time might indicate a packet spoofing attack.
  let ``Incorrect SPI Packets/sec`` =
    { category = "IPsec Driver"; counter = "Incorrect SPI Packets/sec"; instance = NotApplicable }
  /// Offloaded Bytes Received/sec: Offloaded Bytes Received per Second is the rate of bytes received using IPsec hardware offload. Certain network adapters can accelerate IPsec processing by performing hardware offload of IPsec cryptographic functions.
  let ``Offloaded Bytes Received/sec`` =
    { category = "IPsec Driver"; counter = "Offloaded Bytes Received/sec"; instance = NotApplicable }
  /// Offloaded Bytes Sent/sec: Offloaded Bytes Sent per Second is the rate of bytes sent using IPsec hardware offload. Certain network adapters can accelerate IPsec processing by performing hardware offload of IPsec cryptographic functions.
  let ``Offloaded Bytes Sent/sec`` =
    { category = "IPsec Driver"; counter = "Offloaded Bytes Sent/sec"; instance = NotApplicable }
  /// Offloaded Security Associations: Offloaded Security Associations is the number of active quick mode security associations offloaded to hardware. Certain network adapters can accelerate IPsec processing by performing hardware offload of IPsec cryptographic functions.
  let ``Offloaded Security Associations`` =
    { category = "IPsec Driver"; counter = "Offloaded Security Associations"; instance = NotApplicable }
  /// Packets Not Authenticated: Packets Not Authenticated is the number of packets for which data could not be verified (for which the integrity hash verification failed) since the computer was last started. Increases in this counter might indicate an IPsec packet spoofing or modification attack, or packet corruption by network devices.
  let ``Packets Not Authenticated`` =
    { category = "IPsec Driver"; counter = "Packets Not Authenticated"; instance = NotApplicable }
  /// Packets Not Authenticated/sec: Packets Not Authenticated per Second is the rate of packets for which data could not be verified (for which the integrity hash verification failed) since the computer was last started. Increases in this counter might indicate an IPsec packet spoofing or modification attack, or packet corruption by network devices.
  let ``Packets Not Authenticated/sec`` =
    { category = "IPsec Driver"; counter = "Packets Not Authenticated/sec"; instance = NotApplicable }
  /// Packets Not Decrypted: Packets Not Decrypted is the number of packets that could not be decrypted since the computer was last started. A packet might not be decrypted if it fails a validation check.
  let ``Packets Not Decrypted`` =
    { category = "IPsec Driver"; counter = "Packets Not Decrypted"; instance = NotApplicable }
  /// Packets Not Decrypted/sec: Packets Not Decrypted per Second is the rate of packets that could not be decrypted since the computer was last started. A packet might not be decrypted if it fails a validation check.
  let ``Packets Not Decrypted/sec`` =
    { category = "IPsec Driver"; counter = "Packets Not Decrypted/sec"; instance = NotApplicable }
  /// Packets Received Over Wrong SA: Packets Received Over Wrong SA is the number of packets received over the wrong security association since the computer was last started.
  let ``Packets Received Over Wrong SA`` =
    { category = "IPsec Driver"; counter = "Packets Received Over Wrong SA"; instance = NotApplicable }
  /// Packets Received Over Wrong SA/sec: Packets Received Over Wrong SA per Second is the rate of packets received over the wrong security association since the computer was last started.
  let ``Packets Received Over Wrong SA/sec`` =
    { category = "IPsec Driver"; counter = "Packets Received Over Wrong SA/sec"; instance = NotApplicable }
  /// Packets That Failed ESP Validation: Packets That Failed ESP Validation is the number of packets received that failed ESP validation since the computer was last started.
  let ``Packets That Failed ESP Validation`` =
    { category = "IPsec Driver"; counter = "Packets That Failed ESP Validation"; instance = NotApplicable }
  /// Packets That Failed ESP Validation/sec: Packets That Failed ESP Validation per Second is the rate of packets received that failed ESP validation since the computer was last started.
  let ``Packets That Failed ESP Validation/sec`` =
    { category = "IPsec Driver"; counter = "Packets That Failed ESP Validation/sec"; instance = NotApplicable }
  /// Packets That Failed Replay Detection: Packets That Failed Replay Detection is the number of packets that contained an invalid sequence number since the computer was last started. Increases in this counter might indicate a network problem or replay attack.
  let ``Packets That Failed Replay Detection`` =
    { category = "IPsec Driver"; counter = "Packets That Failed Replay Detection"; instance = NotApplicable }
  /// Packets That Failed Replay Detection/sec: Packets That Failed Replay Detection per Second is the rate of packets that contained an invalid sequence number since the computer was last started. Increases in this counter might indicate a network problem or replay attack.
  let ``Packets That Failed Replay Detection/sec`` =
    { category = "IPsec Driver"; counter = "Packets That Failed Replay Detection/sec"; instance = NotApplicable }
  /// Packets That Failed UDP-ESP Validation: Packets That Failed UDP-ESP Validation is the number of packets received that failed UDP-ESP validation (used for NAT traversal) since the computer was last started.
  let ``Packets That Failed UDP-ESP Validation`` =
    { category = "IPsec Driver"; counter = "Packets That Failed UDP-ESP Validation"; instance = NotApplicable }
  /// Packets That Failed UDP-ESP Validation/sec: Packets That Failed UDP-ESP Validation per Second is the rate of packets received that failed UDP-ESP validation (used for NAT traversal) since the computer was last started.
  let ``Packets That Failed UDP-ESP Validation/sec`` =
    { category = "IPsec Driver"; counter = "Packets That Failed UDP-ESP Validation/sec"; instance = NotApplicable }
  /// Pending Security Associations: Pending Security Associations is the number of pending quick mode security associations.
  let ``Pending Security Associations`` =
    { category = "IPsec Driver"; counter = "Pending Security Associations"; instance = NotApplicable }
  /// Plaintext Packets Received: Plaintext Packets Received is the number of clear text packets received since the computer was last started.
  let ``Plaintext Packets Received`` =
    { category = "IPsec Driver"; counter = "Plaintext Packets Received"; instance = NotApplicable }
  /// Plaintext Packets Received/sec: Plaintext Packets Received per Second is the rate of clear text packets received since the computer was last started.
  let ``Plaintext Packets Received/sec`` =
    { category = "IPsec Driver"; counter = "Plaintext Packets Received/sec"; instance = NotApplicable }
  /// SA Rekeys: SA Rekeys is the number of successful rekey operations for quick mode security associations since the computer was last started.
  let ``SA Rekeys`` =
    { category = "IPsec Driver"; counter = "SA Rekeys"; instance = NotApplicable }
  /// Security Associations Added: Security Associations Added is the number of security associations added since the computer was last started.
  let ``Security Associations Added`` =
    { category = "IPsec Driver"; counter = "Security Associations Added"; instance = NotApplicable }
  /// Total Inbound Packets Dropped: Total Inbound Packets Dropped is the total number of inbound packets dropped by IPsec, since the computer was last started.
  let ``Total Inbound Packets Dropped`` =
    { category = "IPsec Driver"; counter = "Total Inbound Packets Dropped"; instance = NotApplicable }
  /// Total Inbound Packets Received: Total Inbound Packets Received is the total number of inbound packets successfully processed by IPsec, since the computer was last started.
  let ``Total Inbound Packets Received`` =
    { category = "IPsec Driver"; counter = "Total Inbound Packets Received"; instance = NotApplicable }

  let allCounters =
    [ ``Active Security Associations``
      ``Bytes Received in Transport Mode/sec``
      ``Bytes Received in Tunnel Mode/sec``
      ``Bytes Sent in Transport Mode/sec``
      ``Bytes Sent in Tunnel Mode/sec``
      ``Inbound Packets Dropped/sec``
      ``Inbound Packets Received/sec``
      ``Incorrect SPI Packets``
      ``Incorrect SPI Packets/sec``
      ``Offloaded Bytes Received/sec``
      ``Offloaded Bytes Sent/sec``
      ``Offloaded Security Associations``
      ``Packets Not Authenticated``
      ``Packets Not Authenticated/sec``
      ``Packets Not Decrypted``
      ``Packets Not Decrypted/sec``
      ``Packets Received Over Wrong SA``
      ``Packets Received Over Wrong SA/sec``
      ``Packets That Failed ESP Validation``
      ``Packets That Failed ESP Validation/sec``
      ``Packets That Failed Replay Detection``
      ``Packets That Failed Replay Detection/sec``
      ``Packets That Failed UDP-ESP Validation``
      ``Packets That Failed UDP-ESP Validation/sec``
      ``Pending Security Associations``
      ``Plaintext Packets Received``
      ``Plaintext Packets Received/sec``
      ``SA Rekeys``
      ``Security Associations Added``
      ``Total Inbound Packets Dropped``
      ``Total Inbound Packets Received``
    ]

/// IPsec IKEv1 IPv4: IPsec IKEv1 IPv4 is the set of Internet Protocol security (IPsec) Internet Key Exchange version 1 (IKEv1) counters that apply to traffic and connections over Internet Protocol version 4.
///
/// This performance counter does not have instance based counters
module ``IPsec IKEv1 IPv4`` =

  [<Literal>]
  let Category = "IPsec IKEv1 IPv4"

  let PCC = getPCC Category
  /// Active Main Mode SAs: Active Main Mode SAs is the number of currently active main mode security associations.
  let ``Active Main Mode SAs`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Active Main Mode SAs"; instance = NotApplicable }
  /// Active Quick Mode SAs: Active Quick Mode SAs is the number of currently active quick mode security associations.
  let ``Active Quick Mode SAs`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Active Quick Mode SAs"; instance = NotApplicable }
  /// Failed Main Mode Negotiations: Failed Main Mode Negotiations is the number of failed main mode negotiations since IPsec was last started.
  let ``Failed Main Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Failed Main Mode Negotiations"; instance = NotApplicable }
  /// Failed Main Mode Negotiations/sec: Failed Main Mode Negotiations per Second is the rate of failed main mode negotiations.
  let ``Failed Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Failed Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations: Failed Quick Mode Negotiations is the number of failed quick mode negotiations since IPsec was last started.
  let ``Failed Quick Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Failed Quick Mode Negotiations"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations/sec: Failed Quick Mode Negotiations per Second is the rate of failed quick mode negotiations.
  let ``Failed Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Failed Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received: Main Mode Negotiation Requests Received is the number of main mode negotiations initiated by a peer since IPsec was last started.
  let ``Main Mode Negotiation Requests Received`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Main Mode Negotiation Requests Received"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received/sec: Main Mode Negotiation Requests Received per Second is the rate of main mode negotiations initiated by a peer.
  let ``Main Mode Negotiation Requests Received/sec`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Main Mode Negotiation Requests Received/sec"; instance = NotApplicable }
  /// Main Mode Negotiations: Main Mode Negotiations is the number of main mode negotiations attempted since IPsec was last started.
  let ``Main Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Main Mode Negotiations"; instance = NotApplicable }
  /// Main Mode Negotiations/sec: Main Mode Negotiations per Second is the rate at which main mode negotiations are being attempted.
  let ``Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Pending Main Mode Negotiations: Pending Main Mode Negotiations is the number of pending main mode negotiations.
  let ``Pending Main Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Pending Main Mode Negotiations"; instance = NotApplicable }
  /// Pending Quick Mode Negotiations: Pending Quick Mode Negotiations is the number of pending quick mode negotiations.
  let ``Pending Quick Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Pending Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations: Quick Mode Negotiations is the number of quick mode negotiations attempted since IPsec was last started.
  let ``Quick Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations/sec: Quick Mode Negotiations per Second is the rate at which quick mode negotiations are being attempted.
  let ``Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Main Mode Negotiations: Successful Main Mode Negotiations is the number of main mode negotiations completed since IPsec was last started.
  let ``Successful Main Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Successful Main Mode Negotiations"; instance = NotApplicable }
  /// Successful Main Mode Negotiations/sec: Successful Main Mode Negotiations per Second is the rate of main mode negotiations completed.
  let ``Successful Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Successful Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations: Successful Quick Mode Negotiations is the number of quick mode negotiations completed since IPsec was last started.
  let ``Successful Quick Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Successful Quick Mode Negotiations"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations/sec: Successful Quick Mode Negotiations per Second is the rate of quick mode negotiations completed.
  let ``Successful Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Successful Quick Mode Negotiations/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Active Main Mode SAs``
      ``Active Quick Mode SAs``
      ``Failed Main Mode Negotiations``
      ``Failed Main Mode Negotiations/sec``
      ``Failed Quick Mode Negotiations``
      ``Failed Quick Mode Negotiations/sec``
      ``Main Mode Negotiation Requests Received``
      ``Main Mode Negotiation Requests Received/sec``
      ``Main Mode Negotiations``
      ``Main Mode Negotiations/sec``
      ``Pending Main Mode Negotiations``
      ``Pending Quick Mode Negotiations``
      ``Quick Mode Negotiations``
      ``Quick Mode Negotiations/sec``
      ``Successful Main Mode Negotiations``
      ``Successful Main Mode Negotiations/sec``
      ``Successful Quick Mode Negotiations``
      ``Successful Quick Mode Negotiations/sec``
    ]

/// IPsec IKEv1 IPv6: IPsec IKEv1 IPv6 is the set of Internet Protocol security (IPsec) Internet Key Exchange version 1 (IKEv1) counters that apply to traffic and connections over Internet Protocol version 6.
///
/// This performance counter does not have instance based counters
module ``IPsec IKEv1 IPv6`` =

  [<Literal>]
  let Category = "IPsec IKEv1 IPv6"

  let PCC = getPCC Category
  /// Active Main Mode SAs: Active Main Mode SAs is the number of currently active main mode security associations.
  let ``Active Main Mode SAs`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Active Main Mode SAs"; instance = NotApplicable }
  /// Active Quick Mode SAs: Active Quick Mode SAs is the number of currently active quick mode security associations.
  let ``Active Quick Mode SAs`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Active Quick Mode SAs"; instance = NotApplicable }
  /// Failed Main Mode Negotiations: Failed Main Mode Negotiations is the number of failed main mode negotiations since IPsec was last started.
  let ``Failed Main Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Failed Main Mode Negotiations"; instance = NotApplicable }
  /// Failed Main Mode Negotiations/sec: Failed Main Mode Negotiations per Second is the rate of failed main mode negotiations.
  let ``Failed Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Failed Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations: Failed Quick Mode Negotiations is the number of failed quick mode negotiations since IPsec was last started.
  let ``Failed Quick Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Failed Quick Mode Negotiations"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations/sec: Failed Quick Mode Negotiations per Second is the rate of failed quick mode negotiations.
  let ``Failed Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Failed Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received: Main Mode Negotiation Requests Received is the number of main mode negotiations initiated by a peer since IPsec was last started.
  let ``Main Mode Negotiation Requests Received`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Main Mode Negotiation Requests Received"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received/sec: Main Mode Negotiation Requests Received per Second is the rate of main mode negotiations initiated by a peer.
  let ``Main Mode Negotiation Requests Received/sec`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Main Mode Negotiation Requests Received/sec"; instance = NotApplicable }
  /// Main Mode Negotiations: Main Mode Negotiations is the number of main mode negotiations attempted since IPsec was last started.
  let ``Main Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Main Mode Negotiations"; instance = NotApplicable }
  /// Main Mode Negotiations/sec: Main Mode Negotiations per Second is the rate at which main mode negotiations are being attempted.
  let ``Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Pending Main Mode Negotiations: Pending Main Mode Negotiations is the number of pending main mode negotiations.
  let ``Pending Main Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Pending Main Mode Negotiations"; instance = NotApplicable }
  /// Pending Quick Mode Negotiations: Pending Quick Mode Negotiations is the number of pending quick mode negotiations.
  let ``Pending Quick Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Pending Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations: Quick Mode Negotiations is the number of quick mode negotiations attempted since IPsec was last started.
  let ``Quick Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations/sec: Quick Mode Negotiations per Second is the rate at which quick mode negotiations are being attempted.
  let ``Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Main Mode Negotiations: Successful Main Mode Negotiations is the number of main mode negotiations completed since IPsec was last started.
  let ``Successful Main Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Successful Main Mode Negotiations"; instance = NotApplicable }
  /// Successful Main Mode Negotiations/sec: Successful Main Mode Negotiations per Second is the rate of main mode negotiations completed.
  let ``Successful Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Successful Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations: Successful Quick Mode Negotiations is the number of quick mode negotiations completed since IPsec was last started.
  let ``Successful Quick Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Successful Quick Mode Negotiations"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations/sec: Successful Quick Mode Negotiations per Second is the rate of quick mode negotiations completed.
  let ``Successful Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Successful Quick Mode Negotiations/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Active Main Mode SAs``
      ``Active Quick Mode SAs``
      ``Failed Main Mode Negotiations``
      ``Failed Main Mode Negotiations/sec``
      ``Failed Quick Mode Negotiations``
      ``Failed Quick Mode Negotiations/sec``
      ``Main Mode Negotiation Requests Received``
      ``Main Mode Negotiation Requests Received/sec``
      ``Main Mode Negotiations``
      ``Main Mode Negotiations/sec``
      ``Pending Main Mode Negotiations``
      ``Pending Quick Mode Negotiations``
      ``Quick Mode Negotiations``
      ``Quick Mode Negotiations/sec``
      ``Successful Main Mode Negotiations``
      ``Successful Main Mode Negotiations/sec``
      ``Successful Quick Mode Negotiations``
      ``Successful Quick Mode Negotiations/sec``
    ]

/// IPsec IKEv2 IPv4: IPsec IKEv2 IPv4 is the set of Internet Protocol security (IPsec) Internet Key Exchange version 2 (IKEv2) counters that apply to traffic and connections over Internet Protocol version 4.
///
/// This performance counter does not have instance based counters
module ``IPsec IKEv2 IPv4`` =

  [<Literal>]
  let Category = "IPsec IKEv2 IPv4"

  let PCC = getPCC Category
  /// Active Main Mode SAs: Active Main Mode SAs is the number of currently active main mode security associations.
  let ``Active Main Mode SAs`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Active Main Mode SAs"; instance = NotApplicable }
  /// Active Quick Mode SAs: Active Quick Mode SAs is the number of currently active quick mode security associations.
  let ``Active Quick Mode SAs`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Active Quick Mode SAs"; instance = NotApplicable }
  /// Failed Main Mode Negotiations: Failed Main Mode Negotiations is the number of failed main mode negotiations since IPsec was last started.
  let ``Failed Main Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Failed Main Mode Negotiations"; instance = NotApplicable }
  /// Failed Main Mode Negotiations/sec: Failed Main Mode Negotiations per Second is the rate of failed main mode negotiations.
  let ``Failed Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Failed Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations: Failed Quick Mode Negotiations is the number of failed quick mode negotiations since IPsec was last started.
  let ``Failed Quick Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Failed Quick Mode Negotiations"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations/sec: Failed Quick Mode Negotiations per Second is the rate of failed quick mode negotiations.
  let ``Failed Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Failed Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received: Main Mode Negotiation Requests Received is the number of main mode negotiations initiated by a peer since IPsec was last started.
  let ``Main Mode Negotiation Requests Received`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Main Mode Negotiation Requests Received"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received/sec: Main Mode Negotiation Requests Received per Second is the rate of main mode negotiations initiated by a peer.
  let ``Main Mode Negotiation Requests Received/sec`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Main Mode Negotiation Requests Received/sec"; instance = NotApplicable }
  /// Main Mode Negotiations: Main Mode Negotiations is the number of main mode negotiations attempted since IPsec was last started.
  let ``Main Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Main Mode Negotiations"; instance = NotApplicable }
  /// Main Mode Negotiations/sec: Main Mode Negotiations per Second is the rate at which main mode negotiations are being attempted.
  let ``Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Pending Main Mode Negotiations: Pending Main Mode Negotiations is the number of pending main mode negotiations.
  let ``Pending Main Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Pending Main Mode Negotiations"; instance = NotApplicable }
  /// Pending Quick Mode Negotiations: Pending Quick Mode Negotiations is the number of pending quick mode negotiations.
  let ``Pending Quick Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Pending Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations: Quick Mode Negotiations is the number of quick mode negotiations attempted since IPsec was last started.
  let ``Quick Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations/sec: Quick Mode Negotiations per Second is the rate at which quick mode negotiations are being attempted.
  let ``Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Main Mode Negotiations: Successful Main Mode Negotiations is the number of main mode negotiations completed since IPsec was last started.
  let ``Successful Main Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Successful Main Mode Negotiations"; instance = NotApplicable }
  /// Successful Main Mode Negotiations/sec: Successful Main Mode Negotiations per Second is the rate of main mode negotiations completed.
  let ``Successful Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Successful Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations: Successful Quick Mode Negotiations is the number of quick mode negotiations completed since IPsec was last started.
  let ``Successful Quick Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Successful Quick Mode Negotiations"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations/sec: Successful Quick Mode Negotiations per Second is the rate of quick mode negotiations completed.
  let ``Successful Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Successful Quick Mode Negotiations/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Active Main Mode SAs``
      ``Active Quick Mode SAs``
      ``Failed Main Mode Negotiations``
      ``Failed Main Mode Negotiations/sec``
      ``Failed Quick Mode Negotiations``
      ``Failed Quick Mode Negotiations/sec``
      ``Main Mode Negotiation Requests Received``
      ``Main Mode Negotiation Requests Received/sec``
      ``Main Mode Negotiations``
      ``Main Mode Negotiations/sec``
      ``Pending Main Mode Negotiations``
      ``Pending Quick Mode Negotiations``
      ``Quick Mode Negotiations``
      ``Quick Mode Negotiations/sec``
      ``Successful Main Mode Negotiations``
      ``Successful Main Mode Negotiations/sec``
      ``Successful Quick Mode Negotiations``
      ``Successful Quick Mode Negotiations/sec``
    ]

/// IPsec IKEv2 IPv6: IPsec IKEv2 IPv6 is the set of Internet Protocol security (IPsec) Internet Key Exchange version 2 (IKEv2) counters that apply to traffic and connections over Internet Protocol version 6.
///
/// This performance counter does not have instance based counters
module ``IPsec IKEv2 IPv6`` =

  [<Literal>]
  let Category = "IPsec IKEv2 IPv6"

  let PCC = getPCC Category
  /// Active Main Mode SAs: Active Main Mode SAs is the number of currently active main mode security associations.
  let ``Active Main Mode SAs`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Active Main Mode SAs"; instance = NotApplicable }
  /// Active Quick Mode SAs: Active Quick Mode SAs is the number of currently active quick mode security associations.
  let ``Active Quick Mode SAs`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Active Quick Mode SAs"; instance = NotApplicable }
  /// Failed Main Mode Negotiations: Failed Main Mode Negotiations is the number of failed main mode negotiations since IPsec was last started.
  let ``Failed Main Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Failed Main Mode Negotiations"; instance = NotApplicable }
  /// Failed Main Mode Negotiations/sec: Failed Main Mode Negotiations per Second is the rate of failed main mode negotiations.
  let ``Failed Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Failed Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations: Failed Quick Mode Negotiations is the number of failed quick mode negotiations since IPsec was last started.
  let ``Failed Quick Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Failed Quick Mode Negotiations"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations/sec: Failed Quick Mode Negotiations per Second is the rate of failed quick mode negotiations.
  let ``Failed Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Failed Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received: Main Mode Negotiation Requests Received is the number of main mode negotiations initiated by a peer since IPsec was last started.
  let ``Main Mode Negotiation Requests Received`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Main Mode Negotiation Requests Received"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received/sec: Main Mode Negotiation Requests Received per Second is the rate of main mode negotiations initiated by a peer.
  let ``Main Mode Negotiation Requests Received/sec`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Main Mode Negotiation Requests Received/sec"; instance = NotApplicable }
  /// Main Mode Negotiations: Main Mode Negotiations is the number of main mode negotiations attempted since IPsec was last started.
  let ``Main Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Main Mode Negotiations"; instance = NotApplicable }
  /// Main Mode Negotiations/sec: Main Mode Negotiations per Second is the rate at which main mode negotiations are being attempted.
  let ``Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Pending Main Mode Negotiations: Pending Main Mode Negotiations is the number of pending main mode negotiations.
  let ``Pending Main Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Pending Main Mode Negotiations"; instance = NotApplicable }
  /// Pending Quick Mode Negotiations: Pending Quick Mode Negotiations is the number of pending quick mode negotiations.
  let ``Pending Quick Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Pending Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations: Quick Mode Negotiations is the number of quick mode negotiations attempted since IPsec was last started.
  let ``Quick Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations/sec: Quick Mode Negotiations per Second is the rate at which quick mode negotiations are being attempted.
  let ``Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Main Mode Negotiations: Successful Main Mode Negotiations is the number of main mode negotiations completed since IPsec was last started.
  let ``Successful Main Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Successful Main Mode Negotiations"; instance = NotApplicable }
  /// Successful Main Mode Negotiations/sec: Successful Main Mode Negotiations per Second is the rate of main mode negotiations completed.
  let ``Successful Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Successful Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations: Successful Quick Mode Negotiations is the number of quick mode negotiations completed since IPsec was last started.
  let ``Successful Quick Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Successful Quick Mode Negotiations"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations/sec: Successful Quick Mode Negotiations per Second is the rate of quick mode negotiations completed.
  let ``Successful Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Successful Quick Mode Negotiations/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Active Main Mode SAs``
      ``Active Quick Mode SAs``
      ``Failed Main Mode Negotiations``
      ``Failed Main Mode Negotiations/sec``
      ``Failed Quick Mode Negotiations``
      ``Failed Quick Mode Negotiations/sec``
      ``Main Mode Negotiation Requests Received``
      ``Main Mode Negotiation Requests Received/sec``
      ``Main Mode Negotiations``
      ``Main Mode Negotiations/sec``
      ``Pending Main Mode Negotiations``
      ``Pending Quick Mode Negotiations``
      ``Quick Mode Negotiations``
      ``Quick Mode Negotiations/sec``
      ``Successful Main Mode Negotiations``
      ``Successful Main Mode Negotiations/sec``
      ``Successful Quick Mode Negotiations``
      ``Successful Quick Mode Negotiations/sec``
    ]

/// IPv4: The IP performance object consists of counters that measure the rates at which IP datagrams are sent and received by using IP protocols.  It also includes counters that monitor IP protocol errors.
///
/// This performance counter does not have instance based counters
module ``IPv4`` =

  [<Literal>]
  let Category = "IPv4"

  let PCC = getPCC Category
  /// Datagrams Forwarded/sec: Datagrams Forwarded/sec is the rate, in incidents per second, at which attemps were made to find routes to forward input datagrams their final destination, because the local server was not the final IP destination. In servers that do not act as IP Gateways, this rate includes only packets that were source-routed via this entity, where the source-route option processing was successful.
  let ``Datagrams Forwarded/sec`` =
    { category = "IPv4"; counter = "Datagrams Forwarded/sec"; instance = NotApplicable }
  /// Datagrams Outbound Discarded: Datagrams Outbound Discarded is the number of output IP datagrams that were discarded even though no problems were encountered to prevent their transmission to their destination (for example, lack of buffer space). This counter includes datagrams counted in Datagrams Forwarded/sec that meet this criterion.
  let ``Datagrams Outbound Discarded`` =
    { category = "IPv4"; counter = "Datagrams Outbound Discarded"; instance = NotApplicable }
  /// Datagrams Outbound No Route: Datagrams Outbound No Route is the number of IP datagrams that were discarded because no route could be found to transmit them to their destination.  This counter includes any packets counted in Datagrams Forwarded/sec that meet this `no route' criterion.
  let ``Datagrams Outbound No Route`` =
    { category = "IPv4"; counter = "Datagrams Outbound No Route"; instance = NotApplicable }
  /// Datagrams Received Address Errors: Datagrams Received Address Errors is the number of input datagrams that were discarded because the IP address in their IP header destination field was not valid for the computer. This count includes invalid addresses (for example, 0.0.  0.0) and addresses of unsupported Classes (for example, Class E). For entities that are not IP gateways and do not forward datagrams, this counter includes datagrams that were discarded because the destination address was not a local address.
  let ``Datagrams Received Address Errors`` =
    { category = "IPv4"; counter = "Datagrams Received Address Errors"; instance = NotApplicable }
  /// Datagrams Received Delivered/sec: Datagrams Received Delivered/sec is the rate, in incidents per second, at which input datagrams were successfully delivered to IP user-protocols, including Internet Control Message Protocol (ICMP).
  let ``Datagrams Received Delivered/sec`` =
    { category = "IPv4"; counter = "Datagrams Received Delivered/sec"; instance = NotApplicable }
  /// Datagrams Received Discarded: Datagrams Received Discarded is the number of input IP datagrams that were discarded even though problems prevented their continued processing (for example, lack of buffer space). This counter does not include any datagrams discarded while awaiting re-assembly.
  let ``Datagrams Received Discarded`` =
    { category = "IPv4"; counter = "Datagrams Received Discarded"; instance = NotApplicable }
  /// Datagrams Received Header Errors: Datagrams Received Header Errors is the number of input datagrams that were discarded due to errors in the IP headers, including bad checksums, version number mismatch, other format errors, time-to-live exceeded, errors discovered in processing their IP options, etc.
  let ``Datagrams Received Header Errors`` =
    { category = "IPv4"; counter = "Datagrams Received Header Errors"; instance = NotApplicable }
  /// Datagrams Received Unknown Protocol: Datagrams Received Unknown Protocol is the number of locally-addressed datagrams that were successfully received but were discarded because of an unknown or unsupported protocol.
  let ``Datagrams Received Unknown Protocol`` =
    { category = "IPv4"; counter = "Datagrams Received Unknown Protocol"; instance = NotApplicable }
  /// Datagrams Received/sec: Datagrams Received/sec is the rate, in incidents per second, at which IP datagrams are received from the interfaces, including those in error. Datagrams Received/sec is a subset of Datagrams/sec.
  let ``Datagrams Received/sec`` =
    { category = "IPv4"; counter = "Datagrams Received/sec"; instance = NotApplicable }
  /// Datagrams Sent/sec: Datagrams Sent/sec is the rate, in incidents per second, at which IP datagrams were supplied for transmission by local IP user-protocols (including ICMP). This counter does not include any datagrams counted in Datagrams Forwarded/sec. Datagrams Sent/sec is a subset of Datagrams/sec.
  let ``Datagrams Sent/sec`` =
    { category = "IPv4"; counter = "Datagrams Sent/sec"; instance = NotApplicable }
  /// Datagrams/sec: Datagrams/sec is the rate, in incidents per second, at which IP datagrams were received from or sent to the interfaces, including those in error. Forwarded datagrams are not included in this rate.
  let ``Datagrams/sec`` =
    { category = "IPv4"; counter = "Datagrams/sec"; instance = NotApplicable }
  /// Fragment Re-assembly Failures: Fragment Re-assembly Failures is the number of failures detected by the IP reassembly algorithm, such as time outs, errors, etc.  This is not necessarily a count of discarded IP fragments since some algorithms (notably RFC 815) lose track of the number of fragments by combining them as they are received.
  let ``Fragment Re-assembly Failures`` =
    { category = "IPv4"; counter = "Fragment Re-assembly Failures"; instance = NotApplicable }
  /// Fragmentation Failures: Fragmentation Failures is the number of IP datagrams that were discarded because they needed to be fragmented at but could not be (for example, because the `Don't Fragment' flag was set).
  let ``Fragmentation Failures`` =
    { category = "IPv4"; counter = "Fragmentation Failures"; instance = NotApplicable }
  /// Fragmented Datagrams/sec: Fragmented Datagrams/sec is the rate, in incidents per second, at which datagrams are successfully fragmented.
  let ``Fragmented Datagrams/sec`` =
    { category = "IPv4"; counter = "Fragmented Datagrams/sec"; instance = NotApplicable }
  /// Fragments Created/sec: Fragments Created/sec is the rate, in incidents per second, at which IP datagram fragments were generated as a result of fragmentation.
  let ``Fragments Created/sec`` =
    { category = "IPv4"; counter = "Fragments Created/sec"; instance = NotApplicable }
  /// Fragments Re-assembled/sec: Fragments Re-assembled/sec is the rate, in incidents per second, at which IP fragments were successfully reassembled.
  let ``Fragments Re-assembled/sec`` =
    { category = "IPv4"; counter = "Fragments Re-assembled/sec"; instance = NotApplicable }
  /// Fragments Received/sec: Fragments Received/sec is the rate, in incidents per second, at which IP fragments that need to be reassembled at this entity are received.
  let ``Fragments Received/sec`` =
    { category = "IPv4"; counter = "Fragments Received/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Datagrams Forwarded/sec``
      ``Datagrams Outbound Discarded``
      ``Datagrams Outbound No Route``
      ``Datagrams Received Address Errors``
      ``Datagrams Received Delivered/sec``
      ``Datagrams Received Discarded``
      ``Datagrams Received Header Errors``
      ``Datagrams Received Unknown Protocol``
      ``Datagrams Received/sec``
      ``Datagrams Sent/sec``
      ``Datagrams/sec``
      ``Fragment Re-assembly Failures``
      ``Fragmentation Failures``
      ``Fragmented Datagrams/sec``
      ``Fragments Created/sec``
      ``Fragments Re-assembled/sec``
      ``Fragments Received/sec``
    ]

/// IPv6: The IP performance object consists of counters that measure the rates at which IP datagrams are sent and received by using IP protocols.  It also includes counters that monitor IP protocol errors.
///
/// This performance counter does not have instance based counters
module ``IPv6`` =

  [<Literal>]
  let Category = "IPv6"

  let PCC = getPCC Category
  /// Datagrams Forwarded/sec: Datagrams Forwarded/sec is the rate, in incidents per second, at which attemps were made to find routes to forward input datagrams their final destination, because the local server was not the final IP destination. In servers that do not act as IP Gateways, this rate includes only packets that were source-routed via this entity, where the source-route option processing was successful.
  let ``Datagrams Forwarded/sec`` =
    { category = "IPv6"; counter = "Datagrams Forwarded/sec"; instance = NotApplicable }
  /// Datagrams Outbound Discarded: Datagrams Outbound Discarded is the number of output IP datagrams that were discarded even though no problems were encountered to prevent their transmission to their destination (for example, lack of buffer space). This counter includes datagrams counted in Datagrams Forwarded/sec that meet this criterion.
  let ``Datagrams Outbound Discarded`` =
    { category = "IPv6"; counter = "Datagrams Outbound Discarded"; instance = NotApplicable }
  /// Datagrams Outbound No Route: Datagrams Outbound No Route is the number of IP datagrams that were discarded because no route could be found to transmit them to their destination.  This counter includes any packets counted in Datagrams Forwarded/sec that meet this `no route' criterion.
  let ``Datagrams Outbound No Route`` =
    { category = "IPv6"; counter = "Datagrams Outbound No Route"; instance = NotApplicable }
  /// Datagrams Received Address Errors: Datagrams Received Address Errors is the number of input datagrams that were discarded because the IP address in their IP header destination field was not valid for the computer. This count includes invalid addresses (for example, 0.0.  0.0) and addresses of unsupported Classes (for example, Class E). For entities that are not IP gateways and do not forward datagrams, this counter includes datagrams that were discarded because the destination address was not a local address.
  let ``Datagrams Received Address Errors`` =
    { category = "IPv6"; counter = "Datagrams Received Address Errors"; instance = NotApplicable }
  /// Datagrams Received Delivered/sec: Datagrams Received Delivered/sec is the rate, in incidents per second, at which input datagrams were successfully delivered to IP user-protocols, including Internet Control Message Protocol (ICMP).
  let ``Datagrams Received Delivered/sec`` =
    { category = "IPv6"; counter = "Datagrams Received Delivered/sec"; instance = NotApplicable }
  /// Datagrams Received Discarded: Datagrams Received Discarded is the number of input IP datagrams that were discarded even though problems prevented their continued processing (for example, lack of buffer space). This counter does not include any datagrams discarded while awaiting re-assembly.
  let ``Datagrams Received Discarded`` =
    { category = "IPv6"; counter = "Datagrams Received Discarded"; instance = NotApplicable }
  /// Datagrams Received Header Errors: Datagrams Received Header Errors is the number of input datagrams that were discarded due to errors in the IP headers, including bad checksums, version number mismatch, other format errors, time-to-live exceeded, errors discovered in processing their IP options, etc.
  let ``Datagrams Received Header Errors`` =
    { category = "IPv6"; counter = "Datagrams Received Header Errors"; instance = NotApplicable }
  /// Datagrams Received Unknown Protocol: Datagrams Received Unknown Protocol is the number of locally-addressed datagrams that were successfully received but were discarded because of an unknown or unsupported protocol.
  let ``Datagrams Received Unknown Protocol`` =
    { category = "IPv6"; counter = "Datagrams Received Unknown Protocol"; instance = NotApplicable }
  /// Datagrams Received/sec: Datagrams Received/sec is the rate, in incidents per second, at which IP datagrams are received from the interfaces, including those in error. Datagrams Received/sec is a subset of Datagrams/sec.
  let ``Datagrams Received/sec`` =
    { category = "IPv6"; counter = "Datagrams Received/sec"; instance = NotApplicable }
  /// Datagrams Sent/sec: Datagrams Sent/sec is the rate, in incidents per second, at which IP datagrams were supplied for transmission by local IP user-protocols (including ICMP). This counter does not include any datagrams counted in Datagrams Forwarded/sec. Datagrams Sent/sec is a subset of Datagrams/sec.
  let ``Datagrams Sent/sec`` =
    { category = "IPv6"; counter = "Datagrams Sent/sec"; instance = NotApplicable }
  /// Datagrams/sec: Datagrams/sec is the rate, in incidents per second, at which IP datagrams were received from or sent to the interfaces, including those in error. Forwarded datagrams are not included in this rate.
  let ``Datagrams/sec`` =
    { category = "IPv6"; counter = "Datagrams/sec"; instance = NotApplicable }
  /// Fragment Re-assembly Failures: Fragment Re-assembly Failures is the number of failures detected by the IP reassembly algorithm, such as time outs, errors, etc.  This is not necessarily a count of discarded IP fragments since some algorithms (notably RFC 815) lose track of the number of fragments by combining them as they are received.
  let ``Fragment Re-assembly Failures`` =
    { category = "IPv6"; counter = "Fragment Re-assembly Failures"; instance = NotApplicable }
  /// Fragmentation Failures: Fragmentation Failures is the number of IP datagrams that were discarded because they needed to be fragmented at but could not be (for example, because the `Don't Fragment' flag was set).
  let ``Fragmentation Failures`` =
    { category = "IPv6"; counter = "Fragmentation Failures"; instance = NotApplicable }
  /// Fragmented Datagrams/sec: Fragmented Datagrams/sec is the rate, in incidents per second, at which datagrams are successfully fragmented.
  let ``Fragmented Datagrams/sec`` =
    { category = "IPv6"; counter = "Fragmented Datagrams/sec"; instance = NotApplicable }
  /// Fragments Created/sec: Fragments Created/sec is the rate, in incidents per second, at which IP datagram fragments were generated as a result of fragmentation.
  let ``Fragments Created/sec`` =
    { category = "IPv6"; counter = "Fragments Created/sec"; instance = NotApplicable }
  /// Fragments Re-assembled/sec: Fragments Re-assembled/sec is the rate, in incidents per second, at which IP fragments were successfully reassembled.
  let ``Fragments Re-assembled/sec`` =
    { category = "IPv6"; counter = "Fragments Re-assembled/sec"; instance = NotApplicable }
  /// Fragments Received/sec: Fragments Received/sec is the rate, in incidents per second, at which IP fragments that need to be reassembled at this entity are received.
  let ``Fragments Received/sec`` =
    { category = "IPv6"; counter = "Fragments Received/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Datagrams Forwarded/sec``
      ``Datagrams Outbound Discarded``
      ``Datagrams Outbound No Route``
      ``Datagrams Received Address Errors``
      ``Datagrams Received Delivered/sec``
      ``Datagrams Received Discarded``
      ``Datagrams Received Header Errors``
      ``Datagrams Received Unknown Protocol``
      ``Datagrams Received/sec``
      ``Datagrams Sent/sec``
      ``Datagrams/sec``
      ``Fragment Re-assembly Failures``
      ``Fragmentation Failures``
      ``Fragmented Datagrams/sec``
      ``Fragments Created/sec``
      ``Fragments Re-assembled/sec``
      ``Fragments Received/sec``
    ]

/// Job Object: Reports the accounting and processor usage data collected by each active named Job object.
///
/// This performance counter does not have instance based counters
module ``Job Object`` =

  [<Literal>]
  let Category = "Job Object"

  let PCC = getPCC Category
  /// Current % Kernel Mode Time: -
  let ``Current % Kernel Mode Time`` instance =
    { category = "Job Object"; counter = "Current % Kernel Mode Time"; instance = instance }
  /// Current % Processor Time: -
  let ``Current % Processor Time`` instance =
    { category = "Job Object"; counter = "Current % Processor Time"; instance = instance }
  /// Current % User Mode Time: -
  let ``Current % User Mode Time`` instance =
    { category = "Job Object"; counter = "Current % User Mode Time"; instance = instance }
  /// Pages/Sec: -
  let ``Pages/Sec`` instance =
    { category = "Job Object"; counter = "Pages/Sec"; instance = instance }
  /// Process Count - Active: -
  let ``Process Count - Active`` instance =
    { category = "Job Object"; counter = "Process Count - Active"; instance = instance }
  /// Process Count - Terminated: -
  let ``Process Count - Terminated`` instance =
    { category = "Job Object"; counter = "Process Count - Terminated"; instance = instance }
  /// Process Count - Total: -
  let ``Process Count - Total`` instance =
    { category = "Job Object"; counter = "Process Count - Total"; instance = instance }
  /// This Period mSec - Kernel Mode: -
  let ``This Period mSec - Kernel Mode`` instance =
    { category = "Job Object"; counter = "This Period mSec - Kernel Mode"; instance = instance }
  /// This Period mSec - Processor: -
  let ``This Period mSec - Processor`` instance =
    { category = "Job Object"; counter = "This Period mSec - Processor"; instance = instance }
  /// This Period mSec - User Mode: -
  let ``This Period mSec - User Mode`` instance =
    { category = "Job Object"; counter = "This Period mSec - User Mode"; instance = instance }
  /// Total mSec - Kernel Mode: -
  let ``Total mSec - Kernel Mode`` instance =
    { category = "Job Object"; counter = "Total mSec - Kernel Mode"; instance = instance }
  /// Total mSec - Processor: -
  let ``Total mSec - Processor`` instance =
    { category = "Job Object"; counter = "Total mSec - Processor"; instance = instance }
  /// Total mSec - User Mode: -
  let ``Total mSec - User Mode`` instance =
    { category = "Job Object"; counter = "Total mSec - User Mode"; instance = instance }

  let allCounters =
    [ ``Current % Kernel Mode Time``
      ``Current % Processor Time``
      ``Current % User Mode Time``
      ``Pages/Sec``
      ``Process Count - Active``
      ``Process Count - Terminated``
      ``Process Count - Total``
      ``This Period mSec - Kernel Mode``
      ``This Period mSec - Processor``
      ``This Period mSec - User Mode``
      ``Total mSec - Kernel Mode``
      ``Total mSec - Processor``
      ``Total mSec - User Mode``
    ]

/// Job Object Details: % Job object Details shows detailed performance information about the active processes that make up a Job object.
///
/// This performance counter does not have instance based counters
module ``Job Object Details`` =

  [<Literal>]
  let Category = "Job Object Details"

  let PCC = getPCC Category
  /// % Privileged Time: -
  let ``% Privileged Time`` instance =
    { category = "Job Object Details"; counter = "% Privileged Time"; instance = instance }
  /// % Processor Time: -
  let ``% Processor Time`` instance =
    { category = "Job Object Details"; counter = "% Processor Time"; instance = instance }
  /// % User Time: -
  let ``% User Time`` instance =
    { category = "Job Object Details"; counter = "% User Time"; instance = instance }
  /// Creating Process ID: -
  let ``Creating Process ID`` instance =
    { category = "Job Object Details"; counter = "Creating Process ID"; instance = instance }
  /// Elapsed Time: -
  let ``Elapsed Time`` instance =
    { category = "Job Object Details"; counter = "Elapsed Time"; instance = instance }
  /// Handle Count: -
  let ``Handle Count`` instance =
    { category = "Job Object Details"; counter = "Handle Count"; instance = instance }
  /// ID Process: -
  let ``ID Process`` instance =
    { category = "Job Object Details"; counter = "ID Process"; instance = instance }
  /// IO Data Bytes/sec: -
  let ``IO Data Bytes/sec`` instance =
    { category = "Job Object Details"; counter = "IO Data Bytes/sec"; instance = instance }
  /// IO Data Operations/sec: -
  let ``IO Data Operations/sec`` instance =
    { category = "Job Object Details"; counter = "IO Data Operations/sec"; instance = instance }
  /// IO Other Bytes/sec: -
  let ``IO Other Bytes/sec`` instance =
    { category = "Job Object Details"; counter = "IO Other Bytes/sec"; instance = instance }
  /// IO Other Operations/sec: -
  let ``IO Other Operations/sec`` instance =
    { category = "Job Object Details"; counter = "IO Other Operations/sec"; instance = instance }
  /// IO Read Bytes/sec: -
  let ``IO Read Bytes/sec`` instance =
    { category = "Job Object Details"; counter = "IO Read Bytes/sec"; instance = instance }
  /// IO Read Operations/sec: -
  let ``IO Read Operations/sec`` instance =
    { category = "Job Object Details"; counter = "IO Read Operations/sec"; instance = instance }
  /// IO Write Bytes/sec: -
  let ``IO Write Bytes/sec`` instance =
    { category = "Job Object Details"; counter = "IO Write Bytes/sec"; instance = instance }
  /// IO Write Operations/sec: -
  let ``IO Write Operations/sec`` instance =
    { category = "Job Object Details"; counter = "IO Write Operations/sec"; instance = instance }
  /// Page Faults/sec: -
  let ``Page Faults/sec`` instance =
    { category = "Job Object Details"; counter = "Page Faults/sec"; instance = instance }
  /// Page File Bytes: -
  let ``Page File Bytes`` instance =
    { category = "Job Object Details"; counter = "Page File Bytes"; instance = instance }
  /// Page File Bytes Peak: -
  let ``Page File Bytes Peak`` instance =
    { category = "Job Object Details"; counter = "Page File Bytes Peak"; instance = instance }
  /// Pool Nonpaged Bytes: -
  let ``Pool Nonpaged Bytes`` instance =
    { category = "Job Object Details"; counter = "Pool Nonpaged Bytes"; instance = instance }
  /// Pool Paged Bytes: -
  let ``Pool Paged Bytes`` instance =
    { category = "Job Object Details"; counter = "Pool Paged Bytes"; instance = instance }
  /// Priority Base: -
  let ``Priority Base`` instance =
    { category = "Job Object Details"; counter = "Priority Base"; instance = instance }
  /// Private Bytes: -
  let ``Private Bytes`` instance =
    { category = "Job Object Details"; counter = "Private Bytes"; instance = instance }
  /// Thread Count: -
  let ``Thread Count`` instance =
    { category = "Job Object Details"; counter = "Thread Count"; instance = instance }
  /// Virtual Bytes: -
  let ``Virtual Bytes`` instance =
    { category = "Job Object Details"; counter = "Virtual Bytes"; instance = instance }
  /// Virtual Bytes Peak: -
  let ``Virtual Bytes Peak`` instance =
    { category = "Job Object Details"; counter = "Virtual Bytes Peak"; instance = instance }
  /// Working Set: -
  let ``Working Set`` instance =
    { category = "Job Object Details"; counter = "Working Set"; instance = instance }
  /// Working Set Peak: -
  let ``Working Set Peak`` instance =
    { category = "Job Object Details"; counter = "Working Set Peak"; instance = instance }

  let allCounters =
    [ ``% Privileged Time``
      ``% Processor Time``
      ``% User Time``
      ``Creating Process ID``
      ``Elapsed Time``
      ``Handle Count``
      ``ID Process``
      ``IO Data Bytes/sec``
      ``IO Data Operations/sec``
      ``IO Other Bytes/sec``
      ``IO Other Operations/sec``
      ``IO Read Bytes/sec``
      ``IO Read Operations/sec``
      ``IO Write Bytes/sec``
      ``IO Write Operations/sec``
      ``Page Faults/sec``
      ``Page File Bytes``
      ``Page File Bytes Peak``
      ``Pool Nonpaged Bytes``
      ``Pool Paged Bytes``
      ``Priority Base``
      ``Private Bytes``
      ``Thread Count``
      ``Virtual Bytes``
      ``Virtual Bytes Peak``
      ``Working Set``
      ``Working Set Peak``
    ]

/// LogicalDisk: The Logical Disk performance object consists of counters that monitor logical partitions of a hard or fixed disk drives.  Performance Monitor identifies logical disks by their a drive letter, such as C.
///
/// This performance counter does not have non-instance based counters
module ``LogicalDisk`` =

  [<Literal>]
  let Category = "LogicalDisk"

  let PCC = getPCC Category
  /// % Disk Read Time: % Disk Read Time is the percentage of elapsed time that the selected disk drive was busy servicing read requests.
  let ``% Disk Read Time`` instance =
    { category = "LogicalDisk"; counter = "% Disk Read Time"; instance = instance }
  /// % Disk Time: % Disk Time is the percentage of elapsed time that the selected disk drive was busy servicing read or write requests.
  let ``% Disk Time`` instance =
    { category = "LogicalDisk"; counter = "% Disk Time"; instance = instance }
  /// % Disk Write Time: % Disk Write Time is the percentage of elapsed time that the selected disk drive was busy servicing write requests.
  let ``% Disk Write Time`` instance =
    { category = "LogicalDisk"; counter = "% Disk Write Time"; instance = instance }
  /// % Free Space: % Free Space is the percentage of total usable space on the selected logical disk drive that was free.
  let ``% Free Space`` instance =
    { category = "LogicalDisk"; counter = "% Free Space"; instance = instance }
  /// % Idle Time: % Idle Time reports the percentage of time during the sample interval that the disk was idle.
  let ``% Idle Time`` instance =
    { category = "LogicalDisk"; counter = "% Idle Time"; instance = instance }
  /// Avg. Disk Bytes/Read: Avg. Disk Bytes/Read is the average number of bytes transferred from the disk during read operations.
  let ``Avg. Disk Bytes/Read`` instance =
    { category = "LogicalDisk"; counter = "Avg. Disk Bytes/Read"; instance = instance }
  /// Avg. Disk Bytes/Transfer: Avg. Disk Bytes/Transfer is the average number of bytes transferred to or from the disk during write or read operations.
  let ``Avg. Disk Bytes/Transfer`` instance =
    { category = "LogicalDisk"; counter = "Avg. Disk Bytes/Transfer"; instance = instance }
  /// Avg. Disk Bytes/Write: Avg. Disk Bytes/Write is the average number of bytes transferred to the disk during write operations.
  let ``Avg. Disk Bytes/Write`` instance =
    { category = "LogicalDisk"; counter = "Avg. Disk Bytes/Write"; instance = instance }
  /// Avg. Disk Queue Length: Avg. Disk Queue Length is the average number of both read and write requests that were queued for the selected disk during the sample interval.
  let ``Avg. Disk Queue Length`` instance =
    { category = "LogicalDisk"; counter = "Avg. Disk Queue Length"; instance = instance }
  /// Avg. Disk Read Queue Length: Avg. Disk Read Queue Length is the average number of read requests that were queued for the selected disk during the sample interval.
  let ``Avg. Disk Read Queue Length`` instance =
    { category = "LogicalDisk"; counter = "Avg. Disk Read Queue Length"; instance = instance }
  /// Avg. Disk Write Queue Length: Avg. Disk Write Queue Length is the average number of write requests that were queued for the selected disk during the sample interval.
  let ``Avg. Disk Write Queue Length`` instance =
    { category = "LogicalDisk"; counter = "Avg. Disk Write Queue Length"; instance = instance }
  /// Avg. Disk sec/Read: Avg. Disk sec/Read is the average time, in seconds, of a read of data from the disk.
  let ``Avg. Disk sec/Read`` instance =
    { category = "LogicalDisk"; counter = "Avg. Disk sec/Read"; instance = instance }
  /// Avg. Disk sec/Transfer: Avg. Disk sec/Transfer is the time, in seconds, of the average disk transfer.
  let ``Avg. Disk sec/Transfer`` instance =
    { category = "LogicalDisk"; counter = "Avg. Disk sec/Transfer"; instance = instance }
  /// Avg. Disk sec/Write: Avg. Disk sec/Write is the average time, in seconds, of a write of data to the disk.
  let ``Avg. Disk sec/Write`` instance =
    { category = "LogicalDisk"; counter = "Avg. Disk sec/Write"; instance = instance }
  /// Current Disk Queue Length: Current Disk Queue Length is the number of requests outstanding on the disk at the time the performance data is collected. It also includes requests in service at the time of the collection. This is a instantaneous snapshot, not an average over the time interval. Multi-spindle disk devices can have multiple requests that are active at one time, but other concurrent requests are awaiting service. This counter might reflect a transitory high or low queue length, but if there is a sustained load on the disk drive, it is likely that this will be consistently high. Requests experience delays proportional to the length of this queue minus the number of spindles on the disks. For good performance, this difference should average less than two.
  let ``Current Disk Queue Length`` instance =
    { category = "LogicalDisk"; counter = "Current Disk Queue Length"; instance = instance }
  /// Disk Bytes/sec: Disk Bytes/sec is the rate bytes are transferred to or from the disk during write or read operations.
  let ``Disk Bytes/sec`` instance =
    { category = "LogicalDisk"; counter = "Disk Bytes/sec"; instance = instance }
  /// Disk Read Bytes/sec: Disk Read Bytes/sec is the rate at which bytes are transferred from the disk during read operations.
  let ``Disk Read Bytes/sec`` instance =
    { category = "LogicalDisk"; counter = "Disk Read Bytes/sec"; instance = instance }
  /// Disk Reads/sec: Disk Reads/sec is the rate of read operations on the disk.
  let ``Disk Reads/sec`` instance =
    { category = "LogicalDisk"; counter = "Disk Reads/sec"; instance = instance }
  /// Disk Transfers/sec: Disk Transfers/sec is the rate of read and write operations on the disk.
  let ``Disk Transfers/sec`` instance =
    { category = "LogicalDisk"; counter = "Disk Transfers/sec"; instance = instance }
  /// Disk Write Bytes/sec: Disk Write Bytes/sec is rate at which bytes are transferred to the disk during write operations.
  let ``Disk Write Bytes/sec`` instance =
    { category = "LogicalDisk"; counter = "Disk Write Bytes/sec"; instance = instance }
  /// Disk Writes/sec: Disk Writes/sec is the rate of write operations on the disk.
  let ``Disk Writes/sec`` instance =
    { category = "LogicalDisk"; counter = "Disk Writes/sec"; instance = instance }
  /// Free Megabytes: Free Megabytes displays the unallocated space, in megabytes, on the disk drive in megabytes. One megabyte is equal to 1,048,576 bytes.
  let ``Free Megabytes`` instance =
    { category = "LogicalDisk"; counter = "Free Megabytes"; instance = instance }
  /// Split IO/Sec: Split IO/Sec reports the rate at which I/Os to the disk were split into multiple I/Os. A split I/O may result from requesting data of a size that is too large to fit into a single I/O or that the disk is fragmented.
  let ``Split IO/Sec`` instance =
    { category = "LogicalDisk"; counter = "Split IO/Sec"; instance = instance }

  let allCounters =
    [ ``% Disk Read Time``
      ``% Disk Time``
      ``% Disk Write Time``
      ``% Free Space``
      ``% Idle Time``
      ``Avg. Disk Bytes/Read``
      ``Avg. Disk Bytes/Transfer``
      ``Avg. Disk Bytes/Write``
      ``Avg. Disk Queue Length``
      ``Avg. Disk Read Queue Length``
      ``Avg. Disk Write Queue Length``
      ``Avg. Disk sec/Read``
      ``Avg. Disk sec/Transfer``
      ``Avg. Disk sec/Write``
      ``Current Disk Queue Length``
      ``Disk Bytes/sec``
      ``Disk Read Bytes/sec``
      ``Disk Reads/sec``
      ``Disk Transfers/sec``
      ``Disk Write Bytes/sec``
      ``Disk Writes/sec``
      ``Free Megabytes``
      ``Split IO/Sec``
    ]

/// MSDTC Bridge 3.0.0.0: MSDTC Bridge 3.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``MSDTC Bridge 3_0_0_0`` =

  [<Literal>]
  let Category = "MSDTC Bridge 3.0.0.0"

  let PCC = getPCC Category
  /// Average participant commit response time: Average time in milliseconds for the WS-AT service to receive a Commit message response from a participant.
  let ``Average participant commit response time`` =
    { category = "MSDTC Bridge 3.0.0.0"; counter = "Average participant commit response time"; instance = NotApplicable }
  /// Average participant commit response time Base: Base counter for the 'Average participant commit response time' counter.
  let ``Average participant commit response time Base`` =
    { category = "MSDTC Bridge 3.0.0.0"; counter = "Average participant commit response time Base"; instance = NotApplicable }
  /// Average participant prepare response time: Average time in milliseconds for the WS-AT service to receive a Prepare message response from a participant.
  let ``Average participant prepare response time`` =
    { category = "MSDTC Bridge 3.0.0.0"; counter = "Average participant prepare response time"; instance = NotApplicable }
  /// Average participant prepare response time Base: Base counter for the 'Average participant prepare response time' counter.
  let ``Average participant prepare response time Base`` =
    { category = "MSDTC Bridge 3.0.0.0"; counter = "Average participant prepare response time Base"; instance = NotApplicable }
  /// Commit retry count/sec: The number of Commit retry messages that the WS-AT service has sent per second.
  let ``Commit retry count/sec`` =
    { category = "MSDTC Bridge 3.0.0.0"; counter = "Commit retry count/sec"; instance = NotApplicable }
  /// Faults received count/sec: The number of Fault messages that the WS-AT service has received per second.
  let ``Faults received count/sec`` =
    { category = "MSDTC Bridge 3.0.0.0"; counter = "Faults received count/sec"; instance = NotApplicable }
  /// Faults sent count/sec: The number of Fault messages that the WS-AT service has sent per second.
  let ``Faults sent count/sec`` =
    { category = "MSDTC Bridge 3.0.0.0"; counter = "Faults sent count/sec"; instance = NotApplicable }
  /// Message send failures/sec: The number of WS-AT protocol messages that the WS-AT service failed to send per second.
  let ``Message send failures/sec`` =
    { category = "MSDTC Bridge 3.0.0.0"; counter = "Message send failures/sec"; instance = NotApplicable }
  /// Prepare retry count/sec: The number of Prepare retry messages that the WS-AT service has sent per second.
  let ``Prepare retry count/sec`` =
    { category = "MSDTC Bridge 3.0.0.0"; counter = "Prepare retry count/sec"; instance = NotApplicable }
  /// Prepared retry count/sec: The number of Prepared retry messages that the WS-AT service has sent per second.
  let ``Prepared retry count/sec`` =
    { category = "MSDTC Bridge 3.0.0.0"; counter = "Prepared retry count/sec"; instance = NotApplicable }
  /// Replay retry count/sec: The number of Replay retry messages that the WS-AT service has sent per second.
  let ``Replay retry count/sec`` =
    { category = "MSDTC Bridge 3.0.0.0"; counter = "Replay retry count/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Average participant commit response time``
      ``Average participant commit response time Base``
      ``Average participant prepare response time``
      ``Average participant prepare response time Base``
      ``Commit retry count/sec``
      ``Faults received count/sec``
      ``Faults sent count/sec``
      ``Message send failures/sec``
      ``Prepare retry count/sec``
      ``Prepared retry count/sec``
      ``Replay retry count/sec``
    ]

/// MSDTC Bridge 4.0.0.0: MSDTC Bridge 4.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``MSDTC Bridge 4_0_0_0`` =

  [<Literal>]
  let Category = "MSDTC Bridge 4.0.0.0"

  let PCC = getPCC Category
  /// Average participant commit response time: Average time in milliseconds for the WS-AT service to receive a Commit message response from a participant.
  let ``Average participant commit response time`` =
    { category = "MSDTC Bridge 4.0.0.0"; counter = "Average participant commit response time"; instance = NotApplicable }
  /// Average participant commit response time Base: Base counter for the 'Average participant commit response time' counter.
  let ``Average participant commit response time Base`` =
    { category = "MSDTC Bridge 4.0.0.0"; counter = "Average participant commit response time Base"; instance = NotApplicable }
  /// Average participant prepare response time: Average time in milliseconds for the WS-AT service to receive a Prepare message response from a participant.
  let ``Average participant prepare response time`` =
    { category = "MSDTC Bridge 4.0.0.0"; counter = "Average participant prepare response time"; instance = NotApplicable }
  /// Average participant prepare response time Base: Base counter for the 'Average participant prepare response time' counter.
  let ``Average participant prepare response time Base`` =
    { category = "MSDTC Bridge 4.0.0.0"; counter = "Average participant prepare response time Base"; instance = NotApplicable }
  /// Commit retry count/sec: The number of Commit retry messages that the WS-AT service has sent per second.
  let ``Commit retry count/sec`` =
    { category = "MSDTC Bridge 4.0.0.0"; counter = "Commit retry count/sec"; instance = NotApplicable }
  /// Faults received count/sec: The number of Fault messages that the WS-AT service has received per second.
  let ``Faults received count/sec`` =
    { category = "MSDTC Bridge 4.0.0.0"; counter = "Faults received count/sec"; instance = NotApplicable }
  /// Faults sent count/sec: The number of Fault messages that the WS-AT service has sent per second.
  let ``Faults sent count/sec`` =
    { category = "MSDTC Bridge 4.0.0.0"; counter = "Faults sent count/sec"; instance = NotApplicable }
  /// Message send failures/sec: The number of WS-AT protocol messages that the WS-AT service failed to send per second.
  let ``Message send failures/sec`` =
    { category = "MSDTC Bridge 4.0.0.0"; counter = "Message send failures/sec"; instance = NotApplicable }
  /// Prepare retry count/sec: The number of Prepare retry messages that the WS-AT service has sent per second.
  let ``Prepare retry count/sec`` =
    { category = "MSDTC Bridge 4.0.0.0"; counter = "Prepare retry count/sec"; instance = NotApplicable }
  /// Prepared retry count/sec: The number of Prepared retry messages that the WS-AT service has sent per second.
  let ``Prepared retry count/sec`` =
    { category = "MSDTC Bridge 4.0.0.0"; counter = "Prepared retry count/sec"; instance = NotApplicable }
  /// Replay retry count/sec: The number of Replay retry messages that the WS-AT service has sent per second.
  let ``Replay retry count/sec`` =
    { category = "MSDTC Bridge 4.0.0.0"; counter = "Replay retry count/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Average participant commit response time``
      ``Average participant commit response time Base``
      ``Average participant prepare response time``
      ``Average participant prepare response time Base``
      ``Commit retry count/sec``
      ``Faults received count/sec``
      ``Faults sent count/sec``
      ``Message send failures/sec``
      ``Prepare retry count/sec``
      ``Prepared retry count/sec``
      ``Replay retry count/sec``
    ]

/// Memory: The Memory performance object  consists of counters that describe the behavior of physical and virtual memory on the computer.  Physical memory is the amount of random access memory on the computer.  Virtual memory consists of the space in physical memory and on disk.  Many of the memory counters monitor paging, which is the movement of pages of code and data between disk and physical memory.  Excessive paging, a symptom of a memory shortage, can cause delays which interfere with all system processes.
///
/// This performance counter does not have instance based counters
module ``Memory`` =

  [<Literal>]
  let Category = "Memory"

  let PCC = getPCC Category
  /// % Committed Bytes In Use: % Committed Bytes In Use is the ratio of Memory\\Committed Bytes to the Memory\\Commit Limit. Committed memory is the physical memory in use for which space has been reserved in the paging file should it need to be written to disk. The commit limit is determined by the size of the paging file.  If the paging file is enlarged, the commit limit increases, and the ratio is reduced). This counter displays the current percentage value only; it is not an average.
  let ``% Committed Bytes In Use`` =
    { category = "Memory"; counter = "% Committed Bytes In Use"; instance = NotApplicable }
  /// Available Bytes: Available Bytes is the amount of physical memory, in bytes, immediately available for allocation to a process or for system use. It is equal to the sum of memory assigned to the standby (cached), free and zero page lists.
  let ``Available Bytes`` =
    { category = "Memory"; counter = "Available Bytes"; instance = NotApplicable }
  /// Available KBytes: Available KBytes is the amount of physical memory, in Kilobytes, immediately available for allocation to a process or for system use. It is equal to the sum of memory assigned to the standby (cached), free and zero page lists.
  let ``Available KBytes`` =
    { category = "Memory"; counter = "Available KBytes"; instance = NotApplicable }
  /// Available MBytes: Available MBytes is the amount of physical memory, in Megabytes, immediately available for allocation to a process or for system use. It is equal to the sum of memory assigned to the standby (cached), free and zero page lists.
  let ``Available MBytes`` =
    { category = "Memory"; counter = "Available MBytes"; instance = NotApplicable }
  /// Cache Bytes: Cache Bytes the size, in bytes, of the portion of the system file cache which is currently resident and active in physical memory. The Cache Bytes and Memory\\System Cache Resident Bytes counters are equivalent.  This counter displays the last observed value only; it is not an average.
  let ``Cache Bytes`` =
    { category = "Memory"; counter = "Cache Bytes"; instance = NotApplicable }
  /// Cache Bytes Peak: Cache Bytes Peak is the maximum number of bytes used by the system file cache since the system was last restarted. This might be larger than the current size of the cache. This counter displays the last observed value only; it is not an average.
  let ``Cache Bytes Peak`` =
    { category = "Memory"; counter = "Cache Bytes Peak"; instance = NotApplicable }
  /// Cache Faults/sec: Cache Faults/sec is the rate at which faults occur when a page sought in the file system cache is not found and must be retrieved from elsewhere in memory (a soft fault) or from disk (a hard fault). The file system cache is an area of physical memory that stores recently used pages of data for applications. Cache activity is a reliable indicator of most application I/O operations. This counter shows the number of faults, without regard for the number of pages faulted in each operation.
  let ``Cache Faults/sec`` =
    { category = "Memory"; counter = "Cache Faults/sec"; instance = NotApplicable }
  /// Commit Limit: Commit Limit is the amount of virtual memory that can be committed without having to extend the paging file(s).  It is measured in bytes. Committed memory is the physical memory which has space reserved on the disk paging files. There can be one paging file on each logical drive). If the paging file(s) are be expanded, this limit increases accordingly.  This counter displays the last observed value only; it is not an average.
  let ``Commit Limit`` =
    { category = "Memory"; counter = "Commit Limit"; instance = NotApplicable }
  /// Committed Bytes: Committed Bytes is the amount of committed virtual memory, in bytes. Committed memory is the physical memory which has space reserved on the disk paging file(s). There can be one or more paging files on each physical drive. This counter displays the last observed value only; it is not an average.
  let ``Committed Bytes`` =
    { category = "Memory"; counter = "Committed Bytes"; instance = NotApplicable }
  /// Demand Zero Faults/sec: Demand Zero Faults/sec is the rate at which a zeroed page is required to satisfy the fault.  Zeroed pages, pages emptied of previously stored data and filled with zeros, are a security feature of Windows that prevent processes from seeing data stored by earlier processes that used the memory space. Windows maintains a list of zeroed pages to accelerate this process. This counter shows the number of faults, without regard to the number of pages retrieved to satisfy the fault. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Demand Zero Faults/sec`` =
    { category = "Memory"; counter = "Demand Zero Faults/sec"; instance = NotApplicable }
  /// Free & Zero Page List Bytes: Free & Zero Page List Bytes is the amount of physical memory, in bytes, that is assigned to the free and zero page lists. This memory does not contain cached data. It is immediately available for allocation to a process or for system use.
  let ``Free & Zero Page List Bytes`` =
    { category = "Memory"; counter = "Free & Zero Page List Bytes"; instance = NotApplicable }
  /// Free System Page Table Entries: Free System Page Table Entries is the number of page table entries not currently in used by the system.  This counter displays the last observed value only; it is not an average.
  let ``Free System Page Table Entries`` =
    { category = "Memory"; counter = "Free System Page Table Entries"; instance = NotApplicable }
  /// Long-Term Average Standby Cache Lifetime (s): Long-Term Average Standby Cache Lifetime, in seconds. The average lifetime of data in the standby cache over a long interval is measured.
  let ``Long-Term Average Standby Cache Lifetime (s)`` =
    { category = "Memory"; counter = "Long-Term Average Standby Cache Lifetime (s)"; instance = NotApplicable }
  /// Modified Page List Bytes: Modified Page List Bytes is the amount of physical memory, in bytes, that is assigned to the modified page list. This memory contains cached data and code that is not actively in use by processes, the system and the system cache. This memory needs to be written out before it will be available for allocation to a process or for system use.
  let ``Modified Page List Bytes`` =
    { category = "Memory"; counter = "Modified Page List Bytes"; instance = NotApplicable }
  /// Page Faults/sec: Page Faults/sec is the average number of pages faulted per second. It is measured in number of pages faulted per second because only one page is faulted in each fault operation, hence this is also equal to the number of page fault operations. This counter includes both hard faults (those that require disk access) and soft faults (where the faulted page is found elsewhere in physical memory.) Most processors can handle large numbers of soft faults without significant consequence. However, hard faults, which require disk access, can cause significant delays.
  let ``Page Faults/sec`` =
    { category = "Memory"; counter = "Page Faults/sec"; instance = NotApplicable }
  /// Page Reads/sec: Page Reads/sec is the rate at which the disk was read to resolve hard page faults. It shows the number of reads operations, without regard to the number of pages retrieved in each operation. Hard page faults occur when a process references a page in virtual memory that is not in working set or elsewhere in physical memory, and must be retrieved from disk. This counter is a primary indicator of the kinds of faults that cause system-wide delays. It includes read operations to satisfy faults in the file system cache (usually requested by applications) and in non-cached mapped memory files. Compare the value of Memory\\Pages Reads/sec to the value of Memory\\Pages Input/sec to determine the average number of pages read during each operation.
  let ``Page Reads/sec`` =
    { category = "Memory"; counter = "Page Reads/sec"; instance = NotApplicable }
  /// Page Writes/sec: Page Writes/sec is the rate at which pages are written to disk to free up space in physical memory. Pages are written to disk only if they are changed while in physical memory, so they are likely to hold data, not code.  This counter shows write operations, without regard to the number of pages written in each operation.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Page Writes/sec`` =
    { category = "Memory"; counter = "Page Writes/sec"; instance = NotApplicable }
  /// Pages Input/sec: Pages Input/sec is the rate at which pages are read from disk to resolve hard page faults. Hard page faults occur when a process refers to a page in virtual memory that is not in its working set or elsewhere in physical memory, and must be retrieved from disk. When a page is faulted, the system tries to read multiple contiguous pages into memory to maximize the benefit of the read operation. Compare the value of Memory\\Pages Input/sec to the value of  Memory\\Page Reads/sec to determine the average number of pages read into memory during each read operation.
  let ``Pages Input/sec`` =
    { category = "Memory"; counter = "Pages Input/sec"; instance = NotApplicable }
  /// Pages Output/sec: Pages Output/sec is the rate at which pages are written to disk to free up space in physical memory. Pages are written back to disk only if they are changed in physical memory, so they are likely to hold data, not code. A high rate of pages output might indicate a memory shortage. Windows writes more pages back to disk to free up space when physical memory is in short supply.  This counter shows the number of pages, and can be compared to other counts of pages, without conversion.
  let ``Pages Output/sec`` =
    { category = "Memory"; counter = "Pages Output/sec"; instance = NotApplicable }
  /// Pages/sec: Pages/sec is the rate at which pages are read from or written to disk to resolve hard page faults. This counter is a primary indicator of the kinds of faults that cause system-wide delays.  It is the sum of Memory\\Pages Input/sec and Memory\\Pages Output/sec.  It is counted in numbers of pages, so it can be compared to other counts of pages, such as Memory\\Page Faults/sec, without conversion. It includes pages retrieved to satisfy faults in the file system cache (usually requested by applications) non-cached mapped memory files.
  let ``Pages/sec`` =
    { category = "Memory"; counter = "Pages/sec"; instance = NotApplicable }
  /// Pool Nonpaged Allocs: Pool Nonpaged Allocs is the number of calls to allocate space in the nonpaged pool. The nonpaged pool is an area of system memory area for objects that cannot be written to disk, and must remain in physical memory as long as they are allocated.  It is measured in numbers of calls to allocate space, regardless of the amount of space allocated in each call.  This counter displays the last observed value only; it is not an average.
  let ``Pool Nonpaged Allocs`` =
    { category = "Memory"; counter = "Pool Nonpaged Allocs"; instance = NotApplicable }
  /// Pool Nonpaged Bytes: Pool Nonpaged Bytes is the size, in bytes, of the nonpaged pool, an area of the system virtual memory that is used for objects that cannot be written to disk, but must remain in physical memory as long as they are allocated.  Memory\\Pool Nonpaged Bytes is calculated differently than Process\\Pool Nonpaged Bytes, so it might not equal Process(_Total)\\Pool Nonpaged Bytes.  This counter displays the last observed value only; it is not an average.
  let ``Pool Nonpaged Bytes`` =
    { category = "Memory"; counter = "Pool Nonpaged Bytes"; instance = NotApplicable }
  /// Pool Paged Allocs: Pool Paged Allocs is the number of calls to allocate space in the paged pool. The paged pool is an area of the system virtual memory that is used for objects that can be written to disk when they are not being used. It is measured in numbers of calls to allocate space, regardless of the amount of space allocated in each call.  This counter displays the last observed value only; it is not an average.
  let ``Pool Paged Allocs`` =
    { category = "Memory"; counter = "Pool Paged Allocs"; instance = NotApplicable }
  /// Pool Paged Bytes: Pool Paged Bytes is the size, in bytes, of the paged pool, an area of the system virtual memory that is used for objects that can be written to disk when they are not being used.  Memory\\Pool Paged Bytes is calculated differently than Process\\Pool Paged Bytes, so it might not equal Process(_Total)\\Pool Paged Bytes. This counter displays the last observed value only; it is not an average.
  let ``Pool Paged Bytes`` =
    { category = "Memory"; counter = "Pool Paged Bytes"; instance = NotApplicable }
  /// Pool Paged Resident Bytes: Pool Paged Resident Bytes is the size, in bytes, of the portion of the paged pool that is currently resident and active in physical memory. The paged pool is an area of the system virtual memory that is used for objects that can be written to disk when they are not being used. This counter displays the last observed value only; it is not an average.
  let ``Pool Paged Resident Bytes`` =
    { category = "Memory"; counter = "Pool Paged Resident Bytes"; instance = NotApplicable }
  /// Standby Cache Core Bytes: Standby Cache Core Bytes is the amount of physical memory, in bytes, that is assigned to the core standby cache page lists. This memory contains cached data and code that is not actively in use by processes, the system and the system cache. It is immediately available for allocation to a process or for system use. If the system runs out of available free and zero memory, memory on lower priority standby cache page lists will be repurposed before memory on higher priority standby cache page lists.
  let ``Standby Cache Core Bytes`` =
    { category = "Memory"; counter = "Standby Cache Core Bytes"; instance = NotApplicable }
  /// Standby Cache Normal Priority Bytes: Standby Cache Normal Priority Bytes is the amount of physical memory, in bytes, that is assigned to the normal priority standby cache page lists. This memory contains cached data and code that is not actively in use by processes, the system and the system cache. It is immediately available for allocation to a process or for system use. If the system runs out of available free and zero memory, memory on lower priority standby cache page lists will be repurposed before memory on higher priority standby cache page lists.
  let ``Standby Cache Normal Priority Bytes`` =
    { category = "Memory"; counter = "Standby Cache Normal Priority Bytes"; instance = NotApplicable }
  /// Standby Cache Reserve Bytes: Standby Cache Reserve Bytes is the amount of physical memory, in bytes, that is assigned to the reserve standby cache page lists. This memory contains cached data and code that is not actively in use by processes, the system and the system cache. It is immediately available for allocation to a process or for system use. If the system runs out of available free and zero memory, memory on lower priority standby cache page lists will be repurposed before memory on higher priority standby cache page lists.
  let ``Standby Cache Reserve Bytes`` =
    { category = "Memory"; counter = "Standby Cache Reserve Bytes"; instance = NotApplicable }
  /// System Cache Resident Bytes: System Cache Resident Bytes is the size, in bytes, of the portion of the system file cache which is currently resident and active in physical memory. The System Cache Resident Bytes and Memory\\Cache Bytes counters are equivalent.  This counter displays the last observed value only; it is not an average.
  let ``System Cache Resident Bytes`` =
    { category = "Memory"; counter = "System Cache Resident Bytes"; instance = NotApplicable }
  /// System Code Resident Bytes: System Code Resident Bytes is the size, in bytes, of the pageable operating system code that is currently resident and active in physical memory. This value is a component of Memory\\System Code Total Bytes. Memory\\System Code Resident Bytes (and Memory\\System Code Total Bytes) does not include code that must remain in physical memory and cannot be written to disk. This counter displays the last observed value only; it is not an average.
  let ``System Code Resident Bytes`` =
    { category = "Memory"; counter = "System Code Resident Bytes"; instance = NotApplicable }
  /// System Code Total Bytes: System Code Total Bytes is the size, in bytes, of the pageable operating system code currently mapped into the system virtual address space. This value is calculated by summing the bytes in Ntoskrnl.exe, Hal.dll, the boot drivers, and file systems loaded by Ntldr/osloader.  This counter does not include code that must remain in physical memory and cannot be written to disk. This counter displays the last observed value only; it is not an average.
  let ``System Code Total Bytes`` =
    { category = "Memory"; counter = "System Code Total Bytes"; instance = NotApplicable }
  /// System Driver Resident Bytes: System Driver Resident Bytes is the size, in bytes, of the pageable physical memory being used by device drivers. It is the working set (physical memory area) of the drivers. This value is a component of Memory\\System Driver Total Bytes, which also includes driver memory that has been written to disk. Neither Memory\\System Driver Resident Bytes nor Memory\\System Driver Total Bytes includes memory that cannot be written to disk.
  let ``System Driver Resident Bytes`` =
    { category = "Memory"; counter = "System Driver Resident Bytes"; instance = NotApplicable }
  /// System Driver Total Bytes: System Driver Total Bytes is the size, in bytes, of the pageable virtual memory currently being used by device drivers. Pageable memory can be written to disk when it is not being used. It includes both physical memory (Memory\\System Driver Resident Bytes) and code and data paged to disk. It is a component of Memory\\System Code Total Bytes. This counter displays the last observed value only; it is not an average.
  let ``System Driver Total Bytes`` =
    { category = "Memory"; counter = "System Driver Total Bytes"; instance = NotApplicable }
  /// Transition Faults/sec: Transition Faults/sec is the rate at which page faults are resolved by recovering pages that were being used by another process sharing the page, or were on the modified page list or the standby list, or were being written to disk at the time of the page fault. The pages were recovered without additional disk activity. Transition faults are counted in numbers of faults; because only one page is faulted in each operation, it is also equal to the number of pages faulted.
  let ``Transition Faults/sec`` =
    { category = "Memory"; counter = "Transition Faults/sec"; instance = NotApplicable }
  /// Transition Pages RePurposed/sec: Transition Pages RePurposed is the rate at which the number of transition cache pages were reused for a different purpose.  These pages would have otherwise remained in the page cache to provide a (fast) soft fault (instead of retrieving it from backing store) in the event the page was accessed in the future.  Note these pages can contain private or sharable memory.
  let ``Transition Pages RePurposed/sec`` =
    { category = "Memory"; counter = "Transition Pages RePurposed/sec"; instance = NotApplicable }
  /// Write Copies/sec: Write Copies/sec is the rate at which page faults are caused by attempts to write that have been satisfied by coping of the page from elsewhere in physical memory. This is an economical way of sharing data since pages are only copied when they are written to; otherwise, the page is shared. This counter shows the number of copies, without regard for the number of pages copied in each operation.
  let ``Write Copies/sec`` =
    { category = "Memory"; counter = "Write Copies/sec"; instance = NotApplicable }

  let allCounters =
    [ ``% Committed Bytes In Use``
      ``Available Bytes``
      ``Available KBytes``
      ``Available MBytes``
      ``Cache Bytes``
      ``Cache Bytes Peak``
      ``Cache Faults/sec``
      ``Commit Limit``
      ``Committed Bytes``
      ``Demand Zero Faults/sec``
      ``Free & Zero Page List Bytes``
      ``Free System Page Table Entries``
      ``Long-Term Average Standby Cache Lifetime (s)``
      ``Modified Page List Bytes``
      ``Page Faults/sec``
      ``Page Reads/sec``
      ``Page Writes/sec``
      ``Pages Input/sec``
      ``Pages Output/sec``
      ``Pages/sec``
      ``Pool Nonpaged Allocs``
      ``Pool Nonpaged Bytes``
      ``Pool Paged Allocs``
      ``Pool Paged Bytes``
      ``Pool Paged Resident Bytes``
      ``Standby Cache Core Bytes``
      ``Standby Cache Normal Priority Bytes``
      ``Standby Cache Reserve Bytes``
      ``System Cache Resident Bytes``
      ``System Code Resident Bytes``
      ``System Code Total Bytes``
      ``System Driver Resident Bytes``
      ``System Driver Total Bytes``
      ``Transition Faults/sec``
      ``Transition Pages RePurposed/sec``
      ``Write Copies/sec``
    ]

/// Microsoft Winsock BSP: Global performance counters for Microsoft Winsock Base Service Provider
///
/// This performance counter does not have instance based counters
module ``Microsoft Winsock BSP`` =

  [<Literal>]
  let Category = "Microsoft Winsock BSP"

  let PCC = getPCC Category
  /// Dropped Datagrams: Dropped Datagrams due to receive buffer limit on any datagram socket
  let ``Dropped Datagrams`` =
    { category = "Microsoft Winsock BSP"; counter = "Dropped Datagrams"; instance = NotApplicable }
  /// Dropped Datagrams/sec: Dropped Datagrams/sec due to receive buffer limit on any datagram socket
  let ``Dropped Datagrams/sec`` =
    { category = "Microsoft Winsock BSP"; counter = "Dropped Datagrams/sec"; instance = NotApplicable }
  /// Rejected Connections: Rejected Connections due to backlog limit on any TCP listening socket
  let ``Rejected Connections`` =
    { category = "Microsoft Winsock BSP"; counter = "Rejected Connections"; instance = NotApplicable }
  /// Rejected Connections/sec: Rejected Connections/sec due to backlog limit on any TCP listening socket
  let ``Rejected Connections/sec`` =
    { category = "Microsoft Winsock BSP"; counter = "Rejected Connections/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Dropped Datagrams``
      ``Dropped Datagrams/sec``
      ``Rejected Connections``
      ``Rejected Connections/sec``
    ]

/// NBT Connection: The NBT Connection performance object consists of counters that measure the rates at which bytes are sent and received over the NBT connection between the local computer and a remote computer.  The connection is identified by the name of the remote computer.
///
/// This performance counter does not have non-instance based counters
module ``NBT Connection`` =

  [<Literal>]
  let Category = "NBT Connection"

  let PCC = getPCC Category
  /// Bytes Received/sec: Bytes Received/sec is the rate at which bytes are received by the local computer over an NBT connection to some remote computer.  All the bytes received by the local computer over the particular NBT connection are counted.
  let ``Bytes Received/sec`` instance =
    { category = "NBT Connection"; counter = "Bytes Received/sec"; instance = instance }
  /// Bytes Sent/sec: Bytes Sent/sec is the rate at which bytes are sent by the local computer over an NBT connection to some remote computer.  All the bytes sent by the local computer over the particular NBT connection are counted.
  let ``Bytes Sent/sec`` instance =
    { category = "NBT Connection"; counter = "Bytes Sent/sec"; instance = instance }
  /// Bytes Total/sec: Bytes Total/sec is the rate at which bytes are sent or received by the local computer over an NBT connection to some remote computer.  All the bytes sent or received by the local computer over the particular NBT connection are counted.
  let ``Bytes Total/sec`` instance =
    { category = "NBT Connection"; counter = "Bytes Total/sec"; instance = instance }

  let allCounters =
    [ ``Bytes Received/sec``
      ``Bytes Sent/sec``
      ``Bytes Total/sec``
    ]

/// NUMA Node Memory: Counters that report approximate memory utilization statistics per node on NUMA systems.
///
/// This performance counter does not have non-instance based counters
module ``NUMA Node Memory`` =

  [<Literal>]
  let Category = "NUMA Node Memory"

  let PCC = getPCC Category
  /// Available MBytes: Approximate amount of physical memory available for allocation for a NUMA node, in megabytes. Computed as the sum of memory on the zeroed, free, and standby lists for a NUMA node. This counter is available only on 64-bit systems.
  let ``Available MBytes`` instance =
    { category = "NUMA Node Memory"; counter = "Available MBytes"; instance = instance }
  /// Free & Zero Page List MBytes: Approximate amount of physical memory on the free and zero page lists for a NUMA node, in megabytes.
  let ``Free & Zero Page List MBytes`` instance =
    { category = "NUMA Node Memory"; counter = "Free & Zero Page List MBytes"; instance = instance }
  /// Standby List MBytes: Approximate amount of physical memory on the standby page list for a NUMA node, in megabytes. This counter is available only on 64-bit systems.
  let ``Standby List MBytes`` instance =
    { category = "NUMA Node Memory"; counter = "Standby List MBytes"; instance = instance }
  /// Total MBytes: Total amount of physical memory associated with a NUMA node in megabytes.
  let ``Total MBytes`` instance =
    { category = "NUMA Node Memory"; counter = "Total MBytes"; instance = instance }

  let allCounters =
    [ ``Available MBytes``
      ``Free & Zero Page List MBytes``
      ``Standby List MBytes``
      ``Total MBytes``
    ]

/// Netlogon: Counters for measuring the performance of Netlogon.
///
/// This performance counter does not have non-instance based counters
module ``Netlogon`` =

  [<Literal>]
  let Category = "Netlogon"

  let PCC = getPCC Category
  /// Average Semaphore Hold Time: The average amount of time the semaphore is held over the last sample.
  let ``Average Semaphore Hold Time`` instance =
    { category = "Netlogon"; counter = "Average Semaphore Hold Time"; instance = instance }
  /// Semaphore Acquires: The total number of times the semaphore has been acquired over the lifetime of the Secure Channel connection (or since system boot for _Total).
  let ``Semaphore Acquires`` instance =
    { category = "Netlogon"; counter = "Semaphore Acquires"; instance = instance }
  /// Semaphore Holders: Number of thread currently holding the semaphore.
  let ``Semaphore Holders`` instance =
    { category = "Netlogon"; counter = "Semaphore Holders"; instance = instance }
  /// Semaphore Timeouts: The total number of times a thread has timed out waiting for the semaphore over the lifetime of the Secure Channel connection (or since system boot for _Total).
  let ``Semaphore Timeouts`` instance =
    { category = "Netlogon"; counter = "Semaphore Timeouts"; instance = instance }
  /// Semaphore Waiters: Number of thread currently waiting to acquire the semaphore.
  let ``Semaphore Waiters`` instance =
    { category = "Netlogon"; counter = "Semaphore Waiters"; instance = instance }

  let allCounters =
    [ ``Average Semaphore Hold Time``
      ``Semaphore Acquires``
      ``Semaphore Holders``
      ``Semaphore Timeouts``
      ``Semaphore Waiters``
    ]

/// Network Adapter: The Network Adapter performance object consists of counters that measure the rates at which bytes and packets are sent and received over a physical or virtual network connection.  It includes counters that monitor connection errors.
///
/// This performance counter does not have non-instance based counters
module ``Network Adapter`` =

  [<Literal>]
  let Category = "Network Adapter"

  let PCC = getPCC Category
  /// Bytes Received/sec: Bytes Received/sec is the rate at which bytes are received over each network adapter, including framing characters. Network Interface\Bytes Received/sec is a subset of Network Interface\Bytes Total/sec.
  let ``Bytes Received/sec`` instance =
    { category = "Network Adapter"; counter = "Bytes Received/sec"; instance = instance }
  /// Bytes Sent/sec: Bytes Sent/sec is the rate at which bytes are sent over each network adapter, including framing characters. Network Interface\Bytes Sent/sec is a subset of Network Interface\Bytes Total/sec.
  let ``Bytes Sent/sec`` instance =
    { category = "Network Adapter"; counter = "Bytes Sent/sec"; instance = instance }
  /// Bytes Total/sec: Bytes Total/sec is the rate at which bytes are sent and received over each network adapter, including framing characters. Network Interface\Bytes Total/sec is a sum of Network Interface\Bytes Received/sec and Network Interface\Bytes Sent/sec.
  let ``Bytes Total/sec`` instance =
    { category = "Network Adapter"; counter = "Bytes Total/sec"; instance = instance }
  /// Current Bandwidth: Current Bandwidth is an estimate of the current bandwidth of the network interface in bits per second (BPS).  For interfaces that do not vary in bandwidth or for those where no accurate estimation can be made, this value is the nominal bandwidth.
  let ``Current Bandwidth`` instance =
    { category = "Network Adapter"; counter = "Current Bandwidth"; instance = instance }
  /// Offloaded Connections: Offloaded Connections is the number of TCP connections (over both IPv4 and IPv6) that are currently handled by the TCP chimney offload capable network adapter.
  let ``Offloaded Connections`` instance =
    { category = "Network Adapter"; counter = "Offloaded Connections"; instance = instance }
  /// Output Queue Length: Output Queue Length is the length of the output packet queue (in packets). If this is longer than two, there are delays and the bottleneck should be found and eliminated, if possible. Since the requests are queued by the Network Driver Interface Specification (NDIS) in this implementation, this will always be 0.
  let ``Output Queue Length`` instance =
    { category = "Network Adapter"; counter = "Output Queue Length"; instance = instance }
  /// Packets Outbound Discarded: Packets Outbound Discarded is the number of outbound packets that were chosen to be discarded even though no errors had been detected to prevent transmission. One possible reason for discarding packets could be to free up buffer space.
  let ``Packets Outbound Discarded`` instance =
    { category = "Network Adapter"; counter = "Packets Outbound Discarded"; instance = instance }
  /// Packets Outbound Errors: Packets Outbound Errors is the number of outbound packets that could not be transmitted because of errors.
  let ``Packets Outbound Errors`` instance =
    { category = "Network Adapter"; counter = "Packets Outbound Errors"; instance = instance }
  /// Packets Received Discarded: Packets Received Discarded is the number of inbound packets that were chosen to be discarded even though no errors had been detected to prevent their delivery to a higher-layer protocol.  One possible reason for discarding packets could be to free up buffer space.
  let ``Packets Received Discarded`` instance =
    { category = "Network Adapter"; counter = "Packets Received Discarded"; instance = instance }
  /// Packets Received Errors: Packets Received Errors is the number of inbound packets that contained errors preventing them from being deliverable to a higher-layer protocol.
  let ``Packets Received Errors`` instance =
    { category = "Network Adapter"; counter = "Packets Received Errors"; instance = instance }
  /// Packets Received Non-Unicast/sec: Packets Received Non-Unicast/sec is the rate at which non-unicast (subnet broadcast or subnet multicast) packets are delivered to a higher-layer protocol.
  let ``Packets Received Non-Unicast/sec`` instance =
    { category = "Network Adapter"; counter = "Packets Received Non-Unicast/sec"; instance = instance }
  /// Packets Received Unicast/sec: Packets Received Unicast/sec is the rate at which (subnet) unicast packets are delivered to a higher-layer protocol.
  let ``Packets Received Unicast/sec`` instance =
    { category = "Network Adapter"; counter = "Packets Received Unicast/sec"; instance = instance }
  /// Packets Received Unknown: Packets Received Unknown is the number of packets received through the interface that were discarded because of an unknown or unsupported protocol.
  let ``Packets Received Unknown`` instance =
    { category = "Network Adapter"; counter = "Packets Received Unknown"; instance = instance }
  /// Packets Received/sec: Packets Received/sec is the rate at which packets are received on the network interface.
  let ``Packets Received/sec`` instance =
    { category = "Network Adapter"; counter = "Packets Received/sec"; instance = instance }
  /// Packets Sent Non-Unicast/sec: Packets Sent Non-Unicast/sec is the rate at which packets are requested to be transmitted to non-unicast (subnet broadcast or subnet multicast) addresses by higher-level protocols.  The rate includes the packets that were discarded or not sent.
  let ``Packets Sent Non-Unicast/sec`` instance =
    { category = "Network Adapter"; counter = "Packets Sent Non-Unicast/sec"; instance = instance }
  /// Packets Sent Unicast/sec: Packets Sent Unicast/sec is the rate at which packets are requested to be transmitted to subnet-unicast addresses by higher-level protocols.  The rate includes the packets that were discarded or not sent.
  let ``Packets Sent Unicast/sec`` instance =
    { category = "Network Adapter"; counter = "Packets Sent Unicast/sec"; instance = instance }
  /// Packets Sent/sec: Packets Sent/sec is the rate at which packets are sent on the network interface.
  let ``Packets Sent/sec`` instance =
    { category = "Network Adapter"; counter = "Packets Sent/sec"; instance = instance }
  /// Packets/sec: Packets/sec is the rate at which packets are sent and received on the network interface.
  let ``Packets/sec`` instance =
    { category = "Network Adapter"; counter = "Packets/sec"; instance = instance }
  /// TCP Active RSC Connections: TCP Active RSC Connections is the number of TCP connections (over both IPv4 and IPv6) that are currently receiving large packets from the RSC capable network adapter on this network interface.
  let ``TCP Active RSC Connections`` instance =
    { category = "Network Adapter"; counter = "TCP Active RSC Connections"; instance = instance }
  /// TCP RSC Average Packet Size: TCP RSC Average Packet Size is the average size in bytes of received packets across all TCP connections on this network interface.
  let ``TCP RSC Average Packet Size`` instance =
    { category = "Network Adapter"; counter = "TCP RSC Average Packet Size"; instance = instance }
  /// TCP RSC Coalesced Packets/sec: TCP RSC Coalesced Packets/sec shows the large packet receive rate across all TCP connections on this network interface.
  let ``TCP RSC Coalesced Packets/sec`` instance =
    { category = "Network Adapter"; counter = "TCP RSC Coalesced Packets/sec"; instance = instance }
  /// TCP RSC Exceptions/sec: TCP RSC Exceptions/sec shows the RSC exception rate for receive packets across all TCP connections on this network interface.
  let ``TCP RSC Exceptions/sec`` instance =
    { category = "Network Adapter"; counter = "TCP RSC Exceptions/sec"; instance = instance }

  let allCounters =
    [ ``Bytes Received/sec``
      ``Bytes Sent/sec``
      ``Bytes Total/sec``
      ``Current Bandwidth``
      ``Offloaded Connections``
      ``Output Queue Length``
      ``Packets Outbound Discarded``
      ``Packets Outbound Errors``
      ``Packets Received Discarded``
      ``Packets Received Errors``
      ``Packets Received Non-Unicast/sec``
      ``Packets Received Unicast/sec``
      ``Packets Received Unknown``
      ``Packets Received/sec``
      ``Packets Sent Non-Unicast/sec``
      ``Packets Sent Unicast/sec``
      ``Packets Sent/sec``
      ``Packets/sec``
      ``TCP Active RSC Connections``
      ``TCP RSC Average Packet Size``
      ``TCP RSC Coalesced Packets/sec``
      ``TCP RSC Exceptions/sec``
    ]

/// Network Interface: The Network Interface performance object consists of counters that measure the rates at which bytes and packets are sent and received over a network connection.  It includes counters that monitor connection errors.
///
/// This performance counter does not have non-instance based counters
module ``Network Interface`` =

  [<Literal>]
  let Category = "Network Interface"

  let PCC = getPCC Category
  /// Bytes Received/sec: Bytes Received/sec is the rate at which bytes are received over each network adapter, including framing characters. Network Interface\Bytes Received/sec is a subset of Network Interface\Bytes Total/sec.
  let ``Bytes Received/sec`` instance =
    { category = "Network Interface"; counter = "Bytes Received/sec"; instance = instance }
  /// Bytes Sent/sec: Bytes Sent/sec is the rate at which bytes are sent over each network adapter, including framing characters. Network Interface\Bytes Sent/sec is a subset of Network Interface\Bytes Total/sec.
  let ``Bytes Sent/sec`` instance =
    { category = "Network Interface"; counter = "Bytes Sent/sec"; instance = instance }
  /// Bytes Total/sec: Bytes Total/sec is the rate at which bytes are sent and received over each network adapter, including framing characters. Network Interface\Bytes Total/sec is a sum of Network Interface\Bytes Received/sec and Network Interface\Bytes Sent/sec.
  let ``Bytes Total/sec`` instance =
    { category = "Network Interface"; counter = "Bytes Total/sec"; instance = instance }
  /// Current Bandwidth: Current Bandwidth is an estimate of the current bandwidth of the network interface in bits per second (BPS).  For interfaces that do not vary in bandwidth or for those where no accurate estimation can be made, this value is the nominal bandwidth.
  let ``Current Bandwidth`` instance =
    { category = "Network Interface"; counter = "Current Bandwidth"; instance = instance }
  /// Offloaded Connections: Offloaded Connections is the number of TCP connections (over both IPv4 and IPv6) that are currently handled by the TCP chimney offload capable network adapter.
  let ``Offloaded Connections`` instance =
    { category = "Network Interface"; counter = "Offloaded Connections"; instance = instance }
  /// Output Queue Length: Output Queue Length is the length of the output packet queue (in packets). If this is longer than two, there are delays and the bottleneck should be found and eliminated, if possible. Since the requests are queued by the Network Driver Interface Specification (NDIS) in this implementation, this will always be 0.
  let ``Output Queue Length`` instance =
    { category = "Network Interface"; counter = "Output Queue Length"; instance = instance }
  /// Packets Outbound Discarded: Packets Outbound Discarded is the number of outbound packets that were chosen to be discarded even though no errors had been detected to prevent transmission. One possible reason for discarding packets could be to free up buffer space.
  let ``Packets Outbound Discarded`` instance =
    { category = "Network Interface"; counter = "Packets Outbound Discarded"; instance = instance }
  /// Packets Outbound Errors: Packets Outbound Errors is the number of outbound packets that could not be transmitted because of errors.
  let ``Packets Outbound Errors`` instance =
    { category = "Network Interface"; counter = "Packets Outbound Errors"; instance = instance }
  /// Packets Received Discarded: Packets Received Discarded is the number of inbound packets that were chosen to be discarded even though no errors had been detected to prevent their delivery to a higher-layer protocol.  One possible reason for discarding packets could be to free up buffer space.
  let ``Packets Received Discarded`` instance =
    { category = "Network Interface"; counter = "Packets Received Discarded"; instance = instance }
  /// Packets Received Errors: Packets Received Errors is the number of inbound packets that contained errors preventing them from being deliverable to a higher-layer protocol.
  let ``Packets Received Errors`` instance =
    { category = "Network Interface"; counter = "Packets Received Errors"; instance = instance }
  /// Packets Received Non-Unicast/sec: Packets Received Non-Unicast/sec is the rate at which non-unicast (subnet broadcast or subnet multicast) packets are delivered to a higher-layer protocol.
  let ``Packets Received Non-Unicast/sec`` instance =
    { category = "Network Interface"; counter = "Packets Received Non-Unicast/sec"; instance = instance }
  /// Packets Received Unicast/sec: Packets Received Unicast/sec is the rate at which (subnet) unicast packets are delivered to a higher-layer protocol.
  let ``Packets Received Unicast/sec`` instance =
    { category = "Network Interface"; counter = "Packets Received Unicast/sec"; instance = instance }
  /// Packets Received Unknown: Packets Received Unknown is the number of packets received through the interface that were discarded because of an unknown or unsupported protocol.
  let ``Packets Received Unknown`` instance =
    { category = "Network Interface"; counter = "Packets Received Unknown"; instance = instance }
  /// Packets Received/sec: Packets Received/sec is the rate at which packets are received on the network interface.
  let ``Packets Received/sec`` instance =
    { category = "Network Interface"; counter = "Packets Received/sec"; instance = instance }
  /// Packets Sent Non-Unicast/sec: Packets Sent Non-Unicast/sec is the rate at which packets are requested to be transmitted to non-unicast (subnet broadcast or subnet multicast) addresses by higher-level protocols.  The rate includes the packets that were discarded or not sent.
  let ``Packets Sent Non-Unicast/sec`` instance =
    { category = "Network Interface"; counter = "Packets Sent Non-Unicast/sec"; instance = instance }
  /// Packets Sent Unicast/sec: Packets Sent Unicast/sec is the rate at which packets are requested to be transmitted to subnet-unicast addresses by higher-level protocols.  The rate includes the packets that were discarded or not sent.
  let ``Packets Sent Unicast/sec`` instance =
    { category = "Network Interface"; counter = "Packets Sent Unicast/sec"; instance = instance }
  /// Packets Sent/sec: Packets Sent/sec is the rate at which packets are sent on the network interface.
  let ``Packets Sent/sec`` instance =
    { category = "Network Interface"; counter = "Packets Sent/sec"; instance = instance }
  /// Packets/sec: Packets/sec is the rate at which packets are sent and received on the network interface.
  let ``Packets/sec`` instance =
    { category = "Network Interface"; counter = "Packets/sec"; instance = instance }
  /// TCP Active RSC Connections: TCP Active RSC Connections is the number of TCP connections (over both IPv4 and IPv6) that are currently receiving large packets from the RSC capable network adapter on this network interface.
  let ``TCP Active RSC Connections`` instance =
    { category = "Network Interface"; counter = "TCP Active RSC Connections"; instance = instance }
  /// TCP RSC Average Packet Size: TCP RSC Average Packet Size is the average size in bytes of received packets across all TCP connections on this network interface.
  let ``TCP RSC Average Packet Size`` instance =
    { category = "Network Interface"; counter = "TCP RSC Average Packet Size"; instance = instance }
  /// TCP RSC Coalesced Packets/sec: TCP RSC Coalesced Packets/sec shows the large packet receive rate across all TCP connections on this network interface.
  let ``TCP RSC Coalesced Packets/sec`` instance =
    { category = "Network Interface"; counter = "TCP RSC Coalesced Packets/sec"; instance = instance }
  /// TCP RSC Exceptions/sec: TCP RSC Exceptions/sec shows the RSC exception rate for receive packets across all TCP connections on this network interface.
  let ``TCP RSC Exceptions/sec`` instance =
    { category = "Network Interface"; counter = "TCP RSC Exceptions/sec"; instance = instance }

  let allCounters =
    [ ``Bytes Received/sec``
      ``Bytes Sent/sec``
      ``Bytes Total/sec``
      ``Current Bandwidth``
      ``Offloaded Connections``
      ``Output Queue Length``
      ``Packets Outbound Discarded``
      ``Packets Outbound Errors``
      ``Packets Received Discarded``
      ``Packets Received Errors``
      ``Packets Received Non-Unicast/sec``
      ``Packets Received Unicast/sec``
      ``Packets Received Unknown``
      ``Packets Received/sec``
      ``Packets Sent Non-Unicast/sec``
      ``Packets Sent Unicast/sec``
      ``Packets Sent/sec``
      ``Packets/sec``
      ``TCP Active RSC Connections``
      ``TCP RSC Average Packet Size``
      ``TCP RSC Coalesced Packets/sec``
      ``TCP RSC Exceptions/sec``
    ]

/// Network QoS Policy: This counter set consists of flow statistics specific to a network QoS policy.
///
/// This performance counter does not have instance based counters
module ``Network QoS Policy`` =

  [<Literal>]
  let Category = "Network QoS Policy"

  let PCC = getPCC Category
  /// Bytes transmitted: -
  let ``Bytes transmitted`` instance =
    { category = "Network QoS Policy"; counter = "Bytes transmitted"; instance = instance }
  /// Bytes transmitted/sec: -
  let ``Bytes transmitted/sec`` instance =
    { category = "Network QoS Policy"; counter = "Bytes transmitted/sec"; instance = instance }
  /// Packets dropped: -
  let ``Packets dropped`` instance =
    { category = "Network QoS Policy"; counter = "Packets dropped"; instance = instance }
  /// Packets dropped/sec: -
  let ``Packets dropped/sec`` instance =
    { category = "Network QoS Policy"; counter = "Packets dropped/sec"; instance = instance }
  /// Packets transmitted: -
  let ``Packets transmitted`` instance =
    { category = "Network QoS Policy"; counter = "Packets transmitted"; instance = instance }
  /// Packets transmitted/sec: -
  let ``Packets transmitted/sec`` instance =
    { category = "Network QoS Policy"; counter = "Packets transmitted/sec"; instance = instance }

  let allCounters =
    [ ``Bytes transmitted``
      ``Bytes transmitted/sec``
      ``Packets dropped``
      ``Packets dropped/sec``
      ``Packets transmitted``
      ``Packets transmitted/sec``
    ]

/// Network Virtualization: Network Virtualization counter set measures network activity for packets matching network virtualization policies.
///
/// This performance counter does not have non-instance based counters
module ``Network Virtualization`` =

  [<Literal>]
  let Category = "Network Virtualization"

  let PCC = getPCC Category
  /// Broadcast packets received: Number of broadcast packets received.
  let ``Broadcast packets received`` instance =
    { category = "Network Virtualization"; counter = "Broadcast packets received"; instance = instance }
  /// Broadcast packets sent: Number of broadcast packets sent.
  let ``Broadcast packets sent`` instance =
    { category = "Network Virtualization"; counter = "Broadcast packets sent"; instance = instance }
  /// Inbound Packets dropped: Number of Inbound packets dropped.
  let ``Inbound Packets dropped`` instance =
    { category = "Network Virtualization"; counter = "Inbound Packets dropped"; instance = instance }
  /// Missing policy icmp errors received: Number of missing policy ICMP errors received.
  let ``Missing policy icmp errors received`` instance =
    { category = "Network Virtualization"; counter = "Missing policy icmp errors received"; instance = instance }
  /// Missing policy icmp errors sent: Number of missing policy ICMP errors sent.
  let ``Missing policy icmp errors sent`` instance =
    { category = "Network Virtualization"; counter = "Missing policy icmp errors sent"; instance = instance }
  /// Missing policy notifications dropped: Number of missing policy notifications dropped.
  let ``Missing policy notifications dropped`` instance =
    { category = "Network Virtualization"; counter = "Missing policy notifications dropped"; instance = instance }
  /// Missing policy notifications indicated: Number of missing policy notifications indicated.
  let ``Missing policy notifications indicated`` instance =
    { category = "Network Virtualization"; counter = "Missing policy notifications indicated"; instance = instance }
  /// Multicast packets received: Number of multicast packets received.
  let ``Multicast packets received`` instance =
    { category = "Network Virtualization"; counter = "Multicast packets received"; instance = instance }
  /// Multicast packets sent: Number of multicast packets sent.
  let ``Multicast packets sent`` instance =
    { category = "Network Virtualization"; counter = "Multicast packets sent"; instance = instance }
  /// Outbound Packets dropped: Number of outbound packets dropped.
  let ``Outbound Packets dropped`` instance =
    { category = "Network Virtualization"; counter = "Outbound Packets dropped"; instance = instance }
  /// Packets buffered: Number of packets buffered waiting for missing lookup records.
  let ``Packets buffered`` instance =
    { category = "Network Virtualization"; counter = "Packets buffered"; instance = instance }
  /// Packets forwarded: Number of packets forwarded between virtual subnets on different hosts.
  let ``Packets forwarded`` instance =
    { category = "Network Virtualization"; counter = "Packets forwarded"; instance = instance }
  /// Packets looped back: Number of packets forwarded between virtual subnets on the local host.
  let ``Packets looped back`` instance =
    { category = "Network Virtualization"; counter = "Packets looped back"; instance = instance }
  /// Policy cache hits: Number of cache hits during policy lookup.
  let ``Policy cache hits`` instance =
    { category = "Network Virtualization"; counter = "Policy cache hits"; instance = instance }
  /// Policy cache misses: Number of cache misses during policy lookup.
  let ``Policy cache misses`` instance =
    { category = "Network Virtualization"; counter = "Policy cache misses"; instance = instance }
  /// Policy lookup failures: Number of failures during policy lookup.
  let ``Policy lookup failures`` instance =
    { category = "Network Virtualization"; counter = "Policy lookup failures"; instance = instance }
  /// Provider address duplicate detection failures: Number of provider address duplicate detection failures.
  let ``Provider address duplicate detection failures`` instance =
    { category = "Network Virtualization"; counter = "Provider address duplicate detection failures"; instance = instance }
  /// Unicast Replicated Packets out: Number of Unicast Replicated packets sent.
  let ``Unicast Replicated Packets out`` instance =
    { category = "Network Virtualization"; counter = "Unicast Replicated Packets out"; instance = instance }
  /// Unicast packets received (GRE): Number of unicast packets received with GRE encapsulation.
  let ``Unicast packets received (GRE)`` instance =
    { category = "Network Virtualization"; counter = "Unicast packets received (GRE)"; instance = instance }
  /// Unicast packets sent (GRE): Number of unicast packets sent with GRE encapsulation.
  let ``Unicast packets sent (GRE)`` instance =
    { category = "Network Virtualization"; counter = "Unicast packets sent (GRE)"; instance = instance }

  let allCounters =
    [ ``Broadcast packets received``
      ``Broadcast packets sent``
      ``Inbound Packets dropped``
      ``Missing policy icmp errors received``
      ``Missing policy icmp errors sent``
      ``Missing policy notifications dropped``
      ``Missing policy notifications indicated``
      ``Multicast packets received``
      ``Multicast packets sent``
      ``Outbound Packets dropped``
      ``Packets buffered``
      ``Packets forwarded``
      ``Packets looped back``
      ``Policy cache hits``
      ``Policy cache misses``
      ``Policy lookup failures``
      ``Provider address duplicate detection failures``
      ``Unicast Replicated Packets out``
      ``Unicast packets received (GRE)``
      ``Unicast packets sent (GRE)``
    ]

/// Node.js: Node.js performance counters
///
/// This performance counter does not have instance based counters
module ``Node_js`` =

  [<Literal>]
  let Category = "Node.js"

  let PCC = getPCC Category
  /// %Time in GC: -
  let ``%Time in GC`` instance =
    { category = "Node.js"; counter = "%Time in GC"; instance = instance }
  /// Active server connections: -
  let ``Active server connections`` instance =
    { category = "Node.js"; counter = "Active server connections"; instance = instance }
  /// HTTP client requests: -
  let ``HTTP client requests`` instance =
    { category = "Node.js"; counter = "HTTP client requests"; instance = instance }
  /// HTTP client responses: -
  let ``HTTP client responses`` instance =
    { category = "Node.js"; counter = "HTTP client responses"; instance = instance }
  /// HTTP server requests: -
  let ``HTTP server requests`` instance =
    { category = "Node.js"; counter = "HTTP server requests"; instance = instance }
  /// HTTP server responses: -
  let ``HTTP server responses`` instance =
    { category = "Node.js"; counter = "HTTP server responses"; instance = instance }
  /// Network bytes received: -
  let ``Network bytes received`` instance =
    { category = "Node.js"; counter = "Network bytes received"; instance = instance }
  /// Network bytes sent: -
  let ``Network bytes sent`` instance =
    { category = "Node.js"; counter = "Network bytes sent"; instance = instance }
  /// Pipe bytes received: -
  let ``Pipe bytes received`` instance =
    { category = "Node.js"; counter = "Pipe bytes received"; instance = instance }
  /// Pipe bytes sent: -
  let ``Pipe bytes sent`` instance =
    { category = "Node.js"; counter = "Pipe bytes sent"; instance = instance }

  let allCounters =
    [ ``%Time in GC``
      ``Active server connections``
      ``HTTP client requests``
      ``HTTP client responses``
      ``HTTP server requests``
      ``HTTP server responses``
      ``Network bytes received``
      ``Network bytes sent``
      ``Pipe bytes received``
      ``Pipe bytes sent``
    ]

/// Objects: The Object performance object consists of counters that monitor  logical objects in the system, such as processes, threads, mutexes, and semaphores.  This information can be used to detect the unnecessary consumption of computer resources.  Each object requires memory to store basic information about the object.
///
/// This performance counter does not have instance based counters
module ``Objects`` =

  [<Literal>]
  let Category = "Objects"

  let PCC = getPCC Category
  /// Events: Events is the number of events in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  An event is used when two or more threads try to synchronize execution.
  let ``Events`` =
    { category = "Objects"; counter = "Events"; instance = NotApplicable }
  /// Mutexes: Mutexes counts the number of mutexes in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  Mutexes are used by threads to assure only one thread is executing a particular section of code.
  let ``Mutexes`` =
    { category = "Objects"; counter = "Mutexes"; instance = NotApplicable }
  /// Processes: Processes is the number of processes in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  Each process represents the running of a program.
  let ``Processes`` =
    { category = "Objects"; counter = "Processes"; instance = NotApplicable }
  /// Sections: Sections is the number of sections in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  A section is a portion of virtual memory created by a process for storing data. A process can share sections with other processes.
  let ``Sections`` =
    { category = "Objects"; counter = "Sections"; instance = NotApplicable }
  /// Semaphores: Semaphores is the number of semaphores in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  Threads use semaphores to obtain exclusive access to data structures that they share with other threads.
  let ``Semaphores`` =
    { category = "Objects"; counter = "Semaphores"; instance = NotApplicable }
  /// Threads: Threads is the number of threads in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  A thread is the basic executable entity that can execute instructions in a processor.
  let ``Threads`` =
    { category = "Objects"; counter = "Threads"; instance = NotApplicable }

  let allCounters =
    [ ``Events``
      ``Mutexes``
      ``Processes``
      ``Sections``
      ``Semaphores``
      ``Threads``
    ]

/// Offline Files: Performance counters for Offline Files
///
/// This performance counter does not have instance based counters
module ``Offline Files`` =

  [<Literal>]
  let Category = "Offline Files"

  let PCC = getPCC Category
  /// Bytes Received: Bytes synchronized from server to client
  let ``Bytes Received`` =
    { category = "Offline Files"; counter = "Bytes Received"; instance = NotApplicable }
  /// Bytes Received/sec: Bytes synchronized per second, server to client
  let ``Bytes Received/sec`` =
    { category = "Offline Files"; counter = "Bytes Received/sec"; instance = NotApplicable }
  /// Bytes Transmitted: Bytes synchronized from client to server
  let ``Bytes Transmitted`` =
    { category = "Offline Files"; counter = "Bytes Transmitted"; instance = NotApplicable }
  /// Bytes Transmitted/sec: Bytes synchronized per second, client to server
  let ``Bytes Transmitted/sec`` =
    { category = "Offline Files"; counter = "Bytes Transmitted/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Bytes Received``
      ``Bytes Received/sec``
      ``Bytes Transmitted``
      ``Bytes Transmitted/sec``
    ]

/// Pacer Flow: The Pacer Flow performance counter set consists of flow statistics from the packet scheduler.
///
/// This performance counter does not have instance based counters
module ``Pacer Flow`` =

  [<Literal>]
  let Category = "Pacer Flow"

  let PCC = getPCC Category
  /// Average packets in netcard: -
  let ``Average packets in netcard`` instance =
    { category = "Pacer Flow"; counter = "Average packets in netcard"; instance = instance }
  /// Average packets in sequencer: -
  let ``Average packets in sequencer`` instance =
    { category = "Pacer Flow"; counter = "Average packets in sequencer"; instance = instance }
  /// Average packets in shaper: -
  let ``Average packets in shaper`` instance =
    { category = "Pacer Flow"; counter = "Average packets in shaper"; instance = instance }
  /// Bytes scheduled: -
  let ``Bytes scheduled`` instance =
    { category = "Pacer Flow"; counter = "Bytes scheduled"; instance = instance }
  /// Bytes scheduled/sec: -
  let ``Bytes scheduled/sec`` instance =
    { category = "Pacer Flow"; counter = "Bytes scheduled/sec"; instance = instance }
  /// Bytes transmitted: -
  let ``Bytes transmitted`` instance =
    { category = "Pacer Flow"; counter = "Bytes transmitted"; instance = instance }
  /// Bytes transmitted/sec: -
  let ``Bytes transmitted/sec`` instance =
    { category = "Pacer Flow"; counter = "Bytes transmitted/sec"; instance = instance }
  /// Max packets in sequencer: -
  let ``Max packets in sequencer`` instance =
    { category = "Pacer Flow"; counter = "Max packets in sequencer"; instance = instance }
  /// Max packets in shaper: -
  let ``Max packets in shaper`` instance =
    { category = "Pacer Flow"; counter = "Max packets in shaper"; instance = instance }
  /// Maximum packets in netcard: -
  let ``Maximum packets in netcard`` instance =
    { category = "Pacer Flow"; counter = "Maximum packets in netcard"; instance = instance }
  /// Nonconforming packets scheduled: -
  let ``Nonconforming packets scheduled`` instance =
    { category = "Pacer Flow"; counter = "Nonconforming packets scheduled"; instance = instance }
  /// Nonconforming packets scheduled/sec: -
  let ``Nonconforming packets scheduled/sec`` instance =
    { category = "Pacer Flow"; counter = "Nonconforming packets scheduled/sec"; instance = instance }
  /// Nonconforming packets transmitted: -
  let ``Nonconforming packets transmitted`` instance =
    { category = "Pacer Flow"; counter = "Nonconforming packets transmitted"; instance = instance }
  /// Nonconforming packets transmitted/sec: -
  let ``Nonconforming packets transmitted/sec`` instance =
    { category = "Pacer Flow"; counter = "Nonconforming packets transmitted/sec"; instance = instance }
  /// Packets dropped: -
  let ``Packets dropped`` instance =
    { category = "Pacer Flow"; counter = "Packets dropped"; instance = instance }
  /// Packets dropped/sec: -
  let ``Packets dropped/sec`` instance =
    { category = "Pacer Flow"; counter = "Packets dropped/sec"; instance = instance }
  /// Packets scheduled: -
  let ``Packets scheduled`` instance =
    { category = "Pacer Flow"; counter = "Packets scheduled"; instance = instance }
  /// Packets scheduled/sec: -
  let ``Packets scheduled/sec`` instance =
    { category = "Pacer Flow"; counter = "Packets scheduled/sec"; instance = instance }
  /// Packets transmitted: -
  let ``Packets transmitted`` instance =
    { category = "Pacer Flow"; counter = "Packets transmitted"; instance = instance }
  /// Packets transmitted/sec: -
  let ``Packets transmitted/sec`` instance =
    { category = "Pacer Flow"; counter = "Packets transmitted/sec"; instance = instance }

  let allCounters =
    [ ``Average packets in netcard``
      ``Average packets in sequencer``
      ``Average packets in shaper``
      ``Bytes scheduled``
      ``Bytes scheduled/sec``
      ``Bytes transmitted``
      ``Bytes transmitted/sec``
      ``Max packets in sequencer``
      ``Max packets in shaper``
      ``Maximum packets in netcard``
      ``Nonconforming packets scheduled``
      ``Nonconforming packets scheduled/sec``
      ``Nonconforming packets transmitted``
      ``Nonconforming packets transmitted/sec``
      ``Packets dropped``
      ``Packets dropped/sec``
      ``Packets scheduled``
      ``Packets scheduled/sec``
      ``Packets transmitted``
      ``Packets transmitted/sec``
    ]

/// Pacer Pipe: The Pacer Pipe performance counter set consists of pipe statistics from the packet scheduler.
///
/// This performance counter does not have non-instance based counters
module ``Pacer Pipe`` =

  [<Literal>]
  let Category = "Pacer Pipe"

  let PCC = getPCC Category
  /// Average packets in netcard: The average number of packets in the network card over the last sampling period.
  let ``Average packets in netcard`` instance =
    { category = "Pacer Pipe"; counter = "Average packets in netcard"; instance = instance }
  /// Average packets in sequencer: The average number of packets in the sequencer over the last sampling period.
  let ``Average packets in sequencer`` instance =
    { category = "Pacer Pipe"; counter = "Average packets in sequencer"; instance = instance }
  /// Average packets in shaper: The average number of packets in the shaper over the last sampling period.
  let ``Average packets in shaper`` instance =
    { category = "Pacer Pipe"; counter = "Average packets in shaper"; instance = instance }
  /// Flow mods rejected: The number of times a flow modification has been rejected.
  let ``Flow mods rejected`` instance =
    { category = "Pacer Pipe"; counter = "Flow mods rejected"; instance = instance }
  /// Flows closed: The number of flows that have been closed.
  let ``Flows closed`` instance =
    { category = "Pacer Pipe"; counter = "Flows closed"; instance = instance }
  /// Flows modified: The number of times a flow has been modified.
  let ``Flows modified`` instance =
    { category = "Pacer Pipe"; counter = "Flows modified"; instance = instance }
  /// Flows opened: The number of flows opened on this pipe (some of which may now be closed).
  let ``Flows opened`` instance =
    { category = "Pacer Pipe"; counter = "Flows opened"; instance = instance }
  /// Flows rejected: The number of flow creations that were rejected.
  let ``Flows rejected`` instance =
    { category = "Pacer Pipe"; counter = "Flows rejected"; instance = instance }
  /// Max packets in netcard: The maximum number of packets ever simultaneously in the network card.
  let ``Max packets in netcard`` instance =
    { category = "Pacer Pipe"; counter = "Max packets in netcard"; instance = instance }
  /// Max packets in sequencer: The maximum number of packets that have ever simultaneously been in the sequencer.
  let ``Max packets in sequencer`` instance =
    { category = "Pacer Pipe"; counter = "Max packets in sequencer"; instance = instance }
  /// Max packets in shaper: The maximum number of packets that have ever simultaneously been in the shaper.
  let ``Max packets in shaper`` instance =
    { category = "Pacer Pipe"; counter = "Max packets in shaper"; instance = instance }
  /// Max simultaneous flows: The maximum number of flows that have been simultaneously open on this pipe.
  let ``Max simultaneous flows`` instance =
    { category = "Pacer Pipe"; counter = "Max simultaneous flows"; instance = instance }
  /// Nonconforming packets scheduled: The number of packets that have entered the packet scheduler at a rate which exceeded that packet's flow parameters.
  let ``Nonconforming packets scheduled`` instance =
    { category = "Pacer Pipe"; counter = "Nonconforming packets scheduled"; instance = instance }
  /// Nonconforming packets scheduled/sec: The rate at which nonconforming packets have entered the packet scheduler.
  let ``Nonconforming packets scheduled/sec`` instance =
    { category = "Pacer Pipe"; counter = "Nonconforming packets scheduled/sec"; instance = instance }
  /// Nonconforming packets transmitted: The number of packets that have been sent by the packet scheduler at a rate which exceeded that packet's flow parameters.
  let ``Nonconforming packets transmitted`` instance =
    { category = "Pacer Pipe"; counter = "Nonconforming packets transmitted"; instance = instance }
  /// Nonconforming packets transmitted/sec: The rate at which nonconforming packets have been sent by the packet scheduler.
  let ``Nonconforming packets transmitted/sec`` instance =
    { category = "Pacer Pipe"; counter = "Nonconforming packets transmitted/sec"; instance = instance }
  /// Out of packets: The number of times Pacer has been unable to allocate a packet.
  let ``Out of packets`` instance =
    { category = "Pacer Pipe"; counter = "Out of packets"; instance = instance }

  let allCounters =
    [ ``Average packets in netcard``
      ``Average packets in sequencer``
      ``Average packets in shaper``
      ``Flow mods rejected``
      ``Flows closed``
      ``Flows modified``
      ``Flows opened``
      ``Flows rejected``
      ``Max packets in netcard``
      ``Max packets in sequencer``
      ``Max packets in shaper``
      ``Max simultaneous flows``
      ``Nonconforming packets scheduled``
      ``Nonconforming packets scheduled/sec``
      ``Nonconforming packets transmitted``
      ``Nonconforming packets transmitted/sec``
      ``Out of packets``
    ]

/// Paging File: The Paging File performance object consists of counters that monitor the paging file(s) on the computer.  The paging file is a reserved space on disk that backs up committed physical memory on the computer.
///
/// This performance counter does not have non-instance based counters
module ``Paging File`` =

  [<Literal>]
  let Category = "Paging File"

  let PCC = getPCC Category
  /// % Usage: The amount of the Page File instance in use in percent.  See also Process\\Page File Bytes.
  let ``% Usage`` instance =
    { category = "Paging File"; counter = "% Usage"; instance = instance }
  /// % Usage Peak: The peak usage of the Page File instance in percent.  See also Process\\Page File Bytes Peak.
  let ``% Usage Peak`` instance =
    { category = "Paging File"; counter = "% Usage Peak"; instance = instance }

  let allCounters =
    [ ``% Usage``
      ``% Usage Peak``
    ]

/// Peer Name Resolution Protocol: The Peer Name Resolution Protocol (PNRP) performance object consists of counters that monitor each of available PNRP clouds.  These counters monitor the local PNRP cache and measure the rates at which PNRP protocol messages are sent and received.
///
/// This performance counter does not have instance based counters
module ``Peer Name Resolution Protocol`` =

  [<Literal>]
  let Category = "Peer Name Resolution Protocol"

  let PCC = getPCC Category
  /// Ack received per second: -
  let ``Ack received per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Ack received per second"; instance = instance }
  /// Ack sent per second: -
  let ``Ack sent per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Ack sent per second"; instance = instance }
  /// Advertise received per second: -
  let ``Advertise received per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Advertise received per second"; instance = instance }
  /// Advertise sent per second: -
  let ``Advertise sent per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Advertise sent per second"; instance = instance }
  /// Authority received per second: -
  let ``Authority received per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Authority received per second"; instance = instance }
  /// Authority sent per second: -
  let ``Authority sent per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Authority sent per second"; instance = instance }
  /// Average bytes received: -
  let ``Average bytes received`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Average bytes received"; instance = instance }
  /// Average bytes sent: -
  let ``Average bytes sent`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Average bytes sent"; instance = instance }
  /// Cache Entry: -
  let ``Cache Entry`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Cache Entry"; instance = instance }
  /// Estimated cloud size: -
  let ``Estimated cloud size`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Estimated cloud size"; instance = instance }
  /// Flood received per second: -
  let ``Flood received per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Flood received per second"; instance = instance }
  /// Flood sent per second: -
  let ``Flood sent per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Flood sent per second"; instance = instance }
  /// Inquire received per second: -
  let ``Inquire received per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Inquire received per second"; instance = instance }
  /// Inquire sent per second: -
  let ``Inquire sent per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Inquire sent per second"; instance = instance }
  /// Lookup received per second: -
  let ``Lookup received per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Lookup received per second"; instance = instance }
  /// Lookup sent per second: -
  let ``Lookup sent per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Lookup sent per second"; instance = instance }
  /// Receive failures: -
  let ``Receive failures`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Receive failures"; instance = instance }
  /// Registration: -
  let ``Registration`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Registration"; instance = instance }
  /// Request received per second: -
  let ``Request received per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Request received per second"; instance = instance }
  /// Request sent per second: -
  let ``Request sent per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Request sent per second"; instance = instance }
  /// Resolve: -
  let ``Resolve`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Resolve"; instance = instance }
  /// Send failures: -
  let ``Send failures`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Send failures"; instance = instance }
  /// Solicit received per second: -
  let ``Solicit received per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Solicit received per second"; instance = instance }
  /// Solicit sent per second: -
  let ``Solicit sent per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Solicit sent per second"; instance = instance }
  /// Stale cache entry: -
  let ``Stale cache entry`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Stale cache entry"; instance = instance }
  /// Unknown message type received: -
  let ``Unknown message type received`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Unknown message type received"; instance = instance }

  let allCounters =
    [ ``Ack received per second``
      ``Ack sent per second``
      ``Advertise received per second``
      ``Advertise sent per second``
      ``Authority received per second``
      ``Authority sent per second``
      ``Average bytes received``
      ``Average bytes sent``
      ``Cache Entry``
      ``Estimated cloud size``
      ``Flood received per second``
      ``Flood sent per second``
      ``Inquire received per second``
      ``Inquire sent per second``
      ``Lookup received per second``
      ``Lookup sent per second``
      ``Receive failures``
      ``Registration``
      ``Request received per second``
      ``Request sent per second``
      ``Resolve``
      ``Send failures``
      ``Solicit received per second``
      ``Solicit sent per second``
      ``Stale cache entry``
      ``Unknown message type received``
    ]

/// Per Processor Network Activity Cycles: The Per Processor Network Activity Cycles counter set measures processor cycles due to network activity of an interface on each processor.
///
/// This performance counter does not have non-instance based counters
module ``Per Processor Network Activity Cycles`` =

  [<Literal>]
  let Category = "Per Processor Network Activity Cycles"

  let PCC = getPCC Category
  /// Build Scatter Gather Cycles/sec: Build Scatter Gather Cycles/sec is the average rate, in cycles per second, at which NDIS processed building Scatter Gather DMA lists for an interface.
  let ``Build Scatter Gather Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "Build Scatter Gather Cycles/sec"; instance = instance }
  /// Interrupt Cycles/sec: Interrupt Cycles/sec is the average rate, in cycles per second, at which NDIS processed hardware interrupts for an interface.
  let ``Interrupt Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "Interrupt Cycles/sec"; instance = instance }
  /// Interrupt DPC Cycles/sec: Interrupt DPC Cycles/sec is the average rate, in cycles per second, at which NDIS processed a Deferred Procedure Call (DPC) for an interface.
  let ``Interrupt DPC Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "Interrupt DPC Cycles/sec"; instance = instance }
  /// Interrupt DPC Latency Cycles/sec: Interrupt DPC Latency Cycles/sec is the amount of time, in cycles per second, between an interrupt and its DPC.
  let ``Interrupt DPC Latency Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "Interrupt DPC Latency Cycles/sec"; instance = instance }
  /// Miniport RSS Indirection Table Change Cycles: Miniport RSS Indirection Table Change Cycles is the average rate, in cycles per second, at which an interface processed changing the RSS indirection table.
  let ``Miniport RSS Indirection Table Change Cycles`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "Miniport RSS Indirection Table Change Cycles"; instance = instance }
  /// Miniport Return Packet Cycles/sec: Miniport Return Packet Cycles/sec is the average rate, in cycles per second, at which an interface processed returning received packets.
  let ``Miniport Return Packet Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "Miniport Return Packet Cycles/sec"; instance = instance }
  /// Miniport Send Cycles/sec: Miniport Send Cycles/sec is the average rate, in cycles per second, at which an interface processed transmitting packets.
  let ``Miniport Send Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "Miniport Send Cycles/sec"; instance = instance }
  /// NDIS Receive Indication Cycles/sec: NDIS Receive Indication Cycles/sec is the average rate, in cycles per second, at which NDIS processed a receive indication call from an interface.
  let ``NDIS Receive Indication Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "NDIS Receive Indication Cycles/sec"; instance = instance }
  /// NDIS Return Packet Cycles/sec: NDIS Return Packet Cycles/sec is the average rate, in cycles per second, at which NDIS processed returning received packets to an interface.
  let ``NDIS Return Packet Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "NDIS Return Packet Cycles/sec"; instance = instance }
  /// NDIS Send Complete Cycles/sec: NDIS Send Complete Cycles/sec is the average rate, in cycles per second, at which NDIS processed transmit-complete notifications from an interface.
  let ``NDIS Send Complete Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "NDIS Send Complete Cycles/sec"; instance = instance }
  /// NDIS Send Cycles/sec: NDIS Send Cycles/sec is the average rate, in cycles per second, at which NDIS processed transmit requests from the stack for an interface.
  let ``NDIS Send Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "NDIS Send Cycles/sec"; instance = instance }
  /// Stack Receive Indication Cycles/sec: Stack Receive Indication Cycles/sec is the average rate, in cycles per second, at which the stack processed a receive indication call from an interface.
  let ``Stack Receive Indication Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "Stack Receive Indication Cycles/sec"; instance = instance }
  /// Stack Send Complete Cycles/sec: Stack Send Complete Cycles/sec is the average rate, in cycles per second, at which the stack processed transmit-complete notifications from an interface.
  let ``Stack Send Complete Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "Stack Send Complete Cycles/sec"; instance = instance }

  let allCounters =
    [ ``Build Scatter Gather Cycles/sec``
      ``Interrupt Cycles/sec``
      ``Interrupt DPC Cycles/sec``
      ``Interrupt DPC Latency Cycles/sec``
      ``Miniport RSS Indirection Table Change Cycles``
      ``Miniport Return Packet Cycles/sec``
      ``Miniport Send Cycles/sec``
      ``NDIS Receive Indication Cycles/sec``
      ``NDIS Return Packet Cycles/sec``
      ``NDIS Send Complete Cycles/sec``
      ``NDIS Send Cycles/sec``
      ``Stack Receive Indication Cycles/sec``
      ``Stack Send Complete Cycles/sec``
    ]

/// Per Processor Network Interface Card Activity: The Per Processor Network Interface Card Activity counter set measures network activity of a network interface card per processor.
///
/// This performance counter does not have non-instance based counters
module ``Per Processor Network Interface Card Activity`` =

  [<Literal>]
  let Category = "Per Processor Network Interface Card Activity"

  let PCC = getPCC Category
  /// Build Scatter Gather List Calls/sec: Build Scatter Gather List Calls/sec is the average rate, in incidents per second, at which NDIS received a request from an interface to build a scatter gather DMA list.
  let ``Build Scatter Gather List Calls/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Build Scatter Gather List Calls/sec"; instance = instance }
  /// DPCs Deferred/sec: DPCs Deferred/sec is the average rate, in incidents per second, at which DPCs are deferred from executing immediately to avoid starving usermode threads.
  let ``DPCs Deferred/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "DPCs Deferred/sec"; instance = instance }
  /// DPCs Queued on Other CPUs/sec: DPCs Queued on Other CPUs/sec is the average rate, in incidents per second, at which the miniport queued a DPC on one CPU from a different CPU.
  let ``DPCs Queued on Other CPUs/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "DPCs Queued on Other CPUs/sec"; instance = instance }
  /// DPCs Queued/sec: DPCs Queued/sec is the average rate, in incidents per second, at which NDIS queued a Deferred Procedure Call (DPC) for an interface.
  let ``DPCs Queued/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "DPCs Queued/sec"; instance = instance }
  /// Interrupts/sec: Interrupts/sec is the average rate, in incidents per second, at which NDIS received and serviced hardware interrupts for an interface.
  let ``Interrupts/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Interrupts/sec"; instance = instance }
  /// Low Resource Receive Indications/sec: Low Resource Receive Indications/sec is the average rate, in incidents per second, at which NDIS received a receive indication call from an interface with low receive resources.
  let ``Low Resource Receive Indications/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Low Resource Receive Indications/sec"; instance = instance }
  /// Low Resource Received Packets/sec: Low Resource Received Packets/sec is the average rate, in packets per second, at which NDIS received packets from an interface with low receive resources.
  let ``Low Resource Received Packets/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Low Resource Received Packets/sec"; instance = instance }
  /// Packets Coalesced/sec: Packets Coalesced/sec is the average rate, in packets per second, at which NDIS received packets that were subjected to coalescing by a network interface before interrupting the host CPU.
  let ``Packets Coalesced/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Packets Coalesced/sec"; instance = instance }
  /// RSS Indirection Table Change Calls/sec: RSS Indirection Table Change Calls/sec is the average rate, in incidents per second, at which the stack submitted a request to change the RSS indirection table of an interface.
  let ``RSS Indirection Table Change Calls/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "RSS Indirection Table Change Calls/sec"; instance = instance }
  /// Receive Indications/sec: Receive Indications/sec is the average rate, in incidents per second, at which NDIS received a receive indication call from an interface.
  let ``Receive Indications/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Receive Indications/sec"; instance = instance }
  /// Received Packets/sec: Received Packets/sec is the average rate, in packets per second, at which NDIS received packets from an interface.
  let ``Received Packets/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Received Packets/sec"; instance = instance }
  /// Return Packet Calls/sec: Return Packet Calls/sec is the average rate, in incidents per second, at which the stack returned received packets to an interface.
  let ``Return Packet Calls/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Return Packet Calls/sec"; instance = instance }
  /// Returned Packets/sec: Returned Packets/sec is the average rate, in packets per second, at which the stack returned received packets to an interface.
  let ``Returned Packets/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Returned Packets/sec"; instance = instance }
  /// Send Complete Calls/sec: Send Complete Calls/sec is the average rate, in incidents per second, at which NDIS received a transmit-complete notification from an interface.
  let ``Send Complete Calls/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Send Complete Calls/sec"; instance = instance }
  /// Send Request Calls/sec: Send Request Calls/sec is the average rate, in incidents per second, at which the stack requested a transmit on an interface.
  let ``Send Request Calls/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Send Request Calls/sec"; instance = instance }
  /// Sent Complete Packets/sec: Sent Complete Packets/sec is the average rate, in packets per second, at which NDIS received a transmit-complete notification from an interface.
  let ``Sent Complete Packets/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Sent Complete Packets/sec"; instance = instance }
  /// Sent Packets/sec: Sent Packets/sec is the average rate, in packets per second, at which the stack requested a transmit on an interface.
  let ``Sent Packets/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Sent Packets/sec"; instance = instance }
  /// Tcp Offload Receive Indications/sec: Tcp Offload Receive Indications/sec is the average rate, in incidents per second, at which NDIS received a TCP offload receive indication call from a network interface.
  let ``Tcp Offload Receive Indications/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Tcp Offload Receive Indications/sec"; instance = instance }
  /// Tcp Offload Receive bytes/sec: Tcp Offload Receive bytes/sec is the average rate, in bytes per second, at which data was delivered by a network interface using the TCP offload receive indication call.
  let ``Tcp Offload Receive bytes/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Tcp Offload Receive bytes/sec"; instance = instance }
  /// Tcp Offload Send Request Calls/sec: Tcp Offload Send Request Calls/sec is the average rate, in incidents per second, at which the TCP/IP protocol requested a TCP offload transmission on a network interface.
  let ``Tcp Offload Send Request Calls/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Tcp Offload Send Request Calls/sec"; instance = instance }
  /// Tcp Offload Send bytes/sec: Tcp Offload Send bytes/sec is the average rate, in bytes per second, at which data was delivered to a network interface using the TCP offload send request call.
  let ``Tcp Offload Send bytes/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Tcp Offload Send bytes/sec"; instance = instance }

  let allCounters =
    [ ``Build Scatter Gather List Calls/sec``
      ``DPCs Deferred/sec``
      ``DPCs Queued on Other CPUs/sec``
      ``DPCs Queued/sec``
      ``Interrupts/sec``
      ``Low Resource Receive Indications/sec``
      ``Low Resource Received Packets/sec``
      ``Packets Coalesced/sec``
      ``RSS Indirection Table Change Calls/sec``
      ``Receive Indications/sec``
      ``Received Packets/sec``
      ``Return Packet Calls/sec``
      ``Returned Packets/sec``
      ``Send Complete Calls/sec``
      ``Send Request Calls/sec``
      ``Sent Complete Packets/sec``
      ``Sent Packets/sec``
      ``Tcp Offload Receive Indications/sec``
      ``Tcp Offload Receive bytes/sec``
      ``Tcp Offload Send Request Calls/sec``
      ``Tcp Offload Send bytes/sec``
    ]

/// Physical Network Interface Card Activity: The Physical Network Interface Card Activity counter set measures events on a physical network card.
///
/// This performance counter does not have non-instance based counters
module ``Physical Network Interface Card Activity`` =

  [<Literal>]
  let Category = "Physical Network Interface Card Activity"

  let PCC = getPCC Category
  /// % Time Suspended (Instantaneous): % Time Suspended (Instantaneous) measures the amount of time that the network interface card is in a low-power suspended state.  The percentage is calculated over the duration of the sample interval.
  let ``% Time Suspended (Instantaneous)`` instance =
    { category = "Physical Network Interface Card Activity"; counter = "% Time Suspended (Instantaneous)"; instance = instance }
  /// % Time Suspended (Lifetime): % Time Suspended (Lifetime) measures the amount of time that the network interface card is in a low-power suspended state.  The percentage is calculated over the entire lifetime of the network card.
  let ``% Time Suspended (Lifetime)`` instance =
    { category = "Physical Network Interface Card Activity"; counter = "% Time Suspended (Lifetime)"; instance = instance }
  /// Device Power State: Device Power State is the current power state of the network interface card.  Power state 0 is the active operating state, while power state 3 is the device's lowest power state.  Intermediate states 1 and 2 are device-specific sleep states.  For example, a USB NIC uses power state 2 to allow remote-wakeup.
  let ``Device Power State`` instance =
    { category = "Physical Network Interface Card Activity"; counter = "Device Power State"; instance = instance }
  /// Low Power Transitions (Lifetime): Low Power Transitions (Lifetime) measures the number of successful low-power transitions over the lifetime of the network interface card.  The counter includes only transitions from the active high-power state to a low-power state.
  let ``Low Power Transitions (Lifetime)`` instance =
    { category = "Physical Network Interface Card Activity"; counter = "Low Power Transitions (Lifetime)"; instance = instance }

  let allCounters =
    [ ``% Time Suspended (Instantaneous)``
      ``% Time Suspended (Lifetime)``
      ``Device Power State``
      ``Low Power Transitions (Lifetime)``
    ]

/// PhysicalDisk: The Physical Disk performance object consists of counters that monitor hard or fixed disk drive on a computer.  Disks are used to store file, program, and paging data and are read to retrieve these items, and written to record changes to them.  The values of physical disk counters are sums of the values of the logical disks (or partitions) into which they are divided.
///
/// This performance counter does not have non-instance based counters
module ``PhysicalDisk`` =

  [<Literal>]
  let Category = "PhysicalDisk"

  let PCC = getPCC Category
  /// % Disk Read Time: % Disk Read Time is the percentage of elapsed time that the selected disk drive was busy servicing read requests.
  let ``% Disk Read Time`` instance =
    { category = "PhysicalDisk"; counter = "% Disk Read Time"; instance = instance }
  /// % Disk Time: % Disk Time is the percentage of elapsed time that the selected disk drive was busy servicing read or write requests.
  let ``% Disk Time`` instance =
    { category = "PhysicalDisk"; counter = "% Disk Time"; instance = instance }
  /// % Disk Write Time: % Disk Write Time is the percentage of elapsed time that the selected disk drive was busy servicing write requests.
  let ``% Disk Write Time`` instance =
    { category = "PhysicalDisk"; counter = "% Disk Write Time"; instance = instance }
  /// % Idle Time: % Idle Time reports the percentage of time during the sample interval that the disk was idle.
  let ``% Idle Time`` instance =
    { category = "PhysicalDisk"; counter = "% Idle Time"; instance = instance }
  /// Avg. Disk Bytes/Read: Avg. Disk Bytes/Read is the average number of bytes transferred from the disk during read operations.
  let ``Avg. Disk Bytes/Read`` instance =
    { category = "PhysicalDisk"; counter = "Avg. Disk Bytes/Read"; instance = instance }
  /// Avg. Disk Bytes/Transfer: Avg. Disk Bytes/Transfer is the average number of bytes transferred to or from the disk during write or read operations.
  let ``Avg. Disk Bytes/Transfer`` instance =
    { category = "PhysicalDisk"; counter = "Avg. Disk Bytes/Transfer"; instance = instance }
  /// Avg. Disk Bytes/Write: Avg. Disk Bytes/Write is the average number of bytes transferred to the disk during write operations.
  let ``Avg. Disk Bytes/Write`` instance =
    { category = "PhysicalDisk"; counter = "Avg. Disk Bytes/Write"; instance = instance }
  /// Avg. Disk Queue Length: Avg. Disk Queue Length is the average number of both read and write requests that were queued for the selected disk during the sample interval.
  let ``Avg. Disk Queue Length`` instance =
    { category = "PhysicalDisk"; counter = "Avg. Disk Queue Length"; instance = instance }
  /// Avg. Disk Read Queue Length: Avg. Disk Read Queue Length is the average number of read requests that were queued for the selected disk during the sample interval.
  let ``Avg. Disk Read Queue Length`` instance =
    { category = "PhysicalDisk"; counter = "Avg. Disk Read Queue Length"; instance = instance }
  /// Avg. Disk Write Queue Length: Avg. Disk Write Queue Length is the average number of write requests that were queued for the selected disk during the sample interval.
  let ``Avg. Disk Write Queue Length`` instance =
    { category = "PhysicalDisk"; counter = "Avg. Disk Write Queue Length"; instance = instance }
  /// Avg. Disk sec/Read: Avg. Disk sec/Read is the average time, in seconds, of a read of data from the disk.
  let ``Avg. Disk sec/Read`` instance =
    { category = "PhysicalDisk"; counter = "Avg. Disk sec/Read"; instance = instance }
  /// Avg. Disk sec/Transfer: Avg. Disk sec/Transfer is the time, in seconds, of the average disk transfer.
  let ``Avg. Disk sec/Transfer`` instance =
    { category = "PhysicalDisk"; counter = "Avg. Disk sec/Transfer"; instance = instance }
  /// Avg. Disk sec/Write: Avg. Disk sec/Write is the average time, in seconds, of a write of data to the disk.
  let ``Avg. Disk sec/Write`` instance =
    { category = "PhysicalDisk"; counter = "Avg. Disk sec/Write"; instance = instance }
  /// Current Disk Queue Length: Current Disk Queue Length is the number of requests outstanding on the disk at the time the performance data is collected. It also includes requests in service at the time of the collection. This is a instantaneous snapshot, not an average over the time interval. Multi-spindle disk devices can have multiple requests that are active at one time, but other concurrent requests are awaiting service. This counter might reflect a transitory high or low queue length, but if there is a sustained load on the disk drive, it is likely that this will be consistently high. Requests experience delays proportional to the length of this queue minus the number of spindles on the disks. For good performance, this difference should average less than two.
  let ``Current Disk Queue Length`` instance =
    { category = "PhysicalDisk"; counter = "Current Disk Queue Length"; instance = instance }
  /// Disk Bytes/sec: Disk Bytes/sec is the rate bytes are transferred to or from the disk during write or read operations.
  let ``Disk Bytes/sec`` instance =
    { category = "PhysicalDisk"; counter = "Disk Bytes/sec"; instance = instance }
  /// Disk Read Bytes/sec: Disk Read Bytes/sec is the rate at which bytes are transferred from the disk during read operations.
  let ``Disk Read Bytes/sec`` instance =
    { category = "PhysicalDisk"; counter = "Disk Read Bytes/sec"; instance = instance }
  /// Disk Reads/sec: Disk Reads/sec is the rate of read operations on the disk.
  let ``Disk Reads/sec`` instance =
    { category = "PhysicalDisk"; counter = "Disk Reads/sec"; instance = instance }
  /// Disk Transfers/sec: Disk Transfers/sec is the rate of read and write operations on the disk.
  let ``Disk Transfers/sec`` instance =
    { category = "PhysicalDisk"; counter = "Disk Transfers/sec"; instance = instance }
  /// Disk Write Bytes/sec: Disk Write Bytes/sec is rate at which bytes are transferred to the disk during write operations.
  let ``Disk Write Bytes/sec`` instance =
    { category = "PhysicalDisk"; counter = "Disk Write Bytes/sec"; instance = instance }
  /// Disk Writes/sec: Disk Writes/sec is the rate of write operations on the disk.
  let ``Disk Writes/sec`` instance =
    { category = "PhysicalDisk"; counter = "Disk Writes/sec"; instance = instance }
  /// Split IO/Sec: Split IO/Sec reports the rate at which I/Os to the disk were split into multiple I/Os. A split I/O may result from requesting data of a size that is too large to fit into a single I/O or that the disk is fragmented.
  let ``Split IO/Sec`` instance =
    { category = "PhysicalDisk"; counter = "Split IO/Sec"; instance = instance }

  let allCounters =
    [ ``% Disk Read Time``
      ``% Disk Time``
      ``% Disk Write Time``
      ``% Idle Time``
      ``Avg. Disk Bytes/Read``
      ``Avg. Disk Bytes/Transfer``
      ``Avg. Disk Bytes/Write``
      ``Avg. Disk Queue Length``
      ``Avg. Disk Read Queue Length``
      ``Avg. Disk Write Queue Length``
      ``Avg. Disk sec/Read``
      ``Avg. Disk sec/Transfer``
      ``Avg. Disk sec/Write``
      ``Current Disk Queue Length``
      ``Disk Bytes/sec``
      ``Disk Read Bytes/sec``
      ``Disk Reads/sec``
      ``Disk Transfers/sec``
      ``Disk Write Bytes/sec``
      ``Disk Writes/sec``
      ``Split IO/Sec``
    ]

/// Power Meter: This counter set displays power metering and budgeting information
///
/// This performance counter does not have instance based counters
module ``Power Meter`` =

  [<Literal>]
  let Category = "Power Meter"

  let PCC = getPCC Category
  /// Power: -
  let ``Power`` instance =
    { category = "Power Meter"; counter = "Power"; instance = instance }
  /// Power Budget: -
  let ``Power Budget`` instance =
    { category = "Power Meter"; counter = "Power Budget"; instance = instance }

  let allCounters =
    [ ``Power``
      ``Power Budget``
    ]

/// PowerShell Workflow: Displays performance counters for PowerShell Workflow engine.
///
/// This performance counter does not have instance based counters
module ``PowerShell Workflow`` =

  [<Literal>]
  let Category = "PowerShell Workflow"

  let PCC = getPCC Category
  /// # of failed workflow jobs: -
  let ``# of failed workflow jobs`` instance =
    { category = "PowerShell Workflow"; counter = "# of failed workflow jobs"; instance = instance }
  /// # of failed workflow jobs/sec: -
  let ``# of failed workflow jobs/sec`` instance =
    { category = "PowerShell Workflow"; counter = "# of failed workflow jobs/sec"; instance = instance }
  /// # of resumed workflow jobs: -
  let ``# of resumed workflow jobs`` instance =
    { category = "PowerShell Workflow"; counter = "# of resumed workflow jobs"; instance = instance }
  /// # of resumed workflow jobs/sec: -
  let ``# of resumed workflow jobs/sec`` instance =
    { category = "PowerShell Workflow"; counter = "# of resumed workflow jobs/sec"; instance = instance }
  /// # of running workflow jobs: -
  let ``# of running workflow jobs`` instance =
    { category = "PowerShell Workflow"; counter = "# of running workflow jobs"; instance = instance }
  /// # of running workflow jobs / sec: -
  let ``# of running workflow jobs / sec`` instance =
    { category = "PowerShell Workflow"; counter = "# of running workflow jobs / sec"; instance = instance }
  /// # of stopped workflow jobs: -
  let ``# of stopped workflow jobs`` instance =
    { category = "PowerShell Workflow"; counter = "# of stopped workflow jobs"; instance = instance }
  /// # of stopped workflow jobs / sec: -
  let ``# of stopped workflow jobs / sec`` instance =
    { category = "PowerShell Workflow"; counter = "# of stopped workflow jobs / sec"; instance = instance }
  /// # of succeeded workflow jobs: -
  let ``# of succeeded workflow jobs`` instance =
    { category = "PowerShell Workflow"; counter = "# of succeeded workflow jobs"; instance = instance }
  /// # of succeeded workflow jobs/sec: -
  let ``# of succeeded workflow jobs/sec`` instance =
    { category = "PowerShell Workflow"; counter = "# of succeeded workflow jobs/sec"; instance = instance }
  /// # of suspended workflow jobs: -
  let ``# of suspended workflow jobs`` instance =
    { category = "PowerShell Workflow"; counter = "# of suspended workflow jobs"; instance = instance }
  /// # of suspended workflow jobs/sec: -
  let ``# of suspended workflow jobs/sec`` instance =
    { category = "PowerShell Workflow"; counter = "# of suspended workflow jobs/sec"; instance = instance }
  /// # of terminated workflow jobs: -
  let ``# of terminated workflow jobs`` instance =
    { category = "PowerShell Workflow"; counter = "# of terminated workflow jobs"; instance = instance }
  /// # of terminated workflow jobs / sec: -
  let ``# of terminated workflow jobs / sec`` instance =
    { category = "PowerShell Workflow"; counter = "# of terminated workflow jobs / sec"; instance = instance }
  /// # of waiting workflow jobs: -
  let ``# of waiting workflow jobs`` instance =
    { category = "PowerShell Workflow"; counter = "# of waiting workflow jobs"; instance = instance }
  /// Activity Host Manager: # of busy host processes: -
  let ``Activity Host Manager: # of busy host processes`` instance =
    { category = "PowerShell Workflow"; counter = "Activity Host Manager: # of busy host processes"; instance = instance }
  /// Activity Host Manager: # of created host processes: -
  let ``Activity Host Manager: # of created host processes`` instance =
    { category = "PowerShell Workflow"; counter = "Activity Host Manager: # of created host processes"; instance = instance }
  /// Activity Host Manager: # of disposed host processes: -
  let ``Activity Host Manager: # of disposed host processes`` instance =
    { category = "PowerShell Workflow"; counter = "Activity Host Manager: # of disposed host processes"; instance = instance }
  /// Activity Host Manager: # of failed requests in queue: -
  let ``Activity Host Manager: # of failed requests in queue`` instance =
    { category = "PowerShell Workflow"; counter = "Activity Host Manager: # of failed requests in queue"; instance = instance }
  /// Activity Host Manager: # of failed requests/sec: -
  let ``Activity Host Manager: # of failed requests/sec`` instance =
    { category = "PowerShell Workflow"; counter = "Activity Host Manager: # of failed requests/sec"; instance = instance }
  /// Activity Host Manager: # of incoming requests/sec: -
  let ``Activity Host Manager: # of incoming requests/sec`` instance =
    { category = "PowerShell Workflow"; counter = "Activity Host Manager: # of incoming requests/sec"; instance = instance }
  /// Activity Host Manager: # of pending requests in queue: -
  let ``Activity Host Manager: # of pending requests in queue`` instance =
    { category = "PowerShell Workflow"; counter = "Activity Host Manager: # of pending requests in queue"; instance = instance }
  /// Activity Host Manager: host processes pool size: -
  let ``Activity Host Manager: host processes pool size`` instance =
    { category = "PowerShell Workflow"; counter = "Activity Host Manager: host processes pool size"; instance = instance }
  /// PowerShell Remoting: # of connections closed-reopened: -
  let ``PowerShell Remoting: # of connections closed-reopened`` instance =
    { category = "PowerShell Workflow"; counter = "PowerShell Remoting: # of connections closed-reopened"; instance = instance }
  /// PowerShell Remoting: # of created connections: -
  let ``PowerShell Remoting: # of created connections`` instance =
    { category = "PowerShell Workflow"; counter = "PowerShell Remoting: # of created connections"; instance = instance }
  /// PowerShell Remoting: # of disposed connections: -
  let ``PowerShell Remoting: # of disposed connections`` instance =
    { category = "PowerShell Workflow"; counter = "PowerShell Remoting: # of disposed connections"; instance = instance }
  /// PowerShell Remoting: # of forced to wait requests in queue: -
  let ``PowerShell Remoting: # of forced to wait requests in queue`` instance =
    { category = "PowerShell Workflow"; counter = "PowerShell Remoting: # of forced to wait requests in queue"; instance = instance }
  /// PowerShell Remoting: # of pending requests in queue: -
  let ``PowerShell Remoting: # of pending requests in queue`` instance =
    { category = "PowerShell Workflow"; counter = "PowerShell Remoting: # of pending requests in queue"; instance = instance }
  /// PowerShell Remoting: # of requests being serviced: -
  let ``PowerShell Remoting: # of requests being serviced`` instance =
    { category = "PowerShell Workflow"; counter = "PowerShell Remoting: # of requests being serviced"; instance = instance }

  let allCounters =
    [ ``# of failed workflow jobs``
      ``# of failed workflow jobs/sec``
      ``# of resumed workflow jobs``
      ``# of resumed workflow jobs/sec``
      ``# of running workflow jobs``
      ``# of running workflow jobs / sec``
      ``# of stopped workflow jobs``
      ``# of stopped workflow jobs / sec``
      ``# of succeeded workflow jobs``
      ``# of succeeded workflow jobs/sec``
      ``# of suspended workflow jobs``
      ``# of suspended workflow jobs/sec``
      ``# of terminated workflow jobs``
      ``# of terminated workflow jobs / sec``
      ``# of waiting workflow jobs``
      ``Activity Host Manager: # of busy host processes``
      ``Activity Host Manager: # of created host processes``
      ``Activity Host Manager: # of disposed host processes``
      ``Activity Host Manager: # of failed requests in queue``
      ``Activity Host Manager: # of failed requests/sec``
      ``Activity Host Manager: # of incoming requests/sec``
      ``Activity Host Manager: # of pending requests in queue``
      ``Activity Host Manager: host processes pool size``
      ``PowerShell Remoting: # of connections closed-reopened``
      ``PowerShell Remoting: # of created connections``
      ``PowerShell Remoting: # of disposed connections``
      ``PowerShell Remoting: # of forced to wait requests in queue``
      ``PowerShell Remoting: # of pending requests in queue``
      ``PowerShell Remoting: # of requests being serviced``
    ]

/// Print Queue: Displays performance statistics about a Print Queue.
///
/// This performance counter does not have non-instance based counters
module ``Print Queue`` =

  [<Literal>]
  let Category = "Print Queue"

  let PCC = getPCC Category
  /// Add Network Printer Calls: Total number of calls from other print servers to add shared network printers to this server since last restart.
  let ``Add Network Printer Calls`` instance =
    { category = "Print Queue"; counter = "Add Network Printer Calls"; instance = instance }
  /// Bytes Printed/sec: Number of bytes per second printed on a print queue.
  let ``Bytes Printed/sec`` instance =
    { category = "Print Queue"; counter = "Bytes Printed/sec"; instance = instance }
  /// Enumerate Network Printer Calls: Total number of calls from browse clients to this print server to request network browse lists since last restart.
  let ``Enumerate Network Printer Calls`` instance =
    { category = "Print Queue"; counter = "Enumerate Network Printer Calls"; instance = instance }
  /// Job Errors: Total number of job errors in a print queue since last restart.
  let ``Job Errors`` instance =
    { category = "Print Queue"; counter = "Job Errors"; instance = instance }
  /// Jobs: Current number of jobs in a print queue.
  let ``Jobs`` instance =
    { category = "Print Queue"; counter = "Jobs"; instance = instance }
  /// Jobs Spooling: Current number of spooling jobs in a print queue.
  let ``Jobs Spooling`` instance =
    { category = "Print Queue"; counter = "Jobs Spooling"; instance = instance }
  /// Max Jobs Spooling: Maximum number of spooling jobs in a print queue since last restart.
  let ``Max Jobs Spooling`` instance =
    { category = "Print Queue"; counter = "Max Jobs Spooling"; instance = instance }
  /// Max References: Peak number of references (open handles) to this printer.
  let ``Max References`` instance =
    { category = "Print Queue"; counter = "Max References"; instance = instance }
  /// Not Ready Errors: Total number of printer not ready errors in a print queue since the last restart.
  let ``Not Ready Errors`` instance =
    { category = "Print Queue"; counter = "Not Ready Errors"; instance = instance }
  /// Out of Paper Errors: Total number of out of paper errors in a print queue since the last restart.
  let ``Out of Paper Errors`` instance =
    { category = "Print Queue"; counter = "Out of Paper Errors"; instance = instance }
  /// References: Current number of references (open handles) to this printer.
  let ``References`` instance =
    { category = "Print Queue"; counter = "References"; instance = instance }
  /// Total Jobs Printed: Total number of jobs printed on a print queue since the last restart.
  let ``Total Jobs Printed`` instance =
    { category = "Print Queue"; counter = "Total Jobs Printed"; instance = instance }
  /// Total Pages Printed: Total number of pages printed through GDI on a print queue since the last restart.
  let ``Total Pages Printed`` instance =
    { category = "Print Queue"; counter = "Total Pages Printed"; instance = instance }

  let allCounters =
    [ ``Add Network Printer Calls``
      ``Bytes Printed/sec``
      ``Enumerate Network Printer Calls``
      ``Job Errors``
      ``Jobs``
      ``Jobs Spooling``
      ``Max Jobs Spooling``
      ``Max References``
      ``Not Ready Errors``
      ``Out of Paper Errors``
      ``References``
      ``Total Jobs Printed``
      ``Total Pages Printed``
    ]

/// Process: The Process performance object consists of counters that monitor running application program and system processes.  All the threads in a process share the same address space and have access to the same data.
///
/// This performance counter does not have non-instance based counters
module ``Process`` =

  [<Literal>]
  let Category = "Process"

  let PCC = getPCC Category
  /// % Privileged Time: % Privileged Time is the percentage of elapsed time that the process threads spent executing code in privileged mode. When a Windows system service is called, the service will often run in privileged mode to gain access to system-private data. Such data is protected from access by threads executing in user mode. Calls to the system can be explicit or implicit, such as page faults or interrupts. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.
  let ``% Privileged Time`` instance =
    { category = "Process"; counter = "% Privileged Time"; instance = instance }
  /// % Processor Time: % Processor Time is the percentage of elapsed time that all of process threads used the processor to execution instructions. An instruction is the basic unit of execution in a computer, a thread is the object that executes instructions, and a process is the object created when a program is run. Code executed to handle some hardware interrupts and trap conditions are included in this count.
  let ``% Processor Time`` instance =
    { category = "Process"; counter = "% Processor Time"; instance = instance }
  /// % User Time: % User Time is the percentage of elapsed time that the process threads spent executing code in user mode. Applications, environment subsystems, and integral subsystems execute in user mode. Code executing in user mode cannot damage the integrity of the Windows executive, kernel, and device drivers. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.
  let ``% User Time`` instance =
    { category = "Process"; counter = "% User Time"; instance = instance }
  /// Creating Process ID: The Creating Process ID value is the Process ID of the process that created the process. The creating process may have terminated, so this value may no longer identify a running process.
  let ``Creating Process ID`` instance =
    { category = "Process"; counter = "Creating Process ID"; instance = instance }
  /// Elapsed Time: The total elapsed time, in seconds, that this process has been running.
  let ``Elapsed Time`` instance =
    { category = "Process"; counter = "Elapsed Time"; instance = instance }
  /// Handle Count: The total number of handles currently open by this process. This number is equal to the sum of the handles currently open by each thread in this process.
  let ``Handle Count`` instance =
    { category = "Process"; counter = "Handle Count"; instance = instance }
  /// ID Process: ID Process is the unique identifier of this process. ID Process numbers are reused, so they only identify a process for the lifetime of that process.
  let ``ID Process`` instance =
    { category = "Process"; counter = "ID Process"; instance = instance }
  /// IO Data Bytes/sec: The rate at which the process is reading and writing bytes in I/O operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Data Bytes/sec`` instance =
    { category = "Process"; counter = "IO Data Bytes/sec"; instance = instance }
  /// IO Data Operations/sec: The rate at which the process is issuing read and write I/O operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Data Operations/sec`` instance =
    { category = "Process"; counter = "IO Data Operations/sec"; instance = instance }
  /// IO Other Bytes/sec: The rate at which the process is issuing bytes to I/O operations that do not involve data such as control operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Other Bytes/sec`` instance =
    { category = "Process"; counter = "IO Other Bytes/sec"; instance = instance }
  /// IO Other Operations/sec: The rate at which the process is issuing I/O operations that are neither read nor write operations (for example, a control function). This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Other Operations/sec`` instance =
    { category = "Process"; counter = "IO Other Operations/sec"; instance = instance }
  /// IO Read Bytes/sec: The rate at which the process is reading bytes from I/O operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Read Bytes/sec`` instance =
    { category = "Process"; counter = "IO Read Bytes/sec"; instance = instance }
  /// IO Read Operations/sec: The rate at which the process is issuing read I/O operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Read Operations/sec`` instance =
    { category = "Process"; counter = "IO Read Operations/sec"; instance = instance }
  /// IO Write Bytes/sec: The rate at which the process is writing bytes to I/O operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Write Bytes/sec`` instance =
    { category = "Process"; counter = "IO Write Bytes/sec"; instance = instance }
  /// IO Write Operations/sec: The rate at which the process is issuing write I/O operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Write Operations/sec`` instance =
    { category = "Process"; counter = "IO Write Operations/sec"; instance = instance }
  /// Page Faults/sec: Page Faults/sec is the rate at which page faults by the threads executing in this process are occurring.  A page fault occurs when a thread refers to a virtual memory page that is not in its working set in main memory. This may not cause the page to be fetched from disk if it is on the standby list and hence already in main memory, or if it is in use by another process with whom the page is shared.
  let ``Page Faults/sec`` instance =
    { category = "Process"; counter = "Page Faults/sec"; instance = instance }
  /// Page File Bytes: Page File Bytes is the current amount of virtual memory, in bytes, that this process has reserved for use in the paging file(s). Paging files are used to store pages of memory used by the process that are not contained in other files. Paging files are shared by all processes, and the lack of space in paging files can prevent other processes from allocating memory. If there is no paging file, this counter reflects the current amount of virtual memory that the process has reserved for use in physical memory.
  let ``Page File Bytes`` instance =
    { category = "Process"; counter = "Page File Bytes"; instance = instance }
  /// Page File Bytes Peak: Page File Bytes Peak is the maximum amount of virtual memory, in bytes, that this process has reserved for use in the paging file(s). Paging files are used to store pages of memory used by the process that are not contained in other files.  Paging files are shared by all processes, and the lack of space in paging files can prevent other processes from allocating memory. If there is no paging file, this counter reflects the maximum amount of virtual memory that the process has reserved for use in physical memory.
  let ``Page File Bytes Peak`` instance =
    { category = "Process"; counter = "Page File Bytes Peak"; instance = instance }
  /// Pool Nonpaged Bytes: Pool Nonpaged Bytes is the size, in bytes, of the nonpaged pool, an area of the system virtual memory that is used for objects that cannot be written to disk, but must remain in physical memory as long as they are allocated.  Memory\\Pool Nonpaged Bytes is calculated differently than Process\\Pool Nonpaged Bytes, so it might not equal Process(_Total)\\Pool Nonpaged Bytes.  This counter displays the last observed value only; it is not an average.
  let ``Pool Nonpaged Bytes`` instance =
    { category = "Process"; counter = "Pool Nonpaged Bytes"; instance = instance }
  /// Pool Paged Bytes: Pool Paged Bytes is the size, in bytes, of the paged pool, an area of the system virtual memory that is used for objects that can be written to disk when they are not being used.  Memory\\Pool Paged Bytes is calculated differently than Process\\Pool Paged Bytes, so it might not equal Process(_Total)\\Pool Paged Bytes. This counter displays the last observed value only; it is not an average.
  let ``Pool Paged Bytes`` instance =
    { category = "Process"; counter = "Pool Paged Bytes"; instance = instance }
  /// Priority Base: The current base priority of this process. Threads within a process can raise and lower their own base priority relative to the process' base priority.
  let ``Priority Base`` instance =
    { category = "Process"; counter = "Priority Base"; instance = instance }
  /// Private Bytes: Private Bytes is the current size, in bytes, of memory that this process has allocated that cannot be shared with other processes.
  let ``Private Bytes`` instance =
    { category = "Process"; counter = "Private Bytes"; instance = instance }
  /// Thread Count: The number of threads currently active in this process. An instruction is the basic unit of execution in a processor, and a thread is the object that executes instructions. Every running process has at least one thread.
  let ``Thread Count`` instance =
    { category = "Process"; counter = "Thread Count"; instance = instance }
  /// Virtual Bytes: Virtual Bytes is the current size, in bytes, of the virtual address space the process is using. Use of virtual address space does not necessarily imply corresponding use of either disk or main memory pages. Virtual space is finite, and the process can limit its ability to load libraries.
  let ``Virtual Bytes`` instance =
    { category = "Process"; counter = "Virtual Bytes"; instance = instance }
  /// Virtual Bytes Peak: Virtual Bytes Peak is the maximum size, in bytes, of virtual address space the process has used at any one time. Use of virtual address space does not necessarily imply corresponding use of either disk or main memory pages. However, virtual space is finite, and the process might limit its ability to load libraries.
  let ``Virtual Bytes Peak`` instance =
    { category = "Process"; counter = "Virtual Bytes Peak"; instance = instance }
  /// Working Set: Working Set is the current size, in bytes, of the Working Set of this process. The Working Set is the set of memory pages touched recently by the threads in the process. If free memory in the computer is above a threshold, pages are left in the Working Set of a process even if they are not in use.  When free memory falls below a threshold, pages are trimmed from Working Sets. If they are needed they will then be soft-faulted back into the Working Set before leaving main memory.
  let ``Working Set`` instance =
    { category = "Process"; counter = "Working Set"; instance = instance }
  /// Working Set - Private: Working Set - Private displays the size of the working set, in bytes, that is use for this process only and not shared nor sharable by other processes.
  let ``Working Set - Private`` instance =
    { category = "Process"; counter = "Working Set - Private"; instance = instance }
  /// Working Set Peak: Working Set Peak is the maximum size, in bytes, of the Working Set of this process at any point in time. The Working Set is the set of memory pages touched recently by the threads in the process. If free memory in the computer is above a threshold, pages are left in the Working Set of a process even if they are not in use. When free memory falls below a threshold, pages are trimmed from Working Sets. If they are needed they will then be soft-faulted back into the Working Set before they leave main memory.
  let ``Working Set Peak`` instance =
    { category = "Process"; counter = "Working Set Peak"; instance = instance }

  let allCounters =
    [ ``% Privileged Time``
      ``% Processor Time``
      ``% User Time``
      ``Creating Process ID``
      ``Elapsed Time``
      ``Handle Count``
      ``ID Process``
      ``IO Data Bytes/sec``
      ``IO Data Operations/sec``
      ``IO Other Bytes/sec``
      ``IO Other Operations/sec``
      ``IO Read Bytes/sec``
      ``IO Read Operations/sec``
      ``IO Write Bytes/sec``
      ``IO Write Operations/sec``
      ``Page Faults/sec``
      ``Page File Bytes``
      ``Page File Bytes Peak``
      ``Pool Nonpaged Bytes``
      ``Pool Paged Bytes``
      ``Priority Base``
      ``Private Bytes``
      ``Thread Count``
      ``Virtual Bytes``
      ``Virtual Bytes Peak``
      ``Working Set``
      ``Working Set - Private``
      ``Working Set Peak``
    ]

/// Processor: The Processor performance object consists of counters that measure aspects of processor activity. The processor is the part of the computer that performs arithmetic and logical computations, initiates operations on peripherals, and runs the threads of processes.  A computer can have multiple processors.  The processor object represents each processor as an instance of the object.
///
/// This performance counter does not have non-instance based counters
module ``Processor`` =

  [<Literal>]
  let Category = "Processor"

  let PCC = getPCC Category
  /// % C1 Time: % C1 Time is the percentage of time the processor spends in the C1 low-power idle state. % C1 Time is a subset of the total processor idle time. C1 low-power idle state enables the processor to maintain its entire context and quickly return to the running state. Not all systems support the % C1 state.
  let ``% C1 Time`` instance =
    { category = "Processor"; counter = "% C1 Time"; instance = instance }
  /// % C2 Time: % C2 Time is the percentage of time the processor spends in the C2 low-power idle state. % C2 Time is a subset of the total processor idle time. C2 low-power idle state enables the processor to maintain the context of the system caches. The C2 power state is a lower power and higher exit latency state than C1. Not all systems support the C2 state.
  let ``% C2 Time`` instance =
    { category = "Processor"; counter = "% C2 Time"; instance = instance }
  /// % C3 Time: % C3 Time is the percentage of time the processor spends in the C3 low-power idle state. % C3 Time is a subset of the total processor idle time. When the processor is in the C3 low-power idle state it is unable to maintain the coherency of its caches. The C3 power state is a lower power and higher exit latency state than C2. Not all systems support the C3 state.
  let ``% C3 Time`` instance =
    { category = "Processor"; counter = "% C3 Time"; instance = instance }
  /// % DPC Time: % DPC Time is the percentage of time that the processor spent receiving and servicing deferred procedure calls (DPCs) during the sample interval. DPCs are interrupts that run at a lower priority than standard interrupts. % DPC Time is a component of % Privileged Time because DPCs are executed in privileged mode. They are counted separately and are not a component of the interrupt counters. This counter displays the average busy time as a percentage of the sample time.
  let ``% DPC Time`` instance =
    { category = "Processor"; counter = "% DPC Time"; instance = instance }
  /// % Idle Time: % Idle Time is the percentage of time the processor is idle during the sample interval
  let ``% Idle Time`` instance =
    { category = "Processor"; counter = "% Idle Time"; instance = instance }
  /// % Interrupt Time: % Interrupt Time is the time the processor spends receiving and servicing hardware interrupts during sample intervals. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention. Normal thread execution is suspended during interrupts. Most system clocks interrupt the processor every 10 milliseconds, creating a background of interrupt activity. suspends normal thread execution during interrupts. This counter displays the average busy time as a percentage of the sample time.
  let ``% Interrupt Time`` instance =
    { category = "Processor"; counter = "% Interrupt Time"; instance = instance }
  /// % Privileged Time: % Privileged Time is the percentage of elapsed time that the process threads spent executing code in privileged mode.  When a Windows system service in called, the service will often run in privileged mode to gain access to system-private data. Such data is protected from access by threads executing in user mode. Calls to the system can be explicit or implicit, such as page faults or interrupts. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.
  let ``% Privileged Time`` instance =
    { category = "Processor"; counter = "% Privileged Time"; instance = instance }
  /// % Processor Time: % Processor Time is the percentage of elapsed time that the processor spends to execute a non-Idle thread. It is calculated by measuring the percentage of time that the processor spends executing the idle thread and then subtracting that value from 100%. (Each processor has an idle thread that consumes cycles when no other threads are ready to run). This counter is the primary indicator of processor activity, and displays the average percentage of busy time observed during the sample interval. It should be noted that the accounting calculation of whether the processor is idle is performed at an internal sampling interval of the system clock (10ms). On todays fast processors, % Processor Time can therefore underestimate the processor utilization as the processor may be spending a lot of time servicing threads between the system clock sampling interval. Workload based timer applications are one example  of applications  which are more likely to be measured inaccurately as timers are signaled just after the sample is taken.
  let ``% Processor Time`` instance =
    { category = "Processor"; counter = "% Processor Time"; instance = instance }
  /// % User Time: % User Time is the percentage of elapsed time the processor spends in the user mode. User mode is a restricted processing mode designed for applications, environment subsystems, and integral subsystems.  The alternative, privileged mode, is designed for operating system components and allows direct access to hardware and all memory.  The operating system switches application threads to privileged mode to access operating system services. This counter displays the average busy time as a percentage of the sample time.
  let ``% User Time`` instance =
    { category = "Processor"; counter = "% User Time"; instance = instance }
  /// C1 Transitions/sec: C1 Transitions/sec is the rate that the CPU enters the C1 low-power idle state. The CPU enters the C1 state when it is sufficiently idle and exits this state on any interrupt. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``C1 Transitions/sec`` instance =
    { category = "Processor"; counter = "C1 Transitions/sec"; instance = instance }
  /// C2 Transitions/sec: C2 Transitions/sec is the rate that the CPU enters the C2 low-power idle state. The CPU enters the C2 state when it is sufficiently idle and exits this state on any interrupt. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``C2 Transitions/sec`` instance =
    { category = "Processor"; counter = "C2 Transitions/sec"; instance = instance }
  /// C3 Transitions/sec: C3 Transitions/sec is the rate that the CPU enters the C3 low-power idle state. The CPU enters the C3 state when it is sufficiently idle and exits this state on any interrupt. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``C3 Transitions/sec`` instance =
    { category = "Processor"; counter = "C3 Transitions/sec"; instance = instance }
  /// DPC Rate: DPC Rate is the rate at which deferred procedure calls (DPCs) were added to the processors DPC queues between the timer ticks of the processor clock. DPCs are interrupts that run at alower priority than standard interrupts.  Each processor has its own DPC queue. This counter measures the rate that DPCs were added to the queue, not the number of DPCs in the queue. This counter displays the last observed value only; it is not an average.
  let ``DPC Rate`` instance =
    { category = "Processor"; counter = "DPC Rate"; instance = instance }
  /// DPCs Queued/sec: DPCs Queued/sec is the average rate, in incidents per second, at which deferred procedure calls (DPCs) were added to the processor's DPC queue. DPCs are interrupts that run at a lower priority than standard interrupts.  Each processor has its own DPC queue. This counter measures the rate that DPCs are added to the queue, not the number of DPCs in the queue.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``DPCs Queued/sec`` instance =
    { category = "Processor"; counter = "DPCs Queued/sec"; instance = instance }
  /// Interrupts/sec: Interrupts/sec is the average rate, in incidents per second, at which the processor received and serviced hardware interrupts. It does not include deferred procedure calls (DPCs), which are counted separately. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards, and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention. Normal thread execution is suspended. The system clock typically interrupts the processor every 10 milliseconds, creating a background of interrupt activity. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Interrupts/sec`` instance =
    { category = "Processor"; counter = "Interrupts/sec"; instance = instance }

  let allCounters =
    [ ``% C1 Time``
      ``% C2 Time``
      ``% C3 Time``
      ``% DPC Time``
      ``% Idle Time``
      ``% Interrupt Time``
      ``% Privileged Time``
      ``% Processor Time``
      ``% User Time``
      ``C1 Transitions/sec``
      ``C2 Transitions/sec``
      ``C3 Transitions/sec``
      ``DPC Rate``
      ``DPCs Queued/sec``
      ``Interrupts/sec``
    ]

/// Processor Information: The Processor Information performance counter set consists of counters that measure aspects of processor activity. The processor is the part of the computer that performs arithmetic and logical computations, initiates operations on peripherals, and runs the threads of processes. A computer can have multiple processors. On some computers, processors are organized in NUMA nodes that share hardware resources such as physical memory. The Processor Information counter set represents each processor as a pair of numbers, where the first number is the NUMA node number and the second number is the zero-based index of the processor within that NUMA node. If the computer does not use NUMA nodes, the first number is zero.
///
/// This performance counter does not have non-instance based counters
module ``Processor Information`` =

  [<Literal>]
  let Category = "Processor Information"

  let PCC = getPCC Category
  /// % C1 Time: % C1 Time is the percentage of time the processor spends in the C1 low-power idle state. % C1 Time is a subset of the total processor idle time. C1 low-power idle state enables the processor to maintain its entire context and quickly return to the running state. Not all systems support the % C1 state.
  let ``% C1 Time`` instance =
    { category = "Processor Information"; counter = "% C1 Time"; instance = instance }
  /// % C2 Time: % C2 Time is the percentage of time the processor spends in the C2 low-power idle state. % C2 Time is a subset of the total processor idle time. C2 low-power idle state enables the processor to maintain the context of the system caches. The C2 power state is a lower power and higher exit latency state than C1. Not all systems support the C2 state.
  let ``% C2 Time`` instance =
    { category = "Processor Information"; counter = "% C2 Time"; instance = instance }
  /// % C3 Time: % C3 Time is the percentage of time the processor spends in the C3 low-power idle state. % C3 Time is a subset of the total processor idle time. When the processor is in the C3 low-power idle state it is unable to maintain the coherency of its caches. The C3 power state is a lower power and higher exit latency state than C2. Not all systems support the C3 state.
  let ``% C3 Time`` instance =
    { category = "Processor Information"; counter = "% C3 Time"; instance = instance }
  /// % DPC Time: % DPC Time is the percentage of time that the processor spent receiving and servicing deferred procedure calls (DPCs) during the sample interval. DPCs are interrupts that run at a lower priority than standard interrupts. % DPC Time is a component of % Privileged Time because DPCs are executed in privileged mode. They are counted separately and are not a component of the interrupt counters. This counter displays the average busy time as a percentage of the sample time.
  let ``% DPC Time`` instance =
    { category = "Processor Information"; counter = "% DPC Time"; instance = instance }
  /// % Idle Time: % Idle Time is the percentage of time the processor is idle during the sample interval
  let ``% Idle Time`` instance =
    { category = "Processor Information"; counter = "% Idle Time"; instance = instance }
  /// % Interrupt Time: % Interrupt Time is the time the processor spends receiving and servicing hardware interrupts during sample intervals. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention. Normal thread execution is suspended during interrupts. Most system clocks interrupt the processor every 10 milliseconds, creating a background of interrupt activity. suspends normal thread execution during interrupts. This counter displays the average busy time as a percentage of the sample time.
  let ``% Interrupt Time`` instance =
    { category = "Processor Information"; counter = "% Interrupt Time"; instance = instance }
  /// % Performance Limit: % Performance Limit is the performance the processor guarantees it can provide, as a percentage of the nominal performance of the processor. Performance can be limited by Windows power policy, or by the platform as a result of a power budget, overheating, or other hardware issues.
  let ``% Performance Limit`` instance =
    { category = "Processor Information"; counter = "% Performance Limit"; instance = instance }
  /// % Priority Time: % Priority Time is the percentage of elapsed time that the processor spends executing threads that are not low priority. It is calculated by measuring the percentage of time that the processor spends executing low priority threads or the idle thread and then subtracting that value from 100%. (Each processor has an idle thread to which time is accumulated when no other threads are ready to run). This counter displays the average percentage of busy time observed during the sample interval excluding low priority background work. It should be noted that the accounting calculation of whether the processor is idle is performed at an internal sampling interval of the system clock tick. % Priority Time can therefore underestimate the processor utilization as the processor may be spending a lot of time servicing threads between the system clock sampling interval. Workload based timer applications are one example  of applications  which are more likely to be measured inaccurately as timers are signaled just after the sample is taken.
  let ``% Priority Time`` instance =
    { category = "Processor Information"; counter = "% Priority Time"; instance = instance }
  /// % Privileged Time: % Privileged Time is the percentage of elapsed time that the process threads spent executing code in privileged mode.  When a Windows system service in called, the service will often run in privileged mode to gain access to system-private data. Such data is protected from access by threads executing in user mode. Calls to the system can be explicit or implicit, such as page faults or interrupts. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.
  let ``% Privileged Time`` instance =
    { category = "Processor Information"; counter = "% Privileged Time"; instance = instance }
  /// % Privileged Utility: Privileged Utility is the amount of work a processor is completing while executing in privileged mode, as a percentage of the amount of work the processor could complete if it were running at its nominal performance and never idle. On some processors, Privileged Utility may exceed 100%.
  let ``% Privileged Utility`` instance =
    { category = "Processor Information"; counter = "% Privileged Utility"; instance = instance }
  /// % Processor Performance: Processor Performance is the average performance of the processor while it is executing instructions, as a percentage of the nominal performance of the processor. On some processors, Processor Performance may exceed 100%.
  let ``% Processor Performance`` instance =
    { category = "Processor Information"; counter = "% Processor Performance"; instance = instance }
  /// % Processor Time: % Processor Time is the percentage of elapsed time that the processor spends to execute a non-Idle thread. It is calculated by measuring the percentage of time that the processor spends executing the idle thread and then subtracting that value from 100%. (Each processor has an idle thread to which time is accumulated when no other threads are ready to run). This counter is the primary indicator of processor activity, and displays the average percentage of busy time observed during the sample interval. It should be noted that the accounting calculation of whether the processor is idle is performed at an internal sampling interval of the system clock tick. On todays fast processors, % Processor Time can therefore underestimate the processor utilization as the processor may be spending a lot of time servicing threads between the system clock sampling interval. Workload based timer applications are one example  of applications  which are more likely to be measured inaccurately as timers are signaled just after the sample is taken.
  let ``% Processor Time`` instance =
    { category = "Processor Information"; counter = "% Processor Time"; instance = instance }
  /// % Processor Utility: Processor Utility is the amount of work a processor is completing, as a percentage of the amount of work the processor could complete if it were running at its nominal performance and never idle. On some processors, Processor Utility may exceed 100%.
  let ``% Processor Utility`` instance =
    { category = "Processor Information"; counter = "% Processor Utility"; instance = instance }
  /// % User Time: % User Time is the percentage of elapsed time the processor spends in the user mode. User mode is a restricted processing mode designed for applications, environment subsystems, and integral subsystems.  The alternative, privileged mode, is designed for operating system components and allows direct access to hardware and all memory.  The operating system switches application threads to privileged mode to access operating system services. This counter displays the average busy time as a percentage of the sample time.
  let ``% User Time`` instance =
    { category = "Processor Information"; counter = "% User Time"; instance = instance }
  /// % of Maximum Frequency: % of Maximum Frequency is the percentage of the current processor's maximum frequency.
  let ``% of Maximum Frequency`` instance =
    { category = "Processor Information"; counter = "% of Maximum Frequency"; instance = instance }
  /// Average Idle Time: Average Idle Time is the average idle duration in 100ns units observed between the last two samples.
  let ``Average Idle Time`` instance =
    { category = "Processor Information"; counter = "Average Idle Time"; instance = instance }
  /// C1 Transitions/sec: C1 Transitions/sec is the rate that the CPU enters the C1 low-power idle state. The CPU enters the C1 state when it is sufficiently idle and exits this state on any interrupt. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``C1 Transitions/sec`` instance =
    { category = "Processor Information"; counter = "C1 Transitions/sec"; instance = instance }
  /// C2 Transitions/sec: C2 Transitions/sec is the rate that the CPU enters the C2 low-power idle state. The CPU enters the C2 state when it is sufficiently idle and exits this state on any interrupt. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``C2 Transitions/sec`` instance =
    { category = "Processor Information"; counter = "C2 Transitions/sec"; instance = instance }
  /// C3 Transitions/sec: C3 Transitions/sec is the rate that the CPU enters the C3 low-power idle state. The CPU enters the C3 state when it is sufficiently idle and exits this state on any interrupt. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``C3 Transitions/sec`` instance =
    { category = "Processor Information"; counter = "C3 Transitions/sec"; instance = instance }
  /// Clock Interrupts/sec: Clock Interrupts/sec is the average rate, in incidents per second, at which the processor received and serviced clock tick interrupts. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Clock Interrupts/sec`` instance =
    { category = "Processor Information"; counter = "Clock Interrupts/sec"; instance = instance }
  /// DPC Rate: DPC Rate is the rate at which deferred procedure calls (DPCs) were added to the processors DPC queues between the timer ticks of the processor clock. DPCs are interrupts that run at alower priority than standard interrupts.  Each processor has its own DPC queue. This counter measures the rate that DPCs were added to the queue, not the number of DPCs in the queue. This counter displays the last observed value only; it is not an average.
  let ``DPC Rate`` instance =
    { category = "Processor Information"; counter = "DPC Rate"; instance = instance }
  /// DPCs Queued/sec: DPCs Queued/sec is the average rate, in incidents per second, at which deferred procedure calls (DPCs) were added to the processor's DPC queue. DPCs are interrupts that run at a lower priority than standard interrupts.  Each processor has its own DPC queue. This counter measures the rate that DPCs are added to the queue, not the number of DPCs in the queue.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``DPCs Queued/sec`` instance =
    { category = "Processor Information"; counter = "DPCs Queued/sec"; instance = instance }
  /// Idle Break Events/sec: Idle Break Events/sec is the average rate, in incidents per second, at which the processor wakes from idle.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Idle Break Events/sec`` instance =
    { category = "Processor Information"; counter = "Idle Break Events/sec"; instance = instance }
  /// Interrupts/sec: Interrupts/sec is the average rate, in incidents per second, at which the processor received and serviced hardware interrupts. It does not include deferred procedure calls (DPCs), which are counted separately. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards, and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention. Normal thread execution is suspended. The system clock typically interrupts the processor every 10 milliseconds, creating a background of interrupt activity. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Interrupts/sec`` instance =
    { category = "Processor Information"; counter = "Interrupts/sec"; instance = instance }
  /// Parking Status: Parking Status represents whether a processor is parked or not.
  let ``Parking Status`` instance =
    { category = "Processor Information"; counter = "Parking Status"; instance = instance }
  /// Performance Limit Flags: Performance Limit Flags indicate reasons why the processor performance was limited.
  let ``Performance Limit Flags`` instance =
    { category = "Processor Information"; counter = "Performance Limit Flags"; instance = instance }
  /// Processor Frequency: Processor Frequency is the frequency of the current processor in megahertz.
  let ``Processor Frequency`` instance =
    { category = "Processor Information"; counter = "Processor Frequency"; instance = instance }
  /// Processor State Flags: Processor State Flags
  let ``Processor State Flags`` instance =
    { category = "Processor Information"; counter = "Processor State Flags"; instance = instance }

  let allCounters =
    [ ``% C1 Time``
      ``% C2 Time``
      ``% C3 Time``
      ``% DPC Time``
      ``% Idle Time``
      ``% Interrupt Time``
      ``% Performance Limit``
      ``% Priority Time``
      ``% Privileged Time``
      ``% Privileged Utility``
      ``% Processor Performance``
      ``% Processor Time``
      ``% Processor Utility``
      ``% User Time``
      ``% of Maximum Frequency``
      ``Average Idle Time``
      ``C1 Transitions/sec``
      ``C2 Transitions/sec``
      ``C3 Transitions/sec``
      ``Clock Interrupts/sec``
      ``DPC Rate``
      ``DPCs Queued/sec``
      ``Idle Break Events/sec``
      ``Interrupts/sec``
      ``Parking Status``
      ``Performance Limit Flags``
      ``Processor Frequency``
      ``Processor State Flags``
    ]

/// RAS: VPN counters which keep track of their values since service start
///
/// This performance counter does not have instance based counters
module ``RAS`` =

  [<Literal>]
  let Category = "RAS"

  let PCC = getPCC Category
  /// Bytes Received By Disconnected Clients: Total number of bytes received by all the disconnected clients since service start
  let ``Bytes Received By Disconnected Clients`` =
    { category = "RAS"; counter = "Bytes Received By Disconnected Clients"; instance = NotApplicable }
  /// Bytes Transmitted By Disconnected Clients: Total number of bytes transmitted by all the disconnected clients since service start
  let ``Bytes Transmitted By Disconnected Clients`` =
    { category = "RAS"; counter = "Bytes Transmitted By Disconnected Clients"; instance = NotApplicable }
  /// Failed Authentications: Number of failed authentications since service start
  let ``Failed Authentications`` =
    { category = "RAS"; counter = "Failed Authentications"; instance = NotApplicable }
  /// Max Clients: Maximum number of remote clients connected to server since service start
  let ``Max Clients`` =
    { category = "RAS"; counter = "Max Clients"; instance = NotApplicable }
  /// Total Clients: Total number of cumulative remote clients connected to server since service start
  let ``Total Clients`` =
    { category = "RAS"; counter = "Total Clients"; instance = NotApplicable }

  let allCounters =
    [ ``Bytes Received By Disconnected Clients``
      ``Bytes Transmitted By Disconnected Clients``
      ``Failed Authentications``
      ``Max Clients``
      ``Total Clients``
    ]

/// RAS Port: The RAS Object Type handles individual ports of the RAS device on your system.
///
/// This performance counter does not have instance based counters
module ``RAS Port`` =

  [<Literal>]
  let Category = "RAS Port"

  let PCC = getPCC Category
  /// Alignment Errors: -
  let ``Alignment Errors`` instance =
    { category = "RAS Port"; counter = "Alignment Errors"; instance = instance }
  /// Buffer Overrun Errors: -
  let ``Buffer Overrun Errors`` instance =
    { category = "RAS Port"; counter = "Buffer Overrun Errors"; instance = instance }
  /// Bytes Received: -
  let ``Bytes Received`` instance =
    { category = "RAS Port"; counter = "Bytes Received"; instance = instance }
  /// Bytes Received/Sec: -
  let ``Bytes Received/Sec`` instance =
    { category = "RAS Port"; counter = "Bytes Received/Sec"; instance = instance }
  /// Bytes Transmitted: -
  let ``Bytes Transmitted`` instance =
    { category = "RAS Port"; counter = "Bytes Transmitted"; instance = instance }
  /// Bytes Transmitted/Sec: -
  let ``Bytes Transmitted/Sec`` instance =
    { category = "RAS Port"; counter = "Bytes Transmitted/Sec"; instance = instance }
  /// CRC Errors: -
  let ``CRC Errors`` instance =
    { category = "RAS Port"; counter = "CRC Errors"; instance = instance }
  /// Frames Received: -
  let ``Frames Received`` instance =
    { category = "RAS Port"; counter = "Frames Received"; instance = instance }
  /// Frames Received/Sec: -
  let ``Frames Received/Sec`` instance =
    { category = "RAS Port"; counter = "Frames Received/Sec"; instance = instance }
  /// Frames Transmitted: -
  let ``Frames Transmitted`` instance =
    { category = "RAS Port"; counter = "Frames Transmitted"; instance = instance }
  /// Frames Transmitted/Sec: -
  let ``Frames Transmitted/Sec`` instance =
    { category = "RAS Port"; counter = "Frames Transmitted/Sec"; instance = instance }
  /// Percent Compression In: -
  let ``Percent Compression In`` instance =
    { category = "RAS Port"; counter = "Percent Compression In"; instance = instance }
  /// Percent Compression Out: -
  let ``Percent Compression Out`` instance =
    { category = "RAS Port"; counter = "Percent Compression Out"; instance = instance }
  /// Serial Overrun Errors: -
  let ``Serial Overrun Errors`` instance =
    { category = "RAS Port"; counter = "Serial Overrun Errors"; instance = instance }
  /// Timeout Errors: -
  let ``Timeout Errors`` instance =
    { category = "RAS Port"; counter = "Timeout Errors"; instance = instance }
  /// Total Errors: -
  let ``Total Errors`` instance =
    { category = "RAS Port"; counter = "Total Errors"; instance = instance }
  /// Total Errors/Sec: -
  let ``Total Errors/Sec`` instance =
    { category = "RAS Port"; counter = "Total Errors/Sec"; instance = instance }

  let allCounters =
    [ ``Alignment Errors``
      ``Buffer Overrun Errors``
      ``Bytes Received``
      ``Bytes Received/Sec``
      ``Bytes Transmitted``
      ``Bytes Transmitted/Sec``
      ``CRC Errors``
      ``Frames Received``
      ``Frames Received/Sec``
      ``Frames Transmitted``
      ``Frames Transmitted/Sec``
      ``Percent Compression In``
      ``Percent Compression Out``
      ``Serial Overrun Errors``
      ``Timeout Errors``
      ``Total Errors``
      ``Total Errors/Sec``
    ]

/// RAS Total: The RAS Object Type handles all combined ports of the RAS device on your system.
///
/// This performance counter does not have instance based counters
module ``RAS Total`` =

  [<Literal>]
  let Category = "RAS Total"

  let PCC = getPCC Category
  /// Alignment Errors: The total number of Alignment Errors for this connection.  Alignment Errors occur when a byte received is different from the byte expected.
  let ``Alignment Errors`` =
    { category = "RAS Total"; counter = "Alignment Errors"; instance = NotApplicable }
  /// Buffer Overrun Errors: The total number of Buffer Overrun Errors for this connection.  Buffer Overrun Errors when the software cannot handle the rate at which data is received.
  let ``Buffer Overrun Errors`` =
    { category = "RAS Total"; counter = "Buffer Overrun Errors"; instance = NotApplicable }
  /// Bytes Received: The number of bytes received total for this connection.
  let ``Bytes Received`` =
    { category = "RAS Total"; counter = "Bytes Received"; instance = NotApplicable }
  /// Bytes Received/Sec: The number of bytes received per second.
  let ``Bytes Received/Sec`` =
    { category = "RAS Total"; counter = "Bytes Received/Sec"; instance = NotApplicable }
  /// Bytes Transmitted: The number of bytes transmitted total for this connection.
  let ``Bytes Transmitted`` =
    { category = "RAS Total"; counter = "Bytes Transmitted"; instance = NotApplicable }
  /// Bytes Transmitted/Sec: The number of bytes transmitted per second.
  let ``Bytes Transmitted/Sec`` =
    { category = "RAS Total"; counter = "Bytes Transmitted/Sec"; instance = NotApplicable }
  /// CRC Errors: The total number of CRC Errors for this connection.  CRC Errors occur when the frame received contains erroneous data.
  let ``CRC Errors`` =
    { category = "RAS Total"; counter = "CRC Errors"; instance = NotApplicable }
  /// Frames Received: The number of data frames received total for this connection.
  let ``Frames Received`` =
    { category = "RAS Total"; counter = "Frames Received"; instance = NotApplicable }
  /// Frames Received/Sec: The number of frames received per second.
  let ``Frames Received/Sec`` =
    { category = "RAS Total"; counter = "Frames Received/Sec"; instance = NotApplicable }
  /// Frames Transmitted: The number of data frames transmitted total for this connection.
  let ``Frames Transmitted`` =
    { category = "RAS Total"; counter = "Frames Transmitted"; instance = NotApplicable }
  /// Frames Transmitted/Sec: The number of frames transmitted per second.
  let ``Frames Transmitted/Sec`` =
    { category = "RAS Total"; counter = "Frames Transmitted/Sec"; instance = NotApplicable }
  /// Percent Compression In: The compression ratio for bytes being received.
  let ``Percent Compression In`` =
    { category = "RAS Total"; counter = "Percent Compression In"; instance = NotApplicable }
  /// Percent Compression Out: The compression ratio for bytes being transmitted.
  let ``Percent Compression Out`` =
    { category = "RAS Total"; counter = "Percent Compression Out"; instance = NotApplicable }
  /// Serial Overrun Errors: The total number of Serial Overrun Errors for this connection.  Serial Overrun Errors occur when the hardware cannot handle the rate at which data is received.
  let ``Serial Overrun Errors`` =
    { category = "RAS Total"; counter = "Serial Overrun Errors"; instance = NotApplicable }
  /// Timeout Errors: The total number of Timeout Errors for this connection.  Timeout Errors occur when an expected is not received in time.
  let ``Timeout Errors`` =
    { category = "RAS Total"; counter = "Timeout Errors"; instance = NotApplicable }
  /// Total Connections: The total number of Remote Access connections.
  let ``Total Connections`` =
    { category = "RAS Total"; counter = "Total Connections"; instance = NotApplicable }
  /// Total Errors: The total number of CRC, Timeout, Serial Overrun, Alignment, and Buffer Overrun Errors for this connection.
  let ``Total Errors`` =
    { category = "RAS Total"; counter = "Total Errors"; instance = NotApplicable }
  /// Total Errors/Sec: The total number of CRC, Timeout, Serial Overrun, Alignment, and Buffer Overrun Errors per second.
  let ``Total Errors/Sec`` =
    { category = "RAS Total"; counter = "Total Errors/Sec"; instance = NotApplicable }

  let allCounters =
    [ ``Alignment Errors``
      ``Buffer Overrun Errors``
      ``Bytes Received``
      ``Bytes Received/Sec``
      ``Bytes Transmitted``
      ``Bytes Transmitted/Sec``
      ``CRC Errors``
      ``Frames Received``
      ``Frames Received/Sec``
      ``Frames Transmitted``
      ``Frames Transmitted/Sec``
      ``Percent Compression In``
      ``Percent Compression Out``
      ``Serial Overrun Errors``
      ``Timeout Errors``
      ``Total Connections``
      ``Total Errors``
      ``Total Errors/Sec``
    ]

/// ReadyBoost Cache: Displays performance statistics about ReadyBoost Caches.
///
/// This performance counter does not have instance based counters
module ``ReadyBoost Cache`` =

  [<Literal>]
  let Category = "ReadyBoost Cache"

  let PCC = getPCC Category
  /// Bytes cached: The total (uncompressed) amount of data currently stored in ReadyBoost caches.
  let ``Bytes cached`` =
    { category = "ReadyBoost Cache"; counter = "Bytes cached"; instance = NotApplicable }
  /// Cache read bytes/sec: Bytes of I/Os satisfied from ReadyBoost caches per second.
  let ``Cache read bytes/sec`` =
    { category = "ReadyBoost Cache"; counter = "Cache read bytes/sec"; instance = NotApplicable }
  /// Cache reads/sec: Number of I/Os satisfied from ReadyBoost caches per second.
  let ``Cache reads/sec`` =
    { category = "ReadyBoost Cache"; counter = "Cache reads/sec"; instance = NotApplicable }
  /// Cache space used: Amount of space in bytes taken by data cached in ReadyBoost caches.
  let ``Cache space used`` =
    { category = "ReadyBoost Cache"; counter = "Cache space used"; instance = NotApplicable }
  /// Compression Ratio: (Cache space used) / (Bytes cached)
  let ``Compression Ratio`` =
    { category = "ReadyBoost Cache"; counter = "Compression Ratio"; instance = NotApplicable }
  /// Skipped read bytes/sec: Bytes of read I/Os ignored by ReadyBoost due to policy.
  let ``Skipped read bytes/sec`` =
    { category = "ReadyBoost Cache"; counter = "Skipped read bytes/sec"; instance = NotApplicable }
  /// Skipped reads/sec: Number of read I/Os ignored by ReadyBoost due to policy.
  let ``Skipped reads/sec`` =
    { category = "ReadyBoost Cache"; counter = "Skipped reads/sec"; instance = NotApplicable }
  /// Total cache size bytes: Total size, in bytes, of all caches regardless of how much data they contain.
  let ``Total cache size bytes`` =
    { category = "ReadyBoost Cache"; counter = "Total cache size bytes"; instance = NotApplicable }
  /// Total read bytes/sec: Bytes of read I/Os that are received by ReadyBoost. This counter includes all reads whether or not they were satisfied by ReadyBoost caches.
  let ``Total read bytes/sec`` =
    { category = "ReadyBoost Cache"; counter = "Total read bytes/sec"; instance = NotApplicable }
  /// Total reads/sec: Number of read I/Os that are received by ReadyBoost. This counter includes all reads whether or not they were satisfied by ReadyBoost caches.
  let ``Total reads/sec`` =
    { category = "ReadyBoost Cache"; counter = "Total reads/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Bytes cached``
      ``Cache read bytes/sec``
      ``Cache reads/sec``
      ``Cache space used``
      ``Compression Ratio``
      ``Skipped read bytes/sec``
      ``Skipped reads/sec``
      ``Total cache size bytes``
      ``Total read bytes/sec``
      ``Total reads/sec``
    ]

/// Redirector: The Redirector performance object consists of counter that monitor network connections originating at the local computer.
///
/// This performance counter does not have instance based counters
module ``Redirector`` =

  [<Literal>]
  let Category = "Redirector"

  let PCC = getPCC Category
  /// Bytes Received/sec: Bytes Received/sec is the rate of bytes coming in to the Redirector from the network.  It includes all application data as well as network protocol information (such as packet headers).
  let ``Bytes Received/sec`` =
    { category = "Redirector"; counter = "Bytes Received/sec"; instance = NotApplicable }
  /// Bytes Total/sec: Bytes Total/sec is the rate the Redirector is processing data bytes.  This includes all application and file data in addition to protocol information such as packet headers.
  let ``Bytes Total/sec`` =
    { category = "Redirector"; counter = "Bytes Total/sec"; instance = NotApplicable }
  /// Bytes Transmitted/sec: Bytes Transmitted/sec is the rate at which bytes are leaving the Redirector to the network.  It includes all application data as well as network protocol information (such as packet headers and the like).
  let ``Bytes Transmitted/sec`` =
    { category = "Redirector"; counter = "Bytes Transmitted/sec"; instance = NotApplicable }
  /// Connects Core: Connects Core counts the number of connections you have to servers running the original MS-Net SMB protocol, including MS-Net itself and Xenix and VAX's.
  let ``Connects Core`` =
    { category = "Redirector"; counter = "Connects Core"; instance = NotApplicable }
  /// Connects Lan Manager 2.0: Connects LAN Manager 2.0 counts connections to LAN Manager 2.0 servers, including LMX servers.
  let ``Connects Lan Manager 2.0`` =
    { category = "Redirector"; counter = "Connects Lan Manager 2.0"; instance = NotApplicable }
  /// Connects Lan Manager 2.1: Connects LAN Manager 2.1 counts connections to LAN Manager 2.1 servers, including LMX servers.
  let ``Connects Lan Manager 2.1`` =
    { category = "Redirector"; counter = "Connects Lan Manager 2.1"; instance = NotApplicable }
  /// Connects Windows NT: Connects Windows NT counts the connections to Windows 2000 or earlier computers.
  let ``Connects Windows NT`` =
    { category = "Redirector"; counter = "Connects Windows NT"; instance = NotApplicable }
  /// Current Commands: Current Commands counter indicates the number of pending commands from the local computer to all destination servers.  If the Current Commands counter shows a high number and the local computer is idle, this may indicate a network-related problem or a redirector bottleneck on the local computer.
  let ``Current Commands`` =
    { category = "Redirector"; counter = "Current Commands"; instance = NotApplicable }
  /// File Data Operations/sec: File Data Operations/sec is the rate at which the Redirector is processing data operations. One operation should include many bytes, since each operation has overhead. The efficiency of this path can be determined by dividing the Bytes/sec by this counter to obtain the average number of bytes transferred per operation.
  let ``File Data Operations/sec`` =
    { category = "Redirector"; counter = "File Data Operations/sec"; instance = NotApplicable }
  /// File Read Operations/sec: File Read Operations/sec is the rate at which applications are asking the Redirector for data. Each call to a file system or similar Application Program Interface (API) call counts as one operation.
  let ``File Read Operations/sec`` =
    { category = "Redirector"; counter = "File Read Operations/sec"; instance = NotApplicable }
  /// File Write Operations/sec: File Write Operations/sec is the rate at which applications are sending data to the Redirector. Each call to a file system or similar Application Program Interface (API) call counts as one operation.
  let ``File Write Operations/sec`` =
    { category = "Redirector"; counter = "File Write Operations/sec"; instance = NotApplicable }
  /// Network Errors/sec: Network Errors/sec is the rate at which serious unexpected errors are occurring. Such errors generally indicate that the Redirector and one or more Servers are having serious communication difficulties. For example an SMB (Server Message Block) protocol error is a Network Error. An entry is written to the System Event Log and provide details.
  let ``Network Errors/sec`` =
    { category = "Redirector"; counter = "Network Errors/sec"; instance = NotApplicable }
  /// Packets Received/sec: Packets Received/sec is the rate at which the Redirector is receiving packets (also called SMBs or Server Message Blocks).  Network transmissions are divided into packets.  The average number of bytes received in a packet can be obtained by dividing Bytes Received/sec by this counter.  Some packets received might not contain incoming data (for example an acknowledgment to a write made by the Redirector would count as an incoming packet).
  let ``Packets Received/sec`` =
    { category = "Redirector"; counter = "Packets Received/sec"; instance = NotApplicable }
  /// Packets Transmitted/sec: Packets Transmitted/sec is the rate at which the Redirector is sending packets (also called SMBs or Server Message Blocks).  Network transmissions are divided into packets.  The average number of bytes transmitted in a packet can be obtained by dividing Bytes Transmitted/sec by this counter.
  let ``Packets Transmitted/sec`` =
    { category = "Redirector"; counter = "Packets Transmitted/sec"; instance = NotApplicable }
  /// Packets/sec: Packets/sec is the rate the Redirector is processing data packets.  One packet includes (hopefully) many bytes.  We say hopefully here because each packet has protocol overhead.  You can determine the efficiency of this path by dividing the Bytes/sec by this counter to determine the average number of bytes transferred/packet.  You can also divide this counter by Operations/sec to determine the average number of packets per operation, another measure of efficiency.
  let ``Packets/sec`` =
    { category = "Redirector"; counter = "Packets/sec"; instance = NotApplicable }
  /// Read Bytes Cache/sec: Read Bytes Cache/sec is the rate at which applications are accessing the file system cache by using the Redirector.  Some of these data requests are satisfied by retrieving the data from the cache.  Requests that miss the Cache cause a page fault (see Read Bytes Paging/sec).
  let ``Read Bytes Cache/sec`` =
    { category = "Redirector"; counter = "Read Bytes Cache/sec"; instance = NotApplicable }
  /// Read Bytes Network/sec: Read Bytes Network/sec is the rate at which applications are reading data across the network. This occurs when data sought in the file system cache is not found there and must be retrieved from the network.  Dividing this value by Bytes Received/sec indicates the proportion of application data traveling across the network. (see Bytes Received/sec).
  let ``Read Bytes Network/sec`` =
    { category = "Redirector"; counter = "Read Bytes Network/sec"; instance = NotApplicable }
  /// Read Bytes Non-Paging/sec: Read Bytes Non-Paging/sec are those bytes read by the Redirector in response to normal file requests by an application when they are redirected to come from another computer.  In addition to file requests, this counter includes other methods of reading across the network such as Named Pipes and Transactions.  This counter does not count network protocol information, just application data.
  let ``Read Bytes Non-Paging/sec`` =
    { category = "Redirector"; counter = "Read Bytes Non-Paging/sec"; instance = NotApplicable }
  /// Read Bytes Paging/sec: Read Bytes Paging/sec is the rate at which the Redirector is attempting to read bytes in response to page faults.  Page faults are caused by loading of modules (such as programs and libraries), by a miss in the Cache (see Read Bytes Cache/sec), or by files directly mapped into the address space of applications (a high-performance feature of Windows NT).
  let ``Read Bytes Paging/sec`` =
    { category = "Redirector"; counter = "Read Bytes Paging/sec"; instance = NotApplicable }
  /// Read Operations Random/sec: Read Operations Random/sec counts the rate at which, on a file-by-file basis, reads are made that are not sequential.  If a read is made using a particular file handle, and then is followed by another read that is not immediately the contiguous next byte, this counter is incremented by one.
  let ``Read Operations Random/sec`` =
    { category = "Redirector"; counter = "Read Operations Random/sec"; instance = NotApplicable }
  /// Read Packets Small/sec: Read Packets Small/sec is the rate at which reads less than one-fourth of the server's negotiated buffer size are made by applications.  Too many of these could indicate a waste of buffers on the server.  This counter is incremented once for each read. It does not count packets.
  let ``Read Packets Small/sec`` =
    { category = "Redirector"; counter = "Read Packets Small/sec"; instance = NotApplicable }
  /// Read Packets/sec: Read Packets/sec is the rate at which read packets are being placed on the network.  Each time a single packet is sent with a request to read data remotely, this counter is incremented by one.
  let ``Read Packets/sec`` =
    { category = "Redirector"; counter = "Read Packets/sec"; instance = NotApplicable }
  /// Reads Denied/sec: Reads Denied/sec is the rate at which the server is unable to accommodate requests for Raw Reads.  When a read is much larger than the server's negotiated buffer size, the Redirector requests a Raw Read which, if granted, would permit the transfer of the data without lots of protocol overhead on each packet.  To accomplish this the server must lock out other requests, so the request is denied if the server is really busy.
  let ``Reads Denied/sec`` =
    { category = "Redirector"; counter = "Reads Denied/sec"; instance = NotApplicable }
  /// Reads Large/sec: Reads Large/sec is the rate at which reads over 2 times the server's negotiated buffer size are made by applications.  Too many of these could place a strain on server resources.  This counter is incremented once for each read. It does not count packets.
  let ``Reads Large/sec`` =
    { category = "Redirector"; counter = "Reads Large/sec"; instance = NotApplicable }
  /// Server Disconnects: Server Disconnects counts the number of times a Server has disconnected your Redirector.  See also Server Reconnects.
  let ``Server Disconnects`` =
    { category = "Redirector"; counter = "Server Disconnects"; instance = NotApplicable }
  /// Server Reconnects: Server Reconnects counts the number of times your Redirector has had to reconnect to a server in order to complete a new active request.  You can be disconnected by the Server if you remain inactive for too long.  Locally even if all your remote files are closed, the Redirector will keep your connections intact for (nominally) ten minutes.  Such inactive connections are called Dormant Connections.  Reconnecting is expensive in time.
  let ``Server Reconnects`` =
    { category = "Redirector"; counter = "Server Reconnects"; instance = NotApplicable }
  /// Server Sessions: Server Sessions counts the total number of security objects the Redirector has managed.  For example, a logon to a server followed by a network access to the same server will establish one connection, but two sessions.
  let ``Server Sessions`` =
    { category = "Redirector"; counter = "Server Sessions"; instance = NotApplicable }
  /// Server Sessions Hung: Server Sessions Hung counts the number of active sessions that are timed out and unable to proceed due to a lack of response from the remote server.
  let ``Server Sessions Hung`` =
    { category = "Redirector"; counter = "Server Sessions Hung"; instance = NotApplicable }
  /// Write Bytes Cache/sec: Write Bytes Cache/sec is the rate at which applications on your computer are writing to the file system cache by using the Redirector.  The data might not leave your computer immediately; it can be retained in the cache for further modification before being written to the network.  This saves network traffic.  Each write of a byte into the cache is counted here.
  let ``Write Bytes Cache/sec`` =
    { category = "Redirector"; counter = "Write Bytes Cache/sec"; instance = NotApplicable }
  /// Write Bytes Network/sec: Write Bytes Network/sec is the rate at which applications are writing data across the network. This occurs when the file system cache is bypassed, such as for Named Pipes or Transactions, or when the cache writes the bytes to disk to make room for other data.  Dividing this counter by Bytes Transmitted/sec will indicate the proportion of application data being to the network (see Transmitted Bytes/sec).
  let ``Write Bytes Network/sec`` =
    { category = "Redirector"; counter = "Write Bytes Network/sec"; instance = NotApplicable }
  /// Write Bytes Non-Paging/sec: Write Bytes Non-Paging/sec is the rate at which bytes are written by the Redirector in response to normal file outputs by an application when they are redirected to another computer.  In addition to file requests, this count includes other methods of writing across the network, such as Named Pipes and Transactions.  This counter does not count network protocol information, just application data.
  let ``Write Bytes Non-Paging/sec`` =
    { category = "Redirector"; counter = "Write Bytes Non-Paging/sec"; instance = NotApplicable }
  /// Write Bytes Paging/sec: Write Bytes Paging/sec is the rate at which the Redirector is attempting to write bytes changed in the pages being used by applications.  The program data changed by modules (such as programs and libraries) that were loaded over the network are 'paged out' when no longer needed.  Other output pages come from the file system cache (see Write Bytes Cache/sec).
  let ``Write Bytes Paging/sec`` =
    { category = "Redirector"; counter = "Write Bytes Paging/sec"; instance = NotApplicable }
  /// Write Operations Random/sec: Write Operations Random/sec is the rate at which, on a file-by-file basis, writes are made that are not sequential.  If a write is made using a particular file handle, and then is followed by another write that is not immediately the next contiguous byte, this counter is incremented by one.
  let ``Write Operations Random/sec`` =
    { category = "Redirector"; counter = "Write Operations Random/sec"; instance = NotApplicable }
  /// Write Packets Small/sec: Write Packets Small/sec is the rate at which writes are made by applications that are less than one-fourth of the server's negotiated buffer size.  Too many of these could indicate a waste of buffers on the server.  This counter is incremented once for each write: it counts writes, not packets.
  let ``Write Packets Small/sec`` =
    { category = "Redirector"; counter = "Write Packets Small/sec"; instance = NotApplicable }
  /// Write Packets/sec: Write Packets/sec is the rate at which writes are being sent to the network.  Each time a single packet is sent with a request to write remote data, this counter is incremented by one.
  let ``Write Packets/sec`` =
    { category = "Redirector"; counter = "Write Packets/sec"; instance = NotApplicable }
  /// Writes Denied/sec: Writes Denied/sec is the rate at which the server is unable to accommodate requests for Raw Writes.  When a write is much larger than the server's negotiated buffer size, the Redirector requests a Raw Write which, if granted, would permit the transfer of the data without lots of protocol overhead on each packet.  To accomplish this the server must lock out other requests, so the request is denied if the server is really busy.
  let ``Writes Denied/sec`` =
    { category = "Redirector"; counter = "Writes Denied/sec"; instance = NotApplicable }
  /// Writes Large/sec: Writes Large/sec is the rate at which writes are made by applications that are over 2 times the server's negotiated buffer size.  Too many of these could place a strain on server resources.  This counter is incremented once for each write: it counts writes, not packets.
  let ``Writes Large/sec`` =
    { category = "Redirector"; counter = "Writes Large/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Bytes Received/sec``
      ``Bytes Total/sec``
      ``Bytes Transmitted/sec``
      ``Connects Core``
      ``Connects Lan Manager 2.0``
      ``Connects Lan Manager 2.1``
      ``Connects Windows NT``
      ``Current Commands``
      ``File Data Operations/sec``
      ``File Read Operations/sec``
      ``File Write Operations/sec``
      ``Network Errors/sec``
      ``Packets Received/sec``
      ``Packets Transmitted/sec``
      ``Packets/sec``
      ``Read Bytes Cache/sec``
      ``Read Bytes Network/sec``
      ``Read Bytes Non-Paging/sec``
      ``Read Bytes Paging/sec``
      ``Read Operations Random/sec``
      ``Read Packets Small/sec``
      ``Read Packets/sec``
      ``Reads Denied/sec``
      ``Reads Large/sec``
      ``Server Disconnects``
      ``Server Reconnects``
      ``Server Sessions``
      ``Server Sessions Hung``
      ``Write Bytes Cache/sec``
      ``Write Bytes Network/sec``
      ``Write Bytes Non-Paging/sec``
      ``Write Bytes Paging/sec``
      ``Write Operations Random/sec``
      ``Write Packets Small/sec``
      ``Write Packets/sec``
      ``Writes Denied/sec``
      ``Writes Large/sec``
    ]

/// RemoteFX Graphics: The RemoteFX encoding performance object consists of counters that measure the performance of RemoteFX graphics encoding
///
/// This performance counter does not have instance based counters
module ``RemoteFX Graphics`` =

  [<Literal>]
  let Category = "RemoteFX Graphics"

  let PCC = getPCC Category
  /// Average Encoding Time: -
  let ``Average Encoding Time`` instance =
    { category = "RemoteFX Graphics"; counter = "Average Encoding Time"; instance = instance }
  /// Frame Quality: -
  let ``Frame Quality`` instance =
    { category = "RemoteFX Graphics"; counter = "Frame Quality"; instance = instance }
  /// Frames Skipped/Second - Insufficient Client Resources: -
  let ``Frames Skipped/Second - Insufficient Client Resources`` instance =
    { category = "RemoteFX Graphics"; counter = "Frames Skipped/Second - Insufficient Client Resources"; instance = instance }
  /// Frames Skipped/Second - Insufficient Network Resources: -
  let ``Frames Skipped/Second - Insufficient Network Resources`` instance =
    { category = "RemoteFX Graphics"; counter = "Frames Skipped/Second - Insufficient Network Resources"; instance = instance }
  /// Frames Skipped/Second - Insufficient Server Resources: -
  let ``Frames Skipped/Second - Insufficient Server Resources`` instance =
    { category = "RemoteFX Graphics"; counter = "Frames Skipped/Second - Insufficient Server Resources"; instance = instance }
  /// Graphics Compression ratio: -
  let ``Graphics Compression ratio`` instance =
    { category = "RemoteFX Graphics"; counter = "Graphics Compression ratio"; instance = instance }
  /// Input Frames/Second: -
  let ``Input Frames/Second`` instance =
    { category = "RemoteFX Graphics"; counter = "Input Frames/Second"; instance = instance }
  /// Output Frames/Second: -
  let ``Output Frames/Second`` instance =
    { category = "RemoteFX Graphics"; counter = "Output Frames/Second"; instance = instance }
  /// Source Frames/Second: -
  let ``Source Frames/Second`` instance =
    { category = "RemoteFX Graphics"; counter = "Source Frames/Second"; instance = instance }

  let allCounters =
    [ ``Average Encoding Time``
      ``Frame Quality``
      ``Frames Skipped/Second - Insufficient Client Resources``
      ``Frames Skipped/Second - Insufficient Network Resources``
      ``Frames Skipped/Second - Insufficient Server Resources``
      ``Graphics Compression ratio``
      ``Input Frames/Second``
      ``Output Frames/Second``
      ``Source Frames/Second``
    ]

/// RemoteFX Network: This is counter set for the per session RemoteFX network counters
///
/// This performance counter does not have instance based counters
module ``RemoteFX Network`` =

  [<Literal>]
  let Category = "RemoteFX Network"

  let PCC = getPCC Category
  /// Base TCP RTT: -
  let ``Base TCP RTT`` instance =
    { category = "RemoteFX Network"; counter = "Base TCP RTT"; instance = instance }
  /// Base UDP RTT: -
  let ``Base UDP RTT`` instance =
    { category = "RemoteFX Network"; counter = "Base UDP RTT"; instance = instance }
  /// Current TCP Bandwidth: -
  let ``Current TCP Bandwidth`` instance =
    { category = "RemoteFX Network"; counter = "Current TCP Bandwidth"; instance = instance }
  /// Current TCP RTT: -
  let ``Current TCP RTT`` instance =
    { category = "RemoteFX Network"; counter = "Current TCP RTT"; instance = instance }
  /// Current UDP Bandwidth: -
  let ``Current UDP Bandwidth`` instance =
    { category = "RemoteFX Network"; counter = "Current UDP Bandwidth"; instance = instance }
  /// Current UDP RTT: -
  let ``Current UDP RTT`` instance =
    { category = "RemoteFX Network"; counter = "Current UDP RTT"; instance = instance }
  /// FEC Rate: -
  let ``FEC Rate`` instance =
    { category = "RemoteFX Network"; counter = "FEC Rate"; instance = instance }
  /// Loss Rate: -
  let ``Loss Rate`` instance =
    { category = "RemoteFX Network"; counter = "Loss Rate"; instance = instance }
  /// Retransmission Rate: -
  let ``Retransmission Rate`` instance =
    { category = "RemoteFX Network"; counter = "Retransmission Rate"; instance = instance }
  /// Sent Rate P0: -
  let ``Sent Rate P0`` instance =
    { category = "RemoteFX Network"; counter = "Sent Rate P0"; instance = instance }
  /// Sent Rate P1: -
  let ``Sent Rate P1`` instance =
    { category = "RemoteFX Network"; counter = "Sent Rate P1"; instance = instance }
  /// Sent Rate P2: -
  let ``Sent Rate P2`` instance =
    { category = "RemoteFX Network"; counter = "Sent Rate P2"; instance = instance }
  /// Sent Rate P3: -
  let ``Sent Rate P3`` instance =
    { category = "RemoteFX Network"; counter = "Sent Rate P3"; instance = instance }
  /// TCP Received Rate: -
  let ``TCP Received Rate`` instance =
    { category = "RemoteFX Network"; counter = "TCP Received Rate"; instance = instance }
  /// TCP Sent Rate: -
  let ``TCP Sent Rate`` instance =
    { category = "RemoteFX Network"; counter = "TCP Sent Rate"; instance = instance }
  /// Total Received Bytes: -
  let ``Total Received Bytes`` instance =
    { category = "RemoteFX Network"; counter = "Total Received Bytes"; instance = instance }
  /// Total Received Rate: -
  let ``Total Received Rate`` instance =
    { category = "RemoteFX Network"; counter = "Total Received Rate"; instance = instance }
  /// Total Sent Bytes: -
  let ``Total Sent Bytes`` instance =
    { category = "RemoteFX Network"; counter = "Total Sent Bytes"; instance = instance }
  /// Total Sent Rate: -
  let ``Total Sent Rate`` instance =
    { category = "RemoteFX Network"; counter = "Total Sent Rate"; instance = instance }
  /// UDP Packets Received/sec: -
  let ``UDP Packets Received/sec`` instance =
    { category = "RemoteFX Network"; counter = "UDP Packets Received/sec"; instance = instance }
  /// UDP Packets Sent/sec: -
  let ``UDP Packets Sent/sec`` instance =
    { category = "RemoteFX Network"; counter = "UDP Packets Sent/sec"; instance = instance }
  /// UDP Received Rate: -
  let ``UDP Received Rate`` instance =
    { category = "RemoteFX Network"; counter = "UDP Received Rate"; instance = instance }
  /// UDP Sent Rate: -
  let ``UDP Sent Rate`` instance =
    { category = "RemoteFX Network"; counter = "UDP Sent Rate"; instance = instance }

  let allCounters =
    [ ``Base TCP RTT``
      ``Base UDP RTT``
      ``Current TCP Bandwidth``
      ``Current TCP RTT``
      ``Current UDP Bandwidth``
      ``Current UDP RTT``
      ``FEC Rate``
      ``Loss Rate``
      ``Retransmission Rate``
      ``Sent Rate P0``
      ``Sent Rate P1``
      ``Sent Rate P2``
      ``Sent Rate P3``
      ``TCP Received Rate``
      ``TCP Sent Rate``
      ``Total Received Bytes``
      ``Total Received Rate``
      ``Total Sent Bytes``
      ``Total Sent Rate``
      ``UDP Packets Received/sec``
      ``UDP Packets Sent/sec``
      ``UDP Received Rate``
      ``UDP Sent Rate``
    ]

/// RemoteFX Root GPU Management: Displays RemoteFX Root GPU Management Counters
///
/// This performance counter does not have instance based counters
module ``RemoteFX Root GPU Management`` =

  [<Literal>]
  let Category = "RemoteFX Root GPU Management"

  let PCC = getPCC Category
  /// Resources: TDR timeouts in server GPUs: -
  let ``Resources: TDR timeouts in server GPUs`` instance =
    { category = "RemoteFX Root GPU Management"; counter = "Resources: TDR timeouts in server GPUs"; instance = instance }
  /// Resources: VMs running RemoteFX: -
  let ``Resources: VMs running RemoteFX`` instance =
    { category = "RemoteFX Root GPU Management"; counter = "Resources: VMs running RemoteFX"; instance = instance }
  /// VRAM: Available MB per GPU: -
  let ``VRAM: Available MB per GPU`` instance =
    { category = "RemoteFX Root GPU Management"; counter = "VRAM: Available MB per GPU"; instance = instance }
  /// VRAM: Reserved  % per GPU: -
  let ``VRAM: Reserved  % per GPU`` instance =
    { category = "RemoteFX Root GPU Management"; counter = "VRAM: Reserved  % per GPU"; instance = instance }

  let allCounters =
    [ ``Resources: TDR timeouts in server GPUs``
      ``Resources: VMs running RemoteFX``
      ``VRAM: Available MB per GPU``
      ``VRAM: Reserved  % per GPU``
    ]

/// RemoteFX VM vGPU Management: Displays RemoteFX VM vGPU Management Counters
///
/// This performance counter does not have instance based counters
module ``RemoteFX VM vGPU Management`` =

  [<Literal>]
  let Category = "RemoteFX VM vGPU Management"

  let PCC = getPCC Category
  /// Resources: TDRs local to VMs: -
  let ``Resources: TDRs local to VMs`` instance =
    { category = "RemoteFX VM vGPU Management"; counter = "Resources: TDRs local to VMs"; instance = instance }
  /// Resources: TDRs propagated by Server: -
  let ``Resources: TDRs propagated by Server`` instance =
    { category = "RemoteFX VM vGPU Management"; counter = "Resources: TDRs propagated by Server"; instance = instance }

  let allCounters =
    [ ``Resources: TDRs local to VMs``
      ``Resources: TDRs propagated by Server``
    ]

/// SMB Client Shares: This counter set displays information about server shares that are being accessed by the client using SMB protocol version 2 or higher.
///
/// This performance counter does not have non-instance based counters
module ``SMB Client Shares`` =

  [<Literal>]
  let Category = "SMB Client Shares"

  let PCC = getPCC Category
  /// Avg. Bytes/Read: The average number of bytes per read request.
  let ``Avg. Bytes/Read`` instance =
    { category = "SMB Client Shares"; counter = "Avg. Bytes/Read"; instance = instance }
  /// Avg. Bytes/Write: The average number of bytes per write request.
  let ``Avg. Bytes/Write`` instance =
    { category = "SMB Client Shares"; counter = "Avg. Bytes/Write"; instance = instance }
  /// Avg. Data Bytes/Request: The average number of bytes per read or write request.
  let ``Avg. Data Bytes/Request`` instance =
    { category = "SMB Client Shares"; counter = "Avg. Data Bytes/Request"; instance = instance }
  /// Avg. Data Queue Length: The average number of both read and write requests that were queued for this share.
  let ``Avg. Data Queue Length`` instance =
    { category = "SMB Client Shares"; counter = "Avg. Data Queue Length"; instance = instance }
  /// Avg. Read Queue Length: The average number of read requests that were queued for this share.
  let ``Avg. Read Queue Length`` instance =
    { category = "SMB Client Shares"; counter = "Avg. Read Queue Length"; instance = instance }
  /// Avg. Write Queue Length: The average number of write requests that were queued for this share.
  let ``Avg. Write Queue Length`` instance =
    { category = "SMB Client Shares"; counter = "Avg. Write Queue Length"; instance = instance }
  /// Avg. sec/Data Request: The average latency between the time a read or write request is sent and when its response is received.
  let ``Avg. sec/Data Request`` instance =
    { category = "SMB Client Shares"; counter = "Avg. sec/Data Request"; instance = instance }
  /// Avg. sec/Read: The average latency between the time a read request is sent and when its response is received.
  let ``Avg. sec/Read`` instance =
    { category = "SMB Client Shares"; counter = "Avg. sec/Read"; instance = instance }
  /// Avg. sec/Write: The average latency between the time a write request is sent and when its response is received.
  let ``Avg. sec/Write`` instance =
    { category = "SMB Client Shares"; counter = "Avg. sec/Write"; instance = instance }
  /// Credit Stalls/sec: The number of requests per second delayed based on insufficient credits for this share.
  let ``Credit Stalls/sec`` instance =
    { category = "SMB Client Shares"; counter = "Credit Stalls/sec"; instance = instance }
  /// Current Data Queue Length: The current number of read or write requests outstanding on this share.
  let ``Current Data Queue Length`` instance =
    { category = "SMB Client Shares"; counter = "Current Data Queue Length"; instance = instance }
  /// Data Bytes/sec: The rate at which bytes are being read or written to this share.
  let ``Data Bytes/sec`` instance =
    { category = "SMB Client Shares"; counter = "Data Bytes/sec"; instance = instance }
  /// Data Requests/sec: The rate at which read or write requests are being sent to this share.
  let ``Data Requests/sec`` instance =
    { category = "SMB Client Shares"; counter = "Data Requests/sec"; instance = instance }
  /// Metadata Requests/sec: The rate at which metadata requests are being sent to this share.
  let ``Metadata Requests/sec`` instance =
    { category = "SMB Client Shares"; counter = "Metadata Requests/sec"; instance = instance }
  /// Read Bytes/sec: The rate at which bytes are being read from this share.
  let ``Read Bytes/sec`` instance =
    { category = "SMB Client Shares"; counter = "Read Bytes/sec"; instance = instance }
  /// Read Requests/sec: The rate at which read requests are being sent to this share.
  let ``Read Requests/sec`` instance =
    { category = "SMB Client Shares"; counter = "Read Requests/sec"; instance = instance }
  /// Write Bytes/sec: The rate at which bytes are being written to this share.
  let ``Write Bytes/sec`` instance =
    { category = "SMB Client Shares"; counter = "Write Bytes/sec"; instance = instance }
  /// Write Requests/sec: The rate at which write requests are being sent to this share.
  let ``Write Requests/sec`` instance =
    { category = "SMB Client Shares"; counter = "Write Requests/sec"; instance = instance }

  let allCounters =
    [ ``Avg. Bytes/Read``
      ``Avg. Bytes/Write``
      ``Avg. Data Bytes/Request``
      ``Avg. Data Queue Length``
      ``Avg. Read Queue Length``
      ``Avg. Write Queue Length``
      ``Avg. sec/Data Request``
      ``Avg. sec/Read``
      ``Avg. sec/Write``
      ``Credit Stalls/sec``
      ``Current Data Queue Length``
      ``Data Bytes/sec``
      ``Data Requests/sec``
      ``Metadata Requests/sec``
      ``Read Bytes/sec``
      ``Read Requests/sec``
      ``Write Bytes/sec``
      ``Write Requests/sec``
    ]

/// SMB Server Sessions: This counter set displays information about SMB server sessions using SMB protocol version 2 or higher
///
/// This performance counter does not have instance based counters
module ``SMB Server Sessions`` =

  [<Literal>]
  let Category = "SMB Server Sessions"

  let PCC = getPCC Category
  /// % Persistent Handles: -
  let ``% Persistent Handles`` instance =
    { category = "SMB Server Sessions"; counter = "% Persistent Handles"; instance = instance }
  /// % Resilient Handles: -
  let ``% Resilient Handles`` instance =
    { category = "SMB Server Sessions"; counter = "% Resilient Handles"; instance = instance }
  /// Avg. Bytes/Read: -
  let ``Avg. Bytes/Read`` instance =
    { category = "SMB Server Sessions"; counter = "Avg. Bytes/Read"; instance = instance }
  /// Avg. Bytes/Write: -
  let ``Avg. Bytes/Write`` instance =
    { category = "SMB Server Sessions"; counter = "Avg. Bytes/Write"; instance = instance }
  /// Avg. Data Bytes/Request: -
  let ``Avg. Data Bytes/Request`` instance =
    { category = "SMB Server Sessions"; counter = "Avg. Data Bytes/Request"; instance = instance }
  /// Avg. Data Queue Length: -
  let ``Avg. Data Queue Length`` instance =
    { category = "SMB Server Sessions"; counter = "Avg. Data Queue Length"; instance = instance }
  /// Avg. Read Queue Length: -
  let ``Avg. Read Queue Length`` instance =
    { category = "SMB Server Sessions"; counter = "Avg. Read Queue Length"; instance = instance }
  /// Avg. Write Queue Length: -
  let ``Avg. Write Queue Length`` instance =
    { category = "SMB Server Sessions"; counter = "Avg. Write Queue Length"; instance = instance }
  /// Avg. sec/Data Request: -
  let ``Avg. sec/Data Request`` instance =
    { category = "SMB Server Sessions"; counter = "Avg. sec/Data Request"; instance = instance }
  /// Avg. sec/Read: -
  let ``Avg. sec/Read`` instance =
    { category = "SMB Server Sessions"; counter = "Avg. sec/Read"; instance = instance }
  /// Avg. sec/Request: -
  let ``Avg. sec/Request`` instance =
    { category = "SMB Server Sessions"; counter = "Avg. sec/Request"; instance = instance }
  /// Avg. sec/Write: -
  let ``Avg. sec/Write`` instance =
    { category = "SMB Server Sessions"; counter = "Avg. sec/Write"; instance = instance }
  /// Current Data Queue Length: -
  let ``Current Data Queue Length`` instance =
    { category = "SMB Server Sessions"; counter = "Current Data Queue Length"; instance = instance }
  /// Current Durable Open File Count: -
  let ``Current Durable Open File Count`` instance =
    { category = "SMB Server Sessions"; counter = "Current Durable Open File Count"; instance = instance }
  /// Current Open File Count: -
  let ``Current Open File Count`` instance =
    { category = "SMB Server Sessions"; counter = "Current Open File Count"; instance = instance }
  /// Current Pending Requests: -
  let ``Current Pending Requests`` instance =
    { category = "SMB Server Sessions"; counter = "Current Pending Requests"; instance = instance }
  /// Data Bytes/sec: -
  let ``Data Bytes/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Data Bytes/sec"; instance = instance }
  /// Data Requests/sec: -
  let ``Data Requests/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Data Requests/sec"; instance = instance }
  /// Files Opened/sec: -
  let ``Files Opened/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Files Opened/sec"; instance = instance }
  /// Metadata Requests/sec: -
  let ``Metadata Requests/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Metadata Requests/sec"; instance = instance }
  /// Read Bytes/sec: -
  let ``Read Bytes/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Read Bytes/sec"; instance = instance }
  /// Read Requests/sec: -
  let ``Read Requests/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Read Requests/sec"; instance = instance }
  /// Received Bytes/sec: -
  let ``Received Bytes/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Received Bytes/sec"; instance = instance }
  /// Requests/sec: -
  let ``Requests/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Requests/sec"; instance = instance }
  /// Sent Bytes/sec: -
  let ``Sent Bytes/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Sent Bytes/sec"; instance = instance }
  /// Total Durable Handle Reopen Count: -
  let ``Total Durable Handle Reopen Count`` instance =
    { category = "SMB Server Sessions"; counter = "Total Durable Handle Reopen Count"; instance = instance }
  /// Total Failed Durable Handle Reopen Count: -
  let ``Total Failed Durable Handle Reopen Count`` instance =
    { category = "SMB Server Sessions"; counter = "Total Failed Durable Handle Reopen Count"; instance = instance }
  /// Total Failed Persistent Handle Reopen Count: -
  let ``Total Failed Persistent Handle Reopen Count`` instance =
    { category = "SMB Server Sessions"; counter = "Total Failed Persistent Handle Reopen Count"; instance = instance }
  /// Total Failed Resilient Handle Reopen Count: -
  let ``Total Failed Resilient Handle Reopen Count`` instance =
    { category = "SMB Server Sessions"; counter = "Total Failed Resilient Handle Reopen Count"; instance = instance }
  /// Total File Open Count: -
  let ``Total File Open Count`` instance =
    { category = "SMB Server Sessions"; counter = "Total File Open Count"; instance = instance }
  /// Total Persistent Handle Reopen Count: -
  let ``Total Persistent Handle Reopen Count`` instance =
    { category = "SMB Server Sessions"; counter = "Total Persistent Handle Reopen Count"; instance = instance }
  /// Total Resilient Handle Reopen Count: -
  let ``Total Resilient Handle Reopen Count`` instance =
    { category = "SMB Server Sessions"; counter = "Total Resilient Handle Reopen Count"; instance = instance }
  /// Transferred Bytes/sec: -
  let ``Transferred Bytes/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Transferred Bytes/sec"; instance = instance }
  /// Tree Connect Count: -
  let ``Tree Connect Count`` instance =
    { category = "SMB Server Sessions"; counter = "Tree Connect Count"; instance = instance }
  /// Write Bytes/sec: -
  let ``Write Bytes/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Write Bytes/sec"; instance = instance }
  /// Write Requests/sec: -
  let ``Write Requests/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Write Requests/sec"; instance = instance }

  let allCounters =
    [ ``% Persistent Handles``
      ``% Resilient Handles``
      ``Avg. Bytes/Read``
      ``Avg. Bytes/Write``
      ``Avg. Data Bytes/Request``
      ``Avg. Data Queue Length``
      ``Avg. Read Queue Length``
      ``Avg. Write Queue Length``
      ``Avg. sec/Data Request``
      ``Avg. sec/Read``
      ``Avg. sec/Request``
      ``Avg. sec/Write``
      ``Current Data Queue Length``
      ``Current Durable Open File Count``
      ``Current Open File Count``
      ``Current Pending Requests``
      ``Data Bytes/sec``
      ``Data Requests/sec``
      ``Files Opened/sec``
      ``Metadata Requests/sec``
      ``Read Bytes/sec``
      ``Read Requests/sec``
      ``Received Bytes/sec``
      ``Requests/sec``
      ``Sent Bytes/sec``
      ``Total Durable Handle Reopen Count``
      ``Total Failed Durable Handle Reopen Count``
      ``Total Failed Persistent Handle Reopen Count``
      ``Total Failed Resilient Handle Reopen Count``
      ``Total File Open Count``
      ``Total Persistent Handle Reopen Count``
      ``Total Resilient Handle Reopen Count``
      ``Transferred Bytes/sec``
      ``Tree Connect Count``
      ``Write Bytes/sec``
      ``Write Requests/sec``
    ]

/// SMB Server Shares: This counter set displays information about SMB server shares that are shared using SMB protocol version 2 or higher.
///
/// This performance counter does not have non-instance based counters
module ``SMB Server Shares`` =

  [<Literal>]
  let Category = "SMB Server Shares"

  let PCC = getPCC Category
  /// % Persistent Handles: The percentage of total handles for which clients requested persistency.
  let ``% Persistent Handles`` instance =
    { category = "SMB Server Shares"; counter = "% Persistent Handles"; instance = instance }
  /// % Resilient Handles: The percentage of total opens for which clients requested resiliency.
  let ``% Resilient Handles`` instance =
    { category = "SMB Server Shares"; counter = "% Resilient Handles"; instance = instance }
  /// Avg. Bytes/Read: The average number of bytes per read request.
  let ``Avg. Bytes/Read`` instance =
    { category = "SMB Server Shares"; counter = "Avg. Bytes/Read"; instance = instance }
  /// Avg. Bytes/Write: The average number of bytes per write request.
  let ``Avg. Bytes/Write`` instance =
    { category = "SMB Server Shares"; counter = "Avg. Bytes/Write"; instance = instance }
  /// Avg. Data Bytes/Request: The average number of bytes per read or write request.
  let ``Avg. Data Bytes/Request`` instance =
    { category = "SMB Server Shares"; counter = "Avg. Data Bytes/Request"; instance = instance }
  /// Avg. Data Queue Length: The average number of read and write requests that were queued for this share.
  let ``Avg. Data Queue Length`` instance =
    { category = "SMB Server Shares"; counter = "Avg. Data Queue Length"; instance = instance }
  /// Avg. Read Queue Length: The average number of read requests that were queued for this share.
  let ``Avg. Read Queue Length`` instance =
    { category = "SMB Server Shares"; counter = "Avg. Read Queue Length"; instance = instance }
  /// Avg. Write Queue Length: The average number of write requests that were queued for this share.
  let ``Avg. Write Queue Length`` instance =
    { category = "SMB Server Shares"; counter = "Avg. Write Queue Length"; instance = instance }
  /// Avg. sec/Data Request: The average number of seconds that elapse between the time at which a read or write request to this share is received and the time at which the SMB File Server processes the request.
  let ``Avg. sec/Data Request`` instance =
    { category = "SMB Server Shares"; counter = "Avg. sec/Data Request"; instance = instance }
  /// Avg. sec/Read: The average number of seconds that elapse between the time at which a read request to this share is received and the time at which the SMB File Server sends the corresponding response.
  let ``Avg. sec/Read`` instance =
    { category = "SMB Server Shares"; counter = "Avg. sec/Read"; instance = instance }
  /// Avg. sec/Request: The average number of seconds that elapse between the time at which the SMB File Server receives a request for this share and the time at which the SMB File Server sends the corresponding response.
  let ``Avg. sec/Request`` instance =
    { category = "SMB Server Shares"; counter = "Avg. sec/Request"; instance = instance }
  /// Avg. sec/Write: The average number of seconds that elapse between the time at which a write request to this share is received and the time at which the SMB File Server sends the corresponding response.
  let ``Avg. sec/Write`` instance =
    { category = "SMB Server Shares"; counter = "Avg. sec/Write"; instance = instance }
  /// Current Data Queue Length: The current number of read or write requests outstanding on this share.
  let ``Current Data Queue Length`` instance =
    { category = "SMB Server Shares"; counter = "Current Data Queue Length"; instance = instance }
  /// Current Durable Open File Count: The number of durable file handles that are currently open on this share
  let ``Current Durable Open File Count`` instance =
    { category = "SMB Server Shares"; counter = "Current Durable Open File Count"; instance = instance }
  /// Current Open File Count: The number of file handles that are currently open in this share
  let ``Current Open File Count`` instance =
    { category = "SMB Server Shares"; counter = "Current Open File Count"; instance = instance }
  /// Current Pending Requests: The number of requests related to this share that are waiting to be processed by the SMB File Server.
  let ``Current Pending Requests`` instance =
    { category = "SMB Server Shares"; counter = "Current Pending Requests"; instance = instance }
  /// Data Bytes/sec: The rate, in seconds, at which data is being written to or read from this share.
  let ``Data Bytes/sec`` instance =
    { category = "SMB Server Shares"; counter = "Data Bytes/sec"; instance = instance }
  /// Data Requests/sec: The rate, in seconds, at which read or write requests are received for this share.
  let ``Data Requests/sec`` instance =
    { category = "SMB Server Shares"; counter = "Data Requests/sec"; instance = instance }
  /// Files Opened/sec: The rate, in seconds, at which files are being opened for the SMB File Server’s clients on this share.
  let ``Files Opened/sec`` instance =
    { category = "SMB Server Shares"; counter = "Files Opened/sec"; instance = instance }
  /// Metadata Requests/sec: The rate, in seconds, at which metadata requests are being sent to this share.
  let ``Metadata Requests/sec`` instance =
    { category = "SMB Server Shares"; counter = "Metadata Requests/sec"; instance = instance }
  /// Read Bytes/sec: The rate, in seconds, at which data is being read from this share.
  let ``Read Bytes/sec`` instance =
    { category = "SMB Server Shares"; counter = "Read Bytes/sec"; instance = instance }
  /// Read Requests/sec: Read requests processed/sec related to this share.
  let ``Read Requests/sec`` instance =
    { category = "SMB Server Shares"; counter = "Read Requests/sec"; instance = instance }
  /// Received Bytes/sec: The rate at which bytes are being received for requests related to this share. This value includes application data as well as SMB protocol data (such as packet headers).
  let ``Received Bytes/sec`` instance =
    { category = "SMB Server Shares"; counter = "Received Bytes/sec"; instance = instance }
  /// Requests/sec: The rate at which requests are being received for this share
  let ``Requests/sec`` instance =
    { category = "SMB Server Shares"; counter = "Requests/sec"; instance = instance }
  /// Sent Bytes/sec: The rate, in seconds, at which bytes are being sent from the SMB File Server related to this share to its clients. This value includes both data bytes and protocol bytes.
  let ``Sent Bytes/sec`` instance =
    { category = "SMB Server Shares"; counter = "Sent Bytes/sec"; instance = instance }
  /// Total Durable Handle Reopen Count: The number of durable opens on this share that have been recovered after a temporary network disconnect since the SMB File Server started.
  let ``Total Durable Handle Reopen Count`` instance =
    { category = "SMB Server Shares"; counter = "Total Durable Handle Reopen Count"; instance = instance }
  /// Total Failed Durable Handle Reopen Count: The number of durable opens on this share that could not be recovered after a temporary network disconnect since the SMB File Server Started.
  let ``Total Failed Durable Handle Reopen Count`` instance =
    { category = "SMB Server Shares"; counter = "Total Failed Durable Handle Reopen Count"; instance = instance }
  /// Total Failed Persistent Handle Reopen Count: The number of persistent opens on this share that could not be recovered after a temporary network disconnect since the SMB File Server Started.
  let ``Total Failed Persistent Handle Reopen Count`` instance =
    { category = "SMB Server Shares"; counter = "Total Failed Persistent Handle Reopen Count"; instance = instance }
  /// Total Failed Resilient Handle Reopen Count: The number of resilient opens on this share that could not be recovered after a temporary network disconnect since the SMB File Server Started.
  let ``Total Failed Resilient Handle Reopen Count`` instance =
    { category = "SMB Server Shares"; counter = "Total Failed Resilient Handle Reopen Count"; instance = instance }
  /// Total File Open Count: The number of files that have been opened by the SMB File Server on behalf of its clients on this share since the server started.
  let ``Total File Open Count`` instance =
    { category = "SMB Server Shares"; counter = "Total File Open Count"; instance = instance }
  /// Total Persistent Handle Reopen Count: The number of persistent opens on this share that have been recovered after a temporary network disconnect since the SMB File Server started.
  let ``Total Persistent Handle Reopen Count`` instance =
    { category = "SMB Server Shares"; counter = "Total Persistent Handle Reopen Count"; instance = instance }
  /// Total Resilient Handle Reopen Count: The number of resilient opens on this share that have been recovered after a temporary network disconnect since the SMB File Server started.
  let ``Total Resilient Handle Reopen Count`` instance =
    { category = "SMB Server Shares"; counter = "Total Resilient Handle Reopen Count"; instance = instance }
  /// Transferred Bytes/sec: The sum of Sent Bytes/sec and Received Bytes/sec for this share.
  let ``Transferred Bytes/sec`` instance =
    { category = "SMB Server Shares"; counter = "Transferred Bytes/sec"; instance = instance }
  /// Tree Connect Count: The current number of tree connects to this share
  let ``Tree Connect Count`` instance =
    { category = "SMB Server Shares"; counter = "Tree Connect Count"; instance = instance }
  /// Write Bytes/sec: The rate, in seconds, at which data is being written to this share.
  let ``Write Bytes/sec`` instance =
    { category = "SMB Server Shares"; counter = "Write Bytes/sec"; instance = instance }
  /// Write Requests/sec: Write requests processed/sec related to this share.
  let ``Write Requests/sec`` instance =
    { category = "SMB Server Shares"; counter = "Write Requests/sec"; instance = instance }

  let allCounters =
    [ ``% Persistent Handles``
      ``% Resilient Handles``
      ``Avg. Bytes/Read``
      ``Avg. Bytes/Write``
      ``Avg. Data Bytes/Request``
      ``Avg. Data Queue Length``
      ``Avg. Read Queue Length``
      ``Avg. Write Queue Length``
      ``Avg. sec/Data Request``
      ``Avg. sec/Read``
      ``Avg. sec/Request``
      ``Avg. sec/Write``
      ``Current Data Queue Length``
      ``Current Durable Open File Count``
      ``Current Open File Count``
      ``Current Pending Requests``
      ``Data Bytes/sec``
      ``Data Requests/sec``
      ``Files Opened/sec``
      ``Metadata Requests/sec``
      ``Read Bytes/sec``
      ``Read Requests/sec``
      ``Received Bytes/sec``
      ``Requests/sec``
      ``Sent Bytes/sec``
      ``Total Durable Handle Reopen Count``
      ``Total Failed Durable Handle Reopen Count``
      ``Total Failed Persistent Handle Reopen Count``
      ``Total Failed Resilient Handle Reopen Count``
      ``Total File Open Count``
      ``Total Persistent Handle Reopen Count``
      ``Total Resilient Handle Reopen Count``
      ``Transferred Bytes/sec``
      ``Tree Connect Count``
      ``Write Bytes/sec``
      ``Write Requests/sec``
    ]

/// SMSvcHost 3.0.0.0: SMSvcHost 3.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``SMSvcHost 3_0_0_0`` =

  [<Literal>]
  let Category = "SMSvcHost 3.0.0.0"

  let PCC = getPCC Category
  /// Connections Accepted over net.pipe: The total number of named pipe connections accepted over net.pipe.
  let ``Connections Accepted over net.pipe`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Connections Accepted over net.pipe"; instance = NotApplicable }
  /// Connections Accepted over net.tcp: The total number of TCP connections accepted over net.tcp.
  let ``Connections Accepted over net.tcp`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Connections Accepted over net.tcp"; instance = NotApplicable }
  /// Connections Dispatched over net.pipe: The total number of connections dispatched over net.pipe.
  let ``Connections Dispatched over net.pipe`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Connections Dispatched over net.pipe"; instance = NotApplicable }
  /// Connections Dispatched over net.tcp: The total number of connections dispatched over net.tcp.
  let ``Connections Dispatched over net.tcp`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Connections Dispatched over net.tcp"; instance = NotApplicable }
  /// Dispatch Failures over net.pipe: The total number of failures dispatching messages received over net.pipe.
  let ``Dispatch Failures over net.pipe`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Dispatch Failures over net.pipe"; instance = NotApplicable }
  /// Dispatch Failures over net.tcp: The total number of failures dispatching messages received over net.tcp.
  let ``Dispatch Failures over net.tcp`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Dispatch Failures over net.tcp"; instance = NotApplicable }
  /// Protocol Failures over net.pipe: The total number of failures at the protocol layer of net.pipe.
  let ``Protocol Failures over net.pipe`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Protocol Failures over net.pipe"; instance = NotApplicable }
  /// Protocol Failures over net.tcp: The total number of failures at the protocol layer of net.tcp.
  let ``Protocol Failures over net.tcp`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Protocol Failures over net.tcp"; instance = NotApplicable }
  /// Registrations Active for net.pipe: The number of uri registrations currently active for net.pipe.
  let ``Registrations Active for net.pipe`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Registrations Active for net.pipe"; instance = NotApplicable }
  /// Registrations Active for net.tcp: The number of uri registrations currently active for net.tcp.
  let ``Registrations Active for net.tcp`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Registrations Active for net.tcp"; instance = NotApplicable }
  /// Uris Registered for net.pipe: The total number of uris that were succesfully registered for net.pipe.
  let ``Uris Registered for net.pipe`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Uris Registered for net.pipe"; instance = NotApplicable }
  /// Uris Registered for net.tcp: The total number of uris that were succesfully registered for net.tcp.
  let ``Uris Registered for net.tcp`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Uris Registered for net.tcp"; instance = NotApplicable }
  /// Uris Unregistered for net.pipe: The total number of uris that were succesfully unregistered for net.pipe.
  let ``Uris Unregistered for net.pipe`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Uris Unregistered for net.pipe"; instance = NotApplicable }
  /// Uris Unregistered for net.tcp: The total number of uris that were succesfully unregistered for net.tcp.
  let ``Uris Unregistered for net.tcp`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Uris Unregistered for net.tcp"; instance = NotApplicable }

  let allCounters =
    [ ``Connections Accepted over net.pipe``
      ``Connections Accepted over net.tcp``
      ``Connections Dispatched over net.pipe``
      ``Connections Dispatched over net.tcp``
      ``Dispatch Failures over net.pipe``
      ``Dispatch Failures over net.tcp``
      ``Protocol Failures over net.pipe``
      ``Protocol Failures over net.tcp``
      ``Registrations Active for net.pipe``
      ``Registrations Active for net.tcp``
      ``Uris Registered for net.pipe``
      ``Uris Registered for net.tcp``
      ``Uris Unregistered for net.pipe``
      ``Uris Unregistered for net.tcp``
    ]

/// SMSvcHost 4.0.0.0: SMSvcHost 4.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``SMSvcHost 4_0_0_0`` =

  [<Literal>]
  let Category = "SMSvcHost 4.0.0.0"

  let PCC = getPCC Category
  /// Connections Accepted over net.pipe: The total number of named pipe connections accepted over net.pipe.
  let ``Connections Accepted over net.pipe`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Connections Accepted over net.pipe"; instance = NotApplicable }
  /// Connections Accepted over net.tcp: The total number of TCP connections accepted over net.tcp.
  let ``Connections Accepted over net.tcp`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Connections Accepted over net.tcp"; instance = NotApplicable }
  /// Connections Dispatched over net.pipe: The total number of connections dispatched over net.pipe.
  let ``Connections Dispatched over net.pipe`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Connections Dispatched over net.pipe"; instance = NotApplicable }
  /// Connections Dispatched over net.tcp: The total number of connections dispatched over net.tcp.
  let ``Connections Dispatched over net.tcp`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Connections Dispatched over net.tcp"; instance = NotApplicable }
  /// Dispatch Failures over net.pipe: The total number of failures dispatching messages received over net.pipe.
  let ``Dispatch Failures over net.pipe`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Dispatch Failures over net.pipe"; instance = NotApplicable }
  /// Dispatch Failures over net.tcp: The total number of failures dispatching messages received over net.tcp.
  let ``Dispatch Failures over net.tcp`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Dispatch Failures over net.tcp"; instance = NotApplicable }
  /// Protocol Failures over net.pipe: The total number of failures at the protocol layer of net.pipe.
  let ``Protocol Failures over net.pipe`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Protocol Failures over net.pipe"; instance = NotApplicable }
  /// Protocol Failures over net.tcp: The total number of failures at the protocol layer of net.tcp.
  let ``Protocol Failures over net.tcp`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Protocol Failures over net.tcp"; instance = NotApplicable }
  /// Registrations Active for net.pipe: The number of uri registrations currently active for net.pipe.
  let ``Registrations Active for net.pipe`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Registrations Active for net.pipe"; instance = NotApplicable }
  /// Registrations Active for net.tcp: The number of uri registrations currently active for net.tcp.
  let ``Registrations Active for net.tcp`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Registrations Active for net.tcp"; instance = NotApplicable }
  /// Uris Registered for net.pipe: The total number of uris that were succesfully registered for net.pipe.
  let ``Uris Registered for net.pipe`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Uris Registered for net.pipe"; instance = NotApplicable }
  /// Uris Registered for net.tcp: The total number of uris that were succesfully registered for net.tcp.
  let ``Uris Registered for net.tcp`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Uris Registered for net.tcp"; instance = NotApplicable }
  /// Uris Unregistered for net.pipe: The total number of uris that were succesfully unregistered for net.pipe.
  let ``Uris Unregistered for net.pipe`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Uris Unregistered for net.pipe"; instance = NotApplicable }
  /// Uris Unregistered for net.tcp: The total number of uris that were succesfully unregistered for net.tcp.
  let ``Uris Unregistered for net.tcp`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Uris Unregistered for net.tcp"; instance = NotApplicable }

  let allCounters =
    [ ``Connections Accepted over net.pipe``
      ``Connections Accepted over net.tcp``
      ``Connections Dispatched over net.pipe``
      ``Connections Dispatched over net.tcp``
      ``Dispatch Failures over net.pipe``
      ``Dispatch Failures over net.tcp``
      ``Protocol Failures over net.pipe``
      ``Protocol Failures over net.tcp``
      ``Registrations Active for net.pipe``
      ``Registrations Active for net.tcp``
      ``Uris Registered for net.pipe``
      ``Uris Registered for net.tcp``
      ``Uris Unregistered for net.pipe``
      ``Uris Unregistered for net.tcp``
    ]

/// SQLAgent:Alerts: SQLAgent statistics about alerts
///
/// This performance counter does not have instance based counters
module ``SQLAgent:Alerts`` =

  [<Literal>]
  let Category = "SQLAgent:Alerts"

  let PCC = getPCC Category
  /// Activated alerts: The number of Alerts that have activated since the last SQL Server restart.
  let ``Activated alerts`` =
    { category = "SQLAgent:Alerts"; counter = "Activated alerts"; instance = NotApplicable }
  /// Alerts activated/minute: The number of Alerts that have activated within the last minute.
  let ``Alerts activated/minute`` =
    { category = "SQLAgent:Alerts"; counter = "Alerts activated/minute"; instance = NotApplicable }

  let allCounters =
    [ ``Activated alerts``
      ``Alerts activated/minute``
    ]

/// SQLAgent:JobSteps: Statistics for job steps
///
/// This performance counter does not have instance based counters
module ``SQLAgent:JobSteps`` =

  [<Literal>]
  let Category = "SQLAgent:JobSteps"

  let PCC = getPCC Category
  /// Active steps: -
  let ``Active steps`` instance =
    { category = "SQLAgent:JobSteps"; counter = "Active steps"; instance = instance }
  /// Queued steps: -
  let ``Queued steps`` instance =
    { category = "SQLAgent:JobSteps"; counter = "Queued steps"; instance = instance }
  /// Total step retries: -
  let ``Total step retries`` instance =
    { category = "SQLAgent:JobSteps"; counter = "Total step retries"; instance = instance }

  let allCounters =
    [ ``Active steps``
      ``Queued steps``
      ``Total step retries``
    ]

/// SQLAgent:Jobs: SQLAgent General Statistics about jobs
///
/// This performance counter does not have instance based counters
module ``SQLAgent:Jobs`` =

  [<Literal>]
  let Category = "SQLAgent:Jobs"

  let PCC = getPCC Category
  /// Active jobs: -
  let ``Active jobs`` instance =
    { category = "SQLAgent:Jobs"; counter = "Active jobs"; instance = instance }
  /// Failed jobs: -
  let ``Failed jobs`` instance =
    { category = "SQLAgent:Jobs"; counter = "Failed jobs"; instance = instance }
  /// Job success rate: -
  let ``Job success rate`` instance =
    { category = "SQLAgent:Jobs"; counter = "Job success rate"; instance = instance }
  /// Jobs activated/minute: -
  let ``Jobs activated/minute`` instance =
    { category = "SQLAgent:Jobs"; counter = "Jobs activated/minute"; instance = instance }
  /// Queued jobs: -
  let ``Queued jobs`` instance =
    { category = "SQLAgent:Jobs"; counter = "Queued jobs"; instance = instance }
  /// Successful jobs: -
  let ``Successful jobs`` instance =
    { category = "SQLAgent:Jobs"; counter = "Successful jobs"; instance = instance }
  /// Successful jobs base: -
  let ``Successful jobs base`` instance =
    { category = "SQLAgent:Jobs"; counter = "Successful jobs base"; instance = instance }

  let allCounters =
    [ ``Active jobs``
      ``Failed jobs``
      ``Job success rate``
      ``Jobs activated/minute``
      ``Queued jobs``
      ``Successful jobs``
      ``Successful jobs base``
    ]

/// SQLAgent:Statistics: SQLAgent general statistics
///
/// This performance counter does not have instance based counters
module ``SQLAgent:Statistics`` =

  [<Literal>]
  let Category = "SQLAgent:Statistics"

  let PCC = getPCC Category
  /// SQL Server restarted: The number of times the SQL Server has been successfully restarted by SQL Server Agent, since the last SQL Server Agent restart.
  let ``SQL Server restarted`` =
    { category = "SQLAgent:Statistics"; counter = "SQL Server restarted"; instance = NotApplicable }

  let allCounters =
    [ ``SQL Server restarted``

    ]

/// SQLAgent:SystemJobs: SQLAgent General Statistics about system jobs
///
/// This performance counter does not have instance based counters
module ``SQLAgent:SystemJobs`` =

  [<Literal>]
  let Category = "SQLAgent:SystemJobs"

  let PCC = getPCC Category
  /// Active system jobs: -
  let ``Active system jobs`` instance =
    { category = "SQLAgent:SystemJobs"; counter = "Active system jobs"; instance = instance }
  /// Failed system jobs: -
  let ``Failed system jobs`` instance =
    { category = "SQLAgent:SystemJobs"; counter = "Failed system jobs"; instance = instance }
  /// Queued system jobs: -
  let ``Queued system jobs`` instance =
    { category = "SQLAgent:SystemJobs"; counter = "Queued system jobs"; instance = instance }
  /// Successful system jobs: -
  let ``Successful system jobs`` instance =
    { category = "SQLAgent:SystemJobs"; counter = "Successful system jobs"; instance = instance }
  /// System Jobs activated/minute: -
  let ``System Jobs activated/minute`` instance =
    { category = "SQLAgent:SystemJobs"; counter = "System Jobs activated/minute"; instance = instance }

  let allCounters =
    [ ``Active system jobs``
      ``Failed system jobs``
      ``Queued system jobs``
      ``Successful system jobs``
      ``System Jobs activated/minute``
    ]

/// SQLServer:Access Methods: Collects statistics associated with the database server access methods
///
/// This performance counter does not have instance based counters
module ``SQLServer:Access Methods`` =

  [<Literal>]
  let Category = "SQLServer:Access Methods"

  let PCC = getPCC Category
  /// AU cleanup batches/sec: The number of batches that completed successfully per second by the background task that cleans up deferred dropped allocation units.
  let ``AU cleanup batches/sec`` =
    { category = "SQLServer:Access Methods"; counter = "AU cleanup batches/sec"; instance = NotApplicable }
  /// AU cleanups/sec: The number of allocation units per second that were successfully dropped by the background task that cleans up deferred dropped allocation units. Each allocation unit drop requires multiple batches.
  let ``AU cleanups/sec`` =
    { category = "SQLServer:Access Methods"; counter = "AU cleanups/sec"; instance = NotApplicable }
  /// By-reference Lob Create Count: Count of large object (LOB) values that were passed by reference. By-reference lobs are used in certain bulk operations to avoid the cost of passing them by value.
  let ``By-reference Lob Create Count`` =
    { category = "SQLServer:Access Methods"; counter = "By-reference Lob Create Count"; instance = NotApplicable }
  /// By-reference Lob Use Count: Count of by-reference lob values that were used. By-reference lobs are used in certain bulk operations to avoid the cost of passing them by value.
  let ``By-reference Lob Use Count`` =
    { category = "SQLServer:Access Methods"; counter = "By-reference Lob Use Count"; instance = NotApplicable }
  /// Count Lob Readahead: Count of lob pages on which readahead was issued.
  let ``Count Lob Readahead`` =
    { category = "SQLServer:Access Methods"; counter = "Count Lob Readahead"; instance = NotApplicable }
  /// Count Pull In Row: Count of values that were pulled in-row from off-row.
  let ``Count Pull In Row`` =
    { category = "SQLServer:Access Methods"; counter = "Count Pull In Row"; instance = NotApplicable }
  /// Count Push Off Row: Count of values that were pushed from in-row to off-row.
  let ``Count Push Off Row`` =
    { category = "SQLServer:Access Methods"; counter = "Count Push Off Row"; instance = NotApplicable }
  /// Deferred Dropped rowsets: The number of rowsets created as a result of aborted online index build operations that are waiting to be dropped by the background task that cleans up deferred dropped rowsets.
  let ``Deferred Dropped rowsets`` =
    { category = "SQLServer:Access Methods"; counter = "Deferred Dropped rowsets"; instance = NotApplicable }
  /// Deferred dropped AUs: The number of allocation units waiting to be dropped by the background task that cleans up deferred dropped allocation units.
  let ``Deferred dropped AUs`` =
    { category = "SQLServer:Access Methods"; counter = "Deferred dropped AUs"; instance = NotApplicable }
  /// Dropped rowset cleanups/sec: The number of rowsets per second created as a result of aborted online index build operations that were successfully dropped by the background task that cleans up deferred dropped rowsets.
  let ``Dropped rowset cleanups/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Dropped rowset cleanups/sec"; instance = NotApplicable }
  /// Dropped rowsets skipped/sec: The number of rowsets per second created as a result of aborted online index build operations that were skipped by the background task that cleans up deferred dropped rowsets created.
  let ``Dropped rowsets skipped/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Dropped rowsets skipped/sec"; instance = NotApplicable }
  /// Extent Deallocations/sec: Number of extents deallocated per second in all databases in this SQL Server instance.
  let ``Extent Deallocations/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Extent Deallocations/sec"; instance = NotApplicable }
  /// Extents Allocated/sec: Number of extents allocated per second in all databases in this SQL Server instance.
  let ``Extents Allocated/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Extents Allocated/sec"; instance = NotApplicable }
  /// Failed AU cleanup batches/sec: The number of batches per second that failed and required retry, by the background task that cleans up deferred dropped allocation units. Failure could be due to lack of memory or disk space, hardware failure and other reasons.
  let ``Failed AU cleanup batches/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Failed AU cleanup batches/sec"; instance = NotApplicable }
  /// Failed leaf page cookie: The number of times that a leaf page cookie could not be used during an index search since changes happened on the leaf page. The cookie is used to speed up index search.
  let ``Failed leaf page cookie`` =
    { category = "SQLServer:Access Methods"; counter = "Failed leaf page cookie"; instance = NotApplicable }
  /// Failed tree page cookie: The number of times that a tree page cookie could not be used during an index search since changes happened on the parent pages of those tree pages. The cookie is used to speed up index search.
  let ``Failed tree page cookie`` =
    { category = "SQLServer:Access Methods"; counter = "Failed tree page cookie"; instance = NotApplicable }
  /// Forwarded Records/sec: Number of records fetched through forwarded record pointers.
  let ``Forwarded Records/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Forwarded Records/sec"; instance = NotApplicable }
  /// FreeSpace Page Fetches/sec: Number of pages fetched per second by free space scans. These scans search for free space within pages already allocated to an allocation unit, to satisfy requests to insert or modify record fragments.
  let ``FreeSpace Page Fetches/sec`` =
    { category = "SQLServer:Access Methods"; counter = "FreeSpace Page Fetches/sec"; instance = NotApplicable }
  /// FreeSpace Scans/sec: Number of scans per second that were initiated to search for free space within pages already allocated to an allocation unit to insert or modify record fragments. Each scan may find multiple pages.
  let ``FreeSpace Scans/sec`` =
    { category = "SQLServer:Access Methods"; counter = "FreeSpace Scans/sec"; instance = NotApplicable }
  /// Full Scans/sec: Number of unrestricted full scans. These can either be base table or full index scans.
  let ``Full Scans/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Full Scans/sec"; instance = NotApplicable }
  /// InSysXact waits/sec: Number of times a reader needs to wait for a page because the InSysXact bit is set
  let ``InSysXact waits/sec`` =
    { category = "SQLServer:Access Methods"; counter = "InSysXact waits/sec"; instance = NotApplicable }
  /// Index Searches/sec: Number of index searches. Index searches are used to start range scans, single index record fetches, and to reposition within an index.
  let ``Index Searches/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Index Searches/sec"; instance = NotApplicable }
  /// LobHandle Create Count: Count of temporary LOBs created.
  let ``LobHandle Create Count`` =
    { category = "SQLServer:Access Methods"; counter = "LobHandle Create Count"; instance = NotApplicable }
  /// LobHandle Destroy Count: Count of temporary LOBs destroyed.
  let ``LobHandle Destroy Count`` =
    { category = "SQLServer:Access Methods"; counter = "LobHandle Destroy Count"; instance = NotApplicable }
  /// LobSS Provider Create Count: Count of LOB Storage Service Providers created. One worktable created per LOB Storage Service Provider.
  let ``LobSS Provider Create Count`` =
    { category = "SQLServer:Access Methods"; counter = "LobSS Provider Create Count"; instance = NotApplicable }
  /// LobSS Provider Destroy Count: Count of LOB Storage Service Providers destroyed.
  let ``LobSS Provider Destroy Count`` =
    { category = "SQLServer:Access Methods"; counter = "LobSS Provider Destroy Count"; instance = NotApplicable }
  /// LobSS Provider Truncation Count: Count of LOB Storage Service Providers truncated.
  let ``LobSS Provider Truncation Count`` =
    { category = "SQLServer:Access Methods"; counter = "LobSS Provider Truncation Count"; instance = NotApplicable }
  /// Mixed page allocations/sec: Number of pages allocated per second from mixed extents. These could be used for storing the IAM pages and the first eight pages that are allocated to an allocation unit.
  let ``Mixed page allocations/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Mixed page allocations/sec"; instance = NotApplicable }
  /// Page Deallocations/sec: Number of pages deallocated per second in all databases in this SQL Server instance. These include pages from mixed extents and uniform extents.
  let ``Page Deallocations/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Page Deallocations/sec"; instance = NotApplicable }
  /// Page Splits/sec: Number of page splits per second that occur as a result of overflowing index pages.
  let ``Page Splits/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Page Splits/sec"; instance = NotApplicable }
  /// Page compression attempts/sec: Number of attempts to compress a database page per second
  let ``Page compression attempts/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Page compression attempts/sec"; instance = NotApplicable }
  /// Pages Allocated/sec: Number of pages allocated per second in all databases in this SQL Server instance. These include pages allocations from both mixed extents and uniform extents.
  let ``Pages Allocated/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Pages Allocated/sec"; instance = NotApplicable }
  /// Pages compressed/sec: Number of times a database page was compressed
  let ``Pages compressed/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Pages compressed/sec"; instance = NotApplicable }
  /// Probe Scans/sec: Number of probe scans per second that are used to find at most one single qualified row in an index or base table directly.
  let ``Probe Scans/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Probe Scans/sec"; instance = NotApplicable }
  /// Range Scans/sec: Number of qualified range scans through indexes per second.
  let ``Range Scans/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Range Scans/sec"; instance = NotApplicable }
  /// Scan Point Revalidations/sec: Number of times the scan point had to be revalidated to continue the scan.
  let ``Scan Point Revalidations/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Scan Point Revalidations/sec"; instance = NotApplicable }
  /// Skipped Ghosted Records/sec: Number of ghosted records per second skipped during scans.
  let ``Skipped Ghosted Records/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Skipped Ghosted Records/sec"; instance = NotApplicable }
  /// Table Lock Escalations/sec: The number of times locks on a table were escalated.
  let ``Table Lock Escalations/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Table Lock Escalations/sec"; instance = NotApplicable }
  /// Used leaf page cookie: Number of times a leaf page cookie was used successfully during an index search since no change happened on the leaf page. The cookie is used to speed up index search.
  let ``Used leaf page cookie`` =
    { category = "SQLServer:Access Methods"; counter = "Used leaf page cookie"; instance = NotApplicable }
  /// Used tree page cookie: Number of times a tree page cookie was used successfully during an index search since no change happened on the parent page of the tree page. The cookie is used to speed up index search.
  let ``Used tree page cookie`` =
    { category = "SQLServer:Access Methods"; counter = "Used tree page cookie"; instance = NotApplicable }
  /// Workfiles Created/sec: Number of work files created per second. For example, work files could be used to store temporary results for hash joins and hash aggregates.
  let ``Workfiles Created/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Workfiles Created/sec"; instance = NotApplicable }
  /// Worktables Created/sec: Number of work tables created per second. For example, work tables could be used to store temporary results for query spool, LOB variables, XML variables, and cursors.
  let ``Worktables Created/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Worktables Created/sec"; instance = NotApplicable }
  /// Worktables From Cache Base: Percent of worktables from cache base.
  let ``Worktables From Cache Base`` =
    { category = "SQLServer:Access Methods"; counter = "Worktables From Cache Base"; instance = NotApplicable }
  /// Worktables From Cache Ratio: Percentage of work tables created where the initial two pages of the work table were not allocated but were immediately available from the work table cache.
  let ``Worktables From Cache Ratio`` =
    { category = "SQLServer:Access Methods"; counter = "Worktables From Cache Ratio"; instance = NotApplicable }

  let allCounters =
    [ ``AU cleanup batches/sec``
      ``AU cleanups/sec``
      ``By-reference Lob Create Count``
      ``By-reference Lob Use Count``
      ``Count Lob Readahead``
      ``Count Pull In Row``
      ``Count Push Off Row``
      ``Deferred Dropped rowsets``
      ``Deferred dropped AUs``
      ``Dropped rowset cleanups/sec``
      ``Dropped rowsets skipped/sec``
      ``Extent Deallocations/sec``
      ``Extents Allocated/sec``
      ``Failed AU cleanup batches/sec``
      ``Failed leaf page cookie``
      ``Failed tree page cookie``
      ``Forwarded Records/sec``
      ``FreeSpace Page Fetches/sec``
      ``FreeSpace Scans/sec``
      ``Full Scans/sec``
      ``InSysXact waits/sec``
      ``Index Searches/sec``
      ``LobHandle Create Count``
      ``LobHandle Destroy Count``
      ``LobSS Provider Create Count``
      ``LobSS Provider Destroy Count``
      ``LobSS Provider Truncation Count``
      ``Mixed page allocations/sec``
      ``Page Deallocations/sec``
      ``Page Splits/sec``
      ``Page compression attempts/sec``
      ``Pages Allocated/sec``
      ``Pages compressed/sec``
      ``Probe Scans/sec``
      ``Range Scans/sec``
      ``Scan Point Revalidations/sec``
      ``Skipped Ghosted Records/sec``
      ``Table Lock Escalations/sec``
      ``Used leaf page cookie``
      ``Used tree page cookie``
      ``Workfiles Created/sec``
      ``Worktables Created/sec``
      ``Worktables From Cache Base``
      ``Worktables From Cache Ratio``
    ]

/// SQLServer:Availability Replica: This defines a HADR availability replica object for SQL Server
///
/// This performance counter does not have non-instance based counters
module ``SQLServer:Availability Replica`` =

  [<Literal>]
  let Category = "SQLServer:Availability Replica"

  let PCC = getPCC Category
  /// Bytes Received from Replica/sec: Total bytes receieved from the availability replica
  let ``Bytes Received from Replica/sec`` instance =
    { category = "SQLServer:Availability Replica"; counter = "Bytes Received from Replica/sec"; instance = instance }
  /// Bytes Sent to Replica/sec: Total bytes sent to the availabilty replica
  let ``Bytes Sent to Replica/sec`` instance =
    { category = "SQLServer:Availability Replica"; counter = "Bytes Sent to Replica/sec"; instance = instance }
  /// Bytes Sent to Transport/sec: Total bytes sent to transport for the availabilty replica
  let ``Bytes Sent to Transport/sec`` instance =
    { category = "SQLServer:Availability Replica"; counter = "Bytes Sent to Transport/sec"; instance = instance }
  /// Flow Control Time (ms/sec): Time in milliseconds messages waited on flow control in the last second
  let ``Flow Control Time (ms/sec)`` instance =
    { category = "SQLServer:Availability Replica"; counter = "Flow Control Time (ms/sec)"; instance = instance }
  /// Flow Control/sec: Number of flow control initiated in the last second
  let ``Flow Control/sec`` instance =
    { category = "SQLServer:Availability Replica"; counter = "Flow Control/sec"; instance = instance }
  /// Receives from Replica/sec: Total receives from the availability replica
  let ``Receives from Replica/sec`` instance =
    { category = "SQLServer:Availability Replica"; counter = "Receives from Replica/sec"; instance = instance }
  /// Resent Messages/sec: Number of messages being resent in the last second
  let ``Resent Messages/sec`` instance =
    { category = "SQLServer:Availability Replica"; counter = "Resent Messages/sec"; instance = instance }
  /// Sends to Replica/sec: Total sends to the availability replica
  let ``Sends to Replica/sec`` instance =
    { category = "SQLServer:Availability Replica"; counter = "Sends to Replica/sec"; instance = instance }
  /// Sends to Transport/sec: Total sends to transport for the availability replica
  let ``Sends to Transport/sec`` instance =
    { category = "SQLServer:Availability Replica"; counter = "Sends to Transport/sec"; instance = instance }

  let allCounters =
    [ ``Bytes Received from Replica/sec``
      ``Bytes Sent to Replica/sec``
      ``Bytes Sent to Transport/sec``
      ``Flow Control Time (ms/sec)``
      ``Flow Control/sec``
      ``Receives from Replica/sec``
      ``Resent Messages/sec``
      ``Sends to Replica/sec``
      ``Sends to Transport/sec``
    ]

/// SQLServer:Backup Device: This defines a backup device object for SQL Server
///
/// This performance counter does not have instance based counters
module ``SQLServer:Backup Device`` =

  [<Literal>]
  let Category = "SQLServer:Backup Device"

  let PCC = getPCC Category
  /// Device Throughput Bytes/sec: -
  let ``Device Throughput Bytes/sec`` instance =
    { category = "SQLServer:Backup Device"; counter = "Device Throughput Bytes/sec"; instance = instance }

  let allCounters =
    [ ``Device Throughput Bytes/sec``

    ]

/// SQLServer:Batch Resp Statistics: Counters to track SQL Batch Response times
///
/// This performance counter does not have non-instance based counters
module ``SQLServer:Batch Resp Statistics`` =

  [<Literal>]
  let Category = "SQLServer:Batch Resp Statistics"

  let PCC = getPCC Category
  /// Batches >=000000ms & <000001ms: Number of SQL Batches having response time greater than or equal to 0ms but less than 1ms
  let ``Batches >=000000ms & <000001ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=000000ms & <000001ms"; instance = instance }
  /// Batches >=000001ms & <000002ms: Number of SQL Batches having response time greater than or equal to 1ms but less than 2ms
  let ``Batches >=000001ms & <000002ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=000001ms & <000002ms"; instance = instance }
  /// Batches >=000002ms & <000005ms: Number of SQL Batches having response time greater than or equal to 2ms but less than 5ms
  let ``Batches >=000002ms & <000005ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=000002ms & <000005ms"; instance = instance }
  /// Batches >=000005ms & <000010ms: Number of SQL Batches having response time greater than or equal to 5ms but less than 10ms
  let ``Batches >=000005ms & <000010ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=000005ms & <000010ms"; instance = instance }
  /// Batches >=000010ms & <000020ms: Number of SQL Batches having response time greater than or equal to 10ms but less than 20ms
  let ``Batches >=000010ms & <000020ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=000010ms & <000020ms"; instance = instance }
  /// Batches >=000020ms & <000050ms: Number of SQL Batches having response time greater than or equal to 20ms but less than 50ms
  let ``Batches >=000020ms & <000050ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=000020ms & <000050ms"; instance = instance }
  /// Batches >=000050ms & <000100ms: Number of SQL Batches having response time greater than or equal to 50ms but less than 100ms
  let ``Batches >=000050ms & <000100ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=000050ms & <000100ms"; instance = instance }
  /// Batches >=000100ms & <000200ms: Number of SQL Batches having response time greater than or equal to 100ms but less than 200ms
  let ``Batches >=000100ms & <000200ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=000100ms & <000200ms"; instance = instance }
  /// Batches >=000200ms & <000500ms: Number of SQL Batches having response time greater than or equal to 200ms but less than 500ms
  let ``Batches >=000200ms & <000500ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=000200ms & <000500ms"; instance = instance }
  /// Batches >=000500ms & <001000ms: Number of SQL Batches having response time greater than or equal to 500ms but less than 1,000ms
  let ``Batches >=000500ms & <001000ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=000500ms & <001000ms"; instance = instance }
  /// Batches >=001000ms & <002000ms: Number of SQL Batches having response time greater than or equal to 1,000ms but less than 2,000ms
  let ``Batches >=001000ms & <002000ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=001000ms & <002000ms"; instance = instance }
  /// Batches >=002000ms & <005000ms: Number of SQL Batches having response time greater than or equal to 2,000ms but less than 5,000ms
  let ``Batches >=002000ms & <005000ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=002000ms & <005000ms"; instance = instance }
  /// Batches >=005000ms & <010000ms: Number of SQL Batches having response time greater than or equal to 5,000ms but less than 10,000ms
  let ``Batches >=005000ms & <010000ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=005000ms & <010000ms"; instance = instance }
  /// Batches >=010000ms & <020000ms: Number of SQL Batches having response time greater than or equal to 10,000ms but less than 20,000ms
  let ``Batches >=010000ms & <020000ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=010000ms & <020000ms"; instance = instance }
  /// Batches >=020000ms & <050000ms: Number of SQL Batches having response time greater than or equal to 20,000ms but less than 50,000ms
  let ``Batches >=020000ms & <050000ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=020000ms & <050000ms"; instance = instance }
  /// Batches >=050000ms & <100000ms: Number of SQL Batches having response time greater than or equal to 50,000ms but less than 100,000ms
  let ``Batches >=050000ms & <100000ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=050000ms & <100000ms"; instance = instance }
  /// Batches >=100000ms: Number of SQL Batches having response time greater than or equal to 100,000ms
  let ``Batches >=100000ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=100000ms"; instance = instance }

  let allCounters =
    [ ``Batches >=000000ms & <000001ms``
      ``Batches >=000001ms & <000002ms``
      ``Batches >=000002ms & <000005ms``
      ``Batches >=000005ms & <000010ms``
      ``Batches >=000010ms & <000020ms``
      ``Batches >=000020ms & <000050ms``
      ``Batches >=000050ms & <000100ms``
      ``Batches >=000100ms & <000200ms``
      ``Batches >=000200ms & <000500ms``
      ``Batches >=000500ms & <001000ms``
      ``Batches >=001000ms & <002000ms``
      ``Batches >=002000ms & <005000ms``
      ``Batches >=005000ms & <010000ms``
      ``Batches >=010000ms & <020000ms``
      ``Batches >=020000ms & <050000ms``
      ``Batches >=050000ms & <100000ms``
      ``Batches >=100000ms``
    ]

/// SQLServer:Broker Activation: Service Broker Activation
///
/// This performance counter does not have non-instance based counters
module ``SQLServer:Broker Activation`` =

  [<Literal>]
  let Category = "SQLServer:Broker Activation"

  let PCC = getPCC Category
  /// Stored Procedures Invoked/sec: The number of stored procedures that are being invoked per second.
  let ``Stored Procedures Invoked/sec`` instance =
    { category = "SQLServer:Broker Activation"; counter = "Stored Procedures Invoked/sec"; instance = instance }
  /// Task Limit Reached: The total number of times the activated task limit on a queue has been reached.
  let ``Task Limit Reached`` instance =
    { category = "SQLServer:Broker Activation"; counter = "Task Limit Reached"; instance = instance }
  /// Task Limit Reached/sec: The number of times the activated task limit on a queue has been reached per second.
  let ``Task Limit Reached/sec`` instance =
    { category = "SQLServer:Broker Activation"; counter = "Task Limit Reached/sec"; instance = instance }
  /// Tasks Aborted/sec: The number of activated tasks that are being aborted per second.
  let ``Tasks Aborted/sec`` instance =
    { category = "SQLServer:Broker Activation"; counter = "Tasks Aborted/sec"; instance = instance }
  /// Tasks Running: The total number of activated tasks that are currently running.
  let ``Tasks Running`` instance =
    { category = "SQLServer:Broker Activation"; counter = "Tasks Running"; instance = instance }
  /// Tasks Started/sec: The number of activated tasks that are being started per second.
  let ``Tasks Started/sec`` instance =
    { category = "SQLServer:Broker Activation"; counter = "Tasks Started/sec"; instance = instance }

  let allCounters =
    [ ``Stored Procedures Invoked/sec``
      ``Task Limit Reached``
      ``Task Limit Reached/sec``
      ``Tasks Aborted/sec``
      ``Tasks Running``
      ``Tasks Started/sec``
    ]

/// SQLServer:Broker Statistics: Service Broker Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Broker Statistics`` =

  [<Literal>]
  let Category = "SQLServer:Broker Statistics"

  let PCC = getPCC Category
  /// Activation Errors Total: The number of times an activation stored procedure exited with an error.
  let ``Activation Errors Total`` =
    { category = "SQLServer:Broker Statistics"; counter = "Activation Errors Total"; instance = NotApplicable }
  /// Broker Transaction Rollbacks: The number of Service Broker related transactions that have rolled back.
  let ``Broker Transaction Rollbacks`` =
    { category = "SQLServer:Broker Statistics"; counter = "Broker Transaction Rollbacks"; instance = NotApplicable }
  /// Corrupted Messages Total: The number of corrupted messages that were received in the instance.
  let ``Corrupted Messages Total`` =
    { category = "SQLServer:Broker Statistics"; counter = "Corrupted Messages Total"; instance = NotApplicable }
  /// Dequeued TransmissionQ Msgs/sec: The number of messages that have been removed from the broker transmission queue per second.
  let ``Dequeued TransmissionQ Msgs/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Dequeued TransmissionQ Msgs/sec"; instance = NotApplicable }
  /// Dialog Timer Event Count: The number of dialog endpoint related timer events in the Broker.
  let ``Dialog Timer Event Count`` =
    { category = "SQLServer:Broker Statistics"; counter = "Dialog Timer Event Count"; instance = NotApplicable }
  /// Dropped Messages Total: The number of messages that were received in the instance but could not be delivered.
  let ``Dropped Messages Total`` =
    { category = "SQLServer:Broker Statistics"; counter = "Dropped Messages Total"; instance = NotApplicable }
  /// Enqueued Local Messages Total: Total number of messages from local endpoints that are successfully delivered directly into local target queues.
  let ``Enqueued Local Messages Total`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued Local Messages Total"; instance = NotApplicable }
  /// Enqueued Local Messages/sec: The number of messages from local endpoints that are successfully delivered directly into local target queues per second.
  let ``Enqueued Local Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued Local Messages/sec"; instance = NotApplicable }
  /// Enqueued Messages Total: Total number of messages from local endpoints and the transport that are successfully delivered into local target queues.
  let ``Enqueued Messages Total`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued Messages Total"; instance = NotApplicable }
  /// Enqueued Messages/sec: The number of messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued Messages/sec"; instance = NotApplicable }
  /// Enqueued P1 Messages/sec: The number of priority 1 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P1 Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued P1 Messages/sec"; instance = NotApplicable }
  /// Enqueued P10 Messages/sec: The number of priority 10 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P10 Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued P10 Messages/sec"; instance = NotApplicable }
  /// Enqueued P2 Messages/sec: The number of priority 2 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P2 Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued P2 Messages/sec"; instance = NotApplicable }
  /// Enqueued P3 Messages/sec: The number of priority 3 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P3 Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued P3 Messages/sec"; instance = NotApplicable }
  /// Enqueued P4 Messages/sec: The number of priority 4 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P4 Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued P4 Messages/sec"; instance = NotApplicable }
  /// Enqueued P5 Messages/sec: The number of priority 5 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P5 Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued P5 Messages/sec"; instance = NotApplicable }
  /// Enqueued P6 Messages/sec: The number of priority 6 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P6 Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued P6 Messages/sec"; instance = NotApplicable }
  /// Enqueued P7 Messages/sec: The number of priority 7 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P7 Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued P7 Messages/sec"; instance = NotApplicable }
  /// Enqueued P8 Messages/sec: The number of priority 8 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P8 Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued P8 Messages/sec"; instance = NotApplicable }
  /// Enqueued P9 Messages/sec: The number of priority 9 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P9 Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued P9 Messages/sec"; instance = NotApplicable }
  /// Enqueued TransmissionQ Msgs/sec: The number of messages that have been placed into the broker transmission queue per second.
  let ``Enqueued TransmissionQ Msgs/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued TransmissionQ Msgs/sec"; instance = NotApplicable }
  /// Enqueued Transport Msg Frag Tot: Total number of message fragments from the transport that are successfully delivered into local target queues. Note that the message can be marked as disabled if it is incomplete and/or out of order.
  let ``Enqueued Transport Msg Frag Tot`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued Transport Msg Frag Tot"; instance = NotApplicable }
  /// Enqueued Transport Msg Frags/sec: The number of message fragments from the transport that are successfully delivered into local target queues per second. Note that the message can be marked as disabled if it is incomplete and/or out of order.
  let ``Enqueued Transport Msg Frags/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued Transport Msg Frags/sec"; instance = NotApplicable }
  /// Enqueued Transport Msgs Total: Total number of messages from the transport that are successfully delivered into local target queues. This includes all messages from remote endpoints and messages from local endpoints which go through the transport.
  let ``Enqueued Transport Msgs Total`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued Transport Msgs Total"; instance = NotApplicable }
  /// Enqueued Transport Msgs/sec: The number of messages from the transport that are successfully delivered into local target queues per second. This includes all messages from remote endpoints and messages from local endpoints which go through the transport.
  let ``Enqueued Transport Msgs/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued Transport Msgs/sec"; instance = NotApplicable }
  /// Forwarded Messages Total: Total number of forwarded messages successfully sent.
  let ``Forwarded Messages Total`` =
    { category = "SQLServer:Broker Statistics"; counter = "Forwarded Messages Total"; instance = NotApplicable }
  /// Forwarded Messages/sec: The number of forwarded messages successfully sent per second.
  let ``Forwarded Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Forwarded Messages/sec"; instance = NotApplicable }
  /// Forwarded Msg Byte Total: Total number of forwarded message bytes successfully sent.
  let ``Forwarded Msg Byte Total`` =
    { category = "SQLServer:Broker Statistics"; counter = "Forwarded Msg Byte Total"; instance = NotApplicable }
  /// Forwarded Msg Bytes/sec: The number of forwarded message bytes successfully sent per second.
  let ``Forwarded Msg Bytes/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Forwarded Msg Bytes/sec"; instance = NotApplicable }
  /// Forwarded Msg Discarded Total: Total number of forwarded messages discarded due to forwarded message memory limits, age limits, etc.
  let ``Forwarded Msg Discarded Total`` =
    { category = "SQLServer:Broker Statistics"; counter = "Forwarded Msg Discarded Total"; instance = NotApplicable }
  /// Forwarded Msgs Discarded/sec: The number of forwarded messages that were discarded per second due to forwarded message memory limits, age limits, etc.
  let ``Forwarded Msgs Discarded/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Forwarded Msgs Discarded/sec"; instance = NotApplicable }
  /// Forwarded Pending Msg Bytes: The number of forwarded message bytes that have not been successfully sent yet.
  let ``Forwarded Pending Msg Bytes`` =
    { category = "SQLServer:Broker Statistics"; counter = "Forwarded Pending Msg Bytes"; instance = NotApplicable }
  /// Forwarded Pending Msg Count: The number of forwarded messages that have not been successfully sent yet.
  let ``Forwarded Pending Msg Count`` =
    { category = "SQLServer:Broker Statistics"; counter = "Forwarded Pending Msg Count"; instance = NotApplicable }
  /// SQL RECEIVE Total: Total number of SQL RECEIVE commands processed by the Broker.
  let ``SQL RECEIVE Total`` =
    { category = "SQLServer:Broker Statistics"; counter = "SQL RECEIVE Total"; instance = NotApplicable }
  /// SQL RECEIVEs/sec: The number of SQL RECEIVE commands processed by the Broker per second.
  let ``SQL RECEIVEs/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "SQL RECEIVEs/sec"; instance = NotApplicable }
  /// SQL SEND Total: Total number of SQL SEND commands processed by the Broker.
  let ``SQL SEND Total`` =
    { category = "SQLServer:Broker Statistics"; counter = "SQL SEND Total"; instance = NotApplicable }
  /// SQL SENDs/sec: The number of SQL SEND commands processed by the Broker per second.
  let ``SQL SENDs/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "SQL SENDs/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Activation Errors Total``
      ``Broker Transaction Rollbacks``
      ``Corrupted Messages Total``
      ``Dequeued TransmissionQ Msgs/sec``
      ``Dialog Timer Event Count``
      ``Dropped Messages Total``
      ``Enqueued Local Messages Total``
      ``Enqueued Local Messages/sec``
      ``Enqueued Messages Total``
      ``Enqueued Messages/sec``
      ``Enqueued P1 Messages/sec``
      ``Enqueued P10 Messages/sec``
      ``Enqueued P2 Messages/sec``
      ``Enqueued P3 Messages/sec``
      ``Enqueued P4 Messages/sec``
      ``Enqueued P5 Messages/sec``
      ``Enqueued P6 Messages/sec``
      ``Enqueued P7 Messages/sec``
      ``Enqueued P8 Messages/sec``
      ``Enqueued P9 Messages/sec``
      ``Enqueued TransmissionQ Msgs/sec``
      ``Enqueued Transport Msg Frag Tot``
      ``Enqueued Transport Msg Frags/sec``
      ``Enqueued Transport Msgs Total``
      ``Enqueued Transport Msgs/sec``
      ``Forwarded Messages Total``
      ``Forwarded Messages/sec``
      ``Forwarded Msg Byte Total``
      ``Forwarded Msg Bytes/sec``
      ``Forwarded Msg Discarded Total``
      ``Forwarded Msgs Discarded/sec``
      ``Forwarded Pending Msg Bytes``
      ``Forwarded Pending Msg Count``
      ``SQL RECEIVE Total``
      ``SQL RECEIVEs/sec``
      ``SQL SEND Total``
      ``SQL SENDs/sec``
    ]

/// SQLServer:Broker TO Statistics: Service Broker Transmission Object Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Broker TO Statistics`` =

  [<Literal>]
  let Category = "SQLServer:Broker TO Statistics"

  let PCC = getPCC Category
  /// Avg. Length of Batched Writes: Average Number of Transmission Objects saved in a batch.
  let ``Avg. Length of Batched Writes`` =
    { category = "SQLServer:Broker TO Statistics"; counter = "Avg. Length of Batched Writes"; instance = NotApplicable }
  /// Avg. Length of Batched Writes BS: Average Number of Transmission Objects saved in a batch.
  let ``Avg. Length of Batched Writes BS`` =
    { category = "SQLServer:Broker TO Statistics"; counter = "Avg. Length of Batched Writes BS"; instance = NotApplicable }
  /// Avg. Time Between Batches (ms): Average time between Transmission Object batch flushes.
  let ``Avg. Time Between Batches (ms)`` =
    { category = "SQLServer:Broker TO Statistics"; counter = "Avg. Time Between Batches (ms)"; instance = NotApplicable }
  /// Avg. Time Between Batches Base: Average time between Transmission Object batch flushes.
  let ``Avg. Time Between Batches Base`` =
    { category = "SQLServer:Broker TO Statistics"; counter = "Avg. Time Between Batches Base"; instance = NotApplicable }
  /// Avg. Time to Write Batch (ms): Average time to save a Transmission Object batch.
  let ``Avg. Time to Write Batch (ms)`` =
    { category = "SQLServer:Broker TO Statistics"; counter = "Avg. Time to Write Batch (ms)"; instance = NotApplicable }
  /// Avg. Time to Write Batch Base: Average time to save a Transmission Object batch.
  let ``Avg. Time to Write Batch Base`` =
    { category = "SQLServer:Broker TO Statistics"; counter = "Avg. Time to Write Batch Base"; instance = NotApplicable }
  /// Transmission Obj Gets/Sec: The number of Transmission Objects requested per second.
  let ``Transmission Obj Gets/Sec`` =
    { category = "SQLServer:Broker TO Statistics"; counter = "Transmission Obj Gets/Sec"; instance = NotApplicable }
  /// Transmission Obj Set Dirty/Sec: The number of Transmission Objects marked dirty per second.
  let ``Transmission Obj Set Dirty/Sec`` =
    { category = "SQLServer:Broker TO Statistics"; counter = "Transmission Obj Set Dirty/Sec"; instance = NotApplicable }
  /// Transmission Obj Writes/Sec: The number of Transmission Objects saved per second.
  let ``Transmission Obj Writes/Sec`` =
    { category = "SQLServer:Broker TO Statistics"; counter = "Transmission Obj Writes/Sec"; instance = NotApplicable }

  let allCounters =
    [ ``Avg. Length of Batched Writes``
      ``Avg. Length of Batched Writes BS``
      ``Avg. Time Between Batches (ms)``
      ``Avg. Time Between Batches Base``
      ``Avg. Time to Write Batch (ms)``
      ``Avg. Time to Write Batch Base``
      ``Transmission Obj Gets/Sec``
      ``Transmission Obj Set Dirty/Sec``
      ``Transmission Obj Writes/Sec``
    ]

/// SQLServer:Broker/DBM Transport: Service Broker/Database Mirroring Transport Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Broker_DBM Transport`` =

  [<Literal>]
  let Category = "SQLServer:Broker/DBM Transport"

  let PCC = getPCC Category
  /// Current Bytes for Recv I/O: The number of bytes associated with current transport receive I/O operations that haven't completed.
  let ``Current Bytes for Recv I/O`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Current Bytes for Recv I/O"; instance = NotApplicable }
  /// Current Bytes for Send I/O: The number of buffer bytes associated with current transport send I/O operations that haven't completed.
  let ``Current Bytes for Send I/O`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Current Bytes for Send I/O"; instance = NotApplicable }
  /// Current Msg Frags for Send I/O: The current number of message fragments associated with current transport send I/O operations that haven't completed.
  let ``Current Msg Frags for Send I/O`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Current Msg Frags for Send I/O"; instance = NotApplicable }
  /// Message Fragment P1 Sends/sec: The number of priority 1 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P1 Sends/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment P1 Sends/sec"; instance = NotApplicable }
  /// Message Fragment P10 Sends/sec: The number of priority 10 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P10 Sends/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment P10 Sends/sec"; instance = NotApplicable }
  /// Message Fragment P2 Sends/sec: The number of priority 2 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P2 Sends/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment P2 Sends/sec"; instance = NotApplicable }
  /// Message Fragment P3 Sends/sec: The number of priority 3 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P3 Sends/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment P3 Sends/sec"; instance = NotApplicable }
  /// Message Fragment P4 Sends/sec: The number of priority 4 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P4 Sends/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment P4 Sends/sec"; instance = NotApplicable }
  /// Message Fragment P5 Sends/sec: The number of priority 5 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P5 Sends/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment P5 Sends/sec"; instance = NotApplicable }
  /// Message Fragment P6 Sends/sec: The number of priority 6 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P6 Sends/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment P6 Sends/sec"; instance = NotApplicable }
  /// Message Fragment P7 Sends/sec: The number of priority 7 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P7 Sends/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment P7 Sends/sec"; instance = NotApplicable }
  /// Message Fragment P8 Sends/sec: The number of priority 8 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P8 Sends/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment P8 Sends/sec"; instance = NotApplicable }
  /// Message Fragment P9 Sends/sec: The number of priority 9 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P9 Sends/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment P9 Sends/sec"; instance = NotApplicable }
  /// Message Fragment Receives/sec: The number of message fragments received per second in transport receive I/O operations.
  let ``Message Fragment Receives/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment Receives/sec"; instance = NotApplicable }
  /// Message Fragment Sends/sec: The number of message fragments sent per second in transport send I/O operations.
  let ``Message Fragment Sends/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment Sends/sec"; instance = NotApplicable }
  /// Msg Fragment Recv Size Avg: The average byte size of message fragments received in transport receive I/O operations.
  let ``Msg Fragment Recv Size Avg`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Msg Fragment Recv Size Avg"; instance = NotApplicable }
  /// Msg Fragment Recv Size Avg Base: Base for the average byte size of message fragments received in transport receive I/O operations.
  let ``Msg Fragment Recv Size Avg Base`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Msg Fragment Recv Size Avg Base"; instance = NotApplicable }
  /// Msg Fragment Send Size Avg: The average byte size of message fragments sent in transport send I/O operations.
  let ``Msg Fragment Send Size Avg`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Msg Fragment Send Size Avg"; instance = NotApplicable }
  /// Msg Fragment Send Size Avg Base: Base for the average byte size of message fragments sent in transport send I/O operations.
  let ``Msg Fragment Send Size Avg Base`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Msg Fragment Send Size Avg Base"; instance = NotApplicable }
  /// Open Connection Count: The total number of transport connections currently open.
  let ``Open Connection Count`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Open Connection Count"; instance = NotApplicable }
  /// Pending Bytes for Recv I/O: The number of bytes associated with in completed transport receive I/O operations whose message fragments haven't been enqueued (or rejected) yet.
  let ``Pending Bytes for Recv I/O`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Pending Bytes for Recv I/O"; instance = NotApplicable }
  /// Pending Bytes for Send I/O: The number of buffer bytes associated with message fragments being marshalled, or marshalled and ready to be sent with send I/O operations.
  let ``Pending Bytes for Send I/O`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Pending Bytes for Send I/O"; instance = NotApplicable }
  /// Pending Msg Frags for Recv I/O: The current number of message fragments received in transport receive I/O operations that have not been enqueued (or rejected) yet.
  let ``Pending Msg Frags for Recv I/O`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Pending Msg Frags for Recv I/O"; instance = NotApplicable }
  /// Pending Msg Frags for Send I/O: The current number of message fragments that are being marshalled, or marshalled and ready to be sent via the transport layer.
  let ``Pending Msg Frags for Send I/O`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Pending Msg Frags for Send I/O"; instance = NotApplicable }
  /// Receive I/O Len Avg: The average byte length of transport receive I/O operations.
  let ``Receive I/O Len Avg`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Receive I/O Len Avg"; instance = NotApplicable }
  /// Receive I/O Len Avg Base: Base for the average byte length of transport receive I/O operations.
  let ``Receive I/O Len Avg Base`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Receive I/O Len Avg Base"; instance = NotApplicable }
  /// Receive I/O bytes/sec: The number of transport receive I/O bytes per second.
  let ``Receive I/O bytes/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Receive I/O bytes/sec"; instance = NotApplicable }
  /// Receive I/Os/sec: The number of transport receives I/O per second. Note that a transport receive I/O may contain more than one message fragment.
  let ``Receive I/Os/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Receive I/Os/sec"; instance = NotApplicable }
  /// Recv I/O Buffer Copies Count: The number of times when transport receive I/O operations had to move buffer fragments in memory.
  let ``Recv I/O Buffer Copies Count`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Recv I/O Buffer Copies Count"; instance = NotApplicable }
  /// Recv I/O Buffer Copies bytes/sec: The rate at which transport receive I/O operations had to move buffer fragments in memory.
  let ``Recv I/O Buffer Copies bytes/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Recv I/O Buffer Copies bytes/sec"; instance = NotApplicable }
  /// Send I/O Len Avg: The average byte length of transport send I/O operations.
  let ``Send I/O Len Avg`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Send I/O Len Avg"; instance = NotApplicable }
  /// Send I/O Len Avg Base: Base for the average byte length of transport send I/O operations.
  let ``Send I/O Len Avg Base`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Send I/O Len Avg Base"; instance = NotApplicable }
  /// Send I/O bytes/sec: The number of transport send I/O bytes per second.
  let ``Send I/O bytes/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Send I/O bytes/sec"; instance = NotApplicable }
  /// Send I/Os/sec: The number of transport send I/Os per second. Note that a transport send I/O may contain more than one message fragment.
  let ``Send I/Os/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Send I/Os/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Current Bytes for Recv I/O``
      ``Current Bytes for Send I/O``
      ``Current Msg Frags for Send I/O``
      ``Message Fragment P1 Sends/sec``
      ``Message Fragment P10 Sends/sec``
      ``Message Fragment P2 Sends/sec``
      ``Message Fragment P3 Sends/sec``
      ``Message Fragment P4 Sends/sec``
      ``Message Fragment P5 Sends/sec``
      ``Message Fragment P6 Sends/sec``
      ``Message Fragment P7 Sends/sec``
      ``Message Fragment P8 Sends/sec``
      ``Message Fragment P9 Sends/sec``
      ``Message Fragment Receives/sec``
      ``Message Fragment Sends/sec``
      ``Msg Fragment Recv Size Avg``
      ``Msg Fragment Recv Size Avg Base``
      ``Msg Fragment Send Size Avg``
      ``Msg Fragment Send Size Avg Base``
      ``Open Connection Count``
      ``Pending Bytes for Recv I/O``
      ``Pending Bytes for Send I/O``
      ``Pending Msg Frags for Recv I/O``
      ``Pending Msg Frags for Send I/O``
      ``Receive I/O Len Avg``
      ``Receive I/O Len Avg Base``
      ``Receive I/O bytes/sec``
      ``Receive I/Os/sec``
      ``Recv I/O Buffer Copies Count``
      ``Recv I/O Buffer Copies bytes/sec``
      ``Send I/O Len Avg``
      ``Send I/O Len Avg Base``
      ``Send I/O bytes/sec``
      ``Send I/Os/sec``
    ]

/// SQLServer:Buffer Manager: Statistics related to SQL Servers buffer manager
///
/// This performance counter does not have instance based counters
module ``SQLServer:Buffer Manager`` =

  [<Literal>]
  let Category = "SQLServer:Buffer Manager"

  let PCC = getPCC Category
  /// Background writer pages/sec: Number of pages flushed to enforce the recovery interval settings.
  let ``Background writer pages/sec`` =
    { category = "SQLServer:Buffer Manager"; counter = "Background writer pages/sec"; instance = NotApplicable }
  /// Buffer cache hit ratio: Percentage of pages that were found in the buffer pool without having to incur a read from disk.
  let ``Buffer cache hit ratio`` =
    { category = "SQLServer:Buffer Manager"; counter = "Buffer cache hit ratio"; instance = NotApplicable }
  /// Buffer cache hit ratio base: Base for prior entry
  let ``Buffer cache hit ratio base`` =
    { category = "SQLServer:Buffer Manager"; counter = "Buffer cache hit ratio base"; instance = NotApplicable }
  /// Checkpoint pages/sec: Number of pages flushed by checkpoint or other operations that require all dirty pages to be flushed.
  let ``Checkpoint pages/sec`` =
    { category = "SQLServer:Buffer Manager"; counter = "Checkpoint pages/sec"; instance = NotApplicable }
  /// Database pages: Number of pages in the buffer pool with database content.
  let ``Database pages`` =
    { category = "SQLServer:Buffer Manager"; counter = "Database pages"; instance = NotApplicable }
  /// Extension allocated pages: Number of pages occupying buffer pool extension cache.
  let ``Extension allocated pages`` =
    { category = "SQLServer:Buffer Manager"; counter = "Extension allocated pages"; instance = NotApplicable }
  /// Extension free pages: Number of pages needed to fill the buffer pool extension cache.
  let ``Extension free pages`` =
    { category = "SQLServer:Buffer Manager"; counter = "Extension free pages"; instance = NotApplicable }
  /// Extension in use as percentage: Percentage of the buffer pool extension paging file occupied by buffer manager pages.
  let ``Extension in use as percentage`` =
    { category = "SQLServer:Buffer Manager"; counter = "Extension in use as percentage"; instance = NotApplicable }
  /// Extension outstanding IO counter: Number of buffer pool extension page reads/writes outstanding.
  let ``Extension outstanding IO counter`` =
    { category = "SQLServer:Buffer Manager"; counter = "Extension outstanding IO counter"; instance = NotApplicable }
  /// Extension page evictions/sec: Number of buffer pool extension page evictions.
  let ``Extension page evictions/sec`` =
    { category = "SQLServer:Buffer Manager"; counter = "Extension page evictions/sec"; instance = NotApplicable }
  /// Extension page reads/sec: Number of buffer pool extension page reads issued.
  let ``Extension page reads/sec`` =
    { category = "SQLServer:Buffer Manager"; counter = "Extension page reads/sec"; instance = NotApplicable }
  /// Extension page unreferenced time: Average seconds a page will stay in the buffer pool extension without references.
  let ``Extension page unreferenced time`` =
    { category = "SQLServer:Buffer Manager"; counter = "Extension page unreferenced time"; instance = NotApplicable }
  /// Extension page writes/sec: Number of Extension page writes issued.
  let ``Extension page writes/sec`` =
    { category = "SQLServer:Buffer Manager"; counter = "Extension page writes/sec"; instance = NotApplicable }
  /// Free list stalls/sec: Number of requests that had to wait for a free page.
  let ``Free list stalls/sec`` =
    { category = "SQLServer:Buffer Manager"; counter = "Free list stalls/sec"; instance = NotApplicable }
  /// Integral Controller Slope: The slope that integral controller for the buffer pool last used, times -10 billion
  let ``Integral Controller Slope`` =
    { category = "SQLServer:Buffer Manager"; counter = "Integral Controller Slope"; instance = NotApplicable }
  /// Lazy writes/sec: Number of buffers written by buffer manager's lazy writer.
  let ``Lazy writes/sec`` =
    { category = "SQLServer:Buffer Manager"; counter = "Lazy writes/sec"; instance = NotApplicable }
  /// Page life expectancy: Number of seconds a page will stay in the buffer pool without references.
  let ``Page life expectancy`` =
    { category = "SQLServer:Buffer Manager"; counter = "Page life expectancy"; instance = NotApplicable }
  /// Page lookups/sec: Number of requests to find a page in the buffer pool.
  let ``Page lookups/sec`` =
    { category = "SQLServer:Buffer Manager"; counter = "Page lookups/sec"; instance = NotApplicable }
  /// Page reads/sec: Number of physical database page reads issued.
  let ``Page reads/sec`` =
    { category = "SQLServer:Buffer Manager"; counter = "Page reads/sec"; instance = NotApplicable }
  /// Page writes/sec: Number of physical database page writes issued.
  let ``Page writes/sec`` =
    { category = "SQLServer:Buffer Manager"; counter = "Page writes/sec"; instance = NotApplicable }
  /// Readahead pages/sec: Number of pages read in anticipation of use.
  let ``Readahead pages/sec`` =
    { category = "SQLServer:Buffer Manager"; counter = "Readahead pages/sec"; instance = NotApplicable }
  /// Readahead time/sec: Time (microseconds) spent issuing readahead.
  let ``Readahead time/sec`` =
    { category = "SQLServer:Buffer Manager"; counter = "Readahead time/sec"; instance = NotApplicable }
  /// Target pages: Ideal number of pages in the buffer pool.
  let ``Target pages`` =
    { category = "SQLServer:Buffer Manager"; counter = "Target pages"; instance = NotApplicable }

  let allCounters =
    [ ``Background writer pages/sec``
      ``Buffer cache hit ratio``
      ``Buffer cache hit ratio base``
      ``Checkpoint pages/sec``
      ``Database pages``
      ``Extension allocated pages``
      ``Extension free pages``
      ``Extension in use as percentage``
      ``Extension outstanding IO counter``
      ``Extension page evictions/sec``
      ``Extension page reads/sec``
      ``Extension page unreferenced time``
      ``Extension page writes/sec``
      ``Free list stalls/sec``
      ``Integral Controller Slope``
      ``Lazy writes/sec``
      ``Page life expectancy``
      ``Page lookups/sec``
      ``Page reads/sec``
      ``Page writes/sec``
      ``Readahead pages/sec``
      ``Readahead time/sec``
      ``Target pages``
    ]

/// SQLServer:Buffer Node: Statistics related to SQL Server's buffer pool by NUMA node
///
/// This performance counter does not have non-instance based counters
module ``SQLServer:Buffer Node`` =

  [<Literal>]
  let Category = "SQLServer:Buffer Node"

  let PCC = getPCC Category
  /// Database pages: Database pages on node.
  let ``Database pages`` instance =
    { category = "SQLServer:Buffer Node"; counter = "Database pages"; instance = instance }
  /// Local node page lookups/sec: Number of lookup requests from this node which were satisfied from this node.
  let ``Local node page lookups/sec`` instance =
    { category = "SQLServer:Buffer Node"; counter = "Local node page lookups/sec"; instance = instance }
  /// Page life expectancy: Number of seconds a page will stay in the buffer pool without references.
  let ``Page life expectancy`` instance =
    { category = "SQLServer:Buffer Node"; counter = "Page life expectancy"; instance = instance }
  /// Remote node page lookups/sec: Number of lookup requests from this node which were satisfied from other nodes.
  let ``Remote node page lookups/sec`` instance =
    { category = "SQLServer:Buffer Node"; counter = "Remote node page lookups/sec"; instance = instance }

  let allCounters =
    [ ``Database pages``
      ``Local node page lookups/sec``
      ``Page life expectancy``
      ``Remote node page lookups/sec``
    ]

/// SQLServer:CLR: CLR Execution in SQL Server
///
/// This performance counter does not have instance based counters
module ``SQLServer:CLR`` =

  [<Literal>]
  let Category = "SQLServer:CLR"

  let PCC = getPCC Category
  /// CLR Execution: Total Execution time in CLR ( microseconds ).
  let ``CLR Execution`` =
    { category = "SQLServer:CLR"; counter = "CLR Execution"; instance = NotApplicable }

  let allCounters =
    [ ``CLR Execution``

    ]

/// SQLServer:Catalog Metadata: This defines a catalog metadata manager object for SQL Server
///
/// This performance counter does not have non-instance based counters
module ``SQLServer:Catalog Metadata`` =

  [<Literal>]
  let Category = "SQLServer:Catalog Metadata"

  let PCC = getPCC Category
  /// Cache Entries Count: Number of entries in the catalog metadata cache
  let ``Cache Entries Count`` instance =
    { category = "SQLServer:Catalog Metadata"; counter = "Cache Entries Count"; instance = instance }
  /// Cache Entries Pinned Count: Number of catalog metadata cache entries that are pinned
  let ``Cache Entries Pinned Count`` instance =
    { category = "SQLServer:Catalog Metadata"; counter = "Cache Entries Pinned Count"; instance = instance }
  /// Cache Hit Ratio: Ratio between catalog metadata cache hits and lookups
  let ``Cache Hit Ratio`` instance =
    { category = "SQLServer:Catalog Metadata"; counter = "Cache Hit Ratio"; instance = instance }
  /// Cache Hit Ratio Base: Base for prior entry
  let ``Cache Hit Ratio Base`` instance =
    { category = "SQLServer:Catalog Metadata"; counter = "Cache Hit Ratio Base"; instance = instance }

  let allCounters =
    [ ``Cache Entries Count``
      ``Cache Entries Pinned Count``
      ``Cache Hit Ratio``
      ``Cache Hit Ratio Base``
    ]

/// SQLServer:Cursor Manager Total: Counters for cursor properties not grouped by type
///
/// This performance counter does not have instance based counters
module ``SQLServer:Cursor Manager Total`` =

  [<Literal>]
  let Category = "SQLServer:Cursor Manager Total"

  let PCC = getPCC Category
  /// Async population count: Number of cursors being populated asynchronously.
  let ``Async population count`` =
    { category = "SQLServer:Cursor Manager Total"; counter = "Async population count"; instance = NotApplicable }
  /// Cursor conversion rate: Number of cursor conversions/sec.
  let ``Cursor conversion rate`` =
    { category = "SQLServer:Cursor Manager Total"; counter = "Cursor conversion rate"; instance = NotApplicable }
  /// Cursor flushes: Total number of times a flush for a cursor xstmt occured.
  let ``Cursor flushes`` =
    { category = "SQLServer:Cursor Manager Total"; counter = "Cursor flushes"; instance = NotApplicable }

  let allCounters =
    [ ``Async population count``
      ``Cursor conversion rate``
      ``Cursor flushes``
    ]

/// SQLServer:Cursor Manager by Type: Counters for cursor properties grouped by type
///
/// This performance counter does not have non-instance based counters
module ``SQLServer:Cursor Manager by Type`` =

  [<Literal>]
  let Category = "SQLServer:Cursor Manager by Type"

  let PCC = getPCC Category
  /// Active cursors: Number of active cursors.
  let ``Active cursors`` instance =
    { category = "SQLServer:Cursor Manager by Type"; counter = "Active cursors"; instance = instance }
  /// Cache Hit Ratio: Ratio between cache hits and lookups
  let ``Cache Hit Ratio`` instance =
    { category = "SQLServer:Cursor Manager by Type"; counter = "Cache Hit Ratio"; instance = instance }
  /// Cache Hit Ratio Base: Base for prior entry
  let ``Cache Hit Ratio Base`` instance =
    { category = "SQLServer:Cursor Manager by Type"; counter = "Cache Hit Ratio Base"; instance = instance }
  /// Cached Cursor Counts: Number of cursors of a given type in the cache
  let ``Cached Cursor Counts`` instance =
    { category = "SQLServer:Cursor Manager by Type"; counter = "Cached Cursor Counts"; instance = instance }
  /// Cursor Cache Use Counts/sec: Times each type of cached cursor has been used
  let ``Cursor Cache Use Counts/sec`` instance =
    { category = "SQLServer:Cursor Manager by Type"; counter = "Cursor Cache Use Counts/sec"; instance = instance }
  /// Cursor Requests/sec: Number of SQL cursor requests received by server.
  let ``Cursor Requests/sec`` instance =
    { category = "SQLServer:Cursor Manager by Type"; counter = "Cursor Requests/sec"; instance = instance }
  /// Cursor memory usage: Amount of memory consumed by cursors (KB).
  let ``Cursor memory usage`` instance =
    { category = "SQLServer:Cursor Manager by Type"; counter = "Cursor memory usage"; instance = instance }
  /// Cursor worktable usage: Number of worktables used by cursors.
  let ``Cursor worktable usage`` instance =
    { category = "SQLServer:Cursor Manager by Type"; counter = "Cursor worktable usage"; instance = instance }
  /// Number of active cursor plans: Number of cursor plans.
  let ``Number of active cursor plans`` instance =
    { category = "SQLServer:Cursor Manager by Type"; counter = "Number of active cursor plans"; instance = instance }

  let allCounters =
    [ ``Active cursors``
      ``Cache Hit Ratio``
      ``Cache Hit Ratio Base``
      ``Cached Cursor Counts``
      ``Cursor Cache Use Counts/sec``
      ``Cursor Requests/sec``
      ``Cursor memory usage``
      ``Cursor worktable usage``
      ``Number of active cursor plans``
    ]

/// SQLServer:Database Mirroring: This defines a Database Mirroring object for SQL Server
///
/// This performance counter does not have instance based counters
module ``SQLServer:Database Mirroring`` =

  [<Literal>]
  let Category = "SQLServer:Database Mirroring"

  let PCC = getPCC Category
  /// Bytes Received/sec: -
  let ``Bytes Received/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Bytes Received/sec"; instance = instance }
  /// Bytes Sent/sec: -
  let ``Bytes Sent/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Bytes Sent/sec"; instance = instance }
  /// Log Bytes Received/sec: -
  let ``Log Bytes Received/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Log Bytes Received/sec"; instance = instance }
  /// Log Bytes Redone from Cache/sec: -
  let ``Log Bytes Redone from Cache/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Log Bytes Redone from Cache/sec"; instance = instance }
  /// Log Bytes Sent from Cache/sec: -
  let ``Log Bytes Sent from Cache/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Log Bytes Sent from Cache/sec"; instance = instance }
  /// Log Bytes Sent/sec: -
  let ``Log Bytes Sent/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Log Bytes Sent/sec"; instance = instance }
  /// Log Compressed Bytes Rcvd/sec: -
  let ``Log Compressed Bytes Rcvd/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Log Compressed Bytes Rcvd/sec"; instance = instance }
  /// Log Compressed Bytes Sent/sec: -
  let ``Log Compressed Bytes Sent/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Log Compressed Bytes Sent/sec"; instance = instance }
  /// Log Harden Time (ms): -
  let ``Log Harden Time (ms)`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Log Harden Time (ms)"; instance = instance }
  /// Log Remaining for Undo KB: -
  let ``Log Remaining for Undo KB`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Log Remaining for Undo KB"; instance = instance }
  /// Log Scanned for Undo KB: -
  let ``Log Scanned for Undo KB`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Log Scanned for Undo KB"; instance = instance }
  /// Log Send Flow Control Time (ms): -
  let ``Log Send Flow Control Time (ms)`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Log Send Flow Control Time (ms)"; instance = instance }
  /// Log Send Queue KB: -
  let ``Log Send Queue KB`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Log Send Queue KB"; instance = instance }
  /// Mirrored Write Transactions/sec: -
  let ``Mirrored Write Transactions/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Mirrored Write Transactions/sec"; instance = instance }
  /// Pages Sent/sec: -
  let ``Pages Sent/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Pages Sent/sec"; instance = instance }
  /// Receives/sec: -
  let ``Receives/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Receives/sec"; instance = instance }
  /// Redo Bytes/sec: -
  let ``Redo Bytes/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Redo Bytes/sec"; instance = instance }
  /// Redo Queue KB: -
  let ``Redo Queue KB`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Redo Queue KB"; instance = instance }
  /// Send/Receive Ack Time: -
  let ``Send/Receive Ack Time`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Send/Receive Ack Time"; instance = instance }
  /// Sends/sec: -
  let ``Sends/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Sends/sec"; instance = instance }
  /// Transaction Delay: -
  let ``Transaction Delay`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Transaction Delay"; instance = instance }

  let allCounters =
    [ ``Bytes Received/sec``
      ``Bytes Sent/sec``
      ``Log Bytes Received/sec``
      ``Log Bytes Redone from Cache/sec``
      ``Log Bytes Sent from Cache/sec``
      ``Log Bytes Sent/sec``
      ``Log Compressed Bytes Rcvd/sec``
      ``Log Compressed Bytes Sent/sec``
      ``Log Harden Time (ms)``
      ``Log Remaining for Undo KB``
      ``Log Scanned for Undo KB``
      ``Log Send Flow Control Time (ms)``
      ``Log Send Queue KB``
      ``Mirrored Write Transactions/sec``
      ``Pages Sent/sec``
      ``Receives/sec``
      ``Redo Bytes/sec``
      ``Redo Queue KB``
      ``Send/Receive Ack Time``
      ``Sends/sec``
      ``Transaction Delay``
    ]

/// SQLServer:Database Replica: This defines a HADR secondary database object for SQL Server
///
/// This performance counter does not have non-instance based counters
module ``SQLServer:Database Replica`` =

  [<Literal>]
  let Category = "SQLServer:Database Replica"

  let PCC = getPCC Category
  /// File Bytes Received/sec: Amount of filestream data received by the availability replica for the database
  let ``File Bytes Received/sec`` instance =
    { category = "SQLServer:Database Replica"; counter = "File Bytes Received/sec"; instance = instance }
  /// Log Bytes Received/sec: Amount of logs received by the availability replica for the database
  let ``Log Bytes Received/sec`` instance =
    { category = "SQLServer:Database Replica"; counter = "Log Bytes Received/sec"; instance = instance }
  /// Log Send Queue: Amount of logs in kilobytes that is waiting to be send to the database replica
  let ``Log Send Queue`` instance =
    { category = "SQLServer:Database Replica"; counter = "Log Send Queue"; instance = instance }
  /// Log remaining for undo: The amount of log in kilobytes remaining to finish the undo phase.
  let ``Log remaining for undo`` instance =
    { category = "SQLServer:Database Replica"; counter = "Log remaining for undo"; instance = instance }
  /// Mirrored Write Transactions/sec: Number of transactions which wrote to the mirrored database in the last second, that waited for log to be sent to the mirror.
  let ``Mirrored Write Transactions/sec`` instance =
    { category = "SQLServer:Database Replica"; counter = "Mirrored Write Transactions/sec"; instance = instance }
  /// Recovery Queue: Total number of hardened log in kilobytes that is waiting to be redone on the secondary
  let ``Recovery Queue`` instance =
    { category = "SQLServer:Database Replica"; counter = "Recovery Queue"; instance = instance }
  /// Redo Bytes Remaining: The amount of log in kilobytes remaining to be redone to finish the reverting phase.
  let ``Redo Bytes Remaining`` instance =
    { category = "SQLServer:Database Replica"; counter = "Redo Bytes Remaining"; instance = instance }
  /// Redo blocked/sec: Number of times redo gets blocked in the last second
  let ``Redo blocked/sec`` instance =
    { category = "SQLServer:Database Replica"; counter = "Redo blocked/sec"; instance = instance }
  /// Redone Bytes/sec: Amount of log records redone in the last second to catch up the database replica
  let ``Redone Bytes/sec`` instance =
    { category = "SQLServer:Database Replica"; counter = "Redone Bytes/sec"; instance = instance }
  /// Total Log requiring undo: The amount of log in kilobytes that need to be undone.
  let ``Total Log requiring undo`` instance =
    { category = "SQLServer:Database Replica"; counter = "Total Log requiring undo"; instance = instance }
  /// Transaction Delay: Number of milliseconds transaction termination waited for acknowledgement per second.
  let ``Transaction Delay`` instance =
    { category = "SQLServer:Database Replica"; counter = "Transaction Delay"; instance = instance }

  let allCounters =
    [ ``File Bytes Received/sec``
      ``Log Bytes Received/sec``
      ``Log Send Queue``
      ``Log remaining for undo``
      ``Mirrored Write Transactions/sec``
      ``Recovery Queue``
      ``Redo Bytes Remaining``
      ``Redo blocked/sec``
      ``Redone Bytes/sec``
      ``Total Log requiring undo``
      ``Transaction Delay``
    ]

/// SQLServer:Databases: This defines a Database manager object for SQL Server
///
/// This performance counter does not have non-instance based counters
module ``SQLServer:Databases`` =

  [<Literal>]
  let Category = "SQLServer:Databases"

  let PCC = getPCC Category
  /// Active Transactions: Number of active update transactions for the database.
  let ``Active Transactions`` instance =
    { category = "SQLServer:Databases"; counter = "Active Transactions"; instance = instance }
  /// Backup/Restore Throughput/sec: Read/write throughput for backup/restore of a database.
  let ``Backup/Restore Throughput/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Backup/Restore Throughput/sec"; instance = instance }
  /// Bulk Copy Rows/sec: Number of rows bulk copied.
  let ``Bulk Copy Rows/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Bulk Copy Rows/sec"; instance = instance }
  /// Bulk Copy Throughput/sec: KiloBytes bulk copied.
  let ``Bulk Copy Throughput/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Bulk Copy Throughput/sec"; instance = instance }
  /// Commit table entries: The size of the in-memory part of the commit table for the database.
  let ``Commit table entries`` instance =
    { category = "SQLServer:Databases"; counter = "Commit table entries"; instance = instance }
  /// DBCC Logical Scan Bytes/sec: Logical read scan rate for DBCC commands
  let ``DBCC Logical Scan Bytes/sec`` instance =
    { category = "SQLServer:Databases"; counter = "DBCC Logical Scan Bytes/sec"; instance = instance }
  /// Data File(s) Size (KB): The cumulative size of all the data files in the database.
  let ``Data File(s) Size (KB)`` instance =
    { category = "SQLServer:Databases"; counter = "Data File(s) Size (KB)"; instance = instance }
  /// Group Commit Time/sec: Group stall time (microseconds) per second.
  let ``Group Commit Time/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Group Commit Time/sec"; instance = instance }
  /// Log Bytes Flushed/sec: Total number of log bytes flushed.
  let ``Log Bytes Flushed/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Log Bytes Flushed/sec"; instance = instance }
  /// Log Cache Hit Ratio: Percentage of log cache reads that were satisfied from the log cache.
  let ``Log Cache Hit Ratio`` instance =
    { category = "SQLServer:Databases"; counter = "Log Cache Hit Ratio"; instance = instance }
  /// Log Cache Hit Ratio Base: Base for log cache calculations
  let ``Log Cache Hit Ratio Base`` instance =
    { category = "SQLServer:Databases"; counter = "Log Cache Hit Ratio Base"; instance = instance }
  /// Log Cache Reads/sec: Reads performed through the log manager cache.
  let ``Log Cache Reads/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Log Cache Reads/sec"; instance = instance }
  /// Log File(s) Size (KB): The cumulative size of all the log files in the database.
  let ``Log File(s) Size (KB)`` instance =
    { category = "SQLServer:Databases"; counter = "Log File(s) Size (KB)"; instance = instance }
  /// Log File(s) Used Size (KB): The cumulative used size of all the log files in the database.
  let ``Log File(s) Used Size (KB)`` instance =
    { category = "SQLServer:Databases"; counter = "Log File(s) Used Size (KB)"; instance = instance }
  /// Log Flush Wait Time: Total wait time (milliseconds).
  let ``Log Flush Wait Time`` instance =
    { category = "SQLServer:Databases"; counter = "Log Flush Wait Time"; instance = instance }
  /// Log Flush Waits/sec: Number of commits waiting on log flush.
  let ``Log Flush Waits/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Log Flush Waits/sec"; instance = instance }
  /// Log Flush Write Time (ms): Milliseconds it took to perform the writes of log flushes completed in the last second
  let ``Log Flush Write Time (ms)`` instance =
    { category = "SQLServer:Databases"; counter = "Log Flush Write Time (ms)"; instance = instance }
  /// Log Flushes/sec: Number of log flushes.
  let ``Log Flushes/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Log Flushes/sec"; instance = instance }
  /// Log Growths: Total number of log growths for this database.
  let ``Log Growths`` instance =
    { category = "SQLServer:Databases"; counter = "Log Growths"; instance = instance }
  /// Log Pool Cache Misses/sec: Log block cache misses from log pool.
  let ``Log Pool Cache Misses/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Log Pool Cache Misses/sec"; instance = instance }
  /// Log Pool Disk Reads/sec: Log disk reads via log pool.
  let ``Log Pool Disk Reads/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Log Pool Disk Reads/sec"; instance = instance }
  /// Log Pool Requests/sec: Log block requests performed through log pool.
  let ``Log Pool Requests/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Log Pool Requests/sec"; instance = instance }
  /// Log Shrinks: Total number of log shrinks for this database.
  let ``Log Shrinks`` instance =
    { category = "SQLServer:Databases"; counter = "Log Shrinks"; instance = instance }
  /// Log Truncations: Total number of log truncations for this database.
  let ``Log Truncations`` instance =
    { category = "SQLServer:Databases"; counter = "Log Truncations"; instance = instance }
  /// Percent Log Used: The percent of space in the log that is in use.
  let ``Percent Log Used`` instance =
    { category = "SQLServer:Databases"; counter = "Percent Log Used"; instance = instance }
  /// Repl. Pending Xacts: Number of pending replication transactions in the database.
  let ``Repl. Pending Xacts`` instance =
    { category = "SQLServer:Databases"; counter = "Repl. Pending Xacts"; instance = instance }
  /// Repl. Trans. Rate: Replication transaction rate (replicated transactions/sec.).
  let ``Repl. Trans. Rate`` instance =
    { category = "SQLServer:Databases"; counter = "Repl. Trans. Rate"; instance = instance }
  /// Shrink Data Movement Bytes/sec: The rate data is being moved by Autoshrink, DBCC SHRINKDATABASE or SHRINKFILE.
  let ``Shrink Data Movement Bytes/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Shrink Data Movement Bytes/sec"; instance = instance }
  /// Tracked transactions/sec: Number of committed transactions recorded in the commit table for the database.
  let ``Tracked transactions/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Tracked transactions/sec"; instance = instance }
  /// Transactions/sec: Number of transactions started for the database.
  let ``Transactions/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Transactions/sec"; instance = instance }
  /// Write Transactions/sec: Number of transactions which wrote to the database in the last second.
  let ``Write Transactions/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Write Transactions/sec"; instance = instance }
  /// XTP Memory Used (KB): The amount of memory used by XTP in the database.
  let ``XTP Memory Used (KB)`` instance =
    { category = "SQLServer:Databases"; counter = "XTP Memory Used (KB)"; instance = instance }

  let allCounters =
    [ ``Active Transactions``
      ``Backup/Restore Throughput/sec``
      ``Bulk Copy Rows/sec``
      ``Bulk Copy Throughput/sec``
      ``Commit table entries``
      ``DBCC Logical Scan Bytes/sec``
      ``Data File(s) Size (KB)``
      ``Group Commit Time/sec``
      ``Log Bytes Flushed/sec``
      ``Log Cache Hit Ratio``
      ``Log Cache Hit Ratio Base``
      ``Log Cache Reads/sec``
      ``Log File(s) Size (KB)``
      ``Log File(s) Used Size (KB)``
      ``Log Flush Wait Time``
      ``Log Flush Waits/sec``
      ``Log Flush Write Time (ms)``
      ``Log Flushes/sec``
      ``Log Growths``
      ``Log Pool Cache Misses/sec``
      ``Log Pool Disk Reads/sec``
      ``Log Pool Requests/sec``
      ``Log Shrinks``
      ``Log Truncations``
      ``Percent Log Used``
      ``Repl. Pending Xacts``
      ``Repl. Trans. Rate``
      ``Shrink Data Movement Bytes/sec``
      ``Tracked transactions/sec``
      ``Transactions/sec``
      ``Write Transactions/sec``
      ``XTP Memory Used (KB)``
    ]

/// SQLServer:Deprecated Features: Statistics on deprecated feature usage
///
/// This performance counter does not have non-instance based counters
module ``SQLServer:Deprecated Features`` =

  [<Literal>]
  let Category = "SQLServer:Deprecated Features"

  let PCC = getPCC Category
  /// Usage: Feature usage since last SQL Server startup
  let ``Usage`` instance =
    { category = "SQLServer:Deprecated Features"; counter = "Usage"; instance = instance }

  let allCounters =
    [ ``Usage``

    ]

/// SQLServer:Exec Statistics: Execution statistics for external calls
///
/// This performance counter does not have non-instance based counters
module ``SQLServer:Exec Statistics`` =

  [<Literal>]
  let Category = "SQLServer:Exec Statistics"

  let PCC = getPCC Category
  /// DTC calls: Statistics relevant to execution of DTC calls.
  let ``DTC calls`` instance =
    { category = "SQLServer:Exec Statistics"; counter = "DTC calls"; instance = instance }
  /// Distributed Query: Statistics relevant to execution of distributed queries.
  let ``Distributed Query`` instance =
    { category = "SQLServer:Exec Statistics"; counter = "Distributed Query"; instance = instance }
  /// Extended Procedures: Statistics relevant to execution of XP calls.
  let ``Extended Procedures`` instance =
    { category = "SQLServer:Exec Statistics"; counter = "Extended Procedures"; instance = instance }
  /// OLEDB calls: Statistics relevant to execution of OLEDB calls.
  let ``OLEDB calls`` instance =
    { category = "SQLServer:Exec Statistics"; counter = "OLEDB calls"; instance = instance }

  let allCounters =
    [ ``DTC calls``
      ``Distributed Query``
      ``Extended Procedures``
      ``OLEDB calls``
    ]

/// SQLServer:FileTable: Statistics associated with FileTable and non-transacted access
///
/// This performance counter does not have instance based counters
module ``SQLServer:FileTable`` =

  [<Literal>]
  let Category = "SQLServer:FileTable"

  let PCC = getPCC Category
  /// Avg time FileTable enumeration: Average time (in milliseconds) taken for a FileTable enumeration request.
  let ``Avg time FileTable enumeration`` =
    { category = "SQLServer:FileTable"; counter = "Avg time FileTable enumeration"; instance = NotApplicable }
  /// Avg time FileTable handle kill: Average time (in milliseconds) taken to kill a FileTable handle.
  let ``Avg time FileTable handle kill`` =
    { category = "SQLServer:FileTable"; counter = "Avg time FileTable handle kill"; instance = NotApplicable }
  /// Avg time delete FileTable item: Average time (in milliseconds) taken to delete a FileTable item.
  let ``Avg time delete FileTable item`` =
    { category = "SQLServer:FileTable"; counter = "Avg time delete FileTable item"; instance = NotApplicable }
  /// Avg time move FileTable item: Average time (in milliseconds) taken to move a FileTable item.
  let ``Avg time move FileTable item`` =
    { category = "SQLServer:FileTable"; counter = "Avg time move FileTable item"; instance = NotApplicable }
  /// Avg time per file I/O request: Average time (in milliseconds) spent handling an incoming file I/O request.
  let ``Avg time per file I/O request`` =
    { category = "SQLServer:FileTable"; counter = "Avg time per file I/O request"; instance = NotApplicable }
  /// Avg time per file I/O response: Average time (in milliseconds) spent handling an outgoing file I/O response.
  let ``Avg time per file I/O response`` =
    { category = "SQLServer:FileTable"; counter = "Avg time per file I/O response"; instance = NotApplicable }
  /// Avg time rename FileTable item: Average time (in milliseconds) taken to rename a FileTable item.
  let ``Avg time rename FileTable item`` =
    { category = "SQLServer:FileTable"; counter = "Avg time rename FileTable item"; instance = NotApplicable }
  /// Avg time to get FileTable item: Average time (in milliseconds) taken to retrieve a FileTable item.
  let ``Avg time to get FileTable item`` =
    { category = "SQLServer:FileTable"; counter = "Avg time to get FileTable item"; instance = NotApplicable }
  /// Avg time update FileTable item: Average time (in milliseconds) taken to update a FileTable item.
  let ``Avg time update FileTable item`` =
    { category = "SQLServer:FileTable"; counter = "Avg time update FileTable item"; instance = NotApplicable }
  /// FileTable db operations/sec: Total number of database operational events processed by the FileTable store component per second.
  let ``FileTable db operations/sec`` =
    { category = "SQLServer:FileTable"; counter = "FileTable db operations/sec"; instance = NotApplicable }
  /// FileTable enumeration reqs/sec: Total number of FileTable enumeration requests per second.
  let ``FileTable enumeration reqs/sec`` =
    { category = "SQLServer:FileTable"; counter = "FileTable enumeration reqs/sec"; instance = NotApplicable }
  /// FileTable file I/O requests/sec: Total number of incoming FileTable file I/O requests per second.
  let ``FileTable file I/O requests/sec`` =
    { category = "SQLServer:FileTable"; counter = "FileTable file I/O requests/sec"; instance = NotApplicable }
  /// FileTable file I/O response/sec: Total number of outgoing file I/O responses per second.
  let ``FileTable file I/O response/sec`` =
    { category = "SQLServer:FileTable"; counter = "FileTable file I/O response/sec"; instance = NotApplicable }
  /// FileTable item delete reqs/sec: Total number of FileTable delete item requests per second.
  let ``FileTable item delete reqs/sec`` =
    { category = "SQLServer:FileTable"; counter = "FileTable item delete reqs/sec"; instance = NotApplicable }
  /// FileTable item get requests/sec: Total number of FileTable retrieve item requests per second.
  let ``FileTable item get requests/sec`` =
    { category = "SQLServer:FileTable"; counter = "FileTable item get requests/sec"; instance = NotApplicable }
  /// FileTable item move reqs/sec: Total number of FileTable move item requests per second.
  let ``FileTable item move reqs/sec`` =
    { category = "SQLServer:FileTable"; counter = "FileTable item move reqs/sec"; instance = NotApplicable }
  /// FileTable item rename reqs/sec: Total number of FileTable rename item requests per second.
  let ``FileTable item rename reqs/sec`` =
    { category = "SQLServer:FileTable"; counter = "FileTable item rename reqs/sec"; instance = NotApplicable }
  /// FileTable item update reqs/sec: Total number of FileTable update item requests per second.
  let ``FileTable item update reqs/sec`` =
    { category = "SQLServer:FileTable"; counter = "FileTable item update reqs/sec"; instance = NotApplicable }
  /// FileTable kill handle ops/sec: Total number of FileTable handle kill operations per second.
  let ``FileTable kill handle ops/sec`` =
    { category = "SQLServer:FileTable"; counter = "FileTable kill handle ops/sec"; instance = NotApplicable }
  /// FileTable table operations/sec: Total number of table operational events processed by the FileTable store component per second.
  let ``FileTable table operations/sec`` =
    { category = "SQLServer:FileTable"; counter = "FileTable table operations/sec"; instance = NotApplicable }
  /// Time FileTable enumeration BASE: Average time (in milliseconds) taken for a FileTable enumeration request (BASE).
  let ``Time FileTable enumeration BASE`` =
    { category = "SQLServer:FileTable"; counter = "Time FileTable enumeration BASE"; instance = NotApplicable }
  /// Time FileTable handle kill BASE: Average time (in milliseconds) taken to kill a FileTable handle (BASE).
  let ``Time FileTable handle kill BASE`` =
    { category = "SQLServer:FileTable"; counter = "Time FileTable handle kill BASE"; instance = NotApplicable }
  /// Time delete FileTable item BASE: Average time (in milliseconds) taken to delete a FileTable item (BASE).
  let ``Time delete FileTable item BASE`` =
    { category = "SQLServer:FileTable"; counter = "Time delete FileTable item BASE"; instance = NotApplicable }
  /// Time move FileTable item BASE: Average time (in milliseconds) taken to move a FileTable item (BASE).
  let ``Time move FileTable item BASE`` =
    { category = "SQLServer:FileTable"; counter = "Time move FileTable item BASE"; instance = NotApplicable }
  /// Time per file I/O request BASE: Average time (in milliseconds) spent handling an incoming file I/O request (BASE).
  let ``Time per file I/O request BASE`` =
    { category = "SQLServer:FileTable"; counter = "Time per file I/O request BASE"; instance = NotApplicable }
  /// Time per file I/O response BASE: Average time (in milliseconds) spent handling an outgoing file I/O response (BASE).
  let ``Time per file I/O response BASE`` =
    { category = "SQLServer:FileTable"; counter = "Time per file I/O response BASE"; instance = NotApplicable }
  /// Time rename FileTable item BASE: Average time (in milliseconds) taken to rename a FileTable item (BASE).
  let ``Time rename FileTable item BASE`` =
    { category = "SQLServer:FileTable"; counter = "Time rename FileTable item BASE"; instance = NotApplicable }
  /// Time to get FileTable item BASE: Average time (in milliseconds) taken to retrieve a FileTable item (BASE).
  let ``Time to get FileTable item BASE`` =
    { category = "SQLServer:FileTable"; counter = "Time to get FileTable item BASE"; instance = NotApplicable }
  /// Time update FileTable item BASE: Average time (in milliseconds) taken to update a FileTable item (BASE).
  let ``Time update FileTable item BASE`` =
    { category = "SQLServer:FileTable"; counter = "Time update FileTable item BASE"; instance = NotApplicable }

  let allCounters =
    [ ``Avg time FileTable enumeration``
      ``Avg time FileTable handle kill``
      ``Avg time delete FileTable item``
      ``Avg time move FileTable item``
      ``Avg time per file I/O request``
      ``Avg time per file I/O response``
      ``Avg time rename FileTable item``
      ``Avg time to get FileTable item``
      ``Avg time update FileTable item``
      ``FileTable db operations/sec``
      ``FileTable enumeration reqs/sec``
      ``FileTable file I/O requests/sec``
      ``FileTable file I/O response/sec``
      ``FileTable item delete reqs/sec``
      ``FileTable item get requests/sec``
      ``FileTable item move reqs/sec``
      ``FileTable item rename reqs/sec``
      ``FileTable item update reqs/sec``
      ``FileTable kill handle ops/sec``
      ``FileTable table operations/sec``
      ``Time FileTable enumeration BASE``
      ``Time FileTable handle kill BASE``
      ``Time delete FileTable item BASE``
      ``Time move FileTable item BASE``
      ``Time per file I/O request BASE``
      ``Time per file I/O response BASE``
      ``Time rename FileTable item BASE``
      ``Time to get FileTable item BASE``
      ``Time update FileTable item BASE``
    ]

/// SQLServer:General Statistics: Server General Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:General Statistics`` =

  [<Literal>]
  let Category = "SQLServer:General Statistics"

  let PCC = getPCC Category
  /// Active Temp Tables: Number of temporary tables/table variables in use
  let ``Active Temp Tables`` =
    { category = "SQLServer:General Statistics"; counter = "Active Temp Tables"; instance = NotApplicable }
  /// Connection Reset/sec: Total number of connection resets per second.
  let ``Connection Reset/sec`` =
    { category = "SQLServer:General Statistics"; counter = "Connection Reset/sec"; instance = NotApplicable }
  /// Event Notifications Delayed Drop: Number of event notifications waiting to be dropped by a system thread
  let ``Event Notifications Delayed Drop`` =
    { category = "SQLServer:General Statistics"; counter = "Event Notifications Delayed Drop"; instance = NotApplicable }
  /// HTTP Authenticated Requests: Number of authenticated HTTP requests started per second.
  let ``HTTP Authenticated Requests`` =
    { category = "SQLServer:General Statistics"; counter = "HTTP Authenticated Requests"; instance = NotApplicable }
  /// Logical Connections: Number of logical connections to the system.
  let ``Logical Connections`` =
    { category = "SQLServer:General Statistics"; counter = "Logical Connections"; instance = NotApplicable }
  /// Logins/sec: Total number of logins started per second.
  let ``Logins/sec`` =
    { category = "SQLServer:General Statistics"; counter = "Logins/sec"; instance = NotApplicable }
  /// Logouts/sec: Total number of logouts started per second.
  let ``Logouts/sec`` =
    { category = "SQLServer:General Statistics"; counter = "Logouts/sec"; instance = NotApplicable }
  /// Mars Deadlocks: Number of Mars Deadlocks detected.
  let ``Mars Deadlocks`` =
    { category = "SQLServer:General Statistics"; counter = "Mars Deadlocks"; instance = NotApplicable }
  /// Non-atomic yield rate: Number of non-atomic yields per second.
  let ``Non-atomic yield rate`` =
    { category = "SQLServer:General Statistics"; counter = "Non-atomic yield rate"; instance = NotApplicable }
  /// Processes blocked: Number of currently blocked processes.
  let ``Processes blocked`` =
    { category = "SQLServer:General Statistics"; counter = "Processes blocked"; instance = NotApplicable }
  /// SOAP Empty Requests: Number of empty SOAP requests started per second.
  let ``SOAP Empty Requests`` =
    { category = "SQLServer:General Statistics"; counter = "SOAP Empty Requests"; instance = NotApplicable }
  /// SOAP Method Invocations: Number of SOAP method invocations started per second.
  let ``SOAP Method Invocations`` =
    { category = "SQLServer:General Statistics"; counter = "SOAP Method Invocations"; instance = NotApplicable }
  /// SOAP SQL Requests: Number of SOAP SQL requests started per second.
  let ``SOAP SQL Requests`` =
    { category = "SQLServer:General Statistics"; counter = "SOAP SQL Requests"; instance = NotApplicable }
  /// SOAP Session Initiate Requests: Number of SOAP Session initiate requests started per second.
  let ``SOAP Session Initiate Requests`` =
    { category = "SQLServer:General Statistics"; counter = "SOAP Session Initiate Requests"; instance = NotApplicable }
  /// SOAP Session Terminate Requests: Number of SOAP Session terminate requests started per second.
  let ``SOAP Session Terminate Requests`` =
    { category = "SQLServer:General Statistics"; counter = "SOAP Session Terminate Requests"; instance = NotApplicable }
  /// SOAP WSDL Requests: Number of SOAP Web Service Description Language requests started per second.
  let ``SOAP WSDL Requests`` =
    { category = "SQLServer:General Statistics"; counter = "SOAP WSDL Requests"; instance = NotApplicable }
  /// SQL Trace IO Provider Lock Waits: Number of waits for the File IO Provider lock per second
  let ``SQL Trace IO Provider Lock Waits`` =
    { category = "SQLServer:General Statistics"; counter = "SQL Trace IO Provider Lock Waits"; instance = NotApplicable }
  /// Temp Tables Creation Rate: Number of temporary tables/table variables created/sec
  let ``Temp Tables Creation Rate`` =
    { category = "SQLServer:General Statistics"; counter = "Temp Tables Creation Rate"; instance = NotApplicable }
  /// Temp Tables For Destruction: Number of temporary tables/table variables waiting to be destroyed by the cleanup system thread
  let ``Temp Tables For Destruction`` =
    { category = "SQLServer:General Statistics"; counter = "Temp Tables For Destruction"; instance = NotApplicable }
  /// Tempdb recovery unit id: Number of duplicate tempdb recovery unit id generated
  let ``Tempdb recovery unit id`` =
    { category = "SQLServer:General Statistics"; counter = "Tempdb recovery unit id"; instance = NotApplicable }
  /// Tempdb rowset id: Number of duplicate tempdb rowset id generated
  let ``Tempdb rowset id`` =
    { category = "SQLServer:General Statistics"; counter = "Tempdb rowset id"; instance = NotApplicable }
  /// Trace Event Notification Queue: Number of trace event notification instances waiting in the internal queue to be sent thru Service Broker
  let ``Trace Event Notification Queue`` =
    { category = "SQLServer:General Statistics"; counter = "Trace Event Notification Queue"; instance = NotApplicable }
  /// Transactions: Number of transaction enlistments (local, dtc, and bound).
  let ``Transactions`` =
    { category = "SQLServer:General Statistics"; counter = "Transactions"; instance = NotApplicable }
  /// User Connections: Number of users connected to the system.
  let ``User Connections`` =
    { category = "SQLServer:General Statistics"; counter = "User Connections"; instance = NotApplicable }

  let allCounters =
    [ ``Active Temp Tables``
      ``Connection Reset/sec``
      ``Event Notifications Delayed Drop``
      ``HTTP Authenticated Requests``
      ``Logical Connections``
      ``Logins/sec``
      ``Logouts/sec``
      ``Mars Deadlocks``
      ``Non-atomic yield rate``
      ``Processes blocked``
      ``SOAP Empty Requests``
      ``SOAP Method Invocations``
      ``SOAP SQL Requests``
      ``SOAP Session Initiate Requests``
      ``SOAP Session Terminate Requests``
      ``SOAP WSDL Requests``
      ``SQL Trace IO Provider Lock Waits``
      ``Temp Tables Creation Rate``
      ``Temp Tables For Destruction``
      ``Tempdb recovery unit id``
      ``Tempdb rowset id``
      ``Trace Event Notification Queue``
      ``Transactions``
      ``User Connections``
    ]

/// SQLServer:HTTP Storage: Defines a HTTP storage object for SQL Server.
///
/// This performance counter does not have non-instance based counters
module ``SQLServer:HTTP Storage`` =

  [<Literal>]
  let Category = "SQLServer:HTTP Storage"

  let PCC = getPCC Category
  /// Avg. Bytes/Read: Average number of bytes transferred from the HTTP storage per read.
  let ``Avg. Bytes/Read`` instance =
    { category = "SQLServer:HTTP Storage"; counter = "Avg. Bytes/Read"; instance = instance }
  /// Avg. Bytes/Read BASE: Average number of bytes transferred from the HTTP storage per read (BASE).
  let ``Avg. Bytes/Read BASE`` instance =
    { category = "SQLServer:HTTP Storage"; counter = "Avg. Bytes/Read BASE"; instance = instance }
  /// Avg. Bytes/Transfer: Average number of bytes transferred from the HTTP storage during read or write operations.
  let ``Avg. Bytes/Transfer`` instance =
    { category = "SQLServer:HTTP Storage"; counter = "Avg. Bytes/Transfer"; instance = instance }
  /// Avg. Bytes/Transfer BASE: Average number of bytes transferred from the HTTP storage during read or write operations (BASE).
  let ``Avg. Bytes/Transfer BASE`` instance =
    { category = "SQLServer:HTTP Storage"; counter = "Avg. Bytes/Transfer BASE"; instance = instance }
  /// Avg. Bytes/Write: Average number of bytes transferred from the HTTP storage per write."
  let ``Avg. Bytes/Write`` instance =
    { category = "SQLServer:HTTP Storage"; counter = "Avg. Bytes/Write"; instance = instance }
  /// Avg. Bytes/Write BASE: Average number of bytes transferred from the HTTP storage per write (BASE).
  let ``Avg. Bytes/Write BASE`` instance =
    { category = "SQLServer:HTTP Storage"; counter = "Avg. Bytes/Write BASE"; instance = instance }
  /// Avg. microsec/Read: The average number of microseconds it takes to do each read from the HTTP storage.
  let ``Avg. microsec/Read`` instance =
    { category = "SQLServer:HTTP Storage"; counter = "Avg. microsec/Read"; instance = instance }
  /// Avg. microsec/Read BASE: The average number of microseconds it takes to do each read from the HTTP storage (BASE).
  let ``Avg. microsec/Read BASE`` instance =
    { category = "SQLServer:HTTP Storage"; counter = "Avg. microsec/Read BASE"; instance = instance }
  /// Avg. microsec/Transfer: The average number of microseconds it takes to do each transfer to the HTTP storage.
  let ``Avg. microsec/Transfer`` instance =
    { category = "SQLServer:HTTP Storage"; counter = "Avg. microsec/Transfer"; instance = instance }
  /// Avg. microsec/Transfer BASE: The average number of microseconds it takes to do each transfer to the HTTP storage (BASE).
  let ``Avg. microsec/Transfer BASE`` instance =
    { category = "SQLServer:HTTP Storage"; counter = "Avg. microsec/Transfer BASE"; instance = instance }
  /// Avg. microsec/Write: The average number of microsecondsit takes to do each write to the HTTP storage.
  let ``Avg. microsec/Write`` instance =
    { category = "SQLServer:HTTP Storage"; counter = "Avg. microsec/Write"; instance = instance }
  /// Avg. microsec/Write BASE: The average number of microseconds it takes to do each write to the HTTP storage (BASE).
  let ``Avg. microsec/Write BASE`` instance =
    { category = "SQLServer:HTTP Storage"; counter = "Avg. microsec/Write BASE"; instance = instance }
  /// HTTP Storage IO retry/sec: Number of retry requests sent to the HTTP storage per second.
  let ``HTTP Storage IO retry/sec`` instance =
    { category = "SQLServer:HTTP Storage"; counter = "HTTP Storage IO retry/sec"; instance = instance }
  /// Outstanding HTTP Storage IO: The total number of outstanding I/Os towards a HTTP storage.
  let ``Outstanding HTTP Storage IO`` instance =
    { category = "SQLServer:HTTP Storage"; counter = "Outstanding HTTP Storage IO"; instance = instance }
  /// Read Bytes/Sec: Amount of data being transferred from the HTTP storage per second during read operations.
  let ``Read Bytes/Sec`` instance =
    { category = "SQLServer:HTTP Storage"; counter = "Read Bytes/Sec"; instance = instance }
  /// Reads/Sec: Number of reads per second on the HTTP storage.
  let ``Reads/Sec`` instance =
    { category = "SQLServer:HTTP Storage"; counter = "Reads/Sec"; instance = instance }
  /// Total Bytes/Sec: Amount of data being transferred from the HTTP storage per second during read or write operations.
  let ``Total Bytes/Sec`` instance =
    { category = "SQLServer:HTTP Storage"; counter = "Total Bytes/Sec"; instance = instance }
  /// Transfers/Sec: Number of read and write operations per second on the HTTP storage.
  let ``Transfers/Sec`` instance =
    { category = "SQLServer:HTTP Storage"; counter = "Transfers/Sec"; instance = instance }
  /// Write Bytes/Sec: Amount of data being transferred from the HTTP storage per second during write operations.
  let ``Write Bytes/Sec`` instance =
    { category = "SQLServer:HTTP Storage"; counter = "Write Bytes/Sec"; instance = instance }
  /// Writes/Sec: Number of writer per second on the HTTP storage.
  let ``Writes/Sec`` instance =
    { category = "SQLServer:HTTP Storage"; counter = "Writes/Sec"; instance = instance }

  let allCounters =
    [ ``Avg. Bytes/Read``
      ``Avg. Bytes/Read BASE``
      ``Avg. Bytes/Transfer``
      ``Avg. Bytes/Transfer BASE``
      ``Avg. Bytes/Write``
      ``Avg. Bytes/Write BASE``
      ``Avg. microsec/Read``
      ``Avg. microsec/Read BASE``
      ``Avg. microsec/Transfer``
      ``Avg. microsec/Transfer BASE``
      ``Avg. microsec/Write``
      ``Avg. microsec/Write BASE``
      ``HTTP Storage IO retry/sec``
      ``Outstanding HTTP Storage IO``
      ``Read Bytes/Sec``
      ``Reads/Sec``
      ``Total Bytes/Sec``
      ``Transfers/Sec``
      ``Write Bytes/Sec``
      ``Writes/Sec``
    ]

/// SQLServer:Latches: Collects statistics associated with internal server latches
///
/// This performance counter does not have instance based counters
module ``SQLServer:Latches`` =

  [<Literal>]
  let Category = "SQLServer:Latches"

  let PCC = getPCC Category
  /// Average Latch Wait Time (ms): Average latch wait time (milliseconds) for latch requests that had to wait.
  let ``Average Latch Wait Time (ms)`` =
    { category = "SQLServer:Latches"; counter = "Average Latch Wait Time (ms)"; instance = NotApplicable }
  /// Average Latch Wait Time Base: Base for Average Latch Wait Time.
  let ``Average Latch Wait Time Base`` =
    { category = "SQLServer:Latches"; counter = "Average Latch Wait Time Base"; instance = NotApplicable }
  /// Latch Waits/sec: Number of latch requests that could not be granted immediately and had to wait before being granted.
  let ``Latch Waits/sec`` =
    { category = "SQLServer:Latches"; counter = "Latch Waits/sec"; instance = NotApplicable }
  /// Number of SuperLatches: Number of latches that are currently SuperLatches.
  let ``Number of SuperLatches`` =
    { category = "SQLServer:Latches"; counter = "Number of SuperLatches"; instance = NotApplicable }
  /// SuperLatch Demotions/sec: Number of SuperLatches that have been demoted to regular latches
  let ``SuperLatch Demotions/sec`` =
    { category = "SQLServer:Latches"; counter = "SuperLatch Demotions/sec"; instance = NotApplicable }
  /// SuperLatch Promotions/sec: Number of latches that have been promoted to SuperLatches
  let ``SuperLatch Promotions/sec`` =
    { category = "SQLServer:Latches"; counter = "SuperLatch Promotions/sec"; instance = NotApplicable }
  /// Total Latch Wait Time (ms): Total latch wait time (milliseconds) for latch requests that had to wait in the last second.
  let ``Total Latch Wait Time (ms)`` =
    { category = "SQLServer:Latches"; counter = "Total Latch Wait Time (ms)"; instance = NotApplicable }

  let allCounters =
    [ ``Average Latch Wait Time (ms)``
      ``Average Latch Wait Time Base``
      ``Latch Waits/sec``
      ``Number of SuperLatches``
      ``SuperLatch Demotions/sec``
      ``SuperLatch Promotions/sec``
      ``Total Latch Wait Time (ms)``
    ]

/// SQLServer:Locks: Describes statistics for individual lock server lock requests
///
/// This performance counter does not have non-instance based counters
module ``SQLServer:Locks`` =

  [<Literal>]
  let Category = "SQLServer:Locks"

  let PCC = getPCC Category
  /// Average Wait Time (ms): The average amount of wait time (milliseconds) for each lock request that resulted in a wait.
  let ``Average Wait Time (ms)`` instance =
    { category = "SQLServer:Locks"; counter = "Average Wait Time (ms)"; instance = instance }
  /// Average Wait Time Base: Base for Averate Wait Time.
  let ``Average Wait Time Base`` instance =
    { category = "SQLServer:Locks"; counter = "Average Wait Time Base"; instance = instance }
  /// Lock Requests/sec: Number of new locks and lock conversions requested from the lock manager.
  let ``Lock Requests/sec`` instance =
    { category = "SQLServer:Locks"; counter = "Lock Requests/sec"; instance = instance }
  /// Lock Timeouts (timeout > 0)/sec: Number of lock requests that timed out. This does not include requests for NOWAIT locks.
  let ``Lock Timeouts (timeout > 0)/sec`` instance =
    { category = "SQLServer:Locks"; counter = "Lock Timeouts (timeout > 0)/sec"; instance = instance }
  /// Lock Timeouts/sec: Number of lock requests that timed out. This includes requests for NOWAIT locks.
  let ``Lock Timeouts/sec`` instance =
    { category = "SQLServer:Locks"; counter = "Lock Timeouts/sec"; instance = instance }
  /// Lock Wait Time (ms): Total wait time (milliseconds) for locks in the last second.
  let ``Lock Wait Time (ms)`` instance =
    { category = "SQLServer:Locks"; counter = "Lock Wait Time (ms)"; instance = instance }
  /// Lock Waits/sec: Number of lock requests that could not be satisfied immediately and required the caller to wait before being granted the lock.
  let ``Lock Waits/sec`` instance =
    { category = "SQLServer:Locks"; counter = "Lock Waits/sec"; instance = instance }
  /// Number of Deadlocks/sec: Number of lock requests that resulted in a deadlock.
  let ``Number of Deadlocks/sec`` instance =
    { category = "SQLServer:Locks"; counter = "Number of Deadlocks/sec"; instance = instance }

  let allCounters =
    [ ``Average Wait Time (ms)``
      ``Average Wait Time Base``
      ``Lock Requests/sec``
      ``Lock Timeouts (timeout > 0)/sec``
      ``Lock Timeouts/sec``
      ``Lock Wait Time (ms)``
      ``Lock Waits/sec``
      ``Number of Deadlocks/sec``
    ]

/// SQLServer:Memory Broker Clerks: Statistics related to memory broker clerks
///
/// This performance counter does not have non-instance based counters
module ``SQLServer:Memory Broker Clerks`` =

  [<Literal>]
  let Category = "SQLServer:Memory Broker Clerks"

  let PCC = getPCC Category
  /// Internal benefit: The internal value of memory for entry count pressure, in ms per page per ms, multiplied by 10 billion and truncated to an integer
  let ``Internal benefit`` instance =
    { category = "SQLServer:Memory Broker Clerks"; counter = "Internal benefit"; instance = instance }
  /// Memory broker clerk size: The size of the the clerk, in pages
  let ``Memory broker clerk size`` instance =
    { category = "SQLServer:Memory Broker Clerks"; counter = "Memory broker clerk size"; instance = instance }
  /// Periodic evictions (pages): The number of pages evicted from the broker clerk by last periodic eviction
  let ``Periodic evictions (pages)`` instance =
    { category = "SQLServer:Memory Broker Clerks"; counter = "Periodic evictions (pages)"; instance = instance }
  /// Pressure evictions (pages/sec): The number of pages per second evicted from the broker clerk by memory pressure
  let ``Pressure evictions (pages/sec)`` instance =
    { category = "SQLServer:Memory Broker Clerks"; counter = "Pressure evictions (pages/sec)"; instance = instance }
  /// Simulation benefit: The value of memory to the clerk, in ms per page per ms, multiplied by 10 billion and truncated to an integer
  let ``Simulation benefit`` instance =
    { category = "SQLServer:Memory Broker Clerks"; counter = "Simulation benefit"; instance = instance }
  /// Simulation size: The current size of the clerk simulation, in pages
  let ``Simulation size`` instance =
    { category = "SQLServer:Memory Broker Clerks"; counter = "Simulation size"; instance = instance }

  let allCounters =
    [ ``Internal benefit``
      ``Memory broker clerk size``
      ``Periodic evictions (pages)``
      ``Pressure evictions (pages/sec)``
      ``Simulation benefit``
      ``Simulation size``
    ]

/// SQLServer:Memory Manager: This defines memory usage.
///
/// This performance counter does not have instance based counters
module ``SQLServer:Memory Manager`` =

  [<Literal>]
  let Category = "SQLServer:Memory Manager"

  let PCC = getPCC Category
  /// Connection Memory (KB): Total amount of dynamic memory the server is using for maintaining connections
  let ``Connection Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Connection Memory (KB)"; instance = NotApplicable }
  /// Database Cache Memory (KB): Amount of memory the server is currently using for the database cache.
  let ``Database Cache Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Database Cache Memory (KB)"; instance = NotApplicable }
  /// External benefit of memory: The external value of memory, in ms per page per ms, multiplied by 10 billion and truncated to an integer
  let ``External benefit of memory`` =
    { category = "SQLServer:Memory Manager"; counter = "External benefit of memory"; instance = NotApplicable }
  /// Free Memory (KB): Amount of memory the server is currently not using.
  let ``Free Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Free Memory (KB)"; instance = NotApplicable }
  /// Granted Workspace Memory (KB): Total amount of memory granted to executing processes. This memory is used for hash, sort and create index operations.
  let ``Granted Workspace Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Granted Workspace Memory (KB)"; instance = NotApplicable }
  /// Lock Blocks: The current number of lock blocks that are in use on the server. Refreshed periodically.
  let ``Lock Blocks`` =
    { category = "SQLServer:Memory Manager"; counter = "Lock Blocks"; instance = NotApplicable }
  /// Lock Blocks Allocated: The current number of allocated lock blocks.
  let ``Lock Blocks Allocated`` =
    { category = "SQLServer:Memory Manager"; counter = "Lock Blocks Allocated"; instance = NotApplicable }
  /// Lock Memory (KB): Total amount of dynamic memory the server is using for locks
  let ``Lock Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Lock Memory (KB)"; instance = NotApplicable }
  /// Lock Owner Blocks: The number of lock owner blocks that are currently in use on the server. Refreshed periodically.
  let ``Lock Owner Blocks`` =
    { category = "SQLServer:Memory Manager"; counter = "Lock Owner Blocks"; instance = NotApplicable }
  /// Lock Owner Blocks Allocated: The current number of allocated lock owner blocks.
  let ``Lock Owner Blocks Allocated`` =
    { category = "SQLServer:Memory Manager"; counter = "Lock Owner Blocks Allocated"; instance = NotApplicable }
  /// Log Pool Memory (KB): Total amount of dynamic memory the server is using for Log Pool
  let ``Log Pool Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Log Pool Memory (KB)"; instance = NotApplicable }
  /// Maximum Workspace Memory (KB): Total amount of memory available for grants to executing processes. This memory is used primarily for hash, sort and create index operations.
  let ``Maximum Workspace Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Maximum Workspace Memory (KB)"; instance = NotApplicable }
  /// Memory Grants Outstanding: Current number of processes that have successfully acquired a workspace memory grant
  let ``Memory Grants Outstanding`` =
    { category = "SQLServer:Memory Manager"; counter = "Memory Grants Outstanding"; instance = NotApplicable }
  /// Memory Grants Pending: Current number of processes waiting for a workspace memory grant
  let ``Memory Grants Pending`` =
    { category = "SQLServer:Memory Manager"; counter = "Memory Grants Pending"; instance = NotApplicable }
  /// Optimizer Memory (KB): Total amount of dynamic memory the server is using for query optimization
  let ``Optimizer Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Optimizer Memory (KB)"; instance = NotApplicable }
  /// Reserved Server Memory (KB): Amount of memory the server has reserved for future usage. This counter shows current unused amount of the initial grant shown in Granted Workspace Memory (KB).
  let ``Reserved Server Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Reserved Server Memory (KB)"; instance = NotApplicable }
  /// SQL Cache Memory (KB): Total amount of dynamic memory the server is using for the dynamic SQL cache
  let ``SQL Cache Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "SQL Cache Memory (KB)"; instance = NotApplicable }
  /// Stolen Server Memory (KB): Amount of memory the server is currently using for the purposes other than the database pages.
  let ``Stolen Server Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Stolen Server Memory (KB)"; instance = NotApplicable }
  /// Target Server Memory (KB): Ideal amount of memory the server is willing to consume
  let ``Target Server Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Target Server Memory (KB)"; instance = NotApplicable }
  /// Total Server Memory (KB): Total amount of dynamic memory the server is currently consuming
  let ``Total Server Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Total Server Memory (KB)"; instance = NotApplicable }

  let allCounters =
    [ ``Connection Memory (KB)``
      ``Database Cache Memory (KB)``
      ``External benefit of memory``
      ``Free Memory (KB)``
      ``Granted Workspace Memory (KB)``
      ``Lock Blocks``
      ``Lock Blocks Allocated``
      ``Lock Memory (KB)``
      ``Lock Owner Blocks``
      ``Lock Owner Blocks Allocated``
      ``Log Pool Memory (KB)``
      ``Maximum Workspace Memory (KB)``
      ``Memory Grants Outstanding``
      ``Memory Grants Pending``
      ``Optimizer Memory (KB)``
      ``Reserved Server Memory (KB)``
      ``SQL Cache Memory (KB)``
      ``Stolen Server Memory (KB)``
      ``Target Server Memory (KB)``
      ``Total Server Memory (KB)``
    ]

/// SQLServer:Memory Node: This defines memory usage per NUMA node.
///
/// This performance counter does not have non-instance based counters
module ``SQLServer:Memory Node`` =

  [<Literal>]
  let Category = "SQLServer:Memory Node"

  let PCC = getPCC Category
  /// Database Node Memory (KB): Amount of memory the server is using on this node for database pages.
  let ``Database Node Memory (KB)`` instance =
    { category = "SQLServer:Memory Node"; counter = "Database Node Memory (KB)"; instance = instance }
  /// Foreign Node Memory (KB): Non NUMA-local amount of memory on this node.
  let ``Foreign Node Memory (KB)`` instance =
    { category = "SQLServer:Memory Node"; counter = "Foreign Node Memory (KB)"; instance = instance }
  /// Free Node Memory (KB): Amount of memory the server is not using on this node.
  let ``Free Node Memory (KB)`` instance =
    { category = "SQLServer:Memory Node"; counter = "Free Node Memory (KB)"; instance = instance }
  /// Stolen Node Memory (KB): Amount of memory the server is using on this node for the purposes other than database pages.
  let ``Stolen Node Memory (KB)`` instance =
    { category = "SQLServer:Memory Node"; counter = "Stolen Node Memory (KB)"; instance = instance }
  /// Target Node Memory (KB): Ideal amount of memory for this node.
  let ``Target Node Memory (KB)`` instance =
    { category = "SQLServer:Memory Node"; counter = "Target Node Memory (KB)"; instance = instance }
  /// Total Node Memory (KB): Total amount of memory the server has committed on this node.
  let ``Total Node Memory (KB)`` instance =
    { category = "SQLServer:Memory Node"; counter = "Total Node Memory (KB)"; instance = instance }

  let allCounters =
    [ ``Database Node Memory (KB)``
      ``Foreign Node Memory (KB)``
      ``Free Node Memory (KB)``
      ``Stolen Node Memory (KB)``
      ``Target Node Memory (KB)``
      ``Total Node Memory (KB)``
    ]

/// SQLServer:Plan Cache: This defines cache counters
///
/// This performance counter does not have non-instance based counters
module ``SQLServer:Plan Cache`` =

  [<Literal>]
  let Category = "SQLServer:Plan Cache"

  let PCC = getPCC Category
  /// Cache Hit Ratio: Ratio between cache hits and lookups
  let ``Cache Hit Ratio`` instance =
    { category = "SQLServer:Plan Cache"; counter = "Cache Hit Ratio"; instance = instance }
  /// Cache Hit Ratio Base: Base for prior entry
  let ``Cache Hit Ratio Base`` instance =
    { category = "SQLServer:Plan Cache"; counter = "Cache Hit Ratio Base"; instance = instance }
  /// Cache Object Counts: Number of cache objects in the cache
  let ``Cache Object Counts`` instance =
    { category = "SQLServer:Plan Cache"; counter = "Cache Object Counts"; instance = instance }
  /// Cache Objects in use: Number of cache objects in use
  let ``Cache Objects in use`` instance =
    { category = "SQLServer:Plan Cache"; counter = "Cache Objects in use"; instance = instance }
  /// Cache Pages: Number of 8k pages used by cache objects
  let ``Cache Pages`` instance =
    { category = "SQLServer:Plan Cache"; counter = "Cache Pages"; instance = instance }

  let allCounters =
    [ ``Cache Hit Ratio``
      ``Cache Hit Ratio Base``
      ``Cache Object Counts``
      ``Cache Objects in use``
      ``Cache Pages``
    ]

/// SQLServer:Replication Agents: Replication Summary
///
/// This performance counter does not have instance based counters
module ``SQLServer:Replication Agents`` =

  [<Literal>]
  let Category = "SQLServer:Replication Agents"

  let PCC = getPCC Category
  /// Running: -
  let ``Running`` instance =
    { category = "SQLServer:Replication Agents"; counter = "Running"; instance = instance }

  let allCounters =
    [ ``Running``

    ]

/// SQLServer:Replication Dist.: Replication Distribution Agent Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Replication Dist_`` =

  [<Literal>]
  let Category = "SQLServer:Replication Dist."

  let PCC = getPCC Category
  /// Dist:Delivered Cmds/sec: -
  let ``Dist:Delivered Cmds/sec`` instance =
    { category = "SQLServer:Replication Dist."; counter = "Dist:Delivered Cmds/sec"; instance = instance }
  /// Dist:Delivered Trans/sec: -
  let ``Dist:Delivered Trans/sec`` instance =
    { category = "SQLServer:Replication Dist."; counter = "Dist:Delivered Trans/sec"; instance = instance }
  /// Dist:Delivery Latency: -
  let ``Dist:Delivery Latency`` instance =
    { category = "SQLServer:Replication Dist."; counter = "Dist:Delivery Latency"; instance = instance }

  let allCounters =
    [ ``Dist:Delivered Cmds/sec``
      ``Dist:Delivered Trans/sec``
      ``Dist:Delivery Latency``
    ]

/// SQLServer:Replication Logreader: Replication Logreader Agent Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Replication Logreader`` =

  [<Literal>]
  let Category = "SQLServer:Replication Logreader"

  let PCC = getPCC Category
  /// Logreader:Delivered Cmds/sec: -
  let ``Logreader:Delivered Cmds/sec`` instance =
    { category = "SQLServer:Replication Logreader"; counter = "Logreader:Delivered Cmds/sec"; instance = instance }
  /// Logreader:Delivered Trans/sec: -
  let ``Logreader:Delivered Trans/sec`` instance =
    { category = "SQLServer:Replication Logreader"; counter = "Logreader:Delivered Trans/sec"; instance = instance }
  /// Logreader:Delivery Latency: -
  let ``Logreader:Delivery Latency`` instance =
    { category = "SQLServer:Replication Logreader"; counter = "Logreader:Delivery Latency"; instance = instance }

  let allCounters =
    [ ``Logreader:Delivered Cmds/sec``
      ``Logreader:Delivered Trans/sec``
      ``Logreader:Delivery Latency``
    ]

/// SQLServer:Replication Merge: Replication Merge Agent Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Replication Merge`` =

  [<Literal>]
  let Category = "SQLServer:Replication Merge"

  let PCC = getPCC Category
  /// Conflicts/sec: -
  let ``Conflicts/sec`` instance =
    { category = "SQLServer:Replication Merge"; counter = "Conflicts/sec"; instance = instance }
  /// Downloaded Changes/sec: -
  let ``Downloaded Changes/sec`` instance =
    { category = "SQLServer:Replication Merge"; counter = "Downloaded Changes/sec"; instance = instance }
  /// Uploaded Changes/sec: -
  let ``Uploaded Changes/sec`` instance =
    { category = "SQLServer:Replication Merge"; counter = "Uploaded Changes/sec"; instance = instance }

  let allCounters =
    [ ``Conflicts/sec``
      ``Downloaded Changes/sec``
      ``Uploaded Changes/sec``
    ]

/// SQLServer:Replication Snapshot: Replication Snapshot Agent Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Replication Snapshot`` =

  [<Literal>]
  let Category = "SQLServer:Replication Snapshot"

  let PCC = getPCC Category
  /// Snapshot:Delivered Cmds/sec: -
  let ``Snapshot:Delivered Cmds/sec`` instance =
    { category = "SQLServer:Replication Snapshot"; counter = "Snapshot:Delivered Cmds/sec"; instance = instance }
  /// Snapshot:Delivered Trans/sec: -
  let ``Snapshot:Delivered Trans/sec`` instance =
    { category = "SQLServer:Replication Snapshot"; counter = "Snapshot:Delivered Trans/sec"; instance = instance }

  let allCounters =
    [ ``Snapshot:Delivered Cmds/sec``
      ``Snapshot:Delivered Trans/sec``
    ]

/// SQLServer:Resource Pool Stats: Statistics associated with resource pools
///
/// This performance counter does not have non-instance based counters
module ``SQLServer:Resource Pool Stats`` =

  [<Literal>]
  let Category = "SQLServer:Resource Pool Stats"

  let PCC = getPCC Category
  /// Active memory grant amount (KB): Total amount of granted memory in kilobytes in the resource pool.
  let ``Active memory grant amount (KB)`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Active memory grant amount (KB)"; instance = instance }
  /// Active memory grants count: Number of query memory grants in the resource pool.
  let ``Active memory grants count`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Active memory grants count"; instance = instance }
  /// Avg Disk Read IO (ms): Average time, in milliseconds, of a read operation from the disk
  let ``Avg Disk Read IO (ms)`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Avg Disk Read IO (ms)"; instance = instance }
  /// Avg Disk Read IO (ms) Base: Average time, in milliseconds, of a read operation from the disk
  let ``Avg Disk Read IO (ms) Base`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Avg Disk Read IO (ms) Base"; instance = instance }
  /// Avg Disk Write IO (ms): Average time, in milliseconds, of a write operation to the disk
  let ``Avg Disk Write IO (ms)`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Avg Disk Write IO (ms)"; instance = instance }
  /// Avg Disk Write IO (ms) Base: Average time, in milliseconds, of a write operation to the disk
  let ``Avg Disk Write IO (ms) Base`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Avg Disk Write IO (ms) Base"; instance = instance }
  /// CPU control effect %: Effect of the resource governor on the resource pool calculated as (CPU usage %) / (CPU usage % without RG).
  let ``CPU control effect %`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "CPU control effect %"; instance = instance }
  /// CPU usage %: System CPU usage by all requests in the specified instance of the performance object.
  let ``CPU usage %`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "CPU usage %"; instance = instance }
  /// CPU usage % base: System CPU usage by all requests in the specified instance of the performance object.
  let ``CPU usage % base`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "CPU usage % base"; instance = instance }
  /// CPU usage target %: Target value of 'CPU usage %' for the resource pool based on the configuration settings and the system load.
  let ``CPU usage target %`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "CPU usage target %"; instance = instance }
  /// Cache memory target (KB): Current memory target for cache memory in kilobytes.
  let ``Cache memory target (KB)`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Cache memory target (KB)"; instance = instance }
  /// Compile memory target (KB): Current memory target for query compile in kilobytes.
  let ``Compile memory target (KB)`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Compile memory target (KB)"; instance = instance }
  /// Disk Read Bytes/sec: Number of bytes read from the disk in the last second
  let ``Disk Read Bytes/sec`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Disk Read Bytes/sec"; instance = instance }
  /// Disk Read IO Throttled/sec: Number of read operations throttled in the last second
  let ``Disk Read IO Throttled/sec`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Disk Read IO Throttled/sec"; instance = instance }
  /// Disk Read IO/sec: Number of read operations from the disk in the last second
  let ``Disk Read IO/sec`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Disk Read IO/sec"; instance = instance }
  /// Disk Write Bytes/sec: Number of bytes written to the disk in the last second
  let ``Disk Write Bytes/sec`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Disk Write Bytes/sec"; instance = instance }
  /// Disk Write IO Throttled/sec: Number of write operations throttled in the last second
  let ``Disk Write IO Throttled/sec`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Disk Write IO Throttled/sec"; instance = instance }
  /// Disk Write IO/sec: Number of write operations to the disk in the last second
  let ``Disk Write IO/sec`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Disk Write IO/sec"; instance = instance }
  /// Max memory (KB): Maximum amount of memory in kilobytes the resource pool can have based on the settings and server state.
  let ``Max memory (KB)`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Max memory (KB)"; instance = instance }
  /// Memory grant timeouts/sec: Number of query memory grant timeouts per second occurring in the resource pool.
  let ``Memory grant timeouts/sec`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Memory grant timeouts/sec"; instance = instance }
  /// Memory grants/sec: Number of query memory grants per second occurring in the resource pool.
  let ``Memory grants/sec`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Memory grants/sec"; instance = instance }
  /// Pending memory grants count: Number of queries waiting for memory grants in the resource pool.
  let ``Pending memory grants count`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Pending memory grants count"; instance = instance }
  /// Query exec memory target (KB): Current memory target for query execution memory grant in kilobytes.
  let ``Query exec memory target (KB)`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Query exec memory target (KB)"; instance = instance }
  /// Target memory (KB): Target amount of memory in kilobytes the resource pool is trying to attain based on the settings and server state.
  let ``Target memory (KB)`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Target memory (KB)"; instance = instance }
  /// Used memory (KB): Used amount of memory in kilobytes in the resource pool.
  let ``Used memory (KB)`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Used memory (KB)"; instance = instance }

  let allCounters =
    [ ``Active memory grant amount (KB)``
      ``Active memory grants count``
      ``Avg Disk Read IO (ms)``
      ``Avg Disk Read IO (ms) Base``
      ``Avg Disk Write IO (ms)``
      ``Avg Disk Write IO (ms) Base``
      ``CPU control effect %``
      ``CPU usage %``
      ``CPU usage % base``
      ``CPU usage target %``
      ``Cache memory target (KB)``
      ``Compile memory target (KB)``
      ``Disk Read Bytes/sec``
      ``Disk Read IO Throttled/sec``
      ``Disk Read IO/sec``
      ``Disk Write Bytes/sec``
      ``Disk Write IO Throttled/sec``
      ``Disk Write IO/sec``
      ``Max memory (KB)``
      ``Memory grant timeouts/sec``
      ``Memory grants/sec``
      ``Pending memory grants count``
      ``Query exec memory target (KB)``
      ``Target memory (KB)``
      ``Used memory (KB)``
    ]

/// SQLServer:SQL Errors: Statistics about errors in SQL Server
///
/// This performance counter does not have non-instance based counters
module ``SQLServer:SQL Errors`` =

  [<Literal>]
  let Category = "SQLServer:SQL Errors"

  let PCC = getPCC Category
  /// Errors/sec: Number of errors/sec
  let ``Errors/sec`` instance =
    { category = "SQLServer:SQL Errors"; counter = "Errors/sec"; instance = instance }

  let allCounters =
    [ ``Errors/sec``

    ]

/// SQLServer:SQL Statistics: Collects statistics associated with SQL requests
///
/// This performance counter does not have instance based counters
module ``SQLServer:SQL Statistics`` =

  [<Literal>]
  let Category = "SQLServer:SQL Statistics"

  let PCC = getPCC Category
  /// Auto-Param Attempts/sec: Number of auto-parameterization attempts.
  let ``Auto-Param Attempts/sec`` =
    { category = "SQLServer:SQL Statistics"; counter = "Auto-Param Attempts/sec"; instance = NotApplicable }
  /// Batch Requests/sec: Number of SQL batch requests received by server.
  let ``Batch Requests/sec`` =
    { category = "SQLServer:SQL Statistics"; counter = "Batch Requests/sec"; instance = NotApplicable }
  /// Failed Auto-Params/sec: Number of failed auto-parameterizations.
  let ``Failed Auto-Params/sec`` =
    { category = "SQLServer:SQL Statistics"; counter = "Failed Auto-Params/sec"; instance = NotApplicable }
  /// Forced Parameterizations/sec: Number of statements parameterized by forced parameterization per second.
  let ``Forced Parameterizations/sec`` =
    { category = "SQLServer:SQL Statistics"; counter = "Forced Parameterizations/sec"; instance = NotApplicable }
  /// Guided plan executions/sec: Number of plan executions per second in which the query plan has been generated by using a plan guide.
  let ``Guided plan executions/sec`` =
    { category = "SQLServer:SQL Statistics"; counter = "Guided plan executions/sec"; instance = NotApplicable }
  /// Misguided plan executions/sec: Number of plan executions per second in which a plan guide could not be honored during plan generation. The plan guide was disregarded and normal compilation was used to generate the executed plan.
  let ``Misguided plan executions/sec`` =
    { category = "SQLServer:SQL Statistics"; counter = "Misguided plan executions/sec"; instance = NotApplicable }
  /// SQL Attention rate: Number of attentions per second.
  let ``SQL Attention rate`` =
    { category = "SQLServer:SQL Statistics"; counter = "SQL Attention rate"; instance = NotApplicable }
  /// SQL Compilations/sec: Number of SQL compilations.
  let ``SQL Compilations/sec`` =
    { category = "SQLServer:SQL Statistics"; counter = "SQL Compilations/sec"; instance = NotApplicable }
  /// SQL Re-Compilations/sec: Number of SQL re-compiles.
  let ``SQL Re-Compilations/sec`` =
    { category = "SQLServer:SQL Statistics"; counter = "SQL Re-Compilations/sec"; instance = NotApplicable }
  /// Safe Auto-Params/sec: Number of safe auto-parameterizations.
  let ``Safe Auto-Params/sec`` =
    { category = "SQLServer:SQL Statistics"; counter = "Safe Auto-Params/sec"; instance = NotApplicable }
  /// Unsafe Auto-Params/sec: Number of unsafe auto-parameterizations.
  let ``Unsafe Auto-Params/sec`` =
    { category = "SQLServer:SQL Statistics"; counter = "Unsafe Auto-Params/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Auto-Param Attempts/sec``
      ``Batch Requests/sec``
      ``Failed Auto-Params/sec``
      ``Forced Parameterizations/sec``
      ``Guided plan executions/sec``
      ``Misguided plan executions/sec``
      ``SQL Attention rate``
      ``SQL Compilations/sec``
      ``SQL Re-Compilations/sec``
      ``Safe Auto-Params/sec``
      ``Unsafe Auto-Params/sec``
    ]

/// SQLServer:Transactions: Statistics related to SQL Server transactions.
///
/// This performance counter does not have instance based counters
module ``SQLServer:Transactions`` =

  [<Literal>]
  let Category = "SQLServer:Transactions"

  let PCC = getPCC Category
  /// Free Space in tempdb (KB): The free space in tempdb in KB.
  let ``Free Space in tempdb (KB)`` =
    { category = "SQLServer:Transactions"; counter = "Free Space in tempdb (KB)"; instance = NotApplicable }
  /// Longest Transaction Running Time: The longest running time of any transaction in seconds.
  let ``Longest Transaction Running Time`` =
    { category = "SQLServer:Transactions"; counter = "Longest Transaction Running Time"; instance = NotApplicable }
  /// NonSnapshot Version Transactions: The total number of active non-snapshot transactions that generate version records.
  let ``NonSnapshot Version Transactions`` =
    { category = "SQLServer:Transactions"; counter = "NonSnapshot Version Transactions"; instance = NotApplicable }
  /// Snapshot Transactions: The total number of active snapshot transactions.
  let ``Snapshot Transactions`` =
    { category = "SQLServer:Transactions"; counter = "Snapshot Transactions"; instance = NotApplicable }
  /// Transactions: The total number of active transactions.
  let ``Transactions`` =
    { category = "SQLServer:Transactions"; counter = "Transactions"; instance = NotApplicable }
  /// Update Snapshot Transactions: The total number of active snapshot transactions that do updates.
  let ``Update Snapshot Transactions`` =
    { category = "SQLServer:Transactions"; counter = "Update Snapshot Transactions"; instance = NotApplicable }
  /// Update conflict ratio: The fraction of update snapshot transactions that have update conflicts to the total number of update snapshot transactions.
  let ``Update conflict ratio`` =
    { category = "SQLServer:Transactions"; counter = "Update conflict ratio"; instance = NotApplicable }
  /// Update conflict ratio base: The total number of update snapshot transactions.
  let ``Update conflict ratio base`` =
    { category = "SQLServer:Transactions"; counter = "Update conflict ratio base"; instance = NotApplicable }
  /// Version Cleanup rate (KB/s): The version cleanup rate in KB per seconds.
  let ``Version Cleanup rate (KB/s)`` =
    { category = "SQLServer:Transactions"; counter = "Version Cleanup rate (KB/s)"; instance = NotApplicable }
  /// Version Generation rate (KB/s): The version generation rate in KB per seconds.
  let ``Version Generation rate (KB/s)`` =
    { category = "SQLServer:Transactions"; counter = "Version Generation rate (KB/s)"; instance = NotApplicable }
  /// Version Store Size (KB): The size of the version store in KB.
  let ``Version Store Size (KB)`` =
    { category = "SQLServer:Transactions"; counter = "Version Store Size (KB)"; instance = NotApplicable }
  /// Version Store unit count: Number of unit in Version Store.
  let ``Version Store unit count`` =
    { category = "SQLServer:Transactions"; counter = "Version Store unit count"; instance = NotApplicable }
  /// Version Store unit creation: Creation of new unit in Version Store.
  let ``Version Store unit creation`` =
    { category = "SQLServer:Transactions"; counter = "Version Store unit creation"; instance = NotApplicable }
  /// Version Store unit truncation: Truncation of unit in Version Store.
  let ``Version Store unit truncation`` =
    { category = "SQLServer:Transactions"; counter = "Version Store unit truncation"; instance = NotApplicable }

  let allCounters =
    [ ``Free Space in tempdb (KB)``
      ``Longest Transaction Running Time``
      ``NonSnapshot Version Transactions``
      ``Snapshot Transactions``
      ``Transactions``
      ``Update Snapshot Transactions``
      ``Update conflict ratio``
      ``Update conflict ratio base``
      ``Version Cleanup rate (KB/s)``
      ``Version Generation rate (KB/s)``
      ``Version Store Size (KB)``
      ``Version Store unit count``
      ``Version Store unit creation``
      ``Version Store unit truncation``
    ]

/// SQLServer:User Settable: This defines user definable counters
///
/// This performance counter does not have non-instance based counters
module ``SQLServer:User Settable`` =

  [<Literal>]
  let Category = "SQLServer:User Settable"

  let PCC = getPCC Category
  /// Query: As defined by the user.
  let ``Query`` instance =
    { category = "SQLServer:User Settable"; counter = "Query"; instance = instance }

  let allCounters =
    [ ``Query``

    ]

/// SQLServer:Wait Statistics: Wait Statistics
///
/// This performance counter does not have non-instance based counters
module ``SQLServer:Wait Statistics`` =

  [<Literal>]
  let Category = "SQLServer:Wait Statistics"

  let PCC = getPCC Category
  /// Lock waits: Statistics for processes waiting on a lock.
  let ``Lock waits`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Lock waits"; instance = instance }
  /// Log buffer waits: Statistics for processes waiting for log buffer to be available.
  let ``Log buffer waits`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Log buffer waits"; instance = instance }
  /// Log write waits: Statistics for processes waiting for log buffer to be written.
  let ``Log write waits`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Log write waits"; instance = instance }
  /// Memory grant queue waits: Statistics for processes waiting for memory grant to become available.
  let ``Memory grant queue waits`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Memory grant queue waits"; instance = instance }
  /// Network IO waits: Statistics relevant to wait on network IO.
  let ``Network IO waits`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Network IO waits"; instance = instance }
  /// Non-Page latch waits: Statistics relevant to non-page latches.
  let ``Non-Page latch waits`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Non-Page latch waits"; instance = instance }
  /// Page IO latch waits: Statistics relevant to page IO latches.
  let ``Page IO latch waits`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Page IO latch waits"; instance = instance }
  /// Page latch waits: Statistics relevant to page latches, not including IO latches
  let ``Page latch waits`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Page latch waits"; instance = instance }
  /// Thread-safe memory objects waits: Statistics for processes waiting on thread-safe memory allocators.
  let ``Thread-safe memory objects waits`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Thread-safe memory objects waits"; instance = instance }
  /// Transaction ownership waits: Statistics relevant to processes synchronizing access to transaction.
  let ``Transaction ownership waits`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Transaction ownership waits"; instance = instance }
  /// Wait for the worker: Statistics relevant to processes waiting for worker to become available.
  let ``Wait for the worker`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Wait for the worker"; instance = instance }
  /// Workspace synchronization waits: Statistics relevant to processes synchronizing access to workspace.
  let ``Workspace synchronization waits`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Workspace synchronization waits"; instance = instance }

  let allCounters =
    [ ``Lock waits``
      ``Log buffer waits``
      ``Log write waits``
      ``Memory grant queue waits``
      ``Network IO waits``
      ``Non-Page latch waits``
      ``Page IO latch waits``
      ``Page latch waits``
      ``Thread-safe memory objects waits``
      ``Transaction ownership waits``
      ``Wait for the worker``
      ``Workspace synchronization waits``
    ]

/// SQLServer:Workload Group Stats: Statistics associated with workload groups
///
/// This performance counter does not have non-instance based counters
module ``SQLServer:Workload Group Stats`` =

  [<Literal>]
  let Category = "SQLServer:Workload Group Stats"

  let PCC = getPCC Category
  /// Active parallel threads: Number of threads used by parallel queries in the workload group. Serial queries and the main thread of parallel queries are not included in this number.
  let ``Active parallel threads`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "Active parallel threads"; instance = instance }
  /// Active requests: Number of currently running requests in the workload group.
  let ``Active requests`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "Active requests"; instance = instance }
  /// Blocked tasks: Number of blocked tasks in the workload group.
  let ``Blocked tasks`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "Blocked tasks"; instance = instance }
  /// CPU usage %: System CPU usage by all requests in the specified instance of the performance object.
  let ``CPU usage %`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "CPU usage %"; instance = instance }
  /// CPU usage % base: System CPU usage by all requests in the specified instance of the performance object.
  let ``CPU usage % base`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "CPU usage % base"; instance = instance }
  /// Max request cpu time (ms): Maximum CPU time in milliseconds used by a request in the workload group.
  let ``Max request cpu time (ms)`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "Max request cpu time (ms)"; instance = instance }
  /// Max request memory grant (KB): Maximum value of memory grant in kilobytes used by a query in the workload group.
  let ``Max request memory grant (KB)`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "Max request memory grant (KB)"; instance = instance }
  /// Query optimizations/sec: Number of query optimizations per second occurring in the workload group.
  let ``Query optimizations/sec`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "Query optimizations/sec"; instance = instance }
  /// Queued requests: Number of requests waiting in the queue due to resource governor limits in the workload group.
  let ``Queued requests`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "Queued requests"; instance = instance }
  /// Reduced memory grants/sec: Number of queries per second getting less than ideal amount of memory in the workload group.
  let ``Reduced memory grants/sec`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "Reduced memory grants/sec"; instance = instance }
  /// Requests completed/sec: Number of completed requests per second in the workload group.
  let ``Requests completed/sec`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "Requests completed/sec"; instance = instance }
  /// Suboptimal plans/sec: Number of suboptimal query plans generated per second in the workload group.
  let ``Suboptimal plans/sec`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "Suboptimal plans/sec"; instance = instance }

  let allCounters =
    [ ``Active parallel threads``
      ``Active requests``
      ``Blocked tasks``
      ``CPU usage %``
      ``CPU usage % base``
      ``Max request cpu time (ms)``
      ``Max request memory grant (KB)``
      ``Query optimizations/sec``
      ``Queued requests``
      ``Reduced memory grants/sec``
      ``Requests completed/sec``
      ``Suboptimal plans/sec``
    ]

/// Search Indexer: Indexer PlugIn statistics
///
/// This performance counter does not have non-instance based counters
module ``Search Indexer`` =

  [<Literal>]
  let Category = "Search Indexer"

  let PCC = getPCC Category
  /// Active Connections: Active Connections
  let ``Active Connections`` instance =
    { category = "Search Indexer"; counter = "Active Connections"; instance = instance }
  /// Clean WidSets: Number of clean WidSets
  let ``Clean WidSets`` instance =
    { category = "Search Indexer"; counter = "Clean WidSets"; instance = instance }
  /// Dirty WidSets: Number of dirty WidSets
  let ``Dirty WidSets`` instance =
    { category = "Search Indexer"; counter = "Dirty WidSets"; instance = instance }
  /// Documents Filtered: Number of Documents Filtered
  let ``Documents Filtered`` instance =
    { category = "Search Indexer"; counter = "Documents Filtered"; instance = instance }
  /// Index Size: Size of Index
  let ``Index Size`` instance =
    { category = "Search Indexer"; counter = "Index Size"; instance = instance }
  /// L0 Indexes (Wordlists): The number of L0 Indexes (Wordlists)
  let ``L0 Indexes (Wordlists)`` instance =
    { category = "Search Indexer"; counter = "L0 Indexes (Wordlists)"; instance = instance }
  /// L0 Merge (Flush) - Count: The number of L0 merges (flushes) since the catalog was loaded
  let ``L0 Merge (Flush) - Count`` instance =
    { category = "Search Indexer"; counter = "L0 Merge (Flush) - Count"; instance = instance }
  /// L0 Merge (Flush) Speed - Average: The average value [documents/hour] computed for the speed of L0 merges (flushes) since the catalog has been loaded
  let ``L0 Merge (Flush) Speed - Average`` instance =
    { category = "Search Indexer"; counter = "L0 Merge (Flush) Speed - Average"; instance = instance }
  /// L0 Merge (Flush) Speed - Last: The last value [documents/hour] computed for the speed of L0 merges (flushes).
  let ``L0 Merge (Flush) Speed - Last`` instance =
    { category = "Search Indexer"; counter = "L0 Merge (Flush) Speed - Last"; instance = instance }
  /// L0 Merges (flushes) Now.: The number of L0 merges (flushes) in progress at any one moment.
  let ``L0 Merges (flushes) Now.`` instance =
    { category = "Search Indexer"; counter = "L0 Merges (flushes) Now."; instance = instance }
  /// L1 Merge - Count: The number of L1 merges since the catalog was loaded
  let ``L1 Merge - Count`` instance =
    { category = "Search Indexer"; counter = "L1 Merge - Count"; instance = instance }
  /// L1 Merge Speed - average: The average value [documents/hour] computed for the speed of L1 merges since the catalog has been loaded
  let ``L1 Merge Speed - average`` instance =
    { category = "Search Indexer"; counter = "L1 Merge Speed - average"; instance = instance }
  /// L1 Merge Speed - last: The last value [documents/hour] computed for the speed of L1 merges.
  let ``L1 Merge Speed - last`` instance =
    { category = "Search Indexer"; counter = "L1 Merge Speed - last"; instance = instance }
  /// L1 Merges Now.: The number of L1 merges in progress at any one moment.
  let ``L1 Merges Now.`` instance =
    { category = "Search Indexer"; counter = "L1 Merges Now."; instance = instance }
  /// L2 Merge - Count: The number of L2 merges since the catalog was loaded
  let ``L2 Merge - Count`` instance =
    { category = "Search Indexer"; counter = "L2 Merge - Count"; instance = instance }
  /// L2 Merge Speed - average: The average value [documents/hour] computed for the speed of L2 merges since the catalog has been loaded
  let ``L2 Merge Speed - average`` instance =
    { category = "Search Indexer"; counter = "L2 Merge Speed - average"; instance = instance }
  /// L2 Merge Speed - last: The last value [documents/hour] computed for the speed of L2 merges.
  let ``L2 Merge Speed - last`` instance =
    { category = "Search Indexer"; counter = "L2 Merge Speed - last"; instance = instance }
  /// L2 Merges Now.: The number of L2 merges in progress at any one moment.
  let ``L2 Merges Now.`` instance =
    { category = "Search Indexer"; counter = "L2 Merges Now."; instance = instance }
  /// L3 Merge - Count: The number of L3 merges since the catalog was loaded
  let ``L3 Merge - Count`` instance =
    { category = "Search Indexer"; counter = "L3 Merge - Count"; instance = instance }
  /// L3 Merge Speed - average: The average value [documents/hour] computed for the speed of L3 merges since the catalog has been loaded
  let ``L3 Merge Speed - average`` instance =
    { category = "Search Indexer"; counter = "L3 Merge Speed - average"; instance = instance }
  /// L3 Merge Speed - last: The last value [documents/hour] computed for the speed of L3 merges.
  let ``L3 Merge Speed - last`` instance =
    { category = "Search Indexer"; counter = "L3 Merge Speed - last"; instance = instance }
  /// L3 Merges Now.: The number of L3 merges in progress at any one moment.
  let ``L3 Merges Now.`` instance =
    { category = "Search Indexer"; counter = "L3 Merges Now."; instance = instance }
  /// L4 Merge - Count: The number of L4 merges since the catalog was loaded
  let ``L4 Merge - Count`` instance =
    { category = "Search Indexer"; counter = "L4 Merge - Count"; instance = instance }
  /// L4 Merge Speed - average: The average value [documents/hour] computed for the speed of L4 merges since the catalog has been loaded
  let ``L4 Merge Speed - average`` instance =
    { category = "Search Indexer"; counter = "L4 Merge Speed - average"; instance = instance }
  /// L4 Merge Speed - last: The last value [documents/hour] computed for the speed of L4 merges.
  let ``L4 Merge Speed - last`` instance =
    { category = "Search Indexer"; counter = "L4 Merge Speed - last"; instance = instance }
  /// L4 Merges Now.: The number of L4 merges in progress at any one moment.
  let ``L4 Merges Now.`` instance =
    { category = "Search Indexer"; counter = "L4 Merges Now."; instance = instance }
  /// L5 Merge - Count: The number of L5 merges since the catalog was loaded
  let ``L5 Merge - Count`` instance =
    { category = "Search Indexer"; counter = "L5 Merge - Count"; instance = instance }
  /// L5 Merge Speed - average: The average value [documents/hour] computed for the speed of L5 merges since the catalog has been loaded
  let ``L5 Merge Speed - average`` instance =
    { category = "Search Indexer"; counter = "L5 Merge Speed - average"; instance = instance }
  /// L5 Merge Speed - last: The last value [documents/hour] computed for the speed of L5 merges.
  let ``L5 Merge Speed - last`` instance =
    { category = "Search Indexer"; counter = "L5 Merge Speed - last"; instance = instance }
  /// L5 Merges Now.: The number of L5 merges in progress at any one moment.
  let ``L5 Merges Now.`` instance =
    { category = "Search Indexer"; counter = "L5 Merges Now."; instance = instance }
  /// L6 Merge - Count: The number of L6 merges since the catalog was loaded
  let ``L6 Merge - Count`` instance =
    { category = "Search Indexer"; counter = "L6 Merge - Count"; instance = instance }
  /// L6 Merge Speed - average: The average value [documents/hour] computed for the speed of L6 merges since the catalog has been loaded
  let ``L6 Merge Speed - average`` instance =
    { category = "Search Indexer"; counter = "L6 Merge Speed - average"; instance = instance }
  /// L6 Merge Speed - last: The last value [documents/hour] computed for the speed of L6 merges.
  let ``L6 Merge Speed - last`` instance =
    { category = "Search Indexer"; counter = "L6 Merge Speed - last"; instance = instance }
  /// L6 Merges Now.: The number of L6 merges in progress at any one moment.
  let ``L6 Merges Now.`` instance =
    { category = "Search Indexer"; counter = "L6 Merges Now."; instance = instance }
  /// L7 Merge - Count: The number of L7 merges since the catalog was loaded
  let ``L7 Merge - Count`` instance =
    { category = "Search Indexer"; counter = "L7 Merge - Count"; instance = instance }
  /// L7 Merge Speed - average: The average value [documents/hour] computed for the speed of L7 merges since the catalog has been loaded
  let ``L7 Merge Speed - average`` instance =
    { category = "Search Indexer"; counter = "L7 Merge Speed - average"; instance = instance }
  /// L7 Merge Speed - last: The last value [documents/hour] computed for the speed of L7 merges.
  let ``L7 Merge Speed - last`` instance =
    { category = "Search Indexer"; counter = "L7 Merge Speed - last"; instance = instance }
  /// L7 Merges Now.: The number of L7 merges in progress at any one moment.
  let ``L7 Merges Now.`` instance =
    { category = "Search Indexer"; counter = "L7 Merges Now."; instance = instance }
  /// L8 Merge - Count: The number of L8 merges since the catalog was loaded
  let ``L8 Merge - Count`` instance =
    { category = "Search Indexer"; counter = "L8 Merge - Count"; instance = instance }
  /// L8 Merge Speed - average: The average value [documents/hour] computed for the speed of L8 merges since the catalog has been loaded
  let ``L8 Merge Speed - average`` instance =
    { category = "Search Indexer"; counter = "L8 Merge Speed - average"; instance = instance }
  /// L8 Merge Speed - last: The last value [documents/hour] computed for the speed of L8 merges.
  let ``L8 Merge Speed - last`` instance =
    { category = "Search Indexer"; counter = "L8 Merge Speed - last"; instance = instance }
  /// L8 Merges Now.: The number of L8 merges in progress at any one moment.
  let ``L8 Merges Now.`` instance =
    { category = "Search Indexer"; counter = "L8 Merges Now."; instance = instance }
  /// Master Index Level.: The level of the master index.
  let ``Master Index Level.`` instance =
    { category = "Search Indexer"; counter = "Master Index Level."; instance = instance }
  /// Master Merge Progress: Master Merge Progress
  let ``Master Merge Progress`` instance =
    { category = "Search Indexer"; counter = "Master Merge Progress"; instance = instance }
  /// Master Merges Now.: Indicator if a master merge is going on.
  let ``Master Merges Now.`` instance =
    { category = "Search Indexer"; counter = "Master Merges Now."; instance = instance }
  /// Master Merges to Date: Number of Master Merges to Date
  let ``Master Merges to Date`` instance =
    { category = "Search Indexer"; counter = "Master Merges to Date"; instance = instance }
  /// Persistent Indexes: Number of Persistent Indexes
  let ``Persistent Indexes`` instance =
    { category = "Search Indexer"; counter = "Persistent Indexes"; instance = instance }
  /// Persistent Indexes L1: The number of L1 Indexes
  let ``Persistent Indexes L1`` instance =
    { category = "Search Indexer"; counter = "Persistent Indexes L1"; instance = instance }
  /// Persistent Indexes L2: The number of L2 Indexes
  let ``Persistent Indexes L2`` instance =
    { category = "Search Indexer"; counter = "Persistent Indexes L2"; instance = instance }
  /// Persistent Indexes L3: The number of L3 Indexes
  let ``Persistent Indexes L3`` instance =
    { category = "Search Indexer"; counter = "Persistent Indexes L3"; instance = instance }
  /// Persistent Indexes L4: The number of L4 Indexes
  let ``Persistent Indexes L4`` instance =
    { category = "Search Indexer"; counter = "Persistent Indexes L4"; instance = instance }
  /// Persistent Indexes L5: The number of L5 Indexes
  let ``Persistent Indexes L5`` instance =
    { category = "Search Indexer"; counter = "Persistent Indexes L5"; instance = instance }
  /// Persistent Indexes L6: The number of L6 Indexes
  let ``Persistent Indexes L6`` instance =
    { category = "Search Indexer"; counter = "Persistent Indexes L6"; instance = instance }
  /// Persistent Indexes L7: The number of L7 Indexes
  let ``Persistent Indexes L7`` instance =
    { category = "Search Indexer"; counter = "Persistent Indexes L7"; instance = instance }
  /// Persistent Indexes L8: The number of L8 Indexes
  let ``Persistent Indexes L8`` instance =
    { category = "Search Indexer"; counter = "Persistent Indexes L8"; instance = instance }
  /// Queries: Number of Queries
  let ``Queries`` instance =
    { category = "Search Indexer"; counter = "Queries"; instance = instance }
  /// Queries Failed: Number of Queries Failed
  let ``Queries Failed`` instance =
    { category = "Search Indexer"; counter = "Queries Failed"; instance = instance }
  /// Queries Succeeded: Number of Queries Succeeded
  let ``Queries Succeeded`` instance =
    { category = "Search Indexer"; counter = "Queries Succeeded"; instance = instance }
  /// Shadow Merge Levels: Shadow Merge Levels
  let ``Shadow Merge Levels`` instance =
    { category = "Search Indexer"; counter = "Shadow Merge Levels"; instance = instance }
  /// Shadow Merge Levels Threshold: Shadow Merge Levels Threshold
  let ``Shadow Merge Levels Threshold`` instance =
    { category = "Search Indexer"; counter = "Shadow Merge Levels Threshold"; instance = instance }
  /// Unique Keys: Number of Unique Keys
  let ``Unique Keys`` instance =
    { category = "Search Indexer"; counter = "Unique Keys"; instance = instance }
  /// Work Items Created: Number of invalidator work items that were created
  let ``Work Items Created`` instance =
    { category = "Search Indexer"; counter = "Work Items Created"; instance = instance }
  /// Work Items Deleted: Number of invalidator work items that were deleted
  let ``Work Items Deleted`` instance =
    { category = "Search Indexer"; counter = "Work Items Deleted"; instance = instance }

  let allCounters =
    [ ``Active Connections``
      ``Clean WidSets``
      ``Dirty WidSets``
      ``Documents Filtered``
      ``Index Size``
      ``L0 Indexes (Wordlists)``
      ``L0 Merge (Flush) - Count``
      ``L0 Merge (Flush) Speed - Average``
      ``L0 Merge (Flush) Speed - Last``
      ``L0 Merges (flushes) Now.``
      ``L1 Merge - Count``
      ``L1 Merge Speed - average``
      ``L1 Merge Speed - last``
      ``L1 Merges Now.``
      ``L2 Merge - Count``
      ``L2 Merge Speed - average``
      ``L2 Merge Speed - last``
      ``L2 Merges Now.``
      ``L3 Merge - Count``
      ``L3 Merge Speed - average``
      ``L3 Merge Speed - last``
      ``L3 Merges Now.``
      ``L4 Merge - Count``
      ``L4 Merge Speed - average``
      ``L4 Merge Speed - last``
      ``L4 Merges Now.``
      ``L5 Merge - Count``
      ``L5 Merge Speed - average``
      ``L5 Merge Speed - last``
      ``L5 Merges Now.``
      ``L6 Merge - Count``
      ``L6 Merge Speed - average``
      ``L6 Merge Speed - last``
      ``L6 Merges Now.``
      ``L7 Merge - Count``
      ``L7 Merge Speed - average``
      ``L7 Merge Speed - last``
      ``L7 Merges Now.``
      ``L8 Merge - Count``
      ``L8 Merge Speed - average``
      ``L8 Merge Speed - last``
      ``L8 Merges Now.``
      ``Master Index Level.``
      ``Master Merge Progress``
      ``Master Merges Now.``
      ``Master Merges to Date``
      ``Persistent Indexes``
      ``Persistent Indexes L1``
      ``Persistent Indexes L2``
      ``Persistent Indexes L3``
      ``Persistent Indexes L4``
      ``Persistent Indexes L5``
      ``Persistent Indexes L6``
      ``Persistent Indexes L7``
      ``Persistent Indexes L8``
      ``Queries``
      ``Queries Failed``
      ``Queries Succeeded``
      ``Shadow Merge Levels``
      ``Shadow Merge Levels Threshold``
      ``Unique Keys``
      ``Work Items Created``
      ``Work Items Deleted``
    ]

/// ServiceModelEndpoint 3.0.0.0: ServiceModelEndpoint 3.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``ServiceModelEndpoint 3_0_0_0`` =

  [<Literal>]
  let Category = "ServiceModelEndpoint 3.0.0.0"

  let PCC = getPCC Category
  /// Calls: -
  let ``Calls`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Calls"; instance = instance }
  /// Calls Duration: -
  let ``Calls Duration`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Calls Duration"; instance = instance }
  /// Calls Duration Base: -
  let ``Calls Duration Base`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Calls Duration Base"; instance = instance }
  /// Calls Failed: -
  let ``Calls Failed`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Calls Failed"; instance = instance }
  /// Calls Failed Per Second: -
  let ``Calls Failed Per Second`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Calls Failed Per Second"; instance = instance }
  /// Calls Faulted: -
  let ``Calls Faulted`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Calls Faulted"; instance = instance }
  /// Calls Faulted Per Second: -
  let ``Calls Faulted Per Second`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Calls Faulted Per Second"; instance = instance }
  /// Calls Outstanding: -
  let ``Calls Outstanding`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Calls Outstanding"; instance = instance }
  /// Calls Per Second: -
  let ``Calls Per Second`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Calls Per Second"; instance = instance }
  /// Reliable Messaging Messages Dropped: -
  let ``Reliable Messaging Messages Dropped`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Reliable Messaging Messages Dropped"; instance = instance }
  /// Reliable Messaging Messages Dropped Per Second: -
  let ``Reliable Messaging Messages Dropped Per Second`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Reliable Messaging Messages Dropped Per Second"; instance = instance }
  /// Reliable Messaging Sessions Faulted: -
  let ``Reliable Messaging Sessions Faulted`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Reliable Messaging Sessions Faulted"; instance = instance }
  /// Reliable Messaging Sessions Faulted Per Second: -
  let ``Reliable Messaging Sessions Faulted Per Second`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Reliable Messaging Sessions Faulted Per Second"; instance = instance }
  /// Security Calls Not Authorized: -
  let ``Security Calls Not Authorized`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Security Calls Not Authorized"; instance = instance }
  /// Security Calls Not Authorized Per Second: -
  let ``Security Calls Not Authorized Per Second`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Security Calls Not Authorized Per Second"; instance = instance }
  /// Security Validation and Authentication Failures: -
  let ``Security Validation and Authentication Failures`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Security Validation and Authentication Failures"; instance = instance }
  /// Security Validation and Authentication Failures Per Second: -
  let ``Security Validation and Authentication Failures Per Second`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Security Validation and Authentication Failures Per Second"; instance = instance }
  /// Transactions Flowed: -
  let ``Transactions Flowed`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Transactions Flowed"; instance = instance }
  /// Transactions Flowed Per Second: -
  let ``Transactions Flowed Per Second`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Transactions Flowed Per Second"; instance = instance }

  let allCounters =
    [ ``Calls``
      ``Calls Duration``
      ``Calls Duration Base``
      ``Calls Failed``
      ``Calls Failed Per Second``
      ``Calls Faulted``
      ``Calls Faulted Per Second``
      ``Calls Outstanding``
      ``Calls Per Second``
      ``Reliable Messaging Messages Dropped``
      ``Reliable Messaging Messages Dropped Per Second``
      ``Reliable Messaging Sessions Faulted``
      ``Reliable Messaging Sessions Faulted Per Second``
      ``Security Calls Not Authorized``
      ``Security Calls Not Authorized Per Second``
      ``Security Validation and Authentication Failures``
      ``Security Validation and Authentication Failures Per Second``
      ``Transactions Flowed``
      ``Transactions Flowed Per Second``
    ]

/// ServiceModelEndpoint 4.0.0.0: ServiceModel performance counters for endpoint
///
/// This performance counter does not have instance based counters
module ``ServiceModelEndpoint 4_0_0_0`` =

  [<Literal>]
  let Category = "ServiceModelEndpoint 4.0.0.0"

  let PCC = getPCC Category
  /// Calls: -
  let ``Calls`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Calls"; instance = instance }
  /// Calls Duration: -
  let ``Calls Duration`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Calls Duration"; instance = instance }
  /// Calls Failed: -
  let ``Calls Failed`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Calls Failed"; instance = instance }
  /// Calls Failed Per Second: -
  let ``Calls Failed Per Second`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Calls Failed Per Second"; instance = instance }
  /// Calls Faulted: -
  let ``Calls Faulted`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Calls Faulted"; instance = instance }
  /// Calls Faulted Per Second: -
  let ``Calls Faulted Per Second`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Calls Faulted Per Second"; instance = instance }
  /// Calls Outstanding: -
  let ``Calls Outstanding`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Calls Outstanding"; instance = instance }
  /// Calls Per Second: -
  let ``Calls Per Second`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Calls Per Second"; instance = instance }
  /// Reliable Messaging Messages Dropped: -
  let ``Reliable Messaging Messages Dropped`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Reliable Messaging Messages Dropped"; instance = instance }
  /// Reliable Messaging Messages Dropped Per Second: -
  let ``Reliable Messaging Messages Dropped Per Second`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Reliable Messaging Messages Dropped Per Second"; instance = instance }
  /// Reliable Messaging Sessions Faulted: -
  let ``Reliable Messaging Sessions Faulted`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Reliable Messaging Sessions Faulted"; instance = instance }
  /// Reliable Messaging Sessions Faulted Per Second: -
  let ``Reliable Messaging Sessions Faulted Per Second`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Reliable Messaging Sessions Faulted Per Second"; instance = instance }
  /// Security Calls Not Authorized: -
  let ``Security Calls Not Authorized`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Security Calls Not Authorized"; instance = instance }
  /// Security Calls Not Authorized Per Second: -
  let ``Security Calls Not Authorized Per Second`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Security Calls Not Authorized Per Second"; instance = instance }
  /// Security Validation and Authentication Failures: -
  let ``Security Validation and Authentication Failures`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Security Validation and Authentication Failures"; instance = instance }
  /// Security Validation and Authentication Failures Per Second: -
  let ``Security Validation and Authentication Failures Per Second`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Security Validation and Authentication Failures Per Second"; instance = instance }
  /// Transactions Flowed: -
  let ``Transactions Flowed`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Transactions Flowed"; instance = instance }
  /// Transactions Flowed Per Second: -
  let ``Transactions Flowed Per Second`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Transactions Flowed Per Second"; instance = instance }

  let allCounters =
    [ ``Calls``
      ``Calls Duration``
      ``Calls Failed``
      ``Calls Failed Per Second``
      ``Calls Faulted``
      ``Calls Faulted Per Second``
      ``Calls Outstanding``
      ``Calls Per Second``
      ``Reliable Messaging Messages Dropped``
      ``Reliable Messaging Messages Dropped Per Second``
      ``Reliable Messaging Sessions Faulted``
      ``Reliable Messaging Sessions Faulted Per Second``
      ``Security Calls Not Authorized``
      ``Security Calls Not Authorized Per Second``
      ``Security Validation and Authentication Failures``
      ``Security Validation and Authentication Failures Per Second``
      ``Transactions Flowed``
      ``Transactions Flowed Per Second``
    ]

/// ServiceModelOperation 3.0.0.0: ServiceModelOperation 3.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``ServiceModelOperation 3_0_0_0`` =

  [<Literal>]
  let Category = "ServiceModelOperation 3.0.0.0"

  let PCC = getPCC Category
  /// Call Failed Per Second: -
  let ``Call Failed Per Second`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Call Failed Per Second"; instance = instance }
  /// Calls: -
  let ``Calls`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Calls"; instance = instance }
  /// Calls Duration: -
  let ``Calls Duration`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Calls Duration"; instance = instance }
  /// Calls Duration Base: -
  let ``Calls Duration Base`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Calls Duration Base"; instance = instance }
  /// Calls Failed: -
  let ``Calls Failed`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Calls Failed"; instance = instance }
  /// Calls Faulted: -
  let ``Calls Faulted`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Calls Faulted"; instance = instance }
  /// Calls Faulted Per Second: -
  let ``Calls Faulted Per Second`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Calls Faulted Per Second"; instance = instance }
  /// Calls Outstanding: -
  let ``Calls Outstanding`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Calls Outstanding"; instance = instance }
  /// Calls Per Second: -
  let ``Calls Per Second`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Calls Per Second"; instance = instance }
  /// Security Calls Not Authorized: -
  let ``Security Calls Not Authorized`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Security Calls Not Authorized"; instance = instance }
  /// Security Calls Not Authorized Per Second: -
  let ``Security Calls Not Authorized Per Second`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Security Calls Not Authorized Per Second"; instance = instance }
  /// Security Validation and Authentication Failures: -
  let ``Security Validation and Authentication Failures`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Security Validation and Authentication Failures"; instance = instance }
  /// Security Validation and Authentication Failures Per Second: -
  let ``Security Validation and Authentication Failures Per Second`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Security Validation and Authentication Failures Per Second"; instance = instance }
  /// Transactions Flowed: -
  let ``Transactions Flowed`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Transactions Flowed"; instance = instance }
  /// Transactions Flowed Per Second: -
  let ``Transactions Flowed Per Second`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Transactions Flowed Per Second"; instance = instance }

  let allCounters =
    [ ``Call Failed Per Second``
      ``Calls``
      ``Calls Duration``
      ``Calls Duration Base``
      ``Calls Failed``
      ``Calls Faulted``
      ``Calls Faulted Per Second``
      ``Calls Outstanding``
      ``Calls Per Second``
      ``Security Calls Not Authorized``
      ``Security Calls Not Authorized Per Second``
      ``Security Validation and Authentication Failures``
      ``Security Validation and Authentication Failures Per Second``
      ``Transactions Flowed``
      ``Transactions Flowed Per Second``
    ]

/// ServiceModelOperation 4.0.0.0: ServiceModelOperation 4.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``ServiceModelOperation 4_0_0_0`` =

  [<Literal>]
  let Category = "ServiceModelOperation 4.0.0.0"

  let PCC = getPCC Category
  /// Call Failed Per Second: -
  let ``Call Failed Per Second`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Call Failed Per Second"; instance = instance }
  /// Calls: -
  let ``Calls`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Calls"; instance = instance }
  /// Calls Duration: -
  let ``Calls Duration`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Calls Duration"; instance = instance }
  /// Calls Failed: -
  let ``Calls Failed`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Calls Failed"; instance = instance }
  /// Calls Faulted: -
  let ``Calls Faulted`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Calls Faulted"; instance = instance }
  /// Calls Faulted Per Second: -
  let ``Calls Faulted Per Second`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Calls Faulted Per Second"; instance = instance }
  /// Calls Outstanding: -
  let ``Calls Outstanding`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Calls Outstanding"; instance = instance }
  /// Calls Per Second: -
  let ``Calls Per Second`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Calls Per Second"; instance = instance }
  /// Security Calls Not Authorized: -
  let ``Security Calls Not Authorized`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Security Calls Not Authorized"; instance = instance }
  /// Security Calls Not Authorized Per Second: -
  let ``Security Calls Not Authorized Per Second`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Security Calls Not Authorized Per Second"; instance = instance }
  /// Security Validation and Authentication Failures: -
  let ``Security Validation and Authentication Failures`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Security Validation and Authentication Failures"; instance = instance }
  /// Security Validation and Authentication Failures Per Second: -
  let ``Security Validation and Authentication Failures Per Second`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Security Validation and Authentication Failures Per Second"; instance = instance }
  /// Transactions Flowed: -
  let ``Transactions Flowed`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Transactions Flowed"; instance = instance }
  /// Transactions Flowed Per Second: -
  let ``Transactions Flowed Per Second`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Transactions Flowed Per Second"; instance = instance }

  let allCounters =
    [ ``Call Failed Per Second``
      ``Calls``
      ``Calls Duration``
      ``Calls Failed``
      ``Calls Faulted``
      ``Calls Faulted Per Second``
      ``Calls Outstanding``
      ``Calls Per Second``
      ``Security Calls Not Authorized``
      ``Security Calls Not Authorized Per Second``
      ``Security Validation and Authentication Failures``
      ``Security Validation and Authentication Failures Per Second``
      ``Transactions Flowed``
      ``Transactions Flowed Per Second``
    ]

/// ServiceModelService 3.0.0.0: ServiceModelService 3.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``ServiceModelService 3_0_0_0`` =

  [<Literal>]
  let Category = "ServiceModelService 3.0.0.0"

  let PCC = getPCC Category
  /// Calls: -
  let ``Calls`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Calls"; instance = instance }
  /// Calls Duration: -
  let ``Calls Duration`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Calls Duration"; instance = instance }
  /// Calls Duration Base: -
  let ``Calls Duration Base`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Calls Duration Base"; instance = instance }
  /// Calls Failed: -
  let ``Calls Failed`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Calls Failed"; instance = instance }
  /// Calls Failed Per Second: -
  let ``Calls Failed Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Calls Failed Per Second"; instance = instance }
  /// Calls Faulted: -
  let ``Calls Faulted`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Calls Faulted"; instance = instance }
  /// Calls Faulted Per Second: -
  let ``Calls Faulted Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Calls Faulted Per Second"; instance = instance }
  /// Calls Outstanding: -
  let ``Calls Outstanding`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Calls Outstanding"; instance = instance }
  /// Calls Per Second: -
  let ``Calls Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Calls Per Second"; instance = instance }
  /// Instances: -
  let ``Instances`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Instances"; instance = instance }
  /// Instances Created Per Second: -
  let ``Instances Created Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Instances Created Per Second"; instance = instance }
  /// Queued Messages Dropped: -
  let ``Queued Messages Dropped`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Queued Messages Dropped"; instance = instance }
  /// Queued Messages Dropped Per Second: -
  let ``Queued Messages Dropped Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Queued Messages Dropped Per Second"; instance = instance }
  /// Queued Messages Rejected: -
  let ``Queued Messages Rejected`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Queued Messages Rejected"; instance = instance }
  /// Queued Messages Rejected Per Second: -
  let ``Queued Messages Rejected Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Queued Messages Rejected Per Second"; instance = instance }
  /// Queued Poison Messages: -
  let ``Queued Poison Messages`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Queued Poison Messages"; instance = instance }
  /// Queued Poison Messages Per Second: -
  let ``Queued Poison Messages Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Queued Poison Messages Per Second"; instance = instance }
  /// Reliable Messaging Messages Dropped: -
  let ``Reliable Messaging Messages Dropped`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Reliable Messaging Messages Dropped"; instance = instance }
  /// Reliable Messaging Messages Dropped Per Second: -
  let ``Reliable Messaging Messages Dropped Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Reliable Messaging Messages Dropped Per Second"; instance = instance }
  /// Reliable Messaging Sessions Faulted: -
  let ``Reliable Messaging Sessions Faulted`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Reliable Messaging Sessions Faulted"; instance = instance }
  /// Reliable Messaging Sessions Faulted Per Second: -
  let ``Reliable Messaging Sessions Faulted Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Reliable Messaging Sessions Faulted Per Second"; instance = instance }
  /// Security Calls Not Authorized: -
  let ``Security Calls Not Authorized`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Security Calls Not Authorized"; instance = instance }
  /// Security Calls Not Authorized Per Second: -
  let ``Security Calls Not Authorized Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Security Calls Not Authorized Per Second"; instance = instance }
  /// Security Validation and Authentication Failures: -
  let ``Security Validation and Authentication Failures`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Security Validation and Authentication Failures"; instance = instance }
  /// Security Validation and Authentication Failures Per Second: -
  let ``Security Validation and Authentication Failures Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Security Validation and Authentication Failures Per Second"; instance = instance }
  /// Transacted Operations Aborted: -
  let ``Transacted Operations Aborted`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Transacted Operations Aborted"; instance = instance }
  /// Transacted Operations Aborted Per Second: -
  let ``Transacted Operations Aborted Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Transacted Operations Aborted Per Second"; instance = instance }
  /// Transacted Operations Committed: -
  let ``Transacted Operations Committed`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Transacted Operations Committed"; instance = instance }
  /// Transacted Operations Committed Per Second: -
  let ``Transacted Operations Committed Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Transacted Operations Committed Per Second"; instance = instance }
  /// Transacted Operations In Doubt: -
  let ``Transacted Operations In Doubt`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Transacted Operations In Doubt"; instance = instance }
  /// Transacted Operations In Doubt Per Second: -
  let ``Transacted Operations In Doubt Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Transacted Operations In Doubt Per Second"; instance = instance }
  /// Transactions Flowed: -
  let ``Transactions Flowed`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Transactions Flowed"; instance = instance }
  /// Transactions Flowed Per Second: -
  let ``Transactions Flowed Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Transactions Flowed Per Second"; instance = instance }

  let allCounters =
    [ ``Calls``
      ``Calls Duration``
      ``Calls Duration Base``
      ``Calls Failed``
      ``Calls Failed Per Second``
      ``Calls Faulted``
      ``Calls Faulted Per Second``
      ``Calls Outstanding``
      ``Calls Per Second``
      ``Instances``
      ``Instances Created Per Second``
      ``Queued Messages Dropped``
      ``Queued Messages Dropped Per Second``
      ``Queued Messages Rejected``
      ``Queued Messages Rejected Per Second``
      ``Queued Poison Messages``
      ``Queued Poison Messages Per Second``
      ``Reliable Messaging Messages Dropped``
      ``Reliable Messaging Messages Dropped Per Second``
      ``Reliable Messaging Sessions Faulted``
      ``Reliable Messaging Sessions Faulted Per Second``
      ``Security Calls Not Authorized``
      ``Security Calls Not Authorized Per Second``
      ``Security Validation and Authentication Failures``
      ``Security Validation and Authentication Failures Per Second``
      ``Transacted Operations Aborted``
      ``Transacted Operations Aborted Per Second``
      ``Transacted Operations Committed``
      ``Transacted Operations Committed Per Second``
      ``Transacted Operations In Doubt``
      ``Transacted Operations In Doubt Per Second``
      ``Transactions Flowed``
      ``Transactions Flowed Per Second``
    ]

/// ServiceModelService 4.0.0.0: ServiceModel performance counters for service
///
/// This performance counter does not have instance based counters
module ``ServiceModelService 4_0_0_0`` =

  [<Literal>]
  let Category = "ServiceModelService 4.0.0.0"

  let PCC = getPCC Category
  /// Calls: -
  let ``Calls`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Calls"; instance = instance }
  /// Calls Duration: -
  let ``Calls Duration`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Calls Duration"; instance = instance }
  /// Calls Failed: -
  let ``Calls Failed`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Calls Failed"; instance = instance }
  /// Calls Failed Per Second: -
  let ``Calls Failed Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Calls Failed Per Second"; instance = instance }
  /// Calls Faulted: -
  let ``Calls Faulted`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Calls Faulted"; instance = instance }
  /// Calls Faulted Per Second: -
  let ``Calls Faulted Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Calls Faulted Per Second"; instance = instance }
  /// Calls Outstanding: -
  let ``Calls Outstanding`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Calls Outstanding"; instance = instance }
  /// Calls Per Second: -
  let ``Calls Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Calls Per Second"; instance = instance }
  /// Instances: -
  let ``Instances`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Instances"; instance = instance }
  /// Instances Created Per Second: -
  let ``Instances Created Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Instances Created Per Second"; instance = instance }
  /// Percent Of Max Concurrent Calls: -
  let ``Percent Of Max Concurrent Calls`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Percent Of Max Concurrent Calls"; instance = instance }
  /// Percent Of Max Concurrent Instances: -
  let ``Percent Of Max Concurrent Instances`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Percent Of Max Concurrent Instances"; instance = instance }
  /// Percent Of Max Concurrent Sessions: -
  let ``Percent Of Max Concurrent Sessions`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Percent Of Max Concurrent Sessions"; instance = instance }
  /// Queued Messages Dropped: -
  let ``Queued Messages Dropped`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Queued Messages Dropped"; instance = instance }
  /// Queued Messages Dropped Per Second: -
  let ``Queued Messages Dropped Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Queued Messages Dropped Per Second"; instance = instance }
  /// Queued Messages Rejected: -
  let ``Queued Messages Rejected`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Queued Messages Rejected"; instance = instance }
  /// Queued Messages Rejected Per Second: -
  let ``Queued Messages Rejected Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Queued Messages Rejected Per Second"; instance = instance }
  /// Queued Poison Messages: -
  let ``Queued Poison Messages`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Queued Poison Messages"; instance = instance }
  /// Queued Poison Messages Per Second: -
  let ``Queued Poison Messages Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Queued Poison Messages Per Second"; instance = instance }
  /// Reliable Messaging Messages Dropped: -
  let ``Reliable Messaging Messages Dropped`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Reliable Messaging Messages Dropped"; instance = instance }
  /// Reliable Messaging Messages Dropped Per Second: -
  let ``Reliable Messaging Messages Dropped Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Reliable Messaging Messages Dropped Per Second"; instance = instance }
  /// Reliable Messaging Sessions Faulted: -
  let ``Reliable Messaging Sessions Faulted`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Reliable Messaging Sessions Faulted"; instance = instance }
  /// Reliable Messaging Sessions Faulted Per Second: -
  let ``Reliable Messaging Sessions Faulted Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Reliable Messaging Sessions Faulted Per Second"; instance = instance }
  /// Security Calls Not Authorized: -
  let ``Security Calls Not Authorized`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Security Calls Not Authorized"; instance = instance }
  /// Security Calls Not Authorized Per Second: -
  let ``Security Calls Not Authorized Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Security Calls Not Authorized Per Second"; instance = instance }
  /// Security Validation and Authentication Failures: -
  let ``Security Validation and Authentication Failures`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Security Validation and Authentication Failures"; instance = instance }
  /// Security Validation and Authentication Failures Per Second: -
  let ``Security Validation and Authentication Failures Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Security Validation and Authentication Failures Per Second"; instance = instance }
  /// Transacted Operations Aborted: -
  let ``Transacted Operations Aborted`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Transacted Operations Aborted"; instance = instance }
  /// Transacted Operations Aborted Per Second: -
  let ``Transacted Operations Aborted Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Transacted Operations Aborted Per Second"; instance = instance }
  /// Transacted Operations Committed: -
  let ``Transacted Operations Committed`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Transacted Operations Committed"; instance = instance }
  /// Transacted Operations Committed Per Second: -
  let ``Transacted Operations Committed Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Transacted Operations Committed Per Second"; instance = instance }
  /// Transacted Operations In Doubt: -
  let ``Transacted Operations In Doubt`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Transacted Operations In Doubt"; instance = instance }
  /// Transacted Operations In Doubt Per Second: -
  let ``Transacted Operations In Doubt Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Transacted Operations In Doubt Per Second"; instance = instance }
  /// Transactions Flowed: -
  let ``Transactions Flowed`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Transactions Flowed"; instance = instance }
  /// Transactions Flowed Per Second: -
  let ``Transactions Flowed Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Transactions Flowed Per Second"; instance = instance }

  let allCounters =
    [ ``Calls``
      ``Calls Duration``
      ``Calls Failed``
      ``Calls Failed Per Second``
      ``Calls Faulted``
      ``Calls Faulted Per Second``
      ``Calls Outstanding``
      ``Calls Per Second``
      ``Instances``
      ``Instances Created Per Second``
      ``Percent Of Max Concurrent Calls``
      ``Percent Of Max Concurrent Instances``
      ``Percent Of Max Concurrent Sessions``
      ``Queued Messages Dropped``
      ``Queued Messages Dropped Per Second``
      ``Queued Messages Rejected``
      ``Queued Messages Rejected Per Second``
      ``Queued Poison Messages``
      ``Queued Poison Messages Per Second``
      ``Reliable Messaging Messages Dropped``
      ``Reliable Messaging Messages Dropped Per Second``
      ``Reliable Messaging Sessions Faulted``
      ``Reliable Messaging Sessions Faulted Per Second``
      ``Security Calls Not Authorized``
      ``Security Calls Not Authorized Per Second``
      ``Security Validation and Authentication Failures``
      ``Security Validation and Authentication Failures Per Second``
      ``Transacted Operations Aborted``
      ``Transacted Operations Aborted Per Second``
      ``Transacted Operations Committed``
      ``Transacted Operations Committed Per Second``
      ``Transacted Operations In Doubt``
      ``Transacted Operations In Doubt Per Second``
      ``Transactions Flowed``
      ``Transactions Flowed Per Second``
    ]

/// Storage Spaces Tier: The Storage Spaces Tier performance object consists of counters that show information about Storage Spaces tiers.
///
/// This performance counter does not have instance based counters
module ``Storage Spaces Tier`` =

  [<Literal>]
  let Category = "Storage Spaces Tier"

  let PCC = getPCC Category
  /// Avg. Tier Bytes/Read: -
  let ``Avg. Tier Bytes/Read`` instance =
    { category = "Storage Spaces Tier"; counter = "Avg. Tier Bytes/Read"; instance = instance }
  /// Avg. Tier Bytes/Transfer: -
  let ``Avg. Tier Bytes/Transfer`` instance =
    { category = "Storage Spaces Tier"; counter = "Avg. Tier Bytes/Transfer"; instance = instance }
  /// Avg. Tier Bytes/Write: -
  let ``Avg. Tier Bytes/Write`` instance =
    { category = "Storage Spaces Tier"; counter = "Avg. Tier Bytes/Write"; instance = instance }
  /// Avg. Tier Queue Length: -
  let ``Avg. Tier Queue Length`` instance =
    { category = "Storage Spaces Tier"; counter = "Avg. Tier Queue Length"; instance = instance }
  /// Avg. Tier Read Queue Length: -
  let ``Avg. Tier Read Queue Length`` instance =
    { category = "Storage Spaces Tier"; counter = "Avg. Tier Read Queue Length"; instance = instance }
  /// Avg. Tier Write Queue Length: -
  let ``Avg. Tier Write Queue Length`` instance =
    { category = "Storage Spaces Tier"; counter = "Avg. Tier Write Queue Length"; instance = instance }
  /// Avg. Tier sec/Read: -
  let ``Avg. Tier sec/Read`` instance =
    { category = "Storage Spaces Tier"; counter = "Avg. Tier sec/Read"; instance = instance }
  /// Avg. Tier sec/Transfer: -
  let ``Avg. Tier sec/Transfer`` instance =
    { category = "Storage Spaces Tier"; counter = "Avg. Tier sec/Transfer"; instance = instance }
  /// Avg. Tier sec/Write: -
  let ``Avg. Tier sec/Write`` instance =
    { category = "Storage Spaces Tier"; counter = "Avg. Tier sec/Write"; instance = instance }
  /// Current Tier Queue Length: -
  let ``Current Tier Queue Length`` instance =
    { category = "Storage Spaces Tier"; counter = "Current Tier Queue Length"; instance = instance }
  /// Tier Read Bytes/sec: -
  let ``Tier Read Bytes/sec`` instance =
    { category = "Storage Spaces Tier"; counter = "Tier Read Bytes/sec"; instance = instance }
  /// Tier Reads/sec: -
  let ``Tier Reads/sec`` instance =
    { category = "Storage Spaces Tier"; counter = "Tier Reads/sec"; instance = instance }
  /// Tier Transfer Bytes/sec: -
  let ``Tier Transfer Bytes/sec`` instance =
    { category = "Storage Spaces Tier"; counter = "Tier Transfer Bytes/sec"; instance = instance }
  /// Tier Transfers/sec: -
  let ``Tier Transfers/sec`` instance =
    { category = "Storage Spaces Tier"; counter = "Tier Transfers/sec"; instance = instance }
  /// Tier Write Bytes/sec: -
  let ``Tier Write Bytes/sec`` instance =
    { category = "Storage Spaces Tier"; counter = "Tier Write Bytes/sec"; instance = instance }
  /// Tier Writes/sec: -
  let ``Tier Writes/sec`` instance =
    { category = "Storage Spaces Tier"; counter = "Tier Writes/sec"; instance = instance }

  let allCounters =
    [ ``Avg. Tier Bytes/Read``
      ``Avg. Tier Bytes/Transfer``
      ``Avg. Tier Bytes/Write``
      ``Avg. Tier Queue Length``
      ``Avg. Tier Read Queue Length``
      ``Avg. Tier Write Queue Length``
      ``Avg. Tier sec/Read``
      ``Avg. Tier sec/Transfer``
      ``Avg. Tier sec/Write``
      ``Current Tier Queue Length``
      ``Tier Read Bytes/sec``
      ``Tier Reads/sec``
      ``Tier Transfer Bytes/sec``
      ``Tier Transfers/sec``
      ``Tier Write Bytes/sec``
      ``Tier Writes/sec``
    ]

/// Storage Spaces Write Cache: The Storage Spaces Write Cache performance object consists of counters that show information about Storage Spaces write caches.
///
/// This performance counter does not have instance based counters
module ``Storage Spaces Write Cache`` =

  [<Literal>]
  let Category = "Storage Spaces Write Cache"

  let PCC = getPCC Category
  /// Avg. Cache Bytes/Evict: -
  let ``Avg. Cache Bytes/Evict`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Avg. Cache Bytes/Evict"; instance = instance }
  /// Avg. Cache Bytes/Overwrite: -
  let ``Avg. Cache Bytes/Overwrite`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Avg. Cache Bytes/Overwrite"; instance = instance }
  /// Avg. Cache Bytes/Write: -
  let ``Avg. Cache Bytes/Write`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Avg. Cache Bytes/Write"; instance = instance }
  /// Avg. Destage Bytes/Evict: -
  let ``Avg. Destage Bytes/Evict`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Avg. Destage Bytes/Evict"; instance = instance }
  /// Avg. Destage Bytes/Transfer: -
  let ``Avg. Destage Bytes/Transfer`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Avg. Destage Bytes/Transfer"; instance = instance }
  /// Avg. Destage Evict Bytes/Operation: -
  let ``Avg. Destage Evict Bytes/Operation`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Avg. Destage Evict Bytes/Operation"; instance = instance }
  /// Avg. Destage Evicts/Operation: -
  let ``Avg. Destage Evicts/Operation`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Avg. Destage Evicts/Operation"; instance = instance }
  /// Avg. Destage Queue Length: -
  let ``Avg. Destage Queue Length`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Avg. Destage Queue Length"; instance = instance }
  /// Avg. Destage Transfer Bytes/Operation: -
  let ``Avg. Destage Transfer Bytes/Operation`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Avg. Destage Transfer Bytes/Operation"; instance = instance }
  /// Avg. Destage Transfers/Evict: -
  let ``Avg. Destage Transfers/Evict`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Avg. Destage Transfers/Evict"; instance = instance }
  /// Avg. Destage Transfers/Operation: -
  let ``Avg. Destage Transfers/Operation`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Avg. Destage Transfers/Operation"; instance = instance }
  /// Avg. Destage sec/Operation: -
  let ``Avg. Destage sec/Operation`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Avg. Destage sec/Operation"; instance = instance }
  /// Bytes Cached: -
  let ``Bytes Cached`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Bytes Cached"; instance = instance }
  /// Bytes Reclaimable: -
  let ``Bytes Reclaimable`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Bytes Reclaimable"; instance = instance }
  /// Bytes Reserved: -
  let ``Bytes Reserved`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Bytes Reserved"; instance = instance }
  /// Bytes Used: -
  let ``Bytes Used`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Bytes Used"; instance = instance }
  /// Cache Evict Bytes/sec: -
  let ``Cache Evict Bytes/sec`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Cache Evict Bytes/sec"; instance = instance }
  /// Cache Evicts/sec: -
  let ``Cache Evicts/sec`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Cache Evicts/sec"; instance = instance }
  /// Cache Overwrite Bytes/sec: -
  let ``Cache Overwrite Bytes/sec`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Cache Overwrite Bytes/sec"; instance = instance }
  /// Cache Overwrites/sec: -
  let ``Cache Overwrites/sec`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Cache Overwrites/sec"; instance = instance }
  /// Cache Size: -
  let ``Cache Size`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Cache Size"; instance = instance }
  /// Cache Write Bytes/sec: -
  let ``Cache Write Bytes/sec`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Cache Write Bytes/sec"; instance = instance }
  /// Cache Writes/sec: -
  let ``Cache Writes/sec`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Cache Writes/sec"; instance = instance }
  /// Current Destage Queue Length: -
  let ``Current Destage Queue Length`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Current Destage Queue Length"; instance = instance }
  /// Destage Evict Bytes/sec: -
  let ``Destage Evict Bytes/sec`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Destage Evict Bytes/sec"; instance = instance }
  /// Destage Evicts/sec: -
  let ``Destage Evicts/sec`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Destage Evicts/sec"; instance = instance }
  /// Destage Operations/sec: -
  let ``Destage Operations/sec`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Destage Operations/sec"; instance = instance }
  /// Destage Optimized Operations/sec: -
  let ``Destage Optimized Operations/sec`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Destage Optimized Operations/sec"; instance = instance }
  /// Destage Transfer Bytes/sec: -
  let ``Destage Transfer Bytes/sec`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Destage Transfer Bytes/sec"; instance = instance }
  /// Destage Transfers/sec: -
  let ``Destage Transfers/sec`` instance =
    { category = "Storage Spaces Write Cache"; counter = "Destage Transfers/sec"; instance = instance }

  let allCounters =
    [ ``Avg. Cache Bytes/Evict``
      ``Avg. Cache Bytes/Overwrite``
      ``Avg. Cache Bytes/Write``
      ``Avg. Destage Bytes/Evict``
      ``Avg. Destage Bytes/Transfer``
      ``Avg. Destage Evict Bytes/Operation``
      ``Avg. Destage Evicts/Operation``
      ``Avg. Destage Queue Length``
      ``Avg. Destage Transfer Bytes/Operation``
      ``Avg. Destage Transfers/Evict``
      ``Avg. Destage Transfers/Operation``
      ``Avg. Destage sec/Operation``
      ``Bytes Cached``
      ``Bytes Reclaimable``
      ``Bytes Reserved``
      ``Bytes Used``
      ``Cache Evict Bytes/sec``
      ``Cache Evicts/sec``
      ``Cache Overwrite Bytes/sec``
      ``Cache Overwrites/sec``
      ``Cache Size``
      ``Cache Write Bytes/sec``
      ``Cache Writes/sec``
      ``Current Destage Queue Length``
      ``Destage Evict Bytes/sec``
      ``Destage Evicts/sec``
      ``Destage Operations/sec``
      ``Destage Optimized Operations/sec``
      ``Destage Transfer Bytes/sec``
      ``Destage Transfers/sec``
    ]

/// Synchronization: The Synchronization performance object consists of counters for kernel synchronization. The synchronization object represents each processor as an instance of the object.
///
/// This performance counter does not have non-instance based counters
module ``Synchronization`` =

  [<Literal>]
  let Category = "Synchronization"

  let PCC = getPCC Category
  /// Exec. Resource Acquires AcqExclLite/sec: Frequency of first exclusive acquires from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Acquires AcqExclLite/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Acquires AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Acquires AcqShrdLite/sec: Frequency of first shared acquires from ExAcquireResourceSharedLite.
  let ``Exec. Resource Acquires AcqShrdLite/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Acquires AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Acquires AcqShrdStarveExcl/sec: Frequency of first shared acquires from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Acquires AcqShrdStarveExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Acquires AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Acquires AcqShrdWaitForExcl/sec: Frequency of first shared acquires from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Acquires AcqShrdWaitForExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Acquires AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Attempts AcqExclLite/sec: Frequency of acquire exclusive attempts on Executive Resources from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Attempts AcqExclLite/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Attempts AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Attempts AcqShrdLite/sec: Frequency of acquire shared attempts on Executive Resources from ExAcquireResourceSharedLite.
  let ``Exec. Resource Attempts AcqShrdLite/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Attempts AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Attempts AcqShrdStarveExcl/sec: Frequency of acquire shared attempts on Executive Resources from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Attempts AcqShrdStarveExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Attempts AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Attempts AcqShrdWaitForExcl/sec: Frequency of acquire shared attempts on Executive Resources from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Attempts AcqShrdWaitForExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Attempts AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Boost Excl. Owner/sec: Frequency of boosting exclusive ownwer when waiting for this Executive Resource.
  let ``Exec. Resource Boost Excl. Owner/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Boost Excl. Owner/sec"; instance = instance }
  /// Exec. Resource Boost Shared Owners/sec: Frequency of boosting shared ownwer(s) when waiting for this Executive Resource.
  let ``Exec. Resource Boost Shared Owners/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Boost Shared Owners/sec"; instance = instance }
  /// Exec. Resource Contention AcqExclLite/sec: Frequency of waits during exclusive acquire attempts from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Contention AcqExclLite/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Contention AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Contention AcqShrdLite/sec: Frequency of waits during acquire attempts from ExAcquireResourceSharedLite.
  let ``Exec. Resource Contention AcqShrdLite/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Contention AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Contention AcqShrdStarveExcl/sec: Frequency of waits during shared acquire attempts from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Contention AcqShrdStarveExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Contention AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Contention AcqShrdWaitForExcl/sec: Frequency of waits during shared acquire attempts from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Contention AcqShrdWaitForExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Contention AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqExclLite/sec: Frequency of recursive exclusive acquires from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Recursive Excl. Acquires AcqExclLite/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Recursive Excl. Acquires AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec: Frequency of recursive exclusive acquires from ExAcquireResourceSharedLite.
  let ``Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec: Frequency of recursive exclusive acquires from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec: Frequency of recursive exclusive acquires from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec: Frequency of recursive shared acquires from ExAcquireResourceSharedLite.
  let ``Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec: Frequency of recursive shared acquires from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec: Frequency of recursive shared acquires from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Set Owner Pointer Exclusive/sec: Frequency of ExSetResourceOwnerPointer to an exclusive owner.
  let ``Exec. Resource Set Owner Pointer Exclusive/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Set Owner Pointer Exclusive/sec"; instance = instance }
  /// Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec: Frequency of ExSetResourceOwnerPointer to an existing shared owner.
  let ``Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec"; instance = instance }
  /// Exec. Resource Set Owner Pointer Shared (New Owner)/sec: Frequency of ExSetResourceOwnerPointer to a new shared owner.
  let ``Exec. Resource Set Owner Pointer Shared (New Owner)/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Set Owner Pointer Shared (New Owner)/sec"; instance = instance }
  /// Exec. Resource Total Acquires/sec: Frequency of acquire operations on Executive Resources.
  let ``Exec. Resource Total Acquires/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Total Acquires/sec"; instance = instance }
  /// Exec. Resource Total Contentions/sec: Contention rate on Executive Resources.
  let ``Exec. Resource Total Contentions/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Total Contentions/sec"; instance = instance }
  /// Exec. Resource Total Conv. Exclusive To Shared/sec: Frequency of convert to shared operations on Executive Resources.
  let ``Exec. Resource Total Conv. Exclusive To Shared/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Total Conv. Exclusive To Shared/sec"; instance = instance }
  /// Exec. Resource Total Delete/sec: Frequency of delete operations on Executive Resources.
  let ``Exec. Resource Total Delete/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Total Delete/sec"; instance = instance }
  /// Exec. Resource Total Exclusive Releases/sec: Frequency of Exclusive releases on Executive Resources.
  let ``Exec. Resource Total Exclusive Releases/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Total Exclusive Releases/sec"; instance = instance }
  /// Exec. Resource Total Initialize/sec: Frequency of initialization operations on Executive Resources.
  let ``Exec. Resource Total Initialize/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Total Initialize/sec"; instance = instance }
  /// Exec. Resource Total Re-Initialize/sec: Frequency of re-initialization operations on Executive Resources.
  let ``Exec. Resource Total Re-Initialize/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Total Re-Initialize/sec"; instance = instance }
  /// Exec. Resource Total Shared Releases/sec: Frequency of Shared releases on Executive Resources.
  let ``Exec. Resource Total Shared Releases/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Total Shared Releases/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqExclLite/sec: Frequency of no-waits during exclusive acquire attempts from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource no-Waits AcqExclLite/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource no-Waits AcqExclLite/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqShrdLite/sec: Frequency of no-waits during acquire attempts from ExAcquireResourceSharedLite.
  let ``Exec. Resource no-Waits AcqShrdLite/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource no-Waits AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqShrdStarveExcl/sec: Frequency of no-waits during shared acquire attempts from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource no-Waits AcqShrdStarveExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource no-Waits AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqShrdWaitForExcl/sec: Frequency of no-waits during exclusive acquire attempts from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource no-Waits AcqShrdWaitForExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource no-Waits AcqShrdWaitForExcl/sec"; instance = instance }
  /// IPI Send Broadcast Requests/sec: IPI Send Broadcast Requests/sec is the rate of IPI broadcast requests.
  let ``IPI Send Broadcast Requests/sec`` instance =
    { category = "Synchronization"; counter = "IPI Send Broadcast Requests/sec"; instance = instance }
  /// IPI Send Routine Requests/sec: IPI Send Routine Requests/sec is the rate of IPI routine requests.
  let ``IPI Send Routine Requests/sec`` instance =
    { category = "Synchronization"; counter = "IPI Send Routine Requests/sec"; instance = instance }
  /// IPI Send Software Interrupts/sec: IPI Send Software Interrrupts/sec is the rate of software interrupts.
  let ``IPI Send Software Interrupts/sec`` instance =
    { category = "Synchronization"; counter = "IPI Send Software Interrupts/sec"; instance = instance }
  /// Spinlock Acquires/sec: Spinlock acquires/sec is the rate of spinlock acquisitions. It includes the basic spinlocks, queued spinlocks, in-stack queued spinlocks, and shared spinlocks acquisitions.
  let ``Spinlock Acquires/sec`` instance =
    { category = "Synchronization"; counter = "Spinlock Acquires/sec"; instance = instance }
  /// Spinlock Contentions/sec: Spinlock contentions/sec is the rate of spinlock contentions. It includes the basic spinlocks, queued spinlocks, in-stack queued spinlocks, and shared spinlocks contentions.
  let ``Spinlock Contentions/sec`` instance =
    { category = "Synchronization"; counter = "Spinlock Contentions/sec"; instance = instance }
  /// Spinlock Spins/sec: Spinlock spins/sec is the rate of spinlock spins. It includes the spins to acquire basic spinlocks, queued spinlocks, in-stack queued spinlocks, and shared spinlocks.
  let ``Spinlock Spins/sec`` instance =
    { category = "Synchronization"; counter = "Spinlock Spins/sec"; instance = instance }

  let allCounters =
    [ ``Exec. Resource Acquires AcqExclLite/sec``
      ``Exec. Resource Acquires AcqShrdLite/sec``
      ``Exec. Resource Acquires AcqShrdStarveExcl/sec``
      ``Exec. Resource Acquires AcqShrdWaitForExcl/sec``
      ``Exec. Resource Attempts AcqExclLite/sec``
      ``Exec. Resource Attempts AcqShrdLite/sec``
      ``Exec. Resource Attempts AcqShrdStarveExcl/sec``
      ``Exec. Resource Attempts AcqShrdWaitForExcl/sec``
      ``Exec. Resource Boost Excl. Owner/sec``
      ``Exec. Resource Boost Shared Owners/sec``
      ``Exec. Resource Contention AcqExclLite/sec``
      ``Exec. Resource Contention AcqShrdLite/sec``
      ``Exec. Resource Contention AcqShrdStarveExcl/sec``
      ``Exec. Resource Contention AcqShrdWaitForExcl/sec``
      ``Exec. Resource Recursive Excl. Acquires AcqExclLite/sec``
      ``Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec``
      ``Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec``
      ``Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec``
      ``Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec``
      ``Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec``
      ``Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec``
      ``Exec. Resource Set Owner Pointer Exclusive/sec``
      ``Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec``
      ``Exec. Resource Set Owner Pointer Shared (New Owner)/sec``
      ``Exec. Resource Total Acquires/sec``
      ``Exec. Resource Total Contentions/sec``
      ``Exec. Resource Total Conv. Exclusive To Shared/sec``
      ``Exec. Resource Total Delete/sec``
      ``Exec. Resource Total Exclusive Releases/sec``
      ``Exec. Resource Total Initialize/sec``
      ``Exec. Resource Total Re-Initialize/sec``
      ``Exec. Resource Total Shared Releases/sec``
      ``Exec. Resource no-Waits AcqExclLite/sec``
      ``Exec. Resource no-Waits AcqShrdLite/sec``
      ``Exec. Resource no-Waits AcqShrdStarveExcl/sec``
      ``Exec. Resource no-Waits AcqShrdWaitForExcl/sec``
      ``IPI Send Broadcast Requests/sec``
      ``IPI Send Routine Requests/sec``
      ``IPI Send Software Interrupts/sec``
      ``Spinlock Acquires/sec``
      ``Spinlock Contentions/sec``
      ``Spinlock Spins/sec``
    ]

/// SynchronizationNuma: The Synchronization performance object consists of counters for kernel synchronization. The synchronization object represents each processor as an instance of the object. The counters are aggregated based on the system NUMA topology.
///
/// This performance counter does not have non-instance based counters
module ``SynchronizationNuma`` =

  [<Literal>]
  let Category = "SynchronizationNuma"

  let PCC = getPCC Category
  /// Exec. Resource Acquires AcqExclLite/sec: Frequency of first exclusive acquires from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Acquires AcqExclLite/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Acquires AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Acquires AcqShrdLite/sec: Frequency of first shared acquires from ExAcquireResourceSharedLite.
  let ``Exec. Resource Acquires AcqShrdLite/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Acquires AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Acquires AcqShrdStarveExcl/sec: Frequency of first shared acquires from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Acquires AcqShrdStarveExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Acquires AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Acquires AcqShrdWaitForExcl/sec: Frequency of first shared acquires from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Acquires AcqShrdWaitForExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Acquires AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Attempts AcqExclLite/sec: Frequency of acquire exclusive attempts on Executive Resources from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Attempts AcqExclLite/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Attempts AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Attempts AcqShrdLite/sec: Frequency of acquire shared attempts on Executive Resources from ExAcquireResourceSharedLite.
  let ``Exec. Resource Attempts AcqShrdLite/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Attempts AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Attempts AcqShrdStarveExcl/sec: Frequency of acquire shared attempts on Executive Resources from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Attempts AcqShrdStarveExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Attempts AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Attempts AcqShrdWaitForExcl/sec: Frequency of acquire shared attempts on Executive Resources from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Attempts AcqShrdWaitForExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Attempts AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Boost Excl. Owner/sec: Frequency of boosting exclusive ownwer when waiting for this Executive Resource.
  let ``Exec. Resource Boost Excl. Owner/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Boost Excl. Owner/sec"; instance = instance }
  /// Exec. Resource Boost Shared Owners/sec: Frequency of boosting shared ownwer(s) when waiting for this Executive Resource.
  let ``Exec. Resource Boost Shared Owners/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Boost Shared Owners/sec"; instance = instance }
  /// Exec. Resource Contention AcqExclLite/sec: Frequency of waits during exclusive acquire attempts from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Contention AcqExclLite/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Contention AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Contention AcqShrdLite/sec: Frequency of waits during acquire attempts from ExAcquireResourceSharedLite.
  let ``Exec. Resource Contention AcqShrdLite/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Contention AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Contention AcqShrdStarveExcl/sec: Frequency of waits during shared acquire attempts from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Contention AcqShrdStarveExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Contention AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Contention AcqShrdWaitForExcl/sec: Frequency of waits during shared acquire attempts from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Contention AcqShrdWaitForExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Contention AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqExclLite/sec: Frequency of recursive exclusive acquires from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Recursive Excl. Acquires AcqExclLite/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Recursive Excl. Acquires AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec: Frequency of recursive exclusive acquires from ExAcquireResourceSharedLite.
  let ``Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec: Frequency of recursive exclusive acquires from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec: Frequency of recursive exclusive acquires from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec: Frequency of recursive shared acquires from ExAcquireResourceSharedLite.
  let ``Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec: Frequency of recursive shared acquires from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec: Frequency of recursive shared acquires from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Set Owner Pointer Exclusive/sec: Frequency of ExSetResourceOwnerPointer to an exclusive owner.
  let ``Exec. Resource Set Owner Pointer Exclusive/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Set Owner Pointer Exclusive/sec"; instance = instance }
  /// Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec: Frequency of ExSetResourceOwnerPointer to an existing shared owner.
  let ``Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec"; instance = instance }
  /// Exec. Resource Set Owner Pointer Shared (New Owner)/sec: Frequency of ExSetResourceOwnerPointer to a new shared owner.
  let ``Exec. Resource Set Owner Pointer Shared (New Owner)/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Set Owner Pointer Shared (New Owner)/sec"; instance = instance }
  /// Exec. Resource Total Acquires/sec: Frequency of acquire operations on Executive Resources.
  let ``Exec. Resource Total Acquires/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Total Acquires/sec"; instance = instance }
  /// Exec. Resource Total Contentions/sec: Contention rate on Executive Resources.
  let ``Exec. Resource Total Contentions/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Total Contentions/sec"; instance = instance }
  /// Exec. Resource Total Conv. Exclusive To Shared/sec: Frequency of convert to shared operations on Executive Resources.
  let ``Exec. Resource Total Conv. Exclusive To Shared/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Total Conv. Exclusive To Shared/sec"; instance = instance }
  /// Exec. Resource Total Delete/sec: Frequency of delete operations on Executive Resources.
  let ``Exec. Resource Total Delete/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Total Delete/sec"; instance = instance }
  /// Exec. Resource Total Exclusive Releases/sec: Frequency of Exclusive releases on Executive Resources.
  let ``Exec. Resource Total Exclusive Releases/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Total Exclusive Releases/sec"; instance = instance }
  /// Exec. Resource Total Initialize/sec: Frequency of initialization operations on Executive Resources.
  let ``Exec. Resource Total Initialize/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Total Initialize/sec"; instance = instance }
  /// Exec. Resource Total Re-Initialize/sec: Frequency of re-initialization operations on Executive Resources.
  let ``Exec. Resource Total Re-Initialize/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Total Re-Initialize/sec"; instance = instance }
  /// Exec. Resource Total Shared Releases/sec: Frequency of Shared releases on Executive Resources.
  let ``Exec. Resource Total Shared Releases/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Total Shared Releases/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqExclLite/sec: Frequency of no-waits during exclusive acquire attempts from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource no-Waits AcqExclLite/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource no-Waits AcqExclLite/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqShrdLite/sec: Frequency of no-waits during acquire attempts from ExAcquireResourceSharedLite.
  let ``Exec. Resource no-Waits AcqShrdLite/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource no-Waits AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqShrdStarveExcl/sec: Frequency of no-waits during shared acquire attempts from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource no-Waits AcqShrdStarveExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource no-Waits AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqShrdWaitForExcl/sec: Frequency of no-waits during exclusive acquire attempts from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource no-Waits AcqShrdWaitForExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource no-Waits AcqShrdWaitForExcl/sec"; instance = instance }
  /// IPI Send Broadcast Requests/sec: IPI Send Broadcast Requests/sec is the rate of IPI broadcast requests.
  let ``IPI Send Broadcast Requests/sec`` instance =
    { category = "SynchronizationNuma"; counter = "IPI Send Broadcast Requests/sec"; instance = instance }
  /// IPI Send Routine Requests/sec: IPI Send Routine Requests/sec is the rate of IPI routine requests.
  let ``IPI Send Routine Requests/sec`` instance =
    { category = "SynchronizationNuma"; counter = "IPI Send Routine Requests/sec"; instance = instance }
  /// IPI Send Software Interrupts/sec: IPI Send Software Interrrupts/sec is the rate of software interrupts.
  let ``IPI Send Software Interrupts/sec`` instance =
    { category = "SynchronizationNuma"; counter = "IPI Send Software Interrupts/sec"; instance = instance }
  /// Spinlock Acquires/sec: Spinlock acquires/sec is the rate of spinlock acquisitions. It includes the basic spinlocks, queued spinlocks, in-stack queued spinlocks, and shared spinlocks acquisitions.
  let ``Spinlock Acquires/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Spinlock Acquires/sec"; instance = instance }
  /// Spinlock Contentions/sec: Spinlock contentions/sec is the rate of spinlock contentions. It includes the basic spinlocks, queued spinlocks, in-stack queued spinlocks, and shared spinlocks contentions.
  let ``Spinlock Contentions/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Spinlock Contentions/sec"; instance = instance }
  /// Spinlock Spins/sec: Spinlock spins/sec is the rate of spinlock spins. It includes the spins to acquire basic spinlocks, queued spinlocks, in-stack queued spinlocks, and shared spinlocks.
  let ``Spinlock Spins/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Spinlock Spins/sec"; instance = instance }

  let allCounters =
    [ ``Exec. Resource Acquires AcqExclLite/sec``
      ``Exec. Resource Acquires AcqShrdLite/sec``
      ``Exec. Resource Acquires AcqShrdStarveExcl/sec``
      ``Exec. Resource Acquires AcqShrdWaitForExcl/sec``
      ``Exec. Resource Attempts AcqExclLite/sec``
      ``Exec. Resource Attempts AcqShrdLite/sec``
      ``Exec. Resource Attempts AcqShrdStarveExcl/sec``
      ``Exec. Resource Attempts AcqShrdWaitForExcl/sec``
      ``Exec. Resource Boost Excl. Owner/sec``
      ``Exec. Resource Boost Shared Owners/sec``
      ``Exec. Resource Contention AcqExclLite/sec``
      ``Exec. Resource Contention AcqShrdLite/sec``
      ``Exec. Resource Contention AcqShrdStarveExcl/sec``
      ``Exec. Resource Contention AcqShrdWaitForExcl/sec``
      ``Exec. Resource Recursive Excl. Acquires AcqExclLite/sec``
      ``Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec``
      ``Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec``
      ``Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec``
      ``Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec``
      ``Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec``
      ``Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec``
      ``Exec. Resource Set Owner Pointer Exclusive/sec``
      ``Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec``
      ``Exec. Resource Set Owner Pointer Shared (New Owner)/sec``
      ``Exec. Resource Total Acquires/sec``
      ``Exec. Resource Total Contentions/sec``
      ``Exec. Resource Total Conv. Exclusive To Shared/sec``
      ``Exec. Resource Total Delete/sec``
      ``Exec. Resource Total Exclusive Releases/sec``
      ``Exec. Resource Total Initialize/sec``
      ``Exec. Resource Total Re-Initialize/sec``
      ``Exec. Resource Total Shared Releases/sec``
      ``Exec. Resource no-Waits AcqExclLite/sec``
      ``Exec. Resource no-Waits AcqShrdLite/sec``
      ``Exec. Resource no-Waits AcqShrdStarveExcl/sec``
      ``Exec. Resource no-Waits AcqShrdWaitForExcl/sec``
      ``IPI Send Broadcast Requests/sec``
      ``IPI Send Routine Requests/sec``
      ``IPI Send Software Interrupts/sec``
      ``Spinlock Acquires/sec``
      ``Spinlock Contentions/sec``
      ``Spinlock Spins/sec``
    ]

/// System: The System performance object consists of counters that apply to more than one instance of a component processors on the computer.
///
/// This performance counter does not have instance based counters
module ``System`` =

  [<Literal>]
  let Category = "System"

  let PCC = getPCC Category
  /// % Registry Quota In Use: % Registry Quota In Use is the percentage of the Total Registry Quota Allowed that is currently being used by the system.  This counter displays the current percentage value only; it is not an average.
  let ``% Registry Quota In Use`` =
    { category = "System"; counter = "% Registry Quota In Use"; instance = NotApplicable }
  /// Alignment Fixups/sec: Alignment Fixups/sec is the rate, in incidents per seconds, at alignment faults were fixed by the system.
  let ``Alignment Fixups/sec`` =
    { category = "System"; counter = "Alignment Fixups/sec"; instance = NotApplicable }
  /// Context Switches/sec: Context Switches/sec is the combined rate at which all processors on the computer are switched from one thread to another.  Context switches occur when a running thread voluntarily relinquishes the processor, is preempted by a higher priority ready thread, or switches between user-mode and privileged (kernel) mode to use an Executive or subsystem service.  It is the sum of Thread\\Context Switches/sec for all threads running on all processors in the computer and is measured in numbers of switches.  There are context switch counters on the System and Thread objects. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Context Switches/sec`` =
    { category = "System"; counter = "Context Switches/sec"; instance = NotApplicable }
  /// Exception Dispatches/sec: Exception Dispatches/sec is the rate, in incidents per second, at which exceptions were dispatched by the system.
  let ``Exception Dispatches/sec`` =
    { category = "System"; counter = "Exception Dispatches/sec"; instance = NotApplicable }
  /// File Control Bytes/sec: File Control Bytes/sec is the overall rate at which bytes are transferred for all file system operations that are neither reads nor writes, including file system control requests and requests for information about device characteristics or status.  It is measured in numbers of bytes.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``File Control Bytes/sec`` =
    { category = "System"; counter = "File Control Bytes/sec"; instance = NotApplicable }
  /// File Control Operations/sec: File Control Operations/sec is the combined rate of file system operations that are neither reads nor writes, such as file system control requests and requests for information about device characteristics or status.  This is the inverse of System: File Data Operations/sec and is measured in number of operations perf second.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``File Control Operations/sec`` =
    { category = "System"; counter = "File Control Operations/sec"; instance = NotApplicable }
  /// File Data Operations/sec: File Data Operations/ sec is the combined rate of read and write operations on all logical disks on the computer.  This is the inverse of System: File Control Operations/sec.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``File Data Operations/sec`` =
    { category = "System"; counter = "File Data Operations/sec"; instance = NotApplicable }
  /// File Read Bytes/sec: File Read Bytes/sec is the overall rate at which bytes are read to satisfy  file system read requests to all devices on the computer, including reads from the file system cache.  It is measured in number of bytes per second.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``File Read Bytes/sec`` =
    { category = "System"; counter = "File Read Bytes/sec"; instance = NotApplicable }
  /// File Read Operations/sec: File Read Operations/sec is the combined rate of file system read requests to all devices on the computer, including requests to read from the file system cache.  It is measured in numbers of reads.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``File Read Operations/sec`` =
    { category = "System"; counter = "File Read Operations/sec"; instance = NotApplicable }
  /// File Write Bytes/sec: File Write Bytes/sec is the overall rate at which bytes are written to satisfy file system write requests to all devices on the computer, including writes to the file system cache.  It is measured in number of bytes per second.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``File Write Bytes/sec`` =
    { category = "System"; counter = "File Write Bytes/sec"; instance = NotApplicable }
  /// File Write Operations/sec: File Write Operations/sec is the combined rate of the file system write requests to all devices on the computer, including requests to write to data in the file system cache.  It is measured in numbers of writes. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``File Write Operations/sec`` =
    { category = "System"; counter = "File Write Operations/sec"; instance = NotApplicable }
  /// Floating Emulations/sec: Floating Emulations/sec is the rate of floating emulations performed by the system.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Floating Emulations/sec`` =
    { category = "System"; counter = "Floating Emulations/sec"; instance = NotApplicable }
  /// Processes: Processes is the number of processes in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  Each process represents the running of a program.
  let ``Processes`` =
    { category = "System"; counter = "Processes"; instance = NotApplicable }
  /// Processor Queue Length: Processor Queue Length is the number of threads in the processor queue.  Unlike the disk counters, this counter counters, this counter shows ready threads only, not threads that are running.  There is a single queue for processor time even on computers with multiple processors. Therefore, if a computer has multiple processors, you need to divide this value by the number of processors servicing the workload. A sustained processor queue of less than 10 threads per processor is normally acceptable, dependent of the workload.
  let ``Processor Queue Length`` =
    { category = "System"; counter = "Processor Queue Length"; instance = NotApplicable }
  /// System Calls/sec: System Calls/sec is the combined rate of calls to operating system service routines by all processes running on the computer. These routines perform all of the basic scheduling and synchronization of activities on the computer, and provide access to non-graphic devices, memory management, and name space management. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``System Calls/sec`` =
    { category = "System"; counter = "System Calls/sec"; instance = NotApplicable }
  /// System Up Time: System Up Time is the elapsed time (in seconds) that the computer has been running since it was last started.  This counter displays the difference between the start time and the current time.
  let ``System Up Time`` =
    { category = "System"; counter = "System Up Time"; instance = NotApplicable }
  /// Threads: Threads is the number of threads in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  A thread is the basic executable entity that can execute instructions in a processor.
  let ``Threads`` =
    { category = "System"; counter = "Threads"; instance = NotApplicable }

  let allCounters =
    [ ``% Registry Quota In Use``
      ``Alignment Fixups/sec``
      ``Context Switches/sec``
      ``Exception Dispatches/sec``
      ``File Control Bytes/sec``
      ``File Control Operations/sec``
      ``File Data Operations/sec``
      ``File Read Bytes/sec``
      ``File Read Operations/sec``
      ``File Write Bytes/sec``
      ``File Write Operations/sec``
      ``Floating Emulations/sec``
      ``Processes``
      ``Processor Queue Length``
      ``System Calls/sec``
      ``System Up Time``
      ``Threads``
    ]

/// TCPIP Performance Diagnostics: This counter set measures various TCPIP activity for performance diagnostics.
///
/// This performance counter does not have instance based counters
module ``TCPIP Performance Diagnostics`` =

  [<Literal>]
  let Category = "TCPIP Performance Diagnostics"

  let PCC = getPCC Category
  /// Denied connect or send requests in low-power mode: Total number of TCP connect or TCP/UDP/RAW send requests denied by the TCPIP stack because the outbound network interface was in low-power mode
  let ``Denied connect or send requests in low-power mode`` =
    { category = "TCPIP Performance Diagnostics"; counter = "Denied connect or send requests in low-power mode"; instance = NotApplicable }
  /// IPv4 NBLs indicated with low-resource flag: Total number of inbound NetBufferLists indicated from IPv4 Framing Layer to IPv4 Network Layer with low-resource flag
  let ``IPv4 NBLs indicated with low-resource flag`` =
    { category = "TCPIP Performance Diagnostics"; counter = "IPv4 NBLs indicated with low-resource flag"; instance = NotApplicable }
  /// IPv4 NBLs indicated without prevalidation: Total number of inbound NetBufferLists indicated from IPv4 Framing Layer to IPv4 Network Layer without prevalidation
  let ``IPv4 NBLs indicated without prevalidation`` =
    { category = "TCPIP Performance Diagnostics"; counter = "IPv4 NBLs indicated without prevalidation"; instance = NotApplicable }
  /// IPv4 NBLs treated as non-prevalidated: Total number of inbound NetBufferLists indicated to IPv4 Network Layer as prevalidated but treated as non-prevalidated consequently
  let ``IPv4 NBLs treated as non-prevalidated`` =
    { category = "TCPIP Performance Diagnostics"; counter = "IPv4 NBLs treated as non-prevalidated"; instance = NotApplicable }
  /// IPv4 NBLs/sec indicated with low-resource flag: Rate of inbound NetBufferLists indicated from IPv4 Framing Layer to IPv4 Network Layer with low-resource flag
  let ``IPv4 NBLs/sec indicated with low-resource flag`` =
    { category = "TCPIP Performance Diagnostics"; counter = "IPv4 NBLs/sec indicated with low-resource flag"; instance = NotApplicable }
  /// IPv4 NBLs/sec indicated without prevalidation: Rate of inbound NetBufferLists indicated from IPv4 Framing Layer to IPv4 Network Layer without prevalidation
  let ``IPv4 NBLs/sec indicated without prevalidation`` =
    { category = "TCPIP Performance Diagnostics"; counter = "IPv4 NBLs/sec indicated without prevalidation"; instance = NotApplicable }
  /// IPv4 NBLs/sec treated as non-prevalidated: Rate of inbound NetBufferLists indicated to IPv4 Network Layer as prevalidated but treated as non-prevalidated consequently
  let ``IPv4 NBLs/sec treated as non-prevalidated`` =
    { category = "TCPIP Performance Diagnostics"; counter = "IPv4 NBLs/sec treated as non-prevalidated"; instance = NotApplicable }
  /// IPv4 outbound NBLs not processed via fast path: Total number of outbound NetBufferLists that could not be processed via IPv4 Framing Layer fast path
  let ``IPv4 outbound NBLs not processed via fast path`` =
    { category = "TCPIP Performance Diagnostics"; counter = "IPv4 outbound NBLs not processed via fast path"; instance = NotApplicable }
  /// IPv4 outbound NBLs/sec not processed via fast path: Rate of outbound NetBufferLists that could not be processed via IPv4 Framing Layer fast path
  let ``IPv4 outbound NBLs/sec not processed via fast path`` =
    { category = "TCPIP Performance Diagnostics"; counter = "IPv4 outbound NBLs/sec not processed via fast path"; instance = NotApplicable }
  /// IPv6 NBLs indicated with low-resource flag: Total number of inbound NetBufferLists indicated from IPv6 Framing Layer to IPv6 Network Layer with low-resource flag
  let ``IPv6 NBLs indicated with low-resource flag`` =
    { category = "TCPIP Performance Diagnostics"; counter = "IPv6 NBLs indicated with low-resource flag"; instance = NotApplicable }
  /// IPv6 NBLs indicated without prevalidation: Total number of inbound NetBufferLists indicated from IPv6 Framing Layer to IPv6 Network Layer without prevalidation
  let ``IPv6 NBLs indicated without prevalidation`` =
    { category = "TCPIP Performance Diagnostics"; counter = "IPv6 NBLs indicated without prevalidation"; instance = NotApplicable }
  /// IPv6 NBLs treated as non-prevalidated: Total number of inbound NetBufferLists indicated to IPv6 Network Layer as prevalidated but treated as non-prevalidated consequently
  let ``IPv6 NBLs treated as non-prevalidated`` =
    { category = "TCPIP Performance Diagnostics"; counter = "IPv6 NBLs treated as non-prevalidated"; instance = NotApplicable }
  /// IPv6 NBLs/sec indicated with low-resource flag: Rate of inbound NetBufferLists indicated from IPv6 Framing Layer to IPv6 Network Layer with low-resource flag
  let ``IPv6 NBLs/sec indicated with low-resource flag`` =
    { category = "TCPIP Performance Diagnostics"; counter = "IPv6 NBLs/sec indicated with low-resource flag"; instance = NotApplicable }
  /// IPv6 NBLs/sec indicated without prevalidation: Rate of inbound NetBufferLists indicated from IPv6 Framing Layer to IPv6 Network Layer without prevalidation
  let ``IPv6 NBLs/sec indicated without prevalidation`` =
    { category = "TCPIP Performance Diagnostics"; counter = "IPv6 NBLs/sec indicated without prevalidation"; instance = NotApplicable }
  /// IPv6 NBLs/sec treated as non-prevalidated: Rate of inbound NetBufferLists indicated to IPv6 Network Layer as prevalidated but treated as non-prevalidated consequently
  let ``IPv6 NBLs/sec treated as non-prevalidated`` =
    { category = "TCPIP Performance Diagnostics"; counter = "IPv6 NBLs/sec treated as non-prevalidated"; instance = NotApplicable }
  /// IPv6 outbound NBLs not processed via fast path: Total number of outbound NetBufferLists that could not be processed via IPv6 Framing Layer fast path
  let ``IPv6 outbound NBLs not processed via fast path`` =
    { category = "TCPIP Performance Diagnostics"; counter = "IPv6 outbound NBLs not processed via fast path"; instance = NotApplicable }
  /// IPv6 outbound NBLs/sec not processed via fast path: Rate of outbound NetBufferLists that could not be processed via IPv6 Framing Layer fast path
  let ``IPv6 outbound NBLs/sec not processed via fast path`` =
    { category = "TCPIP Performance Diagnostics"; counter = "IPv6 outbound NBLs/sec not processed via fast path"; instance = NotApplicable }
  /// TCP connect requests fallen off loopback fast path: Total number of TCP connect requests which were established over normal loopback path despite loopback fast path was requested
  let ``TCP connect requests fallen off loopback fast path`` =
    { category = "TCPIP Performance Diagnostics"; counter = "TCP connect requests fallen off loopback fast path"; instance = NotApplicable }
  /// TCP connect requests/sec fallen off loopback fast path: Rate of TCP connect requests which were established over normal loopback path despite loopback fast path was requested
  let ``TCP connect requests/sec fallen off loopback fast path`` =
    { category = "TCPIP Performance Diagnostics"; counter = "TCP connect requests/sec fallen off loopback fast path"; instance = NotApplicable }
  /// TCP inbound segments not processed via fast path: Total number of inbound TCP segments that could not be processed via fast path
  let ``TCP inbound segments not processed via fast path`` =
    { category = "TCPIP Performance Diagnostics"; counter = "TCP inbound segments not processed via fast path"; instance = NotApplicable }
  /// TCP inbound segments/sec not processed via fast path: Rate of inbound TCP segments that could not be processed via fast path
  let ``TCP inbound segments/sec not processed via fast path`` =
    { category = "TCPIP Performance Diagnostics"; counter = "TCP inbound segments/sec not processed via fast path"; instance = NotApplicable }

  let allCounters =
    [ ``Denied connect or send requests in low-power mode``
      ``IPv4 NBLs indicated with low-resource flag``
      ``IPv4 NBLs indicated without prevalidation``
      ``IPv4 NBLs treated as non-prevalidated``
      ``IPv4 NBLs/sec indicated with low-resource flag``
      ``IPv4 NBLs/sec indicated without prevalidation``
      ``IPv4 NBLs/sec treated as non-prevalidated``
      ``IPv4 outbound NBLs not processed via fast path``
      ``IPv4 outbound NBLs/sec not processed via fast path``
      ``IPv6 NBLs indicated with low-resource flag``
      ``IPv6 NBLs indicated without prevalidation``
      ``IPv6 NBLs treated as non-prevalidated``
      ``IPv6 NBLs/sec indicated with low-resource flag``
      ``IPv6 NBLs/sec indicated without prevalidation``
      ``IPv6 NBLs/sec treated as non-prevalidated``
      ``IPv6 outbound NBLs not processed via fast path``
      ``IPv6 outbound NBLs/sec not processed via fast path``
      ``TCP connect requests fallen off loopback fast path``
      ``TCP connect requests/sec fallen off loopback fast path``
      ``TCP inbound segments not processed via fast path``
      ``TCP inbound segments/sec not processed via fast path``
    ]

/// TCPv4: The TCP performance object consists of counters that measure the rates at which TCP Segments are sent and received by using the TCP protocol.  It includes counters that monitor the number of TCP connections in each TCP connection state.
///
/// This performance counter does not have instance based counters
module ``TCPv4`` =

  [<Literal>]
  let Category = "TCPv4"

  let PCC = getPCC Category
  /// Connection Failures: Connection Failures is the number of times TCP connections have made a direct transition to the CLOSED state from the SYN-SENT state or the SYN-RCVD state, plus the number of times TCP connections have made a direct transition to the LISTEN state from the SYN-RCVD state.
  let ``Connection Failures`` =
    { category = "TCPv4"; counter = "Connection Failures"; instance = NotApplicable }
  /// Connections Active: Connections Active is the number of times TCP connections have made a direct transition to the SYN-SENT state from the CLOSED state. In other words, it shows a number of connections which are initiated by the local computer. The value is a cumulative total.
  let ``Connections Active`` =
    { category = "TCPv4"; counter = "Connections Active"; instance = NotApplicable }
  /// Connections Established: Connections Established is the number of TCP connections for which the current state is either ESTABLISHED or CLOSE-WAIT.
  let ``Connections Established`` =
    { category = "TCPv4"; counter = "Connections Established"; instance = NotApplicable }
  /// Connections Passive: Connections Passive is the number of times TCP connections have made a direct transition to the SYN-RCVD state from the LISTEN state. In other words, it shows a number of connections to the local computer, which are initiated by remote computers. The value is a cumulative total.
  let ``Connections Passive`` =
    { category = "TCPv4"; counter = "Connections Passive"; instance = NotApplicable }
  /// Connections Reset: Connections Reset is the number of times TCP connections have made a direct transition to the CLOSED state from either the ESTABLISHED state or the CLOSE-WAIT state.
  let ``Connections Reset`` =
    { category = "TCPv4"; counter = "Connections Reset"; instance = NotApplicable }
  /// Segments Received/sec: Segments Received/sec is the rate at which segments are received, including those received in error.  This count includes segments received on currently established connections.
  let ``Segments Received/sec`` =
    { category = "TCPv4"; counter = "Segments Received/sec"; instance = NotApplicable }
  /// Segments Retransmitted/sec: Segments Retransmitted/sec is the rate at which segments are retransmitted, that is, segments transmitted containing one or more previously transmitted bytes.
  let ``Segments Retransmitted/sec`` =
    { category = "TCPv4"; counter = "Segments Retransmitted/sec"; instance = NotApplicable }
  /// Segments Sent/sec: Segments Sent/sec is the rate at which segments are sent, including those on current connections, but excluding those containing only retransmitted bytes.
  let ``Segments Sent/sec`` =
    { category = "TCPv4"; counter = "Segments Sent/sec"; instance = NotApplicable }
  /// Segments/sec: Segments/sec is the rate at which TCP segments are sent or received using the TCP protocol.
  let ``Segments/sec`` =
    { category = "TCPv4"; counter = "Segments/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Connection Failures``
      ``Connections Active``
      ``Connections Established``
      ``Connections Passive``
      ``Connections Reset``
      ``Segments Received/sec``
      ``Segments Retransmitted/sec``
      ``Segments Sent/sec``
      ``Segments/sec``
    ]

/// TCPv6: The TCP performance object consists of counters that measure the rates at which TCP Segments are sent and received by using the TCP protocol.  It includes counters that monitor the number of TCP connections in each TCP connection state.
///
/// This performance counter does not have instance based counters
module ``TCPv6`` =

  [<Literal>]
  let Category = "TCPv6"

  let PCC = getPCC Category
  /// Connection Failures: Connection Failures is the number of times TCP connections have made a direct transition to the CLOSED state from the SYN-SENT state or the SYN-RCVD state, plus the number of times TCP connections have made a direct transition to the LISTEN state from the SYN-RCVD state.
  let ``Connection Failures`` =
    { category = "TCPv6"; counter = "Connection Failures"; instance = NotApplicable }
  /// Connections Active: Connections Active is the number of times TCP connections have made a direct transition to the SYN-SENT state from the CLOSED state. In other words, it shows a number of connections which are initiated by the local computer. The value is a cumulative total.
  let ``Connections Active`` =
    { category = "TCPv6"; counter = "Connections Active"; instance = NotApplicable }
  /// Connections Established: Connections Established is the number of TCP connections for which the current state is either ESTABLISHED or CLOSE-WAIT.
  let ``Connections Established`` =
    { category = "TCPv6"; counter = "Connections Established"; instance = NotApplicable }
  /// Connections Passive: Connections Passive is the number of times TCP connections have made a direct transition to the SYN-RCVD state from the LISTEN state. In other words, it shows a number of connections to the local computer, which are initiated by remote computers. The value is a cumulative total.
  let ``Connections Passive`` =
    { category = "TCPv6"; counter = "Connections Passive"; instance = NotApplicable }
  /// Connections Reset: Connections Reset is the number of times TCP connections have made a direct transition to the CLOSED state from either the ESTABLISHED state or the CLOSE-WAIT state.
  let ``Connections Reset`` =
    { category = "TCPv6"; counter = "Connections Reset"; instance = NotApplicable }
  /// Segments Received/sec: Segments Received/sec is the rate at which segments are received, including those received in error.  This count includes segments received on currently established connections.
  let ``Segments Received/sec`` =
    { category = "TCPv6"; counter = "Segments Received/sec"; instance = NotApplicable }
  /// Segments Retransmitted/sec: Segments Retransmitted/sec is the rate at which segments are retransmitted, that is, segments transmitted containing one or more previously transmitted bytes.
  let ``Segments Retransmitted/sec`` =
    { category = "TCPv6"; counter = "Segments Retransmitted/sec"; instance = NotApplicable }
  /// Segments Sent/sec: Segments Sent/sec is the rate at which segments are sent, including those on current connections, but excluding those containing only retransmitted bytes.
  let ``Segments Sent/sec`` =
    { category = "TCPv6"; counter = "Segments Sent/sec"; instance = NotApplicable }
  /// Segments/sec: Segments/sec is the rate at which TCP segments are sent or received using the TCP protocol.
  let ``Segments/sec`` =
    { category = "TCPv6"; counter = "Segments/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Connection Failures``
      ``Connections Active``
      ``Connections Established``
      ``Connections Passive``
      ``Connections Reset``
      ``Segments Received/sec``
      ``Segments Retransmitted/sec``
      ``Segments Sent/sec``
      ``Segments/sec``
    ]

/// Telephony: The Telephony System
///
/// This performance counter does not have instance based counters
module ``Telephony`` =

  [<Literal>]
  let Category = "Telephony"

  let PCC = getPCC Category
  /// Active Lines: The number of telephone lines serviced by this computer that are currently active.
  let ``Active Lines`` =
    { category = "Telephony"; counter = "Active Lines"; instance = NotApplicable }
  /// Active Telephones: The number of telephone devices that are currently being monitored.
  let ``Active Telephones`` =
    { category = "Telephony"; counter = "Active Telephones"; instance = NotApplicable }
  /// Client Apps: The number of applications that are currently using telephony services.
  let ``Client Apps`` =
    { category = "Telephony"; counter = "Client Apps"; instance = NotApplicable }
  /// Current Incoming Calls: Current incoming calls being serviced by this computer.
  let ``Current Incoming Calls`` =
    { category = "Telephony"; counter = "Current Incoming Calls"; instance = NotApplicable }
  /// Current Outgoing Calls: Current outgoing calls being serviced by this computer.
  let ``Current Outgoing Calls`` =
    { category = "Telephony"; counter = "Current Outgoing Calls"; instance = NotApplicable }
  /// Incoming Calls/sec: The rate of incoming calls answered by this computer.
  let ``Incoming Calls/sec`` =
    { category = "Telephony"; counter = "Incoming Calls/sec"; instance = NotApplicable }
  /// Lines: The number of telephone lines serviced by this computer.
  let ``Lines`` =
    { category = "Telephony"; counter = "Lines"; instance = NotApplicable }
  /// Outgoing Calls/sec: The rate of outgoing calls made by this computer.
  let ``Outgoing Calls/sec`` =
    { category = "Telephony"; counter = "Outgoing Calls/sec"; instance = NotApplicable }
  /// Telephone Devices: The number of telephone devices serviced by this computer.
  let ``Telephone Devices`` =
    { category = "Telephony"; counter = "Telephone Devices"; instance = NotApplicable }

  let allCounters =
    [ ``Active Lines``
      ``Active Telephones``
      ``Client Apps``
      ``Current Incoming Calls``
      ``Current Outgoing Calls``
      ``Incoming Calls/sec``
      ``Lines``
      ``Outgoing Calls/sec``
      ``Telephone Devices``
    ]

/// Teredo Client: Statistics of Teredo client.
///
/// This performance counter does not have non-instance based counters
module ``Teredo Client`` =

  [<Literal>]
  let Category = "Teredo Client"

  let PCC = getPCC Category
  /// In - Teredo Bubble: Total bubble packets received by the Teredo client.
  let ``In - Teredo Bubble`` instance =
    { category = "Teredo Client"; counter = "In - Teredo Bubble"; instance = instance }
  /// In - Teredo Data: Total data packets received by the Teredo client.
  let ``In - Teredo Data`` instance =
    { category = "Teredo Client"; counter = "In - Teredo Data"; instance = instance }
  /// In - Teredo Data Kernel Mode: Total data packets received by the Teredo client in kernel mode.
  let ``In - Teredo Data Kernel Mode`` instance =
    { category = "Teredo Client"; counter = "In - Teredo Data Kernel Mode"; instance = instance }
  /// In - Teredo Data User Mode: Total data packets received by the Teredo client in user mode.
  let ``In - Teredo Data User Mode`` instance =
    { category = "Teredo Client"; counter = "In - Teredo Data User Mode"; instance = instance }
  /// In - Teredo Invalid: Total error packets received by the Teredo client.
  let ``In - Teredo Invalid`` instance =
    { category = "Teredo Client"; counter = "In - Teredo Invalid"; instance = instance }
  /// In - Teredo Router Advertisement: Total Router Advertisement packets received by the Teredo client.
  let ``In - Teredo Router Advertisement`` instance =
    { category = "Teredo Client"; counter = "In - Teredo Router Advertisement"; instance = instance }
  /// Out - Teredo Bubble: Total bubble packets sent by the Teredo client.
  let ``Out - Teredo Bubble`` instance =
    { category = "Teredo Client"; counter = "Out - Teredo Bubble"; instance = instance }
  /// Out - Teredo Data: Total data packets sent by the Teredo client.
  let ``Out - Teredo Data`` instance =
    { category = "Teredo Client"; counter = "Out - Teredo Data"; instance = instance }
  /// Out - Teredo Data Kernel Mode: Total data packets sent by the Teredo client in kernel mode.
  let ``Out - Teredo Data Kernel Mode`` instance =
    { category = "Teredo Client"; counter = "Out - Teredo Data Kernel Mode"; instance = instance }
  /// Out - Teredo Data User Mode: Total data packets sent by the Teredo client in user mode.
  let ``Out - Teredo Data User Mode`` instance =
    { category = "Teredo Client"; counter = "Out - Teredo Data User Mode"; instance = instance }
  /// Out - Teredo Router Solicitation: Total Router Solicitation packets sent by the Teredo client.
  let ``Out - Teredo Router Solicitation`` instance =
    { category = "Teredo Client"; counter = "Out - Teredo Router Solicitation"; instance = instance }

  let allCounters =
    [ ``In - Teredo Bubble``
      ``In - Teredo Data``
      ``In - Teredo Data Kernel Mode``
      ``In - Teredo Data User Mode``
      ``In - Teredo Invalid``
      ``In - Teredo Router Advertisement``
      ``Out - Teredo Bubble``
      ``Out - Teredo Data``
      ``Out - Teredo Data Kernel Mode``
      ``Out - Teredo Data User Mode``
      ``Out - Teredo Router Solicitation``
    ]

/// Teredo Relay: Statistics of Teredo relay hosted on this machine.
///
/// This performance counter does not have non-instance based counters
module ``Teredo Relay`` =

  [<Literal>]
  let Category = "Teredo Relay"

  let PCC = getPCC Category
  /// In - Teredo Relay Error Packets: Destination Error: Total error packets( destination error) received by the Teredo relay.
  let ``In - Teredo Relay Error Packets: Destination Error`` instance =
    { category = "Teredo Relay"; counter = "In - Teredo Relay Error Packets: Destination Error"; instance = instance }
  /// In - Teredo Relay Error Packets: Header Error: Total error packets( header error) received by the Teredo relay.
  let ``In - Teredo Relay Error Packets: Header Error`` instance =
    { category = "Teredo Relay"; counter = "In - Teredo Relay Error Packets: Header Error"; instance = instance }
  /// In - Teredo Relay Error Packets: Source Error: Total error packets( source error) received by the Teredo relay.
  let ``In - Teredo Relay Error Packets: Source Error`` instance =
    { category = "Teredo Relay"; counter = "In - Teredo Relay Error Packets: Source Error"; instance = instance }
  /// In - Teredo Relay Error Packets: Total: Total error packets received by the Teredo relay.
  let ``In - Teredo Relay Error Packets: Total`` instance =
    { category = "Teredo Relay"; counter = "In - Teredo Relay Error Packets: Total"; instance = instance }
  /// In - Teredo Relay Success Packets: Bubbles: Total bubbles received by the Teredo relay.
  let ``In - Teredo Relay Success Packets: Bubbles`` instance =
    { category = "Teredo Relay"; counter = "In - Teredo Relay Success Packets: Bubbles"; instance = instance }
  /// In - Teredo Relay Success Packets: Data Packets: Total data packets received by the Teredo relay.
  let ``In - Teredo Relay Success Packets: Data Packets`` instance =
    { category = "Teredo Relay"; counter = "In - Teredo Relay Success Packets: Data Packets"; instance = instance }
  /// In - Teredo Relay Success Packets: Data Packets Kernel Mode: Total data packets received by the Teredo relay in kernel mode.
  let ``In - Teredo Relay Success Packets: Data Packets Kernel Mode`` instance =
    { category = "Teredo Relay"; counter = "In - Teredo Relay Success Packets: Data Packets Kernel Mode"; instance = instance }
  /// In - Teredo Relay Success Packets: Data Packets User Mode: Total data packets received by the Teredo relay in user mode.
  let ``In - Teredo Relay Success Packets: Data Packets User Mode`` instance =
    { category = "Teredo Relay"; counter = "In - Teredo Relay Success Packets: Data Packets User Mode"; instance = instance }
  /// In - Teredo Relay Success Packets: Total: Total valid packets received by the Teredo relay.
  let ``In - Teredo Relay Success Packets: Total`` instance =
    { category = "Teredo Relay"; counter = "In - Teredo Relay Success Packets: Total"; instance = instance }
  /// In - Teredo Relay Total Packets: Success + Error: Total packets received by the Teredo relay.
  let ``In - Teredo Relay Total Packets: Success + Error`` instance =
    { category = "Teredo Relay"; counter = "In - Teredo Relay Total Packets: Success + Error"; instance = instance }
  /// In - Teredo Relay Total Packets: Success + Error / sec: Rate of total packets received by the Teredo relay.
  let ``In - Teredo Relay Total Packets: Success + Error / sec`` instance =
    { category = "Teredo Relay"; counter = "In - Teredo Relay Total Packets: Success + Error / sec"; instance = instance }
  /// Out - Teredo Relay Error Packets: Total packets failed to be sent by the Teredo relay.
  let ``Out - Teredo Relay Error Packets`` instance =
    { category = "Teredo Relay"; counter = "Out - Teredo Relay Error Packets"; instance = instance }
  /// Out - Teredo Relay Error Packets: Destination Error: Total packets failed( destination error) to be sent by the Teredo relay.
  let ``Out - Teredo Relay Error Packets: Destination Error`` instance =
    { category = "Teredo Relay"; counter = "Out - Teredo Relay Error Packets: Destination Error"; instance = instance }
  /// Out - Teredo Relay Error Packets: Header Error: Total packets failed( header error) to be sent by the Teredo relay.
  let ``Out - Teredo Relay Error Packets: Header Error`` instance =
    { category = "Teredo Relay"; counter = "Out - Teredo Relay Error Packets: Header Error"; instance = instance }
  /// Out - Teredo Relay Error Packets: Source Error: Total packets failed( source error) to be sent by the Teredo relay.
  let ``Out - Teredo Relay Error Packets: Source Error`` instance =
    { category = "Teredo Relay"; counter = "Out - Teredo Relay Error Packets: Source Error"; instance = instance }
  /// Out - Teredo Relay Success Packets: Total packets successfully sent by the Teredo relay.
  let ``Out - Teredo Relay Success Packets`` instance =
    { category = "Teredo Relay"; counter = "Out - Teredo Relay Success Packets"; instance = instance }
  /// Out - Teredo Relay Success Packets: Bubbles: Total bubbles sent by the Teredo relay.
  let ``Out - Teredo Relay Success Packets: Bubbles`` instance =
    { category = "Teredo Relay"; counter = "Out - Teredo Relay Success Packets: Bubbles"; instance = instance }
  /// Out - Teredo Relay Success Packets: Data Packets: Total data packets sent by the Teredo relay.
  let ``Out - Teredo Relay Success Packets: Data Packets`` instance =
    { category = "Teredo Relay"; counter = "Out - Teredo Relay Success Packets: Data Packets"; instance = instance }
  /// Out - Teredo Relay Success Packets: Data Packets Kernel Mode: Total data packets sent by the Teredo relay in kernel mode.
  let ``Out - Teredo Relay Success Packets: Data Packets Kernel Mode`` instance =
    { category = "Teredo Relay"; counter = "Out - Teredo Relay Success Packets: Data Packets Kernel Mode"; instance = instance }
  /// Out - Teredo Relay Success Packets: Data Packets User Mode: Total data packets sent by the Teredo relay in user mode.
  let ``Out - Teredo Relay Success Packets: Data Packets User Mode`` instance =
    { category = "Teredo Relay"; counter = "Out - Teredo Relay Success Packets: Data Packets User Mode"; instance = instance }
  /// Out - Teredo Relay Total Packets: Success + Error: Total packets sent by the Teredo relay.
  let ``Out - Teredo Relay Total Packets: Success + Error`` instance =
    { category = "Teredo Relay"; counter = "Out - Teredo Relay Total Packets: Success + Error"; instance = instance }
  /// Out - Teredo Relay Total Packets: Success + Error / sec: Rate of total packets sent by the Teredo relay.
  let ``Out - Teredo Relay Total Packets: Success + Error / sec`` instance =
    { category = "Teredo Relay"; counter = "Out - Teredo Relay Total Packets: Success + Error / sec"; instance = instance }

  let allCounters =
    [ ``In - Teredo Relay Error Packets: Destination Error``
      ``In - Teredo Relay Error Packets: Header Error``
      ``In - Teredo Relay Error Packets: Source Error``
      ``In - Teredo Relay Error Packets: Total``
      ``In - Teredo Relay Success Packets: Bubbles``
      ``In - Teredo Relay Success Packets: Data Packets``
      ``In - Teredo Relay Success Packets: Data Packets Kernel Mode``
      ``In - Teredo Relay Success Packets: Data Packets User Mode``
      ``In - Teredo Relay Success Packets: Total``
      ``In - Teredo Relay Total Packets: Success + Error``
      ``In - Teredo Relay Total Packets: Success + Error / sec``
      ``Out - Teredo Relay Error Packets``
      ``Out - Teredo Relay Error Packets: Destination Error``
      ``Out - Teredo Relay Error Packets: Header Error``
      ``Out - Teredo Relay Error Packets: Source Error``
      ``Out - Teredo Relay Success Packets``
      ``Out - Teredo Relay Success Packets: Bubbles``
      ``Out - Teredo Relay Success Packets: Data Packets``
      ``Out - Teredo Relay Success Packets: Data Packets Kernel Mode``
      ``Out - Teredo Relay Success Packets: Data Packets User Mode``
      ``Out - Teredo Relay Total Packets: Success + Error``
      ``Out - Teredo Relay Total Packets: Success + Error / sec``
    ]

/// Teredo Server: Statistics of Teredo server hosted on this machine.
///
/// This performance counter does not have non-instance based counters
module ``Teredo Server`` =

  [<Literal>]
  let Category = "Teredo Server"

  let PCC = getPCC Category
  /// In - Teredo Server Error Packets: Authentication Error: Total error packets( authentication error) received by the Teredo server.
  let ``In - Teredo Server Error Packets: Authentication Error`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Error Packets: Authentication Error"; instance = instance }
  /// In - Teredo Server Error Packets: Destination Error: Total error packets( destination error) received by the Teredo server.
  let ``In - Teredo Server Error Packets: Destination Error`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Error Packets: Destination Error"; instance = instance }
  /// In - Teredo Server Error Packets: Header Error: Total error packets( header error) received by the Teredo server.
  let ``In - Teredo Server Error Packets: Header Error`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Error Packets: Header Error"; instance = instance }
  /// In - Teredo Server Error Packets: Source Error: Total error packets( source error) received by the Teredo server.
  let ``In - Teredo Server Error Packets: Source Error`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Error Packets: Source Error"; instance = instance }
  /// In - Teredo Server Error Packets: Total: Total error packets received by the Teredo server.
  let ``In - Teredo Server Error Packets: Total`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Error Packets: Total"; instance = instance }
  /// In - Teredo Server Success Packets: Bubbles: Total bubbles received by the Teredo server.
  let ``In - Teredo Server Success Packets: Bubbles`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Success Packets: Bubbles"; instance = instance }
  /// In - Teredo Server Success Packets: Echo: Total echo packets received by the Teredo server.
  let ``In - Teredo Server Success Packets: Echo`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Success Packets: Echo"; instance = instance }
  /// In - Teredo Server Success Packets: RS-Primary: Total Router Solicitations received by the primary server.
  let ``In - Teredo Server Success Packets: RS-Primary`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Success Packets: RS-Primary"; instance = instance }
  /// In - Teredo Server Success Packets: RS-Secondary: Total Router Solicitations received by the secondary server
  let ``In - Teredo Server Success Packets: RS-Secondary`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Success Packets: RS-Secondary"; instance = instance }
  /// In - Teredo Server Success Packets: Total: Total valid packets received by the Teredo server.
  let ``In - Teredo Server Success Packets: Total`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Success Packets: Total"; instance = instance }
  /// In - Teredo Server Total Packets: Success + Error: Total packets received by the Teredo server.
  let ``In - Teredo Server Total Packets: Success + Error`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Total Packets: Success + Error"; instance = instance }
  /// In - Teredo Server Total Packets: Success + Error / sec: Rate of total packets received by the Teredo server.
  let ``In - Teredo Server Total Packets: Success + Error / sec`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Total Packets: Success + Error / sec"; instance = instance }
  /// Out - Teredo Server: RA-Primary: Total Router Advertisements sent by the primary server.
  let ``Out - Teredo Server: RA-Primary`` instance =
    { category = "Teredo Server"; counter = "Out - Teredo Server: RA-Primary"; instance = instance }
  /// Out - Teredo Server: RA-Secondary : Total Router Advertisements sent by the secondary server.
  let ``Out - Teredo Server: RA-Secondary `` instance =
    { category = "Teredo Server"; counter = "Out - Teredo Server: RA-Secondary "; instance = instance }

  let allCounters =
    [ ``In - Teredo Server Error Packets: Authentication Error``
      ``In - Teredo Server Error Packets: Destination Error``
      ``In - Teredo Server Error Packets: Header Error``
      ``In - Teredo Server Error Packets: Source Error``
      ``In - Teredo Server Error Packets: Total``
      ``In - Teredo Server Success Packets: Bubbles``
      ``In - Teredo Server Success Packets: Echo``
      ``In - Teredo Server Success Packets: RS-Primary``
      ``In - Teredo Server Success Packets: RS-Secondary``
      ``In - Teredo Server Success Packets: Total``
      ``In - Teredo Server Total Packets: Success + Error``
      ``In - Teredo Server Total Packets: Success + Error / sec``
      ``Out - Teredo Server: RA-Primary``
      ``Out - Teredo Server: RA-Secondary ``
    ]

/// Terminal Services: Terminal Services Summary Information
///
/// This performance counter does not have instance based counters
module ``Terminal Services`` =

  [<Literal>]
  let Category = "Terminal Services"

  let PCC = getPCC Category
  /// Active Sessions: Number of active Terminal Services sessions
  let ``Active Sessions`` =
    { category = "Terminal Services"; counter = "Active Sessions"; instance = NotApplicable }
  /// Inactive Sessions: Number of inactive Terminal Services sessions
  let ``Inactive Sessions`` =
    { category = "Terminal Services"; counter = "Inactive Sessions"; instance = NotApplicable }
  /// Total Sessions: Total number Terminal services sessions
  let ``Total Sessions`` =
    { category = "Terminal Services"; counter = "Total Sessions"; instance = NotApplicable }

  let allCounters =
    [ ``Active Sessions``
      ``Inactive Sessions``
      ``Total Sessions``
    ]

/// Terminal Services Session: Terminal Services per-session resource monitoring.
///
/// This performance counter does not have non-instance based counters
module ``Terminal Services Session`` =

  [<Literal>]
  let Category = "Terminal Services Session"

  let PCC = getPCC Category
  /// % Privileged Time: % Privileged Time is the percentage of elapsed time that the process threads spent executing code in privileged mode. When a Windows system service is called, the service will often run in privileged mode to gain access to system-private data. Such data is protected from access by threads executing in user mode. Calls to the system can be explicit or implicit, such as page faults or interrupts. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.
  let ``% Privileged Time`` instance =
    { category = "Terminal Services Session"; counter = "% Privileged Time"; instance = instance }
  /// % Processor Time: % Processor Time is the percentage of elapsed time that all of process threads used the processor to execution instructions. An instruction is the basic unit of execution in a computer, a thread is the object that executes instructions, and a process is the object created when a program is run. Code executed to handle some hardware interrupts and trap conditions are included in this count.
  let ``% Processor Time`` instance =
    { category = "Terminal Services Session"; counter = "% Processor Time"; instance = instance }
  /// % User Time: % User Time is the percentage of elapsed time that the process threads spent executing code in user mode. Applications, environment subsystems, and integral subsystems execute in user mode. Code executing in user mode cannot damage the integrity of the Windows executive, kernel, and device drivers. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.
  let ``% User Time`` instance =
    { category = "Terminal Services Session"; counter = "% User Time"; instance = instance }
  /// Handle Count: The total number of handles currently open by this process. This number is equal to the sum of the handles currently open by each thread in this process.
  let ``Handle Count`` instance =
    { category = "Terminal Services Session"; counter = "Handle Count"; instance = instance }
  /// Page Faults/sec: Page Faults/sec is the rate at which page faults by the threads executing in this process are occurring.  A page fault occurs when a thread refers to a virtual memory page that is not in its working set in main memory. This may not cause the page to be fetched from disk if it is on the standby list and hence already in main memory, or if it is in use by another process with whom the page is shared.
  let ``Page Faults/sec`` instance =
    { category = "Terminal Services Session"; counter = "Page Faults/sec"; instance = instance }
  /// Page File Bytes: Page File Bytes is the current amount of virtual memory, in bytes, that this process has reserved for use in the paging file(s). Paging files are used to store pages of memory used by the process that are not contained in other files. Paging files are shared by all processes, and the lack of space in paging files can prevent other processes from allocating memory. If there is no paging file, this counter reflects the current amount of virtual memory that the process has reserved for use in physical memory.
  let ``Page File Bytes`` instance =
    { category = "Terminal Services Session"; counter = "Page File Bytes"; instance = instance }
  /// Page File Bytes Peak: Page File Bytes Peak is the maximum amount of virtual memory, in bytes, that this process has reserved for use in the paging file(s). Paging files are used to store pages of memory used by the process that are not contained in other files.  Paging files are shared by all processes, and the lack of space in paging files can prevent other processes from allocating memory. If there is no paging file, this counter reflects the maximum amount of virtual memory that the process has reserved for use in physical memory.
  let ``Page File Bytes Peak`` instance =
    { category = "Terminal Services Session"; counter = "Page File Bytes Peak"; instance = instance }
  /// Pool Nonpaged Bytes: Pool Nonpaged Bytes is the size, in bytes, of the nonpaged pool, an area of the system virtual memory that is used for objects that cannot be written to disk, but must remain in physical memory as long as they are allocated.  Memory\\Pool Nonpaged Bytes is calculated differently than Process\\Pool Nonpaged Bytes, so it might not equal Process(_Total)\\Pool Nonpaged Bytes.  This counter displays the last observed value only; it is not an average.
  let ``Pool Nonpaged Bytes`` instance =
    { category = "Terminal Services Session"; counter = "Pool Nonpaged Bytes"; instance = instance }
  /// Pool Paged Bytes: Pool Paged Bytes is the size, in bytes, of the paged pool, an area of the system virtual memory that is used for objects that can be written to disk when they are not being used.  Memory\\Pool Paged Bytes is calculated differently than Process\\Pool Paged Bytes, so it might not equal Process(_Total)\\Pool Paged Bytes. This counter displays the last observed value only; it is not an average.
  let ``Pool Paged Bytes`` instance =
    { category = "Terminal Services Session"; counter = "Pool Paged Bytes"; instance = instance }
  /// Private Bytes: Private Bytes is the current size, in bytes, of memory that this process has allocated that cannot be shared with other processes.
  let ``Private Bytes`` instance =
    { category = "Terminal Services Session"; counter = "Private Bytes"; instance = instance }
  /// Thread Count: The number of threads currently active in this process. An instruction is the basic unit of execution in a processor, and a thread is the object that executes instructions. Every running process has at least one thread.
  let ``Thread Count`` instance =
    { category = "Terminal Services Session"; counter = "Thread Count"; instance = instance }
  /// Virtual Bytes: Virtual Bytes is the current size, in bytes, of the virtual address space the process is using. Use of virtual address space does not necessarily imply corresponding use of either disk or main memory pages. Virtual space is finite, and the process can limit its ability to load libraries.
  let ``Virtual Bytes`` instance =
    { category = "Terminal Services Session"; counter = "Virtual Bytes"; instance = instance }
  /// Virtual Bytes Peak: Virtual Bytes Peak is the maximum size, in bytes, of virtual address space the process has used at any one time. Use of virtual address space does not necessarily imply corresponding use of either disk or main memory pages. However, virtual space is finite, and the process might limit its ability to load libraries.
  let ``Virtual Bytes Peak`` instance =
    { category = "Terminal Services Session"; counter = "Virtual Bytes Peak"; instance = instance }
  /// Working Set: Working Set is the current size, in bytes, of the Working Set of this process. The Working Set is the set of memory pages touched recently by the threads in the process. If free memory in the computer is above a threshold, pages are left in the Working Set of a process even if they are not in use.  When free memory falls below a threshold, pages are trimmed from Working Sets. If they are needed they will then be soft-faulted back into the Working Set before leaving main memory.
  let ``Working Set`` instance =
    { category = "Terminal Services Session"; counter = "Working Set"; instance = instance }
  /// Working Set Peak: Working Set Peak is the maximum size, in bytes, of the Working Set of this process at any point in time. The Working Set is the set of memory pages touched recently by the threads in the process. If free memory in the computer is above a threshold, pages are left in the Working Set of a process even if they are not in use. When free memory falls below a threshold, pages are trimmed from Working Sets. If they are needed they will then be soft-faulted back into the Working Set before they leave main memory.
  let ``Working Set Peak`` instance =
    { category = "Terminal Services Session"; counter = "Working Set Peak"; instance = instance }

  let allCounters =
    [ ``% Privileged Time``
      ``% Processor Time``
      ``% User Time``
      ``Handle Count``
      ``Page Faults/sec``
      ``Page File Bytes``
      ``Page File Bytes Peak``
      ``Pool Nonpaged Bytes``
      ``Pool Paged Bytes``
      ``Private Bytes``
      ``Thread Count``
      ``Virtual Bytes``
      ``Virtual Bytes Peak``
      ``Working Set``
      ``Working Set Peak``
    ]

/// Thermal Zone Information: The Thermal Zone Information performance counter set consists of counters that measure aspects of each thermal zone in the system.
///
/// This performance counter does not have instance based counters
module ``Thermal Zone Information`` =

  [<Literal>]
  let Category = "Thermal Zone Information"

  let PCC = getPCC Category
  /// % Passive Limit: -
  let ``% Passive Limit`` instance =
    { category = "Thermal Zone Information"; counter = "% Passive Limit"; instance = instance }
  /// Temperature: -
  let ``Temperature`` instance =
    { category = "Thermal Zone Information"; counter = "Temperature"; instance = instance }
  /// Throttle Reasons: -
  let ``Throttle Reasons`` instance =
    { category = "Thermal Zone Information"; counter = "Throttle Reasons"; instance = instance }

  let allCounters =
    [ ``% Passive Limit``
      ``Temperature``
      ``Throttle Reasons``
    ]

/// Thread: The Thread performance object consists of counters that measure aspects of thread behavior.  A thread is the basic object that executes instructions on a processor.  All running processes have at least one thread.
///
/// This performance counter does not have non-instance based counters
module ``Thread`` =

  [<Literal>]
  let Category = "Thread"

  let PCC = getPCC Category
  /// % Privileged Time: % Privileged Time is the percentage of elapsed time that the process threads spent executing code in privileged mode.  When a Windows system service in called, the service will often run in privileged mode to gain access to system-private data. Such data is protected from access by threads executing in user mode. Calls to the system can be explicit or implicit, such as page faults or interrupts. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.
  let ``% Privileged Time`` instance =
    { category = "Thread"; counter = "% Privileged Time"; instance = instance }
  /// % Processor Time: % Processor Time is the percentage of elapsed time that all of process threads used the processor to execution instructions. An instruction is the basic unit of execution in a computer, a thread is the object that executes instructions, and a process is the object created when a program is run. Code executed to handle some hardware interrupts and trap conditions are included in this count.
  let ``% Processor Time`` instance =
    { category = "Thread"; counter = "% Processor Time"; instance = instance }
  /// % User Time: % User Time is the percentage of elapsed time that this thread has spent executing code in user mode.  Applications, environment subsystems, and integral subsystems execute in user mode.  Code executing in user mode cannot damage the integrity of the Windows NT Executive, Kernel, and device drivers.  Unlike some early operating systems, Windows NT uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes.  These subsystem processes provide additional protection.  Therefore, some work done by Windows NT on behalf of your application might appear in other subsystem processes in addition to the privileged time in your process.
  let ``% User Time`` instance =
    { category = "Thread"; counter = "% User Time"; instance = instance }
  /// Context Switches/sec: Context Switches/sec is the rate of switches from one thread to another.  Thread switches can occur either inside of a single process or across processes.  A thread switch can be caused either by one thread asking another for information, or by a thread being preempted by another, higher priority thread becoming ready to run.  Unlike some early operating systems, Windows NT uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes.  These subsystem processes provide additional protection.  Therefore, some work done by Windows NT on behalf of an application  appear in other subsystem processes in addition to the privileged time in the application.  Switching to the subsystem process causes one Context Switch in the application thread.  Switching back causes another Context Switch in the subsystem thread.
  let ``Context Switches/sec`` instance =
    { category = "Thread"; counter = "Context Switches/sec"; instance = instance }
  /// Elapsed Time: The total elapsed time (in seconds) this thread has been running.
  let ``Elapsed Time`` instance =
    { category = "Thread"; counter = "Elapsed Time"; instance = instance }
  /// ID Process: ID Process is the unique identifier of this process. ID Process numbers are reused, so they only identify a process for the lifetime of that process.
  let ``ID Process`` instance =
    { category = "Thread"; counter = "ID Process"; instance = instance }
  /// ID Thread: ID Thread is the unique identifier of this thread.  ID Thread numbers are reused, so they only identify a thread for the lifetime of that thread.
  let ``ID Thread`` instance =
    { category = "Thread"; counter = "ID Thread"; instance = instance }
  /// Priority Base: The current base priority of this thread.  The system can raise the thread's dynamic priority above the base priority if the thread is handling user input, or lower it towards the base priority if the thread becomes compute bound.
  let ``Priority Base`` instance =
    { category = "Thread"; counter = "Priority Base"; instance = instance }
  /// Priority Current: The current dynamic priority of this thread.  The system can raise the thread's dynamic priority above the base priority if the thread is handling user input, or lower it towards the base priority if the thread becomes compute bound.
  let ``Priority Current`` instance =
    { category = "Thread"; counter = "Priority Current"; instance = instance }
  /// Start Address: Starting virtual address for this thread.
  let ``Start Address`` instance =
    { category = "Thread"; counter = "Start Address"; instance = instance }
  /// Thread State: Thread State is the current state of the thread.  It is 0 for Initialized, 1 for Ready, 2 for Running, 3 for Standby, 4 for Terminated, 5 for Wait, 6 for Transition, 7 for Unknown.  A Running thread is using a processor; a Standby thread is about to use one.  A Ready thread wants to use a processor, but is waiting for a processor because none are free.  A thread in Transition is waiting for a resource in order to execute, such as waiting for its execution stack to be paged in from disk.  A Waiting thread has no use for the processor because it is waiting for a peripheral operation to complete or a resource to become free.
  let ``Thread State`` instance =
    { category = "Thread"; counter = "Thread State"; instance = instance }
  /// Thread Wait Reason: Thread Wait Reason is only applicable when the thread is in the Wait state (see Thread State).  It is 0 or 7 when the thread is waiting for the Executive, 1 or 8 for a Free Page, 2 or 9 for a Page In, 3 or 10 for a Pool Allocation, 4 or 11 for an Execution Delay, 5 or 12 for a Suspended condition, 6 or 13 for a User Request, 14 for an Event Pair High, 15 for an Event Pair Low, 16 for an LPC Receive, 17 for an LPC Reply, 18 for Virtual Memory, 19 for a Page Out; 20 and higher are not assigned at the time of this writing.  Event Pairs are used to communicate with protected subsystems (see Context Switches).
  let ``Thread Wait Reason`` instance =
    { category = "Thread"; counter = "Thread Wait Reason"; instance = instance }

  let allCounters =
    [ ``% Privileged Time``
      ``% Processor Time``
      ``% User Time``
      ``Context Switches/sec``
      ``Elapsed Time``
      ``ID Process``
      ``ID Thread``
      ``Priority Base``
      ``Priority Current``
      ``Start Address``
      ``Thread State``
      ``Thread Wait Reason``
    ]

/// UDPv4: The UDP performance object consists of counters that measure the rates at which UDP datagrams are sent and received by using the UDP protocol.  It includes counters that monitor UDP protocol errors.
///
/// This performance counter does not have instance based counters
module ``UDPv4`` =

  [<Literal>]
  let Category = "UDPv4"

  let PCC = getPCC Category
  /// Datagrams No Port/sec: Datagrams No Port/sec is the rate of received UDP datagrams for which there was no application at the destination port.
  let ``Datagrams No Port/sec`` =
    { category = "UDPv4"; counter = "Datagrams No Port/sec"; instance = NotApplicable }
  /// Datagrams Received Errors: Datagrams Received Errors is the number of received UDP datagrams that could not be delivered for reasons other than the lack of an application at the destination port.
  let ``Datagrams Received Errors`` =
    { category = "UDPv4"; counter = "Datagrams Received Errors"; instance = NotApplicable }
  /// Datagrams Received/sec: Datagrams Received/sec is the rate at which UDP datagrams are delivered to UDP users.
  let ``Datagrams Received/sec`` =
    { category = "UDPv4"; counter = "Datagrams Received/sec"; instance = NotApplicable }
  /// Datagrams Sent/sec: Datagrams Sent/sec is the rate at which UDP datagrams are sent from the entity.
  let ``Datagrams Sent/sec`` =
    { category = "UDPv4"; counter = "Datagrams Sent/sec"; instance = NotApplicable }
  /// Datagrams/sec: Datagrams/sec is the rate at which UDP datagrams are sent or received by the entity.
  let ``Datagrams/sec`` =
    { category = "UDPv4"; counter = "Datagrams/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Datagrams No Port/sec``
      ``Datagrams Received Errors``
      ``Datagrams Received/sec``
      ``Datagrams Sent/sec``
      ``Datagrams/sec``
    ]

/// UDPv6: The UDP performance object consists of counters that measure the rates at which UDP datagrams are sent and received by using the UDP protocol.  It includes counters that monitor UDP protocol errors.
///
/// This performance counter does not have instance based counters
module ``UDPv6`` =

  [<Literal>]
  let Category = "UDPv6"

  let PCC = getPCC Category
  /// Datagrams No Port/sec: Datagrams No Port/sec is the rate of received UDP datagrams for which there was no application at the destination port.
  let ``Datagrams No Port/sec`` =
    { category = "UDPv6"; counter = "Datagrams No Port/sec"; instance = NotApplicable }
  /// Datagrams Received Errors: Datagrams Received Errors is the number of received UDP datagrams that could not be delivered for reasons other than the lack of an application at the destination port.
  let ``Datagrams Received Errors`` =
    { category = "UDPv6"; counter = "Datagrams Received Errors"; instance = NotApplicable }
  /// Datagrams Received/sec: Datagrams Received/sec is the rate at which UDP datagrams are delivered to UDP users.
  let ``Datagrams Received/sec`` =
    { category = "UDPv6"; counter = "Datagrams Received/sec"; instance = NotApplicable }
  /// Datagrams Sent/sec: Datagrams Sent/sec is the rate at which UDP datagrams are sent from the entity.
  let ``Datagrams Sent/sec`` =
    { category = "UDPv6"; counter = "Datagrams Sent/sec"; instance = NotApplicable }
  /// Datagrams/sec: Datagrams/sec is the rate at which UDP datagrams are sent or received by the entity.
  let ``Datagrams/sec`` =
    { category = "UDPv6"; counter = "Datagrams/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Datagrams No Port/sec``
      ``Datagrams Received Errors``
      ``Datagrams Received/sec``
      ``Datagrams Sent/sec``
      ``Datagrams/sec``
    ]

/// USB: USB I/O Counters
///
/// This performance counter does not have non-instance based counters
module ``USB`` =

  [<Literal>]
  let Category = "USB"

  let PCC = getPCC Category
  /// % Total Bandwidth Used for Interrupt: Displays the percentage of BW reserved for interrupt transfers
  let ``% Total Bandwidth Used for Interrupt`` instance =
    { category = "USB"; counter = "% Total Bandwidth Used for Interrupt"; instance = instance }
  /// % Total Bandwidth Used for Iso: Displays the percentage of BW reserved for ISO transfers
  let ``% Total Bandwidth Used for Iso`` instance =
    { category = "USB"; counter = "% Total Bandwidth Used for Iso"; instance = instance }
  /// Avg ms latency for ISO transfers: Avg number of ms between the current frame and the start frame of an ISO transfer when scheduled.  For device instances only.
  let ``Avg ms latency for ISO transfers`` instance =
    { category = "USB"; counter = "Avg ms latency for ISO transfers"; instance = instance }
  /// Avg. Bytes/Transfer: Displays the average size of all transfer URBs. For device instances only.
  let ``Avg. Bytes/Transfer`` instance =
    { category = "USB"; counter = "Avg. Bytes/Transfer"; instance = instance }
  /// Bulk Bytes/Sec: Displays the current bulk transfer rate in bytes/sec.
  let ``Bulk Bytes/Sec`` instance =
    { category = "USB"; counter = "Bulk Bytes/Sec"; instance = instance }
  /// Control Data Bytes/Sec: Displays the current control transfer rate in bytes/sec.
  let ``Control Data Bytes/Sec`` instance =
    { category = "USB"; counter = "Control Data Bytes/Sec"; instance = instance }
  /// Controller PCI Interrupts/Sec: Displays the rate of PCI interrupt generation by the USB controller. For controller instances only.
  let ``Controller PCI Interrupts/Sec`` instance =
    { category = "USB"; counter = "Controller PCI Interrupts/Sec"; instance = instance }
  /// Controller WorkSignals/Sec: Displays the current rate Work Signals generated per second by the usbport driver.  For controller instances only.
  let ``Controller WorkSignals/Sec`` instance =
    { category = "USB"; counter = "Controller WorkSignals/Sec"; instance = instance }
  /// Host Controller Async Cache Flush Count: Incremented each time the controller async cache is flushed.
  let ``Host Controller Async Cache Flush Count`` instance =
    { category = "USB"; counter = "Host Controller Async Cache Flush Count"; instance = instance }
  /// Host Controller Async Idle: Non-Zero value if the host controller async schedule is not running(idle).
  let ``Host Controller Async Idle`` instance =
    { category = "USB"; counter = "Host Controller Async Idle"; instance = instance }
  /// Host Controller Idle: Non-zero value if the host controller is not running(idle).
  let ``Host Controller Idle`` instance =
    { category = "USB"; counter = "Host Controller Idle"; instance = instance }
  /// Host Controller Periodic Cache Flush Count: Incremented each time the controller periodic cache is flushed.
  let ``Host Controller Periodic Cache Flush Count`` instance =
    { category = "USB"; counter = "Host Controller Periodic Cache Flush Count"; instance = instance }
  /// Host Controller Periodic Idle: Non-Zero if the periodic schedule is not running(idle).
  let ``Host Controller Periodic Idle`` instance =
    { category = "USB"; counter = "Host Controller Periodic Idle"; instance = instance }
  /// Interrupt Bytes/Sec: Displays the current interrupt transfer rate in bytes/sec.
  let ``Interrupt Bytes/Sec`` instance =
    { category = "USB"; counter = "Interrupt Bytes/Sec"; instance = instance }
  /// Iso Packet Errors/Sec: Number of ISO packets that are NOT late, but complete with an error. For device instances only.
  let ``Iso Packet Errors/Sec`` instance =
    { category = "USB"; counter = "Iso Packet Errors/Sec"; instance = instance }
  /// Isochronous Bytes/Sec: Displays the current isochronous transfer rate in bytes/sec.
  let ``Isochronous Bytes/Sec`` instance =
    { category = "USB"; counter = "Isochronous Bytes/Sec"; instance = instance }
  /// Transfer Errors/Sec: Number of Transfer URBs completing with an error status. For device instances only.
  let ``Transfer Errors/Sec`` instance =
    { category = "USB"; counter = "Transfer Errors/Sec"; instance = instance }

  let allCounters =
    [ ``% Total Bandwidth Used for Interrupt``
      ``% Total Bandwidth Used for Iso``
      ``Avg ms latency for ISO transfers``
      ``Avg. Bytes/Transfer``
      ``Bulk Bytes/Sec``
      ``Control Data Bytes/Sec``
      ``Controller PCI Interrupts/Sec``
      ``Controller WorkSignals/Sec``
      ``Host Controller Async Cache Flush Count``
      ``Host Controller Async Idle``
      ``Host Controller Idle``
      ``Host Controller Periodic Cache Flush Count``
      ``Host Controller Periodic Idle``
      ``Interrupt Bytes/Sec``
      ``Iso Packet Errors/Sec``
      ``Isochronous Bytes/Sec``
      ``Transfer Errors/Sec``
    ]

/// WF (System.Workflow) 4.0.0.0: Windows Workflow Foundation Performance Counters
///
/// This performance counter does not have instance based counters
module ``WF (System_Workflow) 4_0_0_0`` =

  [<Literal>]
  let Category = "WF (System.Workflow) 4.0.0.0"

  let PCC = getPCC Category
  /// Workflows Aborted: -
  let ``Workflows Aborted`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Aborted"; instance = instance }
  /// Workflows Aborted/sec: -
  let ``Workflows Aborted/sec`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Aborted/sec"; instance = instance }
  /// Workflows Completed: -
  let ``Workflows Completed`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Completed"; instance = instance }
  /// Workflows Completed/sec: -
  let ``Workflows Completed/sec`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Completed/sec"; instance = instance }
  /// Workflows Created: -
  let ``Workflows Created`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Created"; instance = instance }
  /// Workflows Created/sec: -
  let ``Workflows Created/sec`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Created/sec"; instance = instance }
  /// Workflows Executing: -
  let ``Workflows Executing`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Executing"; instance = instance }
  /// Workflows Idle/sec: -
  let ``Workflows Idle/sec`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Idle/sec"; instance = instance }
  /// Workflows In Memory: -
  let ``Workflows In Memory`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows In Memory"; instance = instance }
  /// Workflows Loaded: -
  let ``Workflows Loaded`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Loaded"; instance = instance }
  /// Workflows Loaded/sec: -
  let ``Workflows Loaded/sec`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Loaded/sec"; instance = instance }
  /// Workflows Pending: -
  let ``Workflows Pending`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Pending"; instance = instance }
  /// Workflows Persisted: -
  let ``Workflows Persisted`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Persisted"; instance = instance }
  /// Workflows Persisted/sec: -
  let ``Workflows Persisted/sec`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Persisted/sec"; instance = instance }
  /// Workflows Runnable: -
  let ``Workflows Runnable`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Runnable"; instance = instance }
  /// Workflows Suspended: -
  let ``Workflows Suspended`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Suspended"; instance = instance }
  /// Workflows Suspended/sec: -
  let ``Workflows Suspended/sec`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Suspended/sec"; instance = instance }
  /// Workflows Terminated: -
  let ``Workflows Terminated`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Terminated"; instance = instance }
  /// Workflows Terminated/sec: -
  let ``Workflows Terminated/sec`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Terminated/sec"; instance = instance }
  /// Workflows Unloaded: -
  let ``Workflows Unloaded`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Unloaded"; instance = instance }
  /// Workflows Unloaded/sec: -
  let ``Workflows Unloaded/sec`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Unloaded/sec"; instance = instance }

  let allCounters =
    [ ``Workflows Aborted``
      ``Workflows Aborted/sec``
      ``Workflows Completed``
      ``Workflows Completed/sec``
      ``Workflows Created``
      ``Workflows Created/sec``
      ``Workflows Executing``
      ``Workflows Idle/sec``
      ``Workflows In Memory``
      ``Workflows Loaded``
      ``Workflows Loaded/sec``
      ``Workflows Pending``
      ``Workflows Persisted``
      ``Workflows Persisted/sec``
      ``Workflows Runnable``
      ``Workflows Suspended``
      ``Workflows Suspended/sec``
      ``Workflows Terminated``
      ``Workflows Terminated/sec``
      ``Workflows Unloaded``
      ``Workflows Unloaded/sec``
    ]

/// WFP: WFP is the set of Windows Filtering Platform counters that do not apply to any specific Internet Protocol version.
///
/// This performance counter does not have instance based counters
module ``WFP`` =

  [<Literal>]
  let Category = "WFP"

  let PCC = getPCC Category
  /// Provider Count: Provider Count is the number of providers registered with the Windows Filtering Platform.
  let ``Provider Count`` =
    { category = "WFP"; counter = "Provider Count"; instance = NotApplicable }

  let allCounters =
    [ ``Provider Count``

    ]

/// WFPv4: WFPv4 is the set of Windows Filtering Platform counters that apply to traffic and connections over Internet Protocol version 4.
///
/// This performance counter does not have instance based counters
module ``WFPv4`` =

  [<Literal>]
  let Category = "WFPv4"

  let PCC = getPCC Category
  /// Active Inbound Connections: Active Inbound Connections is the number of current inbound connections allowed by the Windows Filtering Platform.
  let ``Active Inbound Connections`` =
    { category = "WFPv4"; counter = "Active Inbound Connections"; instance = NotApplicable }
  /// Active Outbound Connections: Active Outbound Connections is the number of current outbound connections allowed by the Windows Filtering Platform.
  let ``Active Outbound Connections`` =
    { category = "WFPv4"; counter = "Active Outbound Connections"; instance = NotApplicable }
  /// Allowed Classifies/sec: Allowed Classifies per Second is the rate of Windows Filtering Platform security rule evaluations which allow network activity.
  let ``Allowed Classifies/sec`` =
    { category = "WFPv4"; counter = "Allowed Classifies/sec"; instance = NotApplicable }
  /// Blocked Binds: Blocked Binds is the number of network resource assignment requests blocked by the Windows Filtering Platform since the computer was last started.
  let ``Blocked Binds`` =
    { category = "WFPv4"; counter = "Blocked Binds"; instance = NotApplicable }
  /// Inbound Connections: Inbound Connections is the number of inbound connections allowed by the Windows Filtering Platform since the computer was last started.
  let ``Inbound Connections`` =
    { category = "WFPv4"; counter = "Inbound Connections"; instance = NotApplicable }
  /// Inbound Connections Allowed/sec: Inbound Connections Allowed per Second is the rate at which inbound connections are being allowed by the Windows Filtering Platform.
  let ``Inbound Connections Allowed/sec`` =
    { category = "WFPv4"; counter = "Inbound Connections Allowed/sec"; instance = NotApplicable }
  /// Inbound Connections Blocked/sec: Inbound Connections Blocked per Second is the rate at which inbound connections are being blocked by the Windows Filtering Platform.
  let ``Inbound Connections Blocked/sec`` =
    { category = "WFPv4"; counter = "Inbound Connections Blocked/sec"; instance = NotApplicable }
  /// Inbound Packets Discarded/sec: Inbound Packets Discarded per Second is the rate at which inbound packets are discarded by the Windows Filtering Platform.
  let ``Inbound Packets Discarded/sec`` =
    { category = "WFPv4"; counter = "Inbound Packets Discarded/sec"; instance = NotApplicable }
  /// Outbound Connections: Outbound Connections is the number of outbound connections allowed by the Windows Filtering Platform since the computer was last started.
  let ``Outbound Connections`` =
    { category = "WFPv4"; counter = "Outbound Connections"; instance = NotApplicable }
  /// Outbound Connections Allowed/sec: Outbound Connections Allowed per Second is the rate at which outbound connections are being allowed by the Windows Filtering Platform.
  let ``Outbound Connections Allowed/sec`` =
    { category = "WFPv4"; counter = "Outbound Connections Allowed/sec"; instance = NotApplicable }
  /// Outbound Connections Blocked/sec: Outbound Connections Blocked per Second is the rate at which outbound connections are being blocked by the Windows Filtering Platform.
  let ``Outbound Connections Blocked/sec`` =
    { category = "WFPv4"; counter = "Outbound Connections Blocked/sec"; instance = NotApplicable }
  /// Outbound Packets Discarded/sec: Outbound Packets Discarded per Second is the rate at which outbound packets are discarded by the Windows Filtering Platform.
  let ``Outbound Packets Discarded/sec`` =
    { category = "WFPv4"; counter = "Outbound Packets Discarded/sec"; instance = NotApplicable }
  /// Packets Discarded/sec: Packets Discarded per Second is the rate at which the total of inbound and outbound packets are discarded by the Windows Filtering Platform.
  let ``Packets Discarded/sec`` =
    { category = "WFPv4"; counter = "Packets Discarded/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Active Inbound Connections``
      ``Active Outbound Connections``
      ``Allowed Classifies/sec``
      ``Blocked Binds``
      ``Inbound Connections``
      ``Inbound Connections Allowed/sec``
      ``Inbound Connections Blocked/sec``
      ``Inbound Packets Discarded/sec``
      ``Outbound Connections``
      ``Outbound Connections Allowed/sec``
      ``Outbound Connections Blocked/sec``
      ``Outbound Packets Discarded/sec``
      ``Packets Discarded/sec``
    ]

/// WFPv6: WFPv6 is the set of Windows Filtering Platform counters that apply to traffic and connections over Internet Protocol version 6.
///
/// This performance counter does not have instance based counters
module ``WFPv6`` =

  [<Literal>]
  let Category = "WFPv6"

  let PCC = getPCC Category
  /// Active Inbound Connections: Active Inbound Connections is the number of current inbound connections allowed by the Windows Filtering Platform.
  let ``Active Inbound Connections`` =
    { category = "WFPv6"; counter = "Active Inbound Connections"; instance = NotApplicable }
  /// Active Outbound Connections: Active Outbound Connections is the number of current outbound connections allowed by the Windows Filtering Platform.
  let ``Active Outbound Connections`` =
    { category = "WFPv6"; counter = "Active Outbound Connections"; instance = NotApplicable }
  /// Allowed Classifies/sec: Allowed Classifies per Second is the rate of Windows Filtering Platform security rule evaluations which allow network activity.
  let ``Allowed Classifies/sec`` =
    { category = "WFPv6"; counter = "Allowed Classifies/sec"; instance = NotApplicable }
  /// Blocked Binds: Blocked Binds is the number of network resource assignment requests blocked by the Windows Filtering Platform since the computer was last started.
  let ``Blocked Binds`` =
    { category = "WFPv6"; counter = "Blocked Binds"; instance = NotApplicable }
  /// Inbound Connections: Inbound Connections is the number of inbound connections allowed by the Windows Filtering Platform since the computer was last started.
  let ``Inbound Connections`` =
    { category = "WFPv6"; counter = "Inbound Connections"; instance = NotApplicable }
  /// Inbound Connections Allowed/sec: Inbound Connections Allowed per Second is the rate at which inbound connections are being allowed by the Windows Filtering Platform.
  let ``Inbound Connections Allowed/sec`` =
    { category = "WFPv6"; counter = "Inbound Connections Allowed/sec"; instance = NotApplicable }
  /// Inbound Connections Blocked/sec: Inbound Connections Blocked per Second is the rate at which inbound connections are being blocked by the Windows Filtering Platform.
  let ``Inbound Connections Blocked/sec`` =
    { category = "WFPv6"; counter = "Inbound Connections Blocked/sec"; instance = NotApplicable }
  /// Inbound Packets Discarded/sec: Inbound Packets Discarded per Second is the rate at which inbound packets are discarded by the Windows Filtering Platform.
  let ``Inbound Packets Discarded/sec`` =
    { category = "WFPv6"; counter = "Inbound Packets Discarded/sec"; instance = NotApplicable }
  /// Outbound Connections: Outbound Connections is the number of outbound connections allowed by the Windows Filtering Platform since the computer was last started.
  let ``Outbound Connections`` =
    { category = "WFPv6"; counter = "Outbound Connections"; instance = NotApplicable }
  /// Outbound Connections Allowed/sec: Outbound Connections Allowed per Second is the rate at which outbound connections are being allowed by the Windows Filtering Platform.
  let ``Outbound Connections Allowed/sec`` =
    { category = "WFPv6"; counter = "Outbound Connections Allowed/sec"; instance = NotApplicable }
  /// Outbound Connections Blocked/sec: Outbound Connections Blocked per Second is the rate at which outbound connections are being blocked by the Windows Filtering Platform.
  let ``Outbound Connections Blocked/sec`` =
    { category = "WFPv6"; counter = "Outbound Connections Blocked/sec"; instance = NotApplicable }
  /// Outbound Packets Discarded/sec: Outbound Packets Discarded per Second is the rate at which outbound packets are discarded by the Windows Filtering Platform.
  let ``Outbound Packets Discarded/sec`` =
    { category = "WFPv6"; counter = "Outbound Packets Discarded/sec"; instance = NotApplicable }
  /// Packets Discarded/sec: Packets Discarded per Second is the rate at which the total of inbound and outbound packets are discarded by the Windows Filtering Platform.
  let ``Packets Discarded/sec`` =
    { category = "WFPv6"; counter = "Packets Discarded/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Active Inbound Connections``
      ``Active Outbound Connections``
      ``Allowed Classifies/sec``
      ``Blocked Binds``
      ``Inbound Connections``
      ``Inbound Connections Allowed/sec``
      ``Inbound Connections Blocked/sec``
      ``Inbound Packets Discarded/sec``
      ``Outbound Connections``
      ``Outbound Connections Allowed/sec``
      ``Outbound Connections Blocked/sec``
      ``Outbound Packets Discarded/sec``
      ``Packets Discarded/sec``
    ]

/// WSMan Quota Statistics: Displays quota usage and violation information for WS-Management processes.
///
/// This performance counter does not have instance based counters
module ``WSMan Quota Statistics`` =

  [<Literal>]
  let Category = "WSMan Quota Statistics"

  let PCC = getPCC Category
  /// Active Operations: -
  let ``Active Operations`` instance =
    { category = "WSMan Quota Statistics"; counter = "Active Operations"; instance = instance }
  /// Active Shells: -
  let ``Active Shells`` instance =
    { category = "WSMan Quota Statistics"; counter = "Active Shells"; instance = instance }
  /// Active Users: -
  let ``Active Users`` instance =
    { category = "WSMan Quota Statistics"; counter = "Active Users"; instance = instance }
  /// Process ID: -
  let ``Process ID`` instance =
    { category = "WSMan Quota Statistics"; counter = "Process ID"; instance = instance }
  /// System Quota Violations/Second: -
  let ``System Quota Violations/Second`` instance =
    { category = "WSMan Quota Statistics"; counter = "System Quota Violations/Second"; instance = instance }
  /// Total Requests/Second: -
  let ``Total Requests/Second`` instance =
    { category = "WSMan Quota Statistics"; counter = "Total Requests/Second"; instance = instance }
  /// User Quota Violations/Second: -
  let ``User Quota Violations/Second`` instance =
    { category = "WSMan Quota Statistics"; counter = "User Quota Violations/Second"; instance = instance }

  let allCounters =
    [ ``Active Operations``
      ``Active Shells``
      ``Active Users``
      ``Process ID``
      ``System Quota Violations/Second``
      ``Total Requests/Second``
      ``User Quota Violations/Second``
    ]

/// Windows Media Player Metadata: Windows Media Player Metadata
///
/// This performance counter does not have instance based counters
module ``Windows Media Player Metadata`` =

  [<Literal>]
  let Category = "Windows Media Player Metadata"

  let PCC = getPCC Category
  /// AFTS Execution Time (ms): -
  let ``AFTS Execution Time (ms)`` instance =
    { category = "Windows Media Player Metadata"; counter = "AFTS Execution Time (ms)"; instance = instance }
  /// Art Extraction Time (ms): -
  let ``Art Extraction Time (ms)`` instance =
    { category = "Windows Media Player Metadata"; counter = "Art Extraction Time (ms)"; instance = instance }
  /// Commit Time (ms): -
  let ``Commit Time (ms)`` instance =
    { category = "Windows Media Player Metadata"; counter = "Commit Time (ms)"; instance = instance }
  /// Directory Change Queue Length: -
  let ``Directory Change Queue Length`` instance =
    { category = "Windows Media Player Metadata"; counter = "Directory Change Queue Length"; instance = instance }
  /// Dirty Directory Hit Count: -
  let ``Dirty Directory Hit Count`` instance =
    { category = "Windows Media Player Metadata"; counter = "Dirty Directory Hit Count"; instance = instance }
  /// File Scanning Thread Prioirty: -
  let ``File Scanning Thread Prioirty`` instance =
    { category = "Windows Media Player Metadata"; counter = "File Scanning Thread Prioirty"; instance = instance }
  /// Files Scanned/Minute: -
  let ``Files Scanned/Minute`` instance =
    { category = "Windows Media Player Metadata"; counter = "Files Scanned/Minute"; instance = instance }
  /// Groveler Service Routine Executions/Second: -
  let ``Groveler Service Routine Executions/Second`` instance =
    { category = "Windows Media Player Metadata"; counter = "Groveler Service Routine Executions/Second"; instance = instance }
  /// Library Description Change Notifications/Second: -
  let ``Library Description Change Notifications/Second`` instance =
    { category = "Windows Media Player Metadata"; counter = "Library Description Change Notifications/Second"; instance = instance }
  /// Library Description Updates/Second: -
  let ``Library Description Updates/Second`` instance =
    { category = "Windows Media Player Metadata"; counter = "Library Description Updates/Second"; instance = instance }
  /// Monitored Folder Updates/Second: -
  let ``Monitored Folder Updates/Second`` instance =
    { category = "Windows Media Player Metadata"; counter = "Monitored Folder Updates/Second"; instance = instance }
  /// Normalization Time (ms): -
  let ``Normalization Time (ms)`` instance =
    { category = "Windows Media Player Metadata"; counter = "Normalization Time (ms)"; instance = instance }
  /// Property Extraction Time (ms): -
  let ``Property Extraction Time (ms)`` instance =
    { category = "Windows Media Player Metadata"; counter = "Property Extraction Time (ms)"; instance = instance }
  /// Reorganize Time (ms): -
  let ``Reorganize Time (ms)`` instance =
    { category = "Windows Media Player Metadata"; counter = "Reorganize Time (ms)"; instance = instance }
  /// Scanning State: -
  let ``Scanning State`` instance =
    { category = "Windows Media Player Metadata"; counter = "Scanning State"; instance = instance }
  /// Timestamp Directory Hit Count: -
  let ``Timestamp Directory Hit Count`` instance =
    { category = "Windows Media Player Metadata"; counter = "Timestamp Directory Hit Count"; instance = instance }
  /// URL Classification Time (ms): -
  let ``URL Classification Time (ms)`` instance =
    { category = "Windows Media Player Metadata"; counter = "URL Classification Time (ms)"; instance = instance }

  let allCounters =
    [ ``AFTS Execution Time (ms)``
      ``Art Extraction Time (ms)``
      ``Commit Time (ms)``
      ``Directory Change Queue Length``
      ``Dirty Directory Hit Count``
      ``File Scanning Thread Prioirty``
      ``Files Scanned/Minute``
      ``Groveler Service Routine Executions/Second``
      ``Library Description Change Notifications/Second``
      ``Library Description Updates/Second``
      ``Monitored Folder Updates/Second``
      ``Normalization Time (ms)``
      ``Property Extraction Time (ms)``
      ``Reorganize Time (ms)``
      ``Scanning State``
      ``Timestamp Directory Hit Count``
      ``URL Classification Time (ms)``
    ]

/// Windows Workflow Foundation: Windows Workflow Foundation Performance Counters
///
/// This performance counter does not have instance based counters
module ``Windows Workflow Foundation`` =

  [<Literal>]
  let Category = "Windows Workflow Foundation"

  let PCC = getPCC Category
  /// Workflows Aborted: -
  let ``Workflows Aborted`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Aborted"; instance = instance }
  /// Workflows Aborted/sec: -
  let ``Workflows Aborted/sec`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Aborted/sec"; instance = instance }
  /// Workflows Completed: -
  let ``Workflows Completed`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Completed"; instance = instance }
  /// Workflows Completed/sec: -
  let ``Workflows Completed/sec`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Completed/sec"; instance = instance }
  /// Workflows Created: -
  let ``Workflows Created`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Created"; instance = instance }
  /// Workflows Created/sec: -
  let ``Workflows Created/sec`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Created/sec"; instance = instance }
  /// Workflows Executing: -
  let ``Workflows Executing`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Executing"; instance = instance }
  /// Workflows Idle/sec: -
  let ``Workflows Idle/sec`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Idle/sec"; instance = instance }
  /// Workflows In Memory: -
  let ``Workflows In Memory`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows In Memory"; instance = instance }
  /// Workflows Loaded: -
  let ``Workflows Loaded`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Loaded"; instance = instance }
  /// Workflows Loaded/sec: -
  let ``Workflows Loaded/sec`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Loaded/sec"; instance = instance }
  /// Workflows Pending: -
  let ``Workflows Pending`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Pending"; instance = instance }
  /// Workflows Persisted: -
  let ``Workflows Persisted`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Persisted"; instance = instance }
  /// Workflows Persisted/sec: -
  let ``Workflows Persisted/sec`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Persisted/sec"; instance = instance }
  /// Workflows Runnable: -
  let ``Workflows Runnable`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Runnable"; instance = instance }
  /// Workflows Suspended: -
  let ``Workflows Suspended`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Suspended"; instance = instance }
  /// Workflows Suspended/sec: -
  let ``Workflows Suspended/sec`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Suspended/sec"; instance = instance }
  /// Workflows Terminated: -
  let ``Workflows Terminated`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Terminated"; instance = instance }
  /// Workflows Terminated/sec: -
  let ``Workflows Terminated/sec`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Terminated/sec"; instance = instance }
  /// Workflows Unloaded: -
  let ``Workflows Unloaded`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Unloaded"; instance = instance }
  /// Workflows Unloaded/sec: -
  let ``Workflows Unloaded/sec`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Unloaded/sec"; instance = instance }

  let allCounters =
    [ ``Workflows Aborted``
      ``Workflows Aborted/sec``
      ``Workflows Completed``
      ``Workflows Completed/sec``
      ``Workflows Created``
      ``Workflows Created/sec``
      ``Workflows Executing``
      ``Workflows Idle/sec``
      ``Workflows In Memory``
      ``Workflows Loaded``
      ``Workflows Loaded/sec``
      ``Workflows Pending``
      ``Workflows Persisted``
      ``Workflows Persisted/sec``
      ``Workflows Runnable``
      ``Workflows Suspended``
      ``Workflows Suspended/sec``
      ``Workflows Terminated``
      ``Workflows Terminated/sec``
      ``Workflows Unloaded``
      ``Workflows Unloaded/sec``
    ]

/// WorkflowServiceHost 4.0.0.0: WorkflowServiceHost performance counters for workflow service
///
/// This performance counter does not have instance based counters
module ``WorkflowServiceHost 4_0_0_0`` =

  [<Literal>]
  let Category = "WorkflowServiceHost 4.0.0.0"

  let PCC = getPCC Category
  /// Average Workflow Load Time: -
  let ``Average Workflow Load Time`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Average Workflow Load Time"; instance = instance }
  /// Average Workflow Persist Time: -
  let ``Average Workflow Persist Time`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Average Workflow Persist Time"; instance = instance }
  /// Workflows Aborted: -
  let ``Workflows Aborted`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Aborted"; instance = instance }
  /// Workflows Aborted Per Second: -
  let ``Workflows Aborted Per Second`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Aborted Per Second"; instance = instance }
  /// Workflows Completed: -
  let ``Workflows Completed`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Completed"; instance = instance }
  /// Workflows Completed Per Second: -
  let ``Workflows Completed Per Second`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Completed Per Second"; instance = instance }
  /// Workflows Created: -
  let ``Workflows Created`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Created"; instance = instance }
  /// Workflows Created Per Second: -
  let ``Workflows Created Per Second`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Created Per Second"; instance = instance }
  /// Workflows Executing: -
  let ``Workflows Executing`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Executing"; instance = instance }
  /// Workflows Idle Per Second: -
  let ``Workflows Idle Per Second`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Idle Per Second"; instance = instance }
  /// Workflows In Memory: -
  let ``Workflows In Memory`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows In Memory"; instance = instance }
  /// Workflows Loaded: -
  let ``Workflows Loaded`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Loaded"; instance = instance }
  /// Workflows Loaded Per Second: -
  let ``Workflows Loaded Per Second`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Loaded Per Second"; instance = instance }
  /// Workflows Persisted: -
  let ``Workflows Persisted`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Persisted"; instance = instance }
  /// Workflows Persisted Per Second: -
  let ``Workflows Persisted Per Second`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Persisted Per Second"; instance = instance }
  /// Workflows Suspended: -
  let ``Workflows Suspended`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Suspended"; instance = instance }
  /// Workflows Suspended Per Second: -
  let ``Workflows Suspended Per Second`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Suspended Per Second"; instance = instance }
  /// Workflows Terminated: -
  let ``Workflows Terminated`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Terminated"; instance = instance }
  /// Workflows Terminated Per Second: -
  let ``Workflows Terminated Per Second`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Terminated Per Second"; instance = instance }
  /// Workflows Unloaded: -
  let ``Workflows Unloaded`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Unloaded"; instance = instance }
  /// Workflows Unloaded Per Second: -
  let ``Workflows Unloaded Per Second`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Unloaded Per Second"; instance = instance }

  let allCounters =
    [ ``Average Workflow Load Time``
      ``Average Workflow Persist Time``
      ``Workflows Aborted``
      ``Workflows Aborted Per Second``
      ``Workflows Completed``
      ``Workflows Completed Per Second``
      ``Workflows Created``
      ``Workflows Created Per Second``
      ``Workflows Executing``
      ``Workflows Idle Per Second``
      ``Workflows In Memory``
      ``Workflows Loaded``
      ``Workflows Loaded Per Second``
      ``Workflows Persisted``
      ``Workflows Persisted Per Second``
      ``Workflows Suspended``
      ``Workflows Suspended Per Second``
      ``Workflows Terminated``
      ``Workflows Terminated Per Second``
      ``Workflows Unloaded``
      ``Workflows Unloaded Per Second``
    ]

/// XHCI CommonBuffer: Consists of counters that measure aspects of a CommonBuffer object of an xHCI controller.
///
/// This performance counter does not have instance based counters
module ``XHCI CommonBuffer`` =

  [<Literal>]
  let Category = "XHCI CommonBuffer"

  let PCC = getPCC Category
  /// AllocationCount: -
  let ``AllocationCount`` instance =
    { category = "XHCI CommonBuffer"; counter = "AllocationCount"; instance = instance }
  /// FreeCount: -
  let ``FreeCount`` instance =
    { category = "XHCI CommonBuffer"; counter = "FreeCount"; instance = instance }
  /// PagesInUse: -
  let ``PagesInUse`` instance =
    { category = "XHCI CommonBuffer"; counter = "PagesInUse"; instance = instance }
  /// PagesTotal: -
  let ``PagesTotal`` instance =
    { category = "XHCI CommonBuffer"; counter = "PagesTotal"; instance = instance }

  let allCounters =
    [ ``AllocationCount``
      ``FreeCount``
      ``PagesInUse``
      ``PagesTotal``
    ]

/// XHCI Interrupter: Consists of counters that measure aspects of an interrupter of an xHCI controller.
///
/// This performance counter does not have instance based counters
module ``XHCI Interrupter`` =

  [<Literal>]
  let Category = "XHCI Interrupter"

  let PCC = getPCC Category
  /// DPCs/sec: -
  let ``DPCs/sec`` instance =
    { category = "XHCI Interrupter"; counter = "DPCs/sec"; instance = instance }
  /// DpcRequeueCount: -
  let ``DpcRequeueCount`` instance =
    { category = "XHCI Interrupter"; counter = "DpcRequeueCount"; instance = instance }
  /// EventRingFullCount: -
  let ``EventRingFullCount`` instance =
    { category = "XHCI Interrupter"; counter = "EventRingFullCount"; instance = instance }
  /// Events processed/DPC: -
  let ``Events processed/DPC`` instance =
    { category = "XHCI Interrupter"; counter = "Events processed/DPC"; instance = instance }
  /// Interrupts/sec: -
  let ``Interrupts/sec`` instance =
    { category = "XHCI Interrupter"; counter = "Interrupts/sec"; instance = instance }

  let allCounters =
    [ ``DPCs/sec``
      ``DpcRequeueCount``
      ``EventRingFullCount``
      ``Events processed/DPC``
      ``Interrupts/sec``
    ]

/// XHCI TransferRing: Consists of counters that measure aspects of a transferring of an xHCI controller.
///
/// This performance counter does not have instance based counters
module ``XHCI TransferRing`` =

  [<Literal>]
  let Category = "XHCI TransferRing"

  let PCC = getPCC Category
  /// Bytes/Sec: -
  let ``Bytes/Sec`` instance =
    { category = "XHCI TransferRing"; counter = "Bytes/Sec"; instance = instance }
  /// Failed Transfer Count: -
  let ``Failed Transfer Count`` instance =
    { category = "XHCI TransferRing"; counter = "Failed Transfer Count"; instance = instance }
  /// Isoch TD Failures/sec: -
  let ``Isoch TD Failures/sec`` instance =
    { category = "XHCI TransferRing"; counter = "Isoch TD Failures/sec"; instance = instance }
  /// Isoch TD/sec: -
  let ``Isoch TD/sec`` instance =
    { category = "XHCI TransferRing"; counter = "Isoch TD/sec"; instance = instance }
  /// Missed Service Error Count: -
  let ``Missed Service Error Count`` instance =
    { category = "XHCI TransferRing"; counter = "Missed Service Error Count"; instance = instance }
  /// Transfers/sec: -
  let ``Transfers/sec`` instance =
    { category = "XHCI TransferRing"; counter = "Transfers/sec"; instance = instance }
  /// Underrun Overrun count: -
  let ``Underrun Overrun count`` instance =
    { category = "XHCI TransferRing"; counter = "Underrun Overrun count"; instance = instance }

  let allCounters =
    [ ``Bytes/Sec``
      ``Failed Transfer Count``
      ``Isoch TD Failures/sec``
      ``Isoch TD/sec``
      ``Missed Service Error Count``
      ``Transfers/sec``
      ``Underrun Overrun count``
    ]

/// XTP Cursors: The XTP Cursors performance object contains counters related to internal XTP engine cursors. Cursors are the low-level building blocks the XTP engine uses to process T-SQL queries. As such, a user does not typically have direct control over them.
///
/// This performance counter does not have instance based counters
module ``XTP Cursors`` =

  [<Literal>]
  let Category = "XTP Cursors"

  let PCC = getPCC Category
  /// Cursor deletes/sec: -
  let ``Cursor deletes/sec`` instance =
    { category = "XTP Cursors"; counter = "Cursor deletes/sec"; instance = instance }
  /// Cursor inserts/sec: -
  let ``Cursor inserts/sec`` instance =
    { category = "XTP Cursors"; counter = "Cursor inserts/sec"; instance = instance }
  /// Cursor scans started/sec: -
  let ``Cursor scans started/sec`` instance =
    { category = "XTP Cursors"; counter = "Cursor scans started/sec"; instance = instance }
  /// Cursor unique violations/sec: -
  let ``Cursor unique violations/sec`` instance =
    { category = "XTP Cursors"; counter = "Cursor unique violations/sec"; instance = instance }
  /// Cursor updates/sec: -
  let ``Cursor updates/sec`` instance =
    { category = "XTP Cursors"; counter = "Cursor updates/sec"; instance = instance }
  /// Cursor write conflicts/sec: -
  let ``Cursor write conflicts/sec`` instance =
    { category = "XTP Cursors"; counter = "Cursor write conflicts/sec"; instance = instance }
  /// Dusty corner scan retries/sec (user-issued): -
  let ``Dusty corner scan retries/sec (user-issued)`` instance =
    { category = "XTP Cursors"; counter = "Dusty corner scan retries/sec (user-issued)"; instance = instance }
  /// Expired rows removed/sec: -
  let ``Expired rows removed/sec`` instance =
    { category = "XTP Cursors"; counter = "Expired rows removed/sec"; instance = instance }
  /// Expired rows touched/sec: -
  let ``Expired rows touched/sec`` instance =
    { category = "XTP Cursors"; counter = "Expired rows touched/sec"; instance = instance }
  /// Rows returned/sec: -
  let ``Rows returned/sec`` instance =
    { category = "XTP Cursors"; counter = "Rows returned/sec"; instance = instance }
  /// Rows touched/sec: -
  let ``Rows touched/sec`` instance =
    { category = "XTP Cursors"; counter = "Rows touched/sec"; instance = instance }
  /// Tentatively-deleted rows touched/sec: -
  let ``Tentatively-deleted rows touched/sec`` instance =
    { category = "XTP Cursors"; counter = "Tentatively-deleted rows touched/sec"; instance = instance }

  let allCounters =
    [ ``Cursor deletes/sec``
      ``Cursor inserts/sec``
      ``Cursor scans started/sec``
      ``Cursor unique violations/sec``
      ``Cursor updates/sec``
      ``Cursor write conflicts/sec``
      ``Dusty corner scan retries/sec (user-issued)``
      ``Expired rows removed/sec``
      ``Expired rows touched/sec``
      ``Rows returned/sec``
      ``Rows touched/sec``
      ``Tentatively-deleted rows touched/sec``
    ]

/// XTP Garbage Collection: The XTP Garbage Collection performance object contains counters related to the XTP engine's garbage collector.
///
/// This performance counter does not have instance based counters
module ``XTP Garbage Collection`` =

  [<Literal>]
  let Category = "XTP Garbage Collection"

  let PCC = getPCC Category
  /// Dusty corner scan retries/sec (GC-issued): -
  let ``Dusty corner scan retries/sec (GC-issued)`` instance =
    { category = "XTP Garbage Collection"; counter = "Dusty corner scan retries/sec (GC-issued)"; instance = instance }
  /// Main GC work items/sec: -
  let ``Main GC work items/sec`` instance =
    { category = "XTP Garbage Collection"; counter = "Main GC work items/sec"; instance = instance }
  /// Parallel GC work item/sec: -
  let ``Parallel GC work item/sec`` instance =
    { category = "XTP Garbage Collection"; counter = "Parallel GC work item/sec"; instance = instance }
  /// Rows processed/sec: -
  let ``Rows processed/sec`` instance =
    { category = "XTP Garbage Collection"; counter = "Rows processed/sec"; instance = instance }
  /// Rows processed/sec (first in bucket and removed): -
  let ``Rows processed/sec (first in bucket and removed)`` instance =
    { category = "XTP Garbage Collection"; counter = "Rows processed/sec (first in bucket and removed)"; instance = instance }
  /// Rows processed/sec (first in bucket): -
  let ``Rows processed/sec (first in bucket)`` instance =
    { category = "XTP Garbage Collection"; counter = "Rows processed/sec (first in bucket)"; instance = instance }
  /// Rows processed/sec (marked for unlink): -
  let ``Rows processed/sec (marked for unlink)`` instance =
    { category = "XTP Garbage Collection"; counter = "Rows processed/sec (marked for unlink)"; instance = instance }
  /// Rows processed/sec (no sweep needed): -
  let ``Rows processed/sec (no sweep needed)`` instance =
    { category = "XTP Garbage Collection"; counter = "Rows processed/sec (no sweep needed)"; instance = instance }
  /// Sweep expired rows removed/sec: -
  let ``Sweep expired rows removed/sec`` instance =
    { category = "XTP Garbage Collection"; counter = "Sweep expired rows removed/sec"; instance = instance }
  /// Sweep expired rows touched/sec: -
  let ``Sweep expired rows touched/sec`` instance =
    { category = "XTP Garbage Collection"; counter = "Sweep expired rows touched/sec"; instance = instance }
  /// Sweep expiring rows touched/sec: -
  let ``Sweep expiring rows touched/sec`` instance =
    { category = "XTP Garbage Collection"; counter = "Sweep expiring rows touched/sec"; instance = instance }
  /// Sweep rows touched/sec: -
  let ``Sweep rows touched/sec`` instance =
    { category = "XTP Garbage Collection"; counter = "Sweep rows touched/sec"; instance = instance }
  /// Sweep scans started/sec: -
  let ``Sweep scans started/sec`` instance =
    { category = "XTP Garbage Collection"; counter = "Sweep scans started/sec"; instance = instance }

  let allCounters =
    [ ``Dusty corner scan retries/sec (GC-issued)``
      ``Main GC work items/sec``
      ``Parallel GC work item/sec``
      ``Rows processed/sec``
      ``Rows processed/sec (first in bucket and removed)``
      ``Rows processed/sec (first in bucket)``
      ``Rows processed/sec (marked for unlink)``
      ``Rows processed/sec (no sweep needed)``
      ``Sweep expired rows removed/sec``
      ``Sweep expired rows touched/sec``
      ``Sweep expiring rows touched/sec``
      ``Sweep rows touched/sec``
      ``Sweep scans started/sec``
    ]

/// XTP Phantom Processor: The XTP Phantom Processor performance object contains counters related to the XTP engine's phantom processing subsystem. This component is responsible for detecting phantom rows in transactions running at the SERIALIZABLE isolation level.
///
/// This performance counter does not have instance based counters
module ``XTP Phantom Processor`` =

  [<Literal>]
  let Category = "XTP Phantom Processor"

  let PCC = getPCC Category
  /// Dusty corner scan retries/sec (Phantom-issued): -
  let ``Dusty corner scan retries/sec (Phantom-issued)`` instance =
    { category = "XTP Phantom Processor"; counter = "Dusty corner scan retries/sec (Phantom-issued)"; instance = instance }
  /// Phantom expired rows removed/sec: -
  let ``Phantom expired rows removed/sec`` instance =
    { category = "XTP Phantom Processor"; counter = "Phantom expired rows removed/sec"; instance = instance }
  /// Phantom expired rows touched/sec: -
  let ``Phantom expired rows touched/sec`` instance =
    { category = "XTP Phantom Processor"; counter = "Phantom expired rows touched/sec"; instance = instance }
  /// Phantom expiring rows touched/sec: -
  let ``Phantom expiring rows touched/sec`` instance =
    { category = "XTP Phantom Processor"; counter = "Phantom expiring rows touched/sec"; instance = instance }
  /// Phantom rows touched/sec: -
  let ``Phantom rows touched/sec`` instance =
    { category = "XTP Phantom Processor"; counter = "Phantom rows touched/sec"; instance = instance }
  /// Phantom scans started/sec: -
  let ``Phantom scans started/sec`` instance =
    { category = "XTP Phantom Processor"; counter = "Phantom scans started/sec"; instance = instance }

  let allCounters =
    [ ``Dusty corner scan retries/sec (Phantom-issued)``
      ``Phantom expired rows removed/sec``
      ``Phantom expired rows touched/sec``
      ``Phantom expiring rows touched/sec``
      ``Phantom rows touched/sec``
      ``Phantom scans started/sec``
    ]

/// XTP Storage: The XTP Storage performance object contains counters related to the XTP engine's storage subsystem. This includes checkpointing and merge of checkpoint files.
///
/// This performance counter does not have instance based counters
module ``XTP Storage`` =

  [<Literal>]
  let Category = "XTP Storage"

  let PCC = getPCC Category
  /// Checkpoints Closed: -
  let ``Checkpoints Closed`` instance =
    { category = "XTP Storage"; counter = "Checkpoints Closed"; instance = instance }
  /// Checkpoints Completed: -
  let ``Checkpoints Completed`` instance =
    { category = "XTP Storage"; counter = "Checkpoints Completed"; instance = instance }
  /// Core Merges Completed: -
  let ``Core Merges Completed`` instance =
    { category = "XTP Storage"; counter = "Core Merges Completed"; instance = instance }
  /// Merge Policy Evaluations: -
  let ``Merge Policy Evaluations`` instance =
    { category = "XTP Storage"; counter = "Merge Policy Evaluations"; instance = instance }
  /// Merge Requests Outstanding: -
  let ``Merge Requests Outstanding`` instance =
    { category = "XTP Storage"; counter = "Merge Requests Outstanding"; instance = instance }
  /// Merges Abandoned: -
  let ``Merges Abandoned`` instance =
    { category = "XTP Storage"; counter = "Merges Abandoned"; instance = instance }
  /// Merges Installed: -
  let ``Merges Installed`` instance =
    { category = "XTP Storage"; counter = "Merges Installed"; instance = instance }
  /// Total Files Merged: -
  let ``Total Files Merged`` instance =
    { category = "XTP Storage"; counter = "Total Files Merged"; instance = instance }

  let allCounters =
    [ ``Checkpoints Closed``
      ``Checkpoints Completed``
      ``Core Merges Completed``
      ``Merge Policy Evaluations``
      ``Merge Requests Outstanding``
      ``Merges Abandoned``
      ``Merges Installed``
      ``Total Files Merged``
    ]

/// XTP Transaction Log: The XTP Transaction Log performance object contains counters related to XTP transaction logging in SQL Server.
///
/// This performance counter does not have instance based counters
module ``XTP Transaction Log`` =

  [<Literal>]
  let Category = "XTP Transaction Log"

  let PCC = getPCC Category
  /// Log bytes written/sec: -
  let ``Log bytes written/sec`` instance =
    { category = "XTP Transaction Log"; counter = "Log bytes written/sec"; instance = instance }
  /// Log records written/sec: -
  let ``Log records written/sec`` instance =
    { category = "XTP Transaction Log"; counter = "Log records written/sec"; instance = instance }

  let allCounters =
    [ ``Log bytes written/sec``
      ``Log records written/sec``
    ]

/// XTP Transactions: The XTP Transactions performance object contains counters related to XTP engine transactions in SQL Server.
///
/// This performance counter does not have instance based counters
module ``XTP Transactions`` =

  [<Literal>]
  let Category = "XTP Transactions"

  let PCC = getPCC Category
  /// Cascading aborts/sec: -
  let ``Cascading aborts/sec`` instance =
    { category = "XTP Transactions"; counter = "Cascading aborts/sec"; instance = instance }
  /// Commit dependencies taken/sec: -
  let ``Commit dependencies taken/sec`` instance =
    { category = "XTP Transactions"; counter = "Commit dependencies taken/sec"; instance = instance }
  /// Read-only transactions prepared/sec: -
  let ``Read-only transactions prepared/sec`` instance =
    { category = "XTP Transactions"; counter = "Read-only transactions prepared/sec"; instance = instance }
  /// Save point refreshes/sec: -
  let ``Save point refreshes/sec`` instance =
    { category = "XTP Transactions"; counter = "Save point refreshes/sec"; instance = instance }
  /// Save point rollbacks/sec: -
  let ``Save point rollbacks/sec`` instance =
    { category = "XTP Transactions"; counter = "Save point rollbacks/sec"; instance = instance }
  /// Save points created/sec: -
  let ``Save points created/sec`` instance =
    { category = "XTP Transactions"; counter = "Save points created/sec"; instance = instance }
  /// Transaction validation failures/sec: -
  let ``Transaction validation failures/sec`` instance =
    { category = "XTP Transactions"; counter = "Transaction validation failures/sec"; instance = instance }
  /// Transactions aborted by user/sec: -
  let ``Transactions aborted by user/sec`` instance =
    { category = "XTP Transactions"; counter = "Transactions aborted by user/sec"; instance = instance }
  /// Transactions aborted/sec: -
  let ``Transactions aborted/sec`` instance =
    { category = "XTP Transactions"; counter = "Transactions aborted/sec"; instance = instance }
  /// Transactions created/sec: -
  let ``Transactions created/sec`` instance =
    { category = "XTP Transactions"; counter = "Transactions created/sec"; instance = instance }

  let allCounters =
    [ ``Cascading aborts/sec``
      ``Commit dependencies taken/sec``
      ``Read-only transactions prepared/sec``
      ``Save point refreshes/sec``
      ``Save point rollbacks/sec``
      ``Save points created/sec``
      ``Transaction validation failures/sec``
      ``Transactions aborted by user/sec``
      ``Transactions aborted/sec``
      ``Transactions created/sec``
    ]
