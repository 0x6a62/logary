/// Copyright Henrik Feldt 2014. Part of the Logary source code.
/// An autogenerated file with all performance counters found on a Windows 8.1 system
module Logary.WinPerfCounters

open System
open System.Diagnostics

open Logary.WinPerfCounter
/// .NET CLR Data: .Net CLR Data
///
/// This performance counter does not have instance based counters
module ``_NET CLR Data`` =

  [<Literal>]
  let Category = ".NET CLR Data"

  let PCC = getPCC Category
  /// SqlClient: Current # pooled and nonpooled connections: 
  let ``SqlClient: Current # pooled and nonpooled connections`` instance =
    { category = ".NET CLR Data"; counter = "SqlClient: Current # pooled and nonpooled connections"; instance = instance }
  /// SqlClient: Current # pooled connections: 
  let ``SqlClient: Current # pooled connections`` instance =
    { category = ".NET CLR Data"; counter = "SqlClient: Current # pooled connections"; instance = instance }
  /// SqlClient: Current # connection pools: 
  let ``SqlClient: Current # connection pools`` instance =
    { category = ".NET CLR Data"; counter = "SqlClient: Current # connection pools"; instance = instance }
  /// SqlClient: Peak # pooled connections: 
  let ``SqlClient: Peak # pooled connections`` instance =
    { category = ".NET CLR Data"; counter = "SqlClient: Peak # pooled connections"; instance = instance }
  /// SqlClient: Total # failed connects: 
  let ``SqlClient: Total # failed connects`` instance =
    { category = ".NET CLR Data"; counter = "SqlClient: Total # failed connects"; instance = instance }
  /// SqlClient: Total # failed commands: 
  let ``SqlClient: Total # failed commands`` instance =
    { category = ".NET CLR Data"; counter = "SqlClient: Total # failed commands"; instance = instance }

  let allCounters =
    [ ``SqlClient: Current # pooled and nonpooled connections``
      ``SqlClient: Current # pooled connections``
      ``SqlClient: Current # connection pools``
      ``SqlClient: Peak # pooled connections``
      ``SqlClient: Total # failed connects``
      ``SqlClient: Total # failed commands``
    ]

/// .NET CLR Exceptions: Runtime statistics on CLR exception handling.
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR Exceptions`` =

  [<Literal>]
  let Category = ".NET CLR Exceptions"

  let PCC = getPCC Category
  /// # of Exceps Thrown: This counter displays the total number of exceptions thrown since the start of the application. These include both .NET exceptions and unmanaged exceptions that get converted into .NET exceptions e.g. null pointer reference exception in unmanaged code would get re-thrown in managed code as a .NET System.NullReferenceException; this counter includes both handled and unhandled exceptions. Exceptions that are re-thrown would get counted again. Exceptions should only occur in rare situations and not in the normal control flow of the program.
  let ``# of Exceps Thrown`` instance =
    { category = ".NET CLR Exceptions"; counter = "# of Exceps Thrown"; instance = instance }
  /// # of Exceps Thrown / sec: This counter displays the number of exceptions thrown per second. These include both .NET exceptions and unmanaged exceptions that get converted into .NET exceptions e.g. null pointer reference exception in unmanaged code would get re-thrown in managed code as a .NET System.NullReferenceException; this counter includes both handled and unhandled exceptions. Exceptions should only occur in rare situations and not in the normal control flow of the program; this counter was designed as an indicator of potential performance problems due to large (>100s) rate of exceptions thrown. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``# of Exceps Thrown / sec`` instance =
    { category = ".NET CLR Exceptions"; counter = "# of Exceps Thrown / sec"; instance = instance }
  /// # of Filters / sec: This counter displays the number of .NET exception filters executed per second. An exception filter evaluates whether an exception should be handled or not. This counter tracks the rate of exception filters evaluated; irrespective of whether the exception was handled or not. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``# of Filters / sec`` instance =
    { category = ".NET CLR Exceptions"; counter = "# of Filters / sec"; instance = instance }
  /// # of Finallys / sec: This counter displays the number of finally blocks executed per second. A finally block is guaranteed to be executed regardless of how the try block was exited. Only the finally blocks that are executed for an exception are counted; finally blocks on normal code paths are not counted by this counter. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``# of Finallys / sec`` instance =
    { category = ".NET CLR Exceptions"; counter = "# of Finallys / sec"; instance = instance }
  /// Throw To Catch Depth / sec: This counter displays the number of stack frames traversed from the frame that threw the .NET exception to the frame that handled the exception per second. This counter resets to 0 when an exception handler is entered; so nested exceptions would show the handler to handler stack depth. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``Throw To Catch Depth / sec`` instance =
    { category = ".NET CLR Exceptions"; counter = "Throw To Catch Depth / sec"; instance = instance }

  let allCounters =
    [ ``# of Exceps Thrown``
      ``# of Exceps Thrown / sec``
      ``# of Filters / sec``
      ``# of Finallys / sec``
      ``Throw To Catch Depth / sec``
    ]

/// .NET CLR Interop: Stats for CLR interop.
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR Interop`` =

  [<Literal>]
  let Category = ".NET CLR Interop"

  let PCC = getPCC Category
  /// # of CCWs: This counter displays the current number of Com-Callable-Wrappers (CCWs). A CCW is a proxy for the .NET managed object being referenced from unmanaged COM client(s). This counter was designed to indicate the number of managed objects being referenced by unmanaged COM code.
  let ``# of CCWs`` instance =
    { category = ".NET CLR Interop"; counter = "# of CCWs"; instance = instance }
  /// # of Stubs: This counter displays the current number of stubs created by the CLR. Stubs are responsible for marshalling arguments and return values from managed to unmanaged code and vice versa; during a COM Interop call or PInvoke call.
  let ``# of Stubs`` instance =
    { category = ".NET CLR Interop"; counter = "# of Stubs"; instance = instance }
  /// # of marshalling: This counter displays the total number of times arguments and return values have been marshaled from managed to unmanaged code and vice versa since the start of the application. This counter is not incremented if the stubs are inlined. (Stubs are responsible for marshalling arguments and return values). Stubs usually get inlined if the marshalling overhead is small.
  let ``# of marshalling`` instance =
    { category = ".NET CLR Interop"; counter = "# of marshalling"; instance = instance }
  /// # of TLB imports / sec: Reserved for future use.
  let ``# of TLB imports / sec`` instance =
    { category = ".NET CLR Interop"; counter = "# of TLB imports / sec"; instance = instance }
  /// # of TLB exports / sec: Reserved for future use.
  let ``# of TLB exports / sec`` instance =
    { category = ".NET CLR Interop"; counter = "# of TLB exports / sec"; instance = instance }

  let allCounters =
    [ ``# of CCWs``
      ``# of Stubs``
      ``# of marshalling``
      ``# of TLB imports / sec``
      ``# of TLB exports / sec``
    ]

/// .NET CLR Jit: Stats for CLR Jit.
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR Jit`` =

  [<Literal>]
  let Category = ".NET CLR Jit"

  let PCC = getPCC Category
  /// # of Methods Jitted: This counter displays the total number of methods compiled Just-In-Time (JIT) by the CLR JIT compiler since the start of the application. This counter does not include the pre-jitted methods.
  let ``# of Methods Jitted`` instance =
    { category = ".NET CLR Jit"; counter = "# of Methods Jitted"; instance = instance }
  /// # of IL Bytes Jitted: This counter displays the total IL bytes jitted since the start of the application. This counter is exactly equivalent to the "Total # of IL Bytes Jitted" counter.
  let ``# of IL Bytes Jitted`` instance =
    { category = ".NET CLR Jit"; counter = "# of IL Bytes Jitted"; instance = instance }
  /// Total # of IL Bytes Jitted: This counter displays the total IL bytes jitted since the start of the application. This counter is exactly equivalent to the "# of IL Bytes Jitted" counter.
  let ``Total # of IL Bytes Jitted`` instance =
    { category = ".NET CLR Jit"; counter = "Total # of IL Bytes Jitted"; instance = instance }
  /// IL Bytes Jitted / sec: This counter displays the rate at which IL bytes are jitted per second. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``IL Bytes Jitted / sec`` instance =
    { category = ".NET CLR Jit"; counter = "IL Bytes Jitted / sec"; instance = instance }
  /// Standard Jit Failures: This counter displays the peak number of methods the JIT compiler has failed to JIT since the start of the application. This failure can occur if the IL cannot be verified or if there was an internal error in the JIT compiler.
  let ``Standard Jit Failures`` instance =
    { category = ".NET CLR Jit"; counter = "Standard Jit Failures"; instance = instance }
  /// % Time in Jit: This counter displays the percentage of elapsed time spent in JIT compilation since the last JIT compilation phase. This counter is updated at the end of every JIT compilation phase. A JIT compilation phase is the phase when a method and its dependencies are being compiled.
  let ``% Time in Jit`` instance =
    { category = ".NET CLR Jit"; counter = "% Time in Jit"; instance = instance }
  /// Not Displayed: Not Displayed.
  let ``Not Displayed`` instance =
    { category = ".NET CLR Jit"; counter = "Not Displayed"; instance = instance }

  let allCounters =
    [ ``# of Methods Jitted``
      ``# of IL Bytes Jitted``
      ``Total # of IL Bytes Jitted``
      ``IL Bytes Jitted / sec``
      ``Standard Jit Failures``
      ``% Time in Jit``
      ``Not Displayed``
    ]

/// .NET CLR Loading: Statistics for CLR Class Loader.
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR Loading`` =

  [<Literal>]
  let Category = ".NET CLR Loading"

  let PCC = getPCC Category
  /// Current Classes Loaded: This counter displays the current number of classes loaded in all Assemblies.
  let ``Current Classes Loaded`` instance =
    { category = ".NET CLR Loading"; counter = "Current Classes Loaded"; instance = instance }
  /// Total Classes Loaded: This counter displays the cumulative number of classes loaded in all Assemblies since the start of this application.
  let ``Total Classes Loaded`` instance =
    { category = ".NET CLR Loading"; counter = "Total Classes Loaded"; instance = instance }
  /// Rate of Classes Loaded: This counter displays the number of classes loaded per second in all Assemblies. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``Rate of Classes Loaded`` instance =
    { category = ".NET CLR Loading"; counter = "Rate of Classes Loaded"; instance = instance }
  /// Current appdomains: This counter displays the current number of AppDomains loaded in this application. AppDomains (application domains) provide a secure and versatile unit of processing that the CLR can use to provide isolation between applications running in the same process.
  let ``Current appdomains`` instance =
    { category = ".NET CLR Loading"; counter = "Current appdomains"; instance = instance }
  /// Total Appdomains: This counter displays the peak number of AppDomains loaded since the start of this application. AppDomains (application domains) provide a secure and versatile unit of processing that the CLR can use to provide isolation between applications running in the same process.
  let ``Total Appdomains`` instance =
    { category = ".NET CLR Loading"; counter = "Total Appdomains"; instance = instance }
  /// Rate of appdomains: This counter displays the number of AppDomains loaded per second. AppDomains (application domains) provide a secure and versatile unit of processing that the CLR can use to provide isolation between applications running in the same process. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``Rate of appdomains`` instance =
    { category = ".NET CLR Loading"; counter = "Rate of appdomains"; instance = instance }
  /// Current Assemblies: This counter displays the current number of Assemblies loaded across all AppDomains in this application. If the Assembly is loaded as domain-neutral from multiple AppDomains then this counter is incremented once only. Assemblies can be loaded as domain-neutral when their code can be shared by all AppDomains or they can be loaded as domain-specific when their code is private to the AppDomain.
  let ``Current Assemblies`` instance =
    { category = ".NET CLR Loading"; counter = "Current Assemblies"; instance = instance }
  /// Total Assemblies: This counter displays the total number of Assemblies loaded since the start of this application. If the Assembly is loaded as domain-neutral from multiple AppDomains then this counter is incremented once only. Assemblies can be loaded as domain-neutral when their code can be shared by all AppDomains or they can be loaded as domain-specific when their code is private to the AppDomain.
  let ``Total Assemblies`` instance =
    { category = ".NET CLR Loading"; counter = "Total Assemblies"; instance = instance }
  /// Rate of Assemblies: This counter displays the number of Assemblies loaded across all AppDomains per second. If the Assembly is loaded as domain-neutral from multiple AppDomains then this counter is incremented once only. Assemblies can be loaded as domain-neutral when their code can be shared by all AppDomains or they can be loaded as domain-specific when their code is private to the AppDomain. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``Rate of Assemblies`` instance =
    { category = ".NET CLR Loading"; counter = "Rate of Assemblies"; instance = instance }
  /// % Time Loading: Reserved for future use.
  let ``% Time Loading`` instance =
    { category = ".NET CLR Loading"; counter = "% Time Loading"; instance = instance }
  /// Assembly Search Length: Reserved for future use.
  let ``Assembly Search Length`` instance =
    { category = ".NET CLR Loading"; counter = "Assembly Search Length"; instance = instance }
  /// Total # of Load Failures: This counter displays the peak number of classes that have failed to load since the start of the application. These load failures could be due to many reasons like inadequate security or illegal format. Full details can be found in the profiling services help.
  let ``Total # of Load Failures`` instance =
    { category = ".NET CLR Loading"; counter = "Total # of Load Failures"; instance = instance }
  /// Rate of Load Failures: This counter displays the number of classes that failed to load per second. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval. These load failures could be due to many reasons like inadequate security or illegal format. Full details can be found in the profiling services help.
  let ``Rate of Load Failures`` instance =
    { category = ".NET CLR Loading"; counter = "Rate of Load Failures"; instance = instance }
  /// Bytes in Loader Heap: This counter displays the current size (in bytes) of the memory committed by the class loader across all AppDomains. (Committed memory is the physical memory for which space has been reserved on the disk paging file.)
  let ``Bytes in Loader Heap`` instance =
    { category = ".NET CLR Loading"; counter = "Bytes in Loader Heap"; instance = instance }
  /// Total appdomains unloaded: This counter displays the total number of AppDomains unloaded since the start of the application. If an AppDomain is loaded and unloaded multiple times this counter would count each of those unloads as separate.
  let ``Total appdomains unloaded`` instance =
    { category = ".NET CLR Loading"; counter = "Total appdomains unloaded"; instance = instance }
  /// Rate of appdomains unloaded: This counter displays the number of AppDomains unloaded per second. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``Rate of appdomains unloaded`` instance =
    { category = ".NET CLR Loading"; counter = "Rate of appdomains unloaded"; instance = instance }

  let allCounters =
    [ ``Current Classes Loaded``
      ``Total Classes Loaded``
      ``Rate of Classes Loaded``
      ``Current appdomains``
      ``Total Appdomains``
      ``Rate of appdomains``
      ``Current Assemblies``
      ``Total Assemblies``
      ``Rate of Assemblies``
      ``% Time Loading``
      ``Assembly Search Length``
      ``Total # of Load Failures``
      ``Rate of Load Failures``
      ``Bytes in Loader Heap``
      ``Total appdomains unloaded``
      ``Rate of appdomains unloaded``
    ]

/// .NET CLR LocksAndThreads: Stats for CLR Locks and Threads.
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR LocksAndThreads`` =

  [<Literal>]
  let Category = ".NET CLR LocksAndThreads"

  let PCC = getPCC Category
  /// Total # of Contentions: This counter displays the total number of times threads in the CLR have attempted to acquire a managed lock unsuccessfully. Managed locks can be acquired in many ways; by the "lock" statement in C# or by calling System.Monitor.Enter or by using MethodImplOptions.Synchronized custom attribute.
  let ``Total # of Contentions`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "Total # of Contentions"; instance = instance }
  /// Contention Rate / sec: Rate at which threads in the runtime attempt to acquire a managed lock unsuccessfully. Managed locks can be acquired in many ways; by the "lock" statement in C# or by calling System.Monitor.Enter or by using MethodImplOptions.Synchronized custom attribute.
  let ``Contention Rate / sec`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "Contention Rate / sec"; instance = instance }
  /// Current Queue Length: This counter displays the total number of threads currently waiting to acquire some managed lock in the application. This counter is not an average over time; it displays the last observed value.
  let ``Current Queue Length`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "Current Queue Length"; instance = instance }
  /// Queue Length Peak: This counter displays the total number of threads that waited to acquire some managed lock since the start of the application.
  let ``Queue Length Peak`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "Queue Length Peak"; instance = instance }
  /// Queue Length / sec: This counter displays the number of threads per second waiting to acquire some lock in the application. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``Queue Length / sec`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "Queue Length / sec"; instance = instance }
  /// # of current logical Threads: This counter displays the number of current .NET thread objects in the application. A .NET thread object is created either by new System.Threading.Thread or when an unmanaged thread enters the managed environment. This counters maintains the count of both running and stopped threads. This counter is not an average over time; it just displays the last observed value.
  let ``# of current logical Threads`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "# of current logical Threads"; instance = instance }
  /// # of current physical Threads: This counter displays the number of native OS threads created and owned by the CLR to act as underlying threads for .NET thread objects. This counters value does not include the threads used by the CLR in its internal operations; it is a subset of the threads in the OS process.
  let ``# of current physical Threads`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "# of current physical Threads"; instance = instance }
  /// # of current recognized threads: This counter displays the number of threads that are currently recognized by the CLR; they have a corresponding .NET thread object associated with them. These threads are not created by the CLR; they are created outside the CLR but have since run inside the CLR at least once. Only unique threads are tracked; threads with same thread ID re-entering the CLR or recreated after thread exit are not counted twice.
  let ``# of current recognized threads`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "# of current recognized threads"; instance = instance }
  /// # of total recognized threads: This counter displays the total number of threads that have been recognized by the CLR since the start of this application; these threads have a corresponding .NET thread object associated with them. These threads are not created by the CLR; they are created outside the CLR but have since run inside the CLR at least once. Only unique threads are tracked; threads with same thread ID re-entering the CLR or recreated after thread exit are not counted twice.
  let ``# of total recognized threads`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "# of total recognized threads"; instance = instance }
  /// rate of recognized threads / sec: This counter displays the number of threads per second that have been recognized by the CLR; these threads have a corresponding .NET thread object associated with them. These threads are not created by the CLR; they are created outside the CLR but have since run inside the CLR at least once. Only unique threads are tracked; threads with same thread ID re-entering the CLR or recreated after thread exit are not counted twice. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``rate of recognized threads / sec`` instance =
    { category = ".NET CLR LocksAndThreads"; counter = "rate of recognized threads / sec"; instance = instance }

  let allCounters =
    [ ``Total # of Contentions``
      ``Contention Rate / sec``
      ``Current Queue Length``
      ``Queue Length Peak``
      ``Queue Length / sec``
      ``# of current logical Threads``
      ``# of current physical Threads``
      ``# of current recognized threads``
      ``# of total recognized threads``
      ``rate of recognized threads / sec``
    ]

/// .NET CLR Memory: Counters for CLR Garbage Collected heap.
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR Memory`` =

  [<Literal>]
  let Category = ".NET CLR Memory"

  let PCC = getPCC Category
  /// # Gen 0 Collections: This counter displays the number of times the generation 0 objects (youngest; most recently allocated) are garbage collected (Gen 0 GC) since the start of the application. Gen 0 GC occurs when the available memory in generation 0 is not sufficient to satisfy an allocation request. This counter is incremented at the end of a Gen 0 GC. Higher generation GCs include all lower generation GCs. This counter is explicitly incremented when a higher generation (Gen 1 or Gen 2) GC occurs. _Global_ counter value is not accurate and should be ignored. This counter displays the last observed value.
  let ``# Gen 0 Collections`` instance =
    { category = ".NET CLR Memory"; counter = "# Gen 0 Collections"; instance = instance }
  /// # Gen 1 Collections: This counter displays the number of times the generation 1 objects are garbage collected since the start of the application. The counter is incremented at the end of a Gen 1 GC. Higher generation GCs include all lower generation GCs. This counter is explicitly incremented when a higher generation (Gen 2) GC occurs. _Global_ counter value is not accurate and should be ignored. This counter displays the last observed value.
  let ``# Gen 1 Collections`` instance =
    { category = ".NET CLR Memory"; counter = "# Gen 1 Collections"; instance = instance }
  /// # Gen 2 Collections: This counter displays the number of times the generation 2 objects (older) are garbage collected since the start of the application. The counter is incremented at the end of a Gen 2 GC (also called full GC). _Global_ counter value is not accurate and should be ignored. This counter displays the last observed value.
  let ``# Gen 2 Collections`` instance =
    { category = ".NET CLR Memory"; counter = "# Gen 2 Collections"; instance = instance }
  /// Promoted Memory from Gen 0: This counter displays the bytes of memory that survive garbage collection (GC) and are promoted from generation 0 to generation 1; objects that are promoted just because they are waiting to be finalized are not included in this counter. This counter displays the value observed at the end of the last GC; its not a cumulative counter.
  let ``Promoted Memory from Gen 0`` instance =
    { category = ".NET CLR Memory"; counter = "Promoted Memory from Gen 0"; instance = instance }
  /// Promoted Memory from Gen 1: This counter displays the bytes of memory that survive garbage collection (GC) and are promoted from generation 1 to generation 2; objects that are promoted just because they are waiting to be finalized are not included in this counter. This counter displays the value observed at the end of the last GC; its not a cumulative counter. This counter is reset to 0 if the last GC was a Gen 0 GC only.
  let ``Promoted Memory from Gen 1`` instance =
    { category = ".NET CLR Memory"; counter = "Promoted Memory from Gen 1"; instance = instance }
  /// Gen 0 Promoted Bytes/Sec: This counter displays the bytes per second that are promoted from generation 0 (youngest) to generation 1; objects that are promoted just because they are waiting to be finalized are not included in this counter. Memory is promoted when it survives a garbage collection. This counter was designed as an indicator of relatively long-lived objects being created per sec. This counter displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``Gen 0 Promoted Bytes/Sec`` instance =
    { category = ".NET CLR Memory"; counter = "Gen 0 Promoted Bytes/Sec"; instance = instance }
  /// Gen 1 Promoted Bytes/Sec: This counter displays the bytes per second that are promoted from generation 1 to generation 2 (oldest); objects that are promoted just because they are waiting to be finalized are not included in this counter. Memory is promoted when it survives a garbage collection. Nothing is promoted from generation 2 since it is the oldest. This counter was designed as an indicator of very long-lived objects being created per sec. This counter displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``Gen 1 Promoted Bytes/Sec`` instance =
    { category = ".NET CLR Memory"; counter = "Gen 1 Promoted Bytes/Sec"; instance = instance }
  /// Promoted Finalization-Memory from Gen 0: This counter displays the bytes of memory that are promoted from generation 0 to generation 1 just because they are waiting to be finalized. This counter displays the value observed at the end of the last GC; its not a cumulative counter.
  let ``Promoted Finalization-Memory from Gen 0`` instance =
    { category = ".NET CLR Memory"; counter = "Promoted Finalization-Memory from Gen 0"; instance = instance }
  /// Process ID: This counter displays the process ID of the CLR process instance being monitored. The value displayed will be 0 until after the first garbage collection.
  let ``Process ID`` instance =
    { category = ".NET CLR Memory"; counter = "Process ID"; instance = instance }
  /// Gen 0 heap size: This counter displays the maximum bytes that can be allocated in generation 0 (Gen 0); its does not indicate the current number of bytes allocated in Gen 0. A Gen 0 GC is triggered when the allocations since the last GC exceed this size. The Gen 0 size is tuned by the Garbage Collector and can change during the execution of the application. At the end of a Gen 0 collection the size of the Gen 0 heap is infact 0 bytes; this counter displays the size (in bytes) of allocations that would trigger the next Gen 0 GC. This counter is updated at the end of a GC; its not updated on every allocation.
  let ``Gen 0 heap size`` instance =
    { category = ".NET CLR Memory"; counter = "Gen 0 heap size"; instance = instance }
  /// Gen 1 heap size: This counter displays the current number of bytes in generation 1 (Gen 1); this counter does not display the maximum size of Gen 1. Objects are not directly allocated in this generation; they are promoted from previous Gen 0 GCs. This counter is updated at the end of a GC; its not updated on every allocation.
  let ``Gen 1 heap size`` instance =
    { category = ".NET CLR Memory"; counter = "Gen 1 heap size"; instance = instance }
  /// Gen 2 heap size: This counter displays the current number of bytes in generation 2 (Gen 2). Objects are not directly allocated in this generation; they are promoted from Gen 1 during previous Gen 1 GCs. This counter is updated at the end of a GC; its not updated on every allocation.
  let ``Gen 2 heap size`` instance =
    { category = ".NET CLR Memory"; counter = "Gen 2 heap size"; instance = instance }
  /// Large Object Heap size: This counter displays the current size of the Large Object Heap in bytes. Objects greater than a threshold are treated as large objects by the Garbage Collector and are directly allocated in a special heap; they are not promoted through the generations. In CLR v1.1 and above this threshold is equal to 85000 bytes. This counter is updated at the end of a GC; it’s not updated on every allocation.
  let ``Large Object Heap size`` instance =
    { category = ".NET CLR Memory"; counter = "Large Object Heap size"; instance = instance }
  /// Finalization Survivors: This counter displays the number of garbage collected objects that survive a collection because they are waiting to be finalized. If these objects hold references to other objects then those objects also survive but are not counted by this counter; the "Promoted Finalization-Memory from Gen 0" and "Promoted Finalization-Memory from Gen 1" counters represent all the memory that survived due to finalization. This counter is not a cumulative counter; its updated at the end of every GC with count of the survivors during that particular GC only. This counter was designed to indicate the extra overhead that the application might incur because of finalization.
  let ``Finalization Survivors`` instance =
    { category = ".NET CLR Memory"; counter = "Finalization Survivors"; instance = instance }
  /// # GC Handles: This counter displays the current number of GC Handles in use. GCHandles are handles to resources external to the CLR and the managed environment. Handles occupy small amounts of memory in the GCHeap but potentially expensive unmanaged resources.
  let ``# GC Handles`` instance =
    { category = ".NET CLR Memory"; counter = "# GC Handles"; instance = instance }
  /// Allocated Bytes/sec: This counter displays the rate of bytes per second allocated on the GC Heap. This counter is updated at the end of every GC; not at each allocation. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``Allocated Bytes/sec`` instance =
    { category = ".NET CLR Memory"; counter = "Allocated Bytes/sec"; instance = instance }
  /// # Induced GC: This counter displays the peak number of times a garbage collection was performed because of an explicit call to GC.Collect. Its a good practice to let the GC tune the frequency of its collections.
  let ``# Induced GC`` instance =
    { category = ".NET CLR Memory"; counter = "# Induced GC"; instance = instance }
  /// % Time in GC: % Time in GC is the percentage of elapsed time that was spent in performing a garbage collection (GC) since the last GC cycle. This counter is usually an indicator of the work done by the Garbage Collector on behalf of the application to collect and compact memory. This counter is updated only at the end of every GC and the counter value reflects the last observed value; its not an average.
  let ``% Time in GC`` instance =
    { category = ".NET CLR Memory"; counter = "% Time in GC"; instance = instance }
  /// Not Displayed: Not Displayed.
  let ``Not Displayed`` instance =
    { category = ".NET CLR Memory"; counter = "Not Displayed"; instance = instance }
  /// # Bytes in all Heaps: This counter is the sum of four other counters; Gen 0 Heap Size; Gen 1 Heap Size; Gen 2 Heap Size and the Large Object Heap Size. This counter indicates the current memory allocated in bytes on the GC Heaps.
  let ``# Bytes in all Heaps`` instance =
    { category = ".NET CLR Memory"; counter = "# Bytes in all Heaps"; instance = instance }
  /// # Total committed Bytes: This counter displays the amount of virtual memory (in bytes) currently committed by the Garbage Collector. (Committed memory is the physical memory for which space has been reserved on the disk paging file).
  let ``# Total committed Bytes`` instance =
    { category = ".NET CLR Memory"; counter = "# Total committed Bytes"; instance = instance }
  /// # Total reserved Bytes: This counter displays the amount of virtual memory (in bytes) currently reserved by the Garbage Collector. (Reserved memory is the virtual memory space reserved for the application but no disk or main memory pages have been used.)
  let ``# Total reserved Bytes`` instance =
    { category = ".NET CLR Memory"; counter = "# Total reserved Bytes"; instance = instance }
  /// # of Pinned Objects: This counter displays the number of pinned objects encountered in the last GC. This counter tracks the pinned objects only in the heaps that were garbage collected e.g. a Gen 0 GC would cause enumeration of pinned objects in the generation 0 heap only. A pinned object is one that the Garbage Collector cannot move in memory.
  let ``# of Pinned Objects`` instance =
    { category = ".NET CLR Memory"; counter = "# of Pinned Objects"; instance = instance }
  /// # of Sink Blocks in use: This counter displays the current number of sync blocks in use. Sync blocks are per-object data structures allocated for storing synchronization information. Sync blocks hold weak references to managed objects and need to be scanned by the Garbage Collector. Sync blocks are not limited to storing synchronization information and can also store COM interop metadata. This counter was designed to indicate performance problems with heavy use of synchronization primitives.
  let ``# of Sink Blocks in use`` instance =
    { category = ".NET CLR Memory"; counter = "# of Sink Blocks in use"; instance = instance }

  let allCounters =
    [ ``# Gen 0 Collections``
      ``# Gen 1 Collections``
      ``# Gen 2 Collections``
      ``Promoted Memory from Gen 0``
      ``Promoted Memory from Gen 1``
      ``Gen 0 Promoted Bytes/Sec``
      ``Gen 1 Promoted Bytes/Sec``
      ``Promoted Finalization-Memory from Gen 0``
      ``Process ID``
      ``Gen 0 heap size``
      ``Gen 1 heap size``
      ``Gen 2 heap size``
      ``Large Object Heap size``
      ``Finalization Survivors``
      ``# GC Handles``
      ``Allocated Bytes/sec``
      ``# Induced GC``
      ``% Time in GC``
      ``Not Displayed``
      ``# Bytes in all Heaps``
      ``# Total committed Bytes``
      ``# Total reserved Bytes``
      ``# of Pinned Objects``
      ``# of Sink Blocks in use``
    ]

/// .NET CLR Networking: Help not available.
///
/// This performance counter does not have instance based counters
module ``_NET CLR Networking`` =

  [<Literal>]
  let Category = ".NET CLR Networking"

  let PCC = getPCC Category
  /// Connections Established: 
  let ``Connections Established`` instance =
    { category = ".NET CLR Networking"; counter = "Connections Established"; instance = instance }
  /// Bytes Received: 
  let ``Bytes Received`` instance =
    { category = ".NET CLR Networking"; counter = "Bytes Received"; instance = instance }
  /// Bytes Sent: 
  let ``Bytes Sent`` instance =
    { category = ".NET CLR Networking"; counter = "Bytes Sent"; instance = instance }
  /// Datagrams Received: 
  let ``Datagrams Received`` instance =
    { category = ".NET CLR Networking"; counter = "Datagrams Received"; instance = instance }
  /// Datagrams Sent: 
  let ``Datagrams Sent`` instance =
    { category = ".NET CLR Networking"; counter = "Datagrams Sent"; instance = instance }

  let allCounters =
    [ ``Connections Established``
      ``Bytes Received``
      ``Bytes Sent``
      ``Datagrams Received``
      ``Datagrams Sent``
    ]

/// .NET CLR Networking 4.0.0.0: Counters for classes in the System.Net namespace.
///
/// This performance counter does not have instance based counters
module ``_NET CLR Networking 4_0_0_0`` =

  [<Literal>]
  let Category = ".NET CLR Networking 4.0.0.0"

  let PCC = getPCC Category
  /// Connections Established: 
  let ``Connections Established`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "Connections Established"; instance = instance }
  /// Bytes Received: 
  let ``Bytes Received`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "Bytes Received"; instance = instance }
  /// Bytes Sent: 
  let ``Bytes Sent`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "Bytes Sent"; instance = instance }
  /// Datagrams Received: 
  let ``Datagrams Received`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "Datagrams Received"; instance = instance }
  /// Datagrams Sent: 
  let ``Datagrams Sent`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "Datagrams Sent"; instance = instance }
  /// HttpWebRequests Created/Sec: 
  let ``HttpWebRequests Created/Sec`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "HttpWebRequests Created/Sec"; instance = instance }
  /// HttpWebRequests Average Lifetime: 
  let ``HttpWebRequests Average Lifetime`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "HttpWebRequests Average Lifetime"; instance = instance }
  /// HttpWebRequests Average Lifetime Base: 
  let ``HttpWebRequests Average Lifetime Base`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "HttpWebRequests Average Lifetime Base"; instance = instance }
  /// HttpWebRequests Queued/Sec: 
  let ``HttpWebRequests Queued/Sec`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "HttpWebRequests Queued/Sec"; instance = instance }
  /// HttpWebRequests Average Queue Time: 
  let ``HttpWebRequests Average Queue Time`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "HttpWebRequests Average Queue Time"; instance = instance }
  /// HttpWebRequests Average Queue Time Base: 
  let ``HttpWebRequests Average Queue Time Base`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "HttpWebRequests Average Queue Time Base"; instance = instance }
  /// HttpWebRequests Aborted/Sec: 
  let ``HttpWebRequests Aborted/Sec`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "HttpWebRequests Aborted/Sec"; instance = instance }
  /// HttpWebRequests Failed/Sec: 
  let ``HttpWebRequests Failed/Sec`` instance =
    { category = ".NET CLR Networking 4.0.0.0"; counter = "HttpWebRequests Failed/Sec"; instance = instance }

  let allCounters =
    [ ``Connections Established``
      ``Bytes Received``
      ``Bytes Sent``
      ``Datagrams Received``
      ``Datagrams Sent``
      ``HttpWebRequests Created/Sec``
      ``HttpWebRequests Average Lifetime``
      ``HttpWebRequests Average Lifetime Base``
      ``HttpWebRequests Queued/Sec``
      ``HttpWebRequests Average Queue Time``
      ``HttpWebRequests Average Queue Time Base``
      ``HttpWebRequests Aborted/Sec``
      ``HttpWebRequests Failed/Sec``
    ]

/// .NET CLR Remoting: Stats for CLR Remoting.
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR Remoting`` =

  [<Literal>]
  let Category = ".NET CLR Remoting"

  let PCC = getPCC Category
  /// Remote Calls/sec: This counter displays the number of remote procedure calls invoked per second. A remote procedure call is a call on any object outside the caller;s AppDomain. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``Remote Calls/sec`` instance =
    { category = ".NET CLR Remoting"; counter = "Remote Calls/sec"; instance = instance }
  /// Total Remote Calls: This counter displays the total number of remote procedure calls invoked since the start of this application. A remote procedure call is a call on any object outside the caller;s AppDomain.
  let ``Total Remote Calls`` instance =
    { category = ".NET CLR Remoting"; counter = "Total Remote Calls"; instance = instance }
  /// Channels: This counter displays the total number of remoting channels registered across all AppDomains since the start of the application. Channels are used to transport messages to and from remote objects.
  let ``Channels`` instance =
    { category = ".NET CLR Remoting"; counter = "Channels"; instance = instance }
  /// Context Proxies: This counter displays the total number of remoting proxy objects created in this process since the start of the process. Proxy object acts as a representative of the remote objects and ensures that all calls made on the proxy are forwarded to the correct remote object instance.
  let ``Context Proxies`` instance =
    { category = ".NET CLR Remoting"; counter = "Context Proxies"; instance = instance }
  /// Context-Bound Classes Loaded: This counter displays the current number of context-bound classes loaded. Classes that can be bound to a context are called context-bound classes; context-bound classes are marked with Context Attributes which provide usage rules for synchronization; thread affinity; transactions etc.
  let ``Context-Bound Classes Loaded`` instance =
    { category = ".NET CLR Remoting"; counter = "Context-Bound Classes Loaded"; instance = instance }
  /// Context-Bound Objects Alloc / sec: This counter displays the number of context-bound objects allocated per second. Instances of classes that can be bound to a context are called context-bound objects; context-bound classes are marked with Context Attributes which provide usage rules for synchronization; thread affinity; transactions etc. This counter is not an average over time; it displays the difference between the values observed in the last two samples divided by the duration of the sample interval.
  let ``Context-Bound Objects Alloc / sec`` instance =
    { category = ".NET CLR Remoting"; counter = "Context-Bound Objects Alloc / sec"; instance = instance }
  /// Contexts: This counter displays the current number of remoting contexts in the application. A context is a boundary containing a collection of objects with the same usage rules like synchronization; thread affinity; transactions etc.
  let ``Contexts`` instance =
    { category = ".NET CLR Remoting"; counter = "Contexts"; instance = instance }

  let allCounters =
    [ ``Remote Calls/sec``
      ``Total Remote Calls``
      ``Channels``
      ``Context Proxies``
      ``Context-Bound Classes Loaded``
      ``Context-Bound Objects Alloc / sec``
      ``Contexts``
    ]

/// .NET CLR Security: Stats for CLR Security.
///
/// This performance counter does not have non-instance based counters
module ``_NET CLR Security`` =

  [<Literal>]
  let Category = ".NET CLR Security"

  let PCC = getPCC Category
  /// Total Runtime Checks: This counter displays the total number of runtime Code Access Security (CAS) checks performed since the start of the application. Runtime CAS checks are performed when a caller makes a call to a callee demanding a particular permission; the runtime check is made on every call by the caller; the check is done by examining the current thread stack of the caller. This counter used together with "Stack Walk Depth" is indicative of performance penalty for security checks.
  let ``Total Runtime Checks`` instance =
    { category = ".NET CLR Security"; counter = "Total Runtime Checks"; instance = instance }
  /// % Time Sig. Authenticating: Reserved for future use.
  let ``% Time Sig. Authenticating`` instance =
    { category = ".NET CLR Security"; counter = "% Time Sig. Authenticating"; instance = instance }
  /// # Link Time Checks: This counter displays the total number of linktime Code Access Security (CAS) checks since the start of the application. Linktime CAS checks are performed when a caller makes a call to a callee demanding a particular permission at JIT compile time; linktime check is performed once per caller. This count is not indicative of serious performance issues; its indicative of the security system activity.
  let ``# Link Time Checks`` instance =
    { category = ".NET CLR Security"; counter = "# Link Time Checks"; instance = instance }
  /// % Time in RT checks: This counter displays the percentage of elapsed time spent in performing runtime Code Access Security (CAS) checks since the last such check. CAS allows code to be trusted to varying degrees and enforces these varying levels of trust depending on code identity. This counter is updated at the end of a runtime security check; it represents the last observed value; its not an average.
  let ``% Time in RT checks`` instance =
    { category = ".NET CLR Security"; counter = "% Time in RT checks"; instance = instance }
  /// Not Displayed: Not Displayed.
  let ``Not Displayed`` instance =
    { category = ".NET CLR Security"; counter = "Not Displayed"; instance = instance }
  /// Stack Walk Depth: This counter displays the depth of the stack during that last runtime Code Access Security check. Runtime Code Access Security check is performed by crawling the stack. This counter is not an average; it just displays the last observed value.
  let ``Stack Walk Depth`` instance =
    { category = ".NET CLR Security"; counter = "Stack Walk Depth"; instance = instance }

  let allCounters =
    [ ``Total Runtime Checks``
      ``% Time Sig. Authenticating``
      ``# Link Time Checks``
      ``% Time in RT checks``
      ``Not Displayed``
      ``Stack Walk Depth``
    ]

/// .NET Data Provider for Oracle: Counters for System.Data.OracleClient
///
/// This performance counter does not have instance based counters
module ``_NET Data Provider for Oracle`` =

  [<Literal>]
  let Category = ".NET Data Provider for Oracle"

  let PCC = getPCC Category
  /// HardConnectsPerSecond: 
  let ``HardConnectsPerSecond`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "HardConnectsPerSecond"; instance = instance }
  /// HardDisconnectsPerSecond: 
  let ``HardDisconnectsPerSecond`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "HardDisconnectsPerSecond"; instance = instance }
  /// SoftConnectsPerSecond: 
  let ``SoftConnectsPerSecond`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "SoftConnectsPerSecond"; instance = instance }
  /// SoftDisconnectsPerSecond: 
  let ``SoftDisconnectsPerSecond`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "SoftDisconnectsPerSecond"; instance = instance }
  /// NumberOfNonPooledConnections: 
  let ``NumberOfNonPooledConnections`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "NumberOfNonPooledConnections"; instance = instance }
  /// NumberOfPooledConnections: 
  let ``NumberOfPooledConnections`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "NumberOfPooledConnections"; instance = instance }
  /// NumberOfActiveConnectionPoolGroups: 
  let ``NumberOfActiveConnectionPoolGroups`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "NumberOfActiveConnectionPoolGroups"; instance = instance }
  /// NumberOfInactiveConnectionPoolGroups: 
  let ``NumberOfInactiveConnectionPoolGroups`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "NumberOfInactiveConnectionPoolGroups"; instance = instance }
  /// NumberOfActiveConnectionPools: 
  let ``NumberOfActiveConnectionPools`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "NumberOfActiveConnectionPools"; instance = instance }
  /// NumberOfInactiveConnectionPools: 
  let ``NumberOfInactiveConnectionPools`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "NumberOfInactiveConnectionPools"; instance = instance }
  /// NumberOfActiveConnections: 
  let ``NumberOfActiveConnections`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "NumberOfActiveConnections"; instance = instance }
  /// NumberOfFreeConnections: 
  let ``NumberOfFreeConnections`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "NumberOfFreeConnections"; instance = instance }
  /// NumberOfStasisConnections: 
  let ``NumberOfStasisConnections`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "NumberOfStasisConnections"; instance = instance }
  /// NumberOfReclaimedConnections: 
  let ``NumberOfReclaimedConnections`` instance =
    { category = ".NET Data Provider for Oracle"; counter = "NumberOfReclaimedConnections"; instance = instance }

  let allCounters =
    [ ``HardConnectsPerSecond``
      ``HardDisconnectsPerSecond``
      ``SoftConnectsPerSecond``
      ``SoftDisconnectsPerSecond``
      ``NumberOfNonPooledConnections``
      ``NumberOfPooledConnections``
      ``NumberOfActiveConnectionPoolGroups``
      ``NumberOfInactiveConnectionPoolGroups``
      ``NumberOfActiveConnectionPools``
      ``NumberOfInactiveConnectionPools``
      ``NumberOfActiveConnections``
      ``NumberOfFreeConnections``
      ``NumberOfStasisConnections``
      ``NumberOfReclaimedConnections``
    ]

/// .NET Data Provider for SqlServer: Counters for System.Data.SqlClient
///
/// This performance counter does not have non-instance based counters
module ``_NET Data Provider for SqlServer`` =

  [<Literal>]
  let Category = ".NET Data Provider for SqlServer"

  let PCC = getPCC Category
  /// HardConnectsPerSecond: The number of actual connections per second that are being made to servers
  let ``HardConnectsPerSecond`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "HardConnectsPerSecond"; instance = instance }
  /// HardDisconnectsPerSecond: The number of actual disconnects per second that are being made to servers
  let ``HardDisconnectsPerSecond`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "HardDisconnectsPerSecond"; instance = instance }
  /// SoftConnectsPerSecond: The number of connections we get from the pool per second
  let ``SoftConnectsPerSecond`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "SoftConnectsPerSecond"; instance = instance }
  /// SoftDisconnectsPerSecond: The number of connections we return to the pool per second
  let ``SoftDisconnectsPerSecond`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "SoftDisconnectsPerSecond"; instance = instance }
  /// NumberOfNonPooledConnections: The number of connections that are not using connection pooling
  let ``NumberOfNonPooledConnections`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "NumberOfNonPooledConnections"; instance = instance }
  /// NumberOfPooledConnections: The number of connections that are managed by the connection pooler
  let ``NumberOfPooledConnections`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "NumberOfPooledConnections"; instance = instance }
  /// NumberOfActiveConnectionPoolGroups: The number of unique connection strings
  let ``NumberOfActiveConnectionPoolGroups`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "NumberOfActiveConnectionPoolGroups"; instance = instance }
  /// NumberOfInactiveConnectionPoolGroups: The number of unique connection strings waiting for pruning
  let ``NumberOfInactiveConnectionPoolGroups`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "NumberOfInactiveConnectionPoolGroups"; instance = instance }
  /// NumberOfActiveConnectionPools: The number of active connection pools
  let ``NumberOfActiveConnectionPools`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "NumberOfActiveConnectionPools"; instance = instance }
  /// NumberOfInactiveConnectionPools: The number of inactive connection pools
  let ``NumberOfInactiveConnectionPools`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "NumberOfInactiveConnectionPools"; instance = instance }
  /// NumberOfActiveConnections: The number of connections currently in-use
  let ``NumberOfActiveConnections`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "NumberOfActiveConnections"; instance = instance }
  /// NumberOfFreeConnections: The number of connections currently available for use
  let ``NumberOfFreeConnections`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "NumberOfFreeConnections"; instance = instance }
  /// NumberOfStasisConnections: The number of connections currently waiting to be made ready for use
  let ``NumberOfStasisConnections`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "NumberOfStasisConnections"; instance = instance }
  /// NumberOfReclaimedConnections: The number of connections we reclaim from GCed external connections
  let ``NumberOfReclaimedConnections`` instance =
    { category = ".NET Data Provider for SqlServer"; counter = "NumberOfReclaimedConnections"; instance = instance }

  let allCounters =
    [ ``HardConnectsPerSecond``
      ``HardDisconnectsPerSecond``
      ``SoftConnectsPerSecond``
      ``SoftDisconnectsPerSecond``
      ``NumberOfNonPooledConnections``
      ``NumberOfPooledConnections``
      ``NumberOfActiveConnectionPoolGroups``
      ``NumberOfInactiveConnectionPoolGroups``
      ``NumberOfActiveConnectionPools``
      ``NumberOfInactiveConnectionPools``
      ``NumberOfActiveConnections``
      ``NumberOfFreeConnections``
      ``NumberOfStasisConnections``
      ``NumberOfReclaimedConnections``
    ]

/// APP_POOL_WAS: This counter set exposes WAS related counters for IIS Application Pools.
///
/// This performance counter does not have non-instance based counters
module ``APP_POOL_WAS`` =

  [<Literal>]
  let Category = "APP_POOL_WAS"

  let PCC = getPCC Category
  /// Current Worker Processes: The current number of worker processes that are running in the application pool.
  let ``Current Worker Processes`` instance =
    { category = "APP_POOL_WAS"; counter = "Current Worker Processes"; instance = instance }
  /// Maximum Worker Processes: The maximum number of worker processes that have been created for the application pool since Windows Process Activation Service (WAS) started.
  let ``Maximum Worker Processes`` instance =
    { category = "APP_POOL_WAS"; counter = "Maximum Worker Processes"; instance = instance }
  /// Total Application Pool Recycles: The number of times that the application pool has been recycled since Windows Process Activation Service (WAS) started.
  let ``Total Application Pool Recycles`` instance =
    { category = "APP_POOL_WAS"; counter = "Total Application Pool Recycles"; instance = instance }
  /// Current Application Pool Uptime: The length of time, in seconds, that the application pool has been running since it was started.
  let ``Current Application Pool Uptime`` instance =
    { category = "APP_POOL_WAS"; counter = "Current Application Pool Uptime"; instance = instance }
  /// Total Application Pool Uptime: The length of time, in seconds, that the application pool has been running since Windows Process Activation Service (WAS) started.
  let ``Total Application Pool Uptime`` instance =
    { category = "APP_POOL_WAS"; counter = "Total Application Pool Uptime"; instance = instance }
  /// Recent Worker Process Failures: The number of times that worker processes for the application pool failed during the rapid-fail protection interval.
  let ``Recent Worker Process Failures`` instance =
    { category = "APP_POOL_WAS"; counter = "Recent Worker Process Failures"; instance = instance }
  /// Total Worker Process Failures: The number of times that worker processes have crashed since the application pool was started.
  let ``Total Worker Process Failures`` instance =
    { category = "APP_POOL_WAS"; counter = "Total Worker Process Failures"; instance = instance }
  /// Current Application Pool State: The current status of the application pool (1 - Uninitialized, 2 - Initialized, 3 - Running, 4 - Disabling, 5 - Disabled, 6 - Shutdown Pending, 7 - Delete Pending).
  let ``Current Application Pool State`` instance =
    { category = "APP_POOL_WAS"; counter = "Current Application Pool State"; instance = instance }
  /// Total Worker Process Startup Failures: The number of times that Windows Process Activation Service (WAS) failed to start a worker process.
  let ``Total Worker Process Startup Failures`` instance =
    { category = "APP_POOL_WAS"; counter = "Total Worker Process Startup Failures"; instance = instance }
  /// Total Worker Process Shutdown Failures: The number of times that Windows Process Activation Service (WAS) failed to shut down a worker process.
  let ``Total Worker Process Shutdown Failures`` instance =
    { category = "APP_POOL_WAS"; counter = "Total Worker Process Shutdown Failures"; instance = instance }
  /// Total Worker Process Ping Failures: The number of times that Windows Process Activation Service (WAS) did not receive a response to ping messages sent to a worker process.
  let ``Total Worker Process Ping Failures`` instance =
    { category = "APP_POOL_WAS"; counter = "Total Worker Process Ping Failures"; instance = instance }
  /// Time Since Last Worker Process Failure: The length of time, in seconds, since the last worker process failure occurred for the application pool.
  let ``Time Since Last Worker Process Failure`` instance =
    { category = "APP_POOL_WAS"; counter = "Time Since Last Worker Process Failure"; instance = instance }
  /// Total Worker Processes Created: The number of worker processes created for the application pool since Windows Process Activation Service (WAS) started.
  let ``Total Worker Processes Created`` instance =
    { category = "APP_POOL_WAS"; counter = "Total Worker Processes Created"; instance = instance }

  let allCounters =
    [ ``Current Worker Processes``
      ``Maximum Worker Processes``
      ``Total Application Pool Recycles``
      ``Current Application Pool Uptime``
      ``Total Application Pool Uptime``
      ``Recent Worker Process Failures``
      ``Total Worker Process Failures``
      ``Current Application Pool State``
      ``Total Worker Process Startup Failures``
      ``Total Worker Process Shutdown Failures``
      ``Total Worker Process Ping Failures``
      ``Time Since Last Worker Process Failure``
      ``Total Worker Processes Created``
    ]

/// ASP.NET: ASP.NET global performance counters
///
/// This performance counter does not have instance based counters
module ``ASP_NET`` =

  [<Literal>]
  let Category = "ASP.NET"

  let PCC = getPCC Category
  /// Application Restarts: Number of times the application has been restarted during the web server's lifetime.
  let ``Application Restarts`` =
    { category = "ASP.NET"; counter = "Application Restarts"; instance = NotApplicable }
  /// Applications Running: Number of currently running web applications.
  let ``Applications Running`` =
    { category = "ASP.NET"; counter = "Applications Running"; instance = NotApplicable }
  /// Requests Disconnected: The number of requests disconnected due to communication errors or user terminated.
  let ``Requests Disconnected`` =
    { category = "ASP.NET"; counter = "Requests Disconnected"; instance = NotApplicable }
  /// Request Execution Time: The number of milliseconds that it took to execute the most recent request.
  let ``Request Execution Time`` =
    { category = "ASP.NET"; counter = "Request Execution Time"; instance = NotApplicable }
  /// Requests Rejected: The number of requests rejected because the request queue was full.
  let ``Requests Rejected`` =
    { category = "ASP.NET"; counter = "Requests Rejected"; instance = NotApplicable }
  /// Requests Queued: The number of requests waiting to be processed.
  let ``Requests Queued`` =
    { category = "ASP.NET"; counter = "Requests Queued"; instance = NotApplicable }
  /// Worker Processes Running: Number of worker processes running on the machine.
  let ``Worker Processes Running`` =
    { category = "ASP.NET"; counter = "Worker Processes Running"; instance = NotApplicable }
  /// Worker Process Restarts: Number of times a worker process has restarted on the machine.
  let ``Worker Process Restarts`` =
    { category = "ASP.NET"; counter = "Worker Process Restarts"; instance = NotApplicable }
  /// Request Wait Time: The number of milliseconds the most recent request was waiting in the queue.
  let ``Request Wait Time`` =
    { category = "ASP.NET"; counter = "Request Wait Time"; instance = NotApplicable }
  /// State Server Sessions Active: The current number of sessions currently active.
  let ``State Server Sessions Active`` =
    { category = "ASP.NET"; counter = "State Server Sessions Active"; instance = NotApplicable }
  /// State Server Sessions Abandoned: The number of sessions that have been explicitly abandoned.
  let ``State Server Sessions Abandoned`` =
    { category = "ASP.NET"; counter = "State Server Sessions Abandoned"; instance = NotApplicable }
  /// State Server Sessions Timed Out: The number of sessions timed out.
  let ``State Server Sessions Timed Out`` =
    { category = "ASP.NET"; counter = "State Server Sessions Timed Out"; instance = NotApplicable }
  /// State Server Sessions Total: The number of sessions total.
  let ``State Server Sessions Total`` =
    { category = "ASP.NET"; counter = "State Server Sessions Total"; instance = NotApplicable }
  /// Requests Current: The current number of requests, including those that are queued, currently executing, or waiting to be written to the client.  Under the ASP.NET process model, when this counter exceeds the requestQueueLimit defined in the processModel configuration section, ASP.NET will begin rejecting requests.
  let ``Requests Current`` =
    { category = "ASP.NET"; counter = "Requests Current"; instance = NotApplicable }
  /// Audit Success Events Raised: Number of audit successes in the application since it was started.
  let ``Audit Success Events Raised`` =
    { category = "ASP.NET"; counter = "Audit Success Events Raised"; instance = NotApplicable }
  /// Audit Failure Events Raised: Number of audit failures in the application since it was started.
  let ``Audit Failure Events Raised`` =
    { category = "ASP.NET"; counter = "Audit Failure Events Raised"; instance = NotApplicable }
  /// Error Events Raised: Number of error events raised since the application was started.
  let ``Error Events Raised`` =
    { category = "ASP.NET"; counter = "Error Events Raised"; instance = NotApplicable }
  /// Request Error Events Raised: Number of runtime error events raised since the application was started.
  let ``Request Error Events Raised`` =
    { category = "ASP.NET"; counter = "Request Error Events Raised"; instance = NotApplicable }
  /// Infrastructure Error Events Raised: Number of HTTP error events raised since the application was started.
  let ``Infrastructure Error Events Raised`` =
    { category = "ASP.NET"; counter = "Infrastructure Error Events Raised"; instance = NotApplicable }
  /// Requests In Native Queue: Requests queued because the concurrency limits have been exceeded.
  let ``Requests In Native Queue`` =
    { category = "ASP.NET"; counter = "Requests In Native Queue"; instance = NotApplicable }

  let allCounters =
    [ ``Application Restarts``
      ``Applications Running``
      ``Requests Disconnected``
      ``Request Execution Time``
      ``Requests Rejected``
      ``Requests Queued``
      ``Worker Processes Running``
      ``Worker Process Restarts``
      ``Request Wait Time``
      ``State Server Sessions Active``
      ``State Server Sessions Abandoned``
      ``State Server Sessions Timed Out``
      ``State Server Sessions Total``
      ``Requests Current``
      ``Audit Success Events Raised``
      ``Audit Failure Events Raised``
      ``Error Events Raised``
      ``Request Error Events Raised``
      ``Infrastructure Error Events Raised``
      ``Requests In Native Queue``
    ]

/// ASP.NET Applications: ASP.NET application performance counters
///
/// This performance counter does not have non-instance based counters
module ``ASP_NET Applications`` =

  [<Literal>]
  let Category = "ASP.NET Applications"

  let PCC = getPCC Category
  /// Anonymous Requests: Number of requests utilizing anonymous authentication.
  let ``Anonymous Requests`` instance =
    { category = "ASP.NET Applications"; counter = "Anonymous Requests"; instance = instance }
  /// Anonymous Requests/Sec: Number of Authentication Anonymous Requests/Sec
  let ``Anonymous Requests/Sec`` instance =
    { category = "ASP.NET Applications"; counter = "Anonymous Requests/Sec"; instance = instance }
  /// Cache Total Entries: Total number of entries within the cache (both internal and user added)
  let ``Cache Total Entries`` instance =
    { category = "ASP.NET Applications"; counter = "Cache Total Entries"; instance = instance }
  /// Cache Total Turnover Rate: Number of additions and removals to the total cache per second.
  let ``Cache Total Turnover Rate`` instance =
    { category = "ASP.NET Applications"; counter = "Cache Total Turnover Rate"; instance = instance }
  /// Cache Total Hits: Total number of hits from the cache.
  let ``Cache Total Hits`` instance =
    { category = "ASP.NET Applications"; counter = "Cache Total Hits"; instance = instance }
  /// Cache Total Misses: Total number of cache misses.
  let ``Cache Total Misses`` instance =
    { category = "ASP.NET Applications"; counter = "Cache Total Misses"; instance = instance }
  /// Cache Total Hit Ratio: Ratio of hits from all cache calls.
  let ``Cache Total Hit Ratio`` instance =
    { category = "ASP.NET Applications"; counter = "Cache Total Hit Ratio"; instance = instance }
  /// Cache Total Hit Ratio Base: Cache Total Hit Ratio Base
  let ``Cache Total Hit Ratio Base`` instance =
    { category = "ASP.NET Applications"; counter = "Cache Total Hit Ratio Base"; instance = instance }
  /// Cache API Entries: Total number of entries within the cache added by the user.
  let ``Cache API Entries`` instance =
    { category = "ASP.NET Applications"; counter = "Cache API Entries"; instance = instance }
  /// Cache API Turnover Rate: Number of additions and removals to the API cache per second.
  let ``Cache API Turnover Rate`` instance =
    { category = "ASP.NET Applications"; counter = "Cache API Turnover Rate"; instance = instance }
  /// Cache API Hits: Number of cache hits from user code.
  let ``Cache API Hits`` instance =
    { category = "ASP.NET Applications"; counter = "Cache API Hits"; instance = instance }
  /// Cache API Misses: Number of cache misses called from user code.
  let ``Cache API Misses`` instance =
    { category = "ASP.NET Applications"; counter = "Cache API Misses"; instance = instance }
  /// Cache API Hit Ratio: Ratio of hits called from user code.
  let ``Cache API Hit Ratio`` instance =
    { category = "ASP.NET Applications"; counter = "Cache API Hit Ratio"; instance = instance }
  /// Cache API Hit Ratio Base: Cache API Hit Ratio Base
  let ``Cache API Hit Ratio Base`` instance =
    { category = "ASP.NET Applications"; counter = "Cache API Hit Ratio Base"; instance = instance }
  /// Output Cache Entries: Current number of entries in the output cache.
  let ``Output Cache Entries`` instance =
    { category = "ASP.NET Applications"; counter = "Output Cache Entries"; instance = instance }
  /// Output Cache Turnover Rate: Number of additions and removals to the output cache per second.
  let ``Output Cache Turnover Rate`` instance =
    { category = "ASP.NET Applications"; counter = "Output Cache Turnover Rate"; instance = instance }
  /// Output Cache Hits: Total number of output cacheable requests served from the output cache.
  let ``Output Cache Hits`` instance =
    { category = "ASP.NET Applications"; counter = "Output Cache Hits"; instance = instance }
  /// Output Cache Misses: Total number of output cacheable requests not served from the output cache.
  let ``Output Cache Misses`` instance =
    { category = "ASP.NET Applications"; counter = "Output Cache Misses"; instance = instance }
  /// Output Cache Hit Ratio: Ratio of hits to requests for output cacheable requests.
  let ``Output Cache Hit Ratio`` instance =
    { category = "ASP.NET Applications"; counter = "Output Cache Hit Ratio"; instance = instance }
  /// Output Cache Hit Ratio Base: Output Cache Hit Ratio Base
  let ``Output Cache Hit Ratio Base`` instance =
    { category = "ASP.NET Applications"; counter = "Output Cache Hit Ratio Base"; instance = instance }
  /// Compilations Total: Number of .asax, .ascx, .ashx, .asmx, or .aspx source files dynamically compiled.
  let ``Compilations Total`` instance =
    { category = "ASP.NET Applications"; counter = "Compilations Total"; instance = instance }
  /// Debugging Requests: Number of debugging requests processed.
  let ``Debugging Requests`` instance =
    { category = "ASP.NET Applications"; counter = "Debugging Requests"; instance = instance }
  /// Errors During Preprocessing: Number of errors that have occurred during parsing and configuration.
  let ``Errors During Preprocessing`` instance =
    { category = "ASP.NET Applications"; counter = "Errors During Preprocessing"; instance = instance }
  /// Errors During Compilation: Number of errors that have occurred during compilation.
  let ``Errors During Compilation`` instance =
    { category = "ASP.NET Applications"; counter = "Errors During Compilation"; instance = instance }
  /// Errors During Execution: Number of errors that have occurred during the processing of a request.
  let ``Errors During Execution`` instance =
    { category = "ASP.NET Applications"; counter = "Errors During Execution"; instance = instance }
  /// Errors Unhandled During Execution: Number of errors not handled by user code, but by the default error handler.
  let ``Errors Unhandled During Execution`` instance =
    { category = "ASP.NET Applications"; counter = "Errors Unhandled During Execution"; instance = instance }
  /// Errors Unhandled During Execution/Sec: Rate of unhandled errors.
  let ``Errors Unhandled During Execution/Sec`` instance =
    { category = "ASP.NET Applications"; counter = "Errors Unhandled During Execution/Sec"; instance = instance }
  /// Errors Total: Total number of errors occurred.
  let ``Errors Total`` instance =
    { category = "ASP.NET Applications"; counter = "Errors Total"; instance = instance }
  /// Errors Total/Sec: Rate of errors occurred.
  let ``Errors Total/Sec`` instance =
    { category = "ASP.NET Applications"; counter = "Errors Total/Sec"; instance = instance }
  /// Pipeline Instance Count: Number of active pipeline instances.
  let ``Pipeline Instance Count`` instance =
    { category = "ASP.NET Applications"; counter = "Pipeline Instance Count"; instance = instance }
  /// Request Bytes In Total: The total size, in bytes, of all requests.
  let ``Request Bytes In Total`` instance =
    { category = "ASP.NET Applications"; counter = "Request Bytes In Total"; instance = instance }
  /// Request Bytes Out Total: The total size, in bytes, of responses sent to a client.  This does not include standard HTTP response headers.
  let ``Request Bytes Out Total`` instance =
    { category = "ASP.NET Applications"; counter = "Request Bytes Out Total"; instance = instance }
  /// Requests Executing: The number of requests currently executing.
  let ``Requests Executing`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Executing"; instance = instance }
  /// Requests Failed: Total number of failed requests.
  let ``Requests Failed`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Failed"; instance = instance }
  /// Requests Not Found: The number of requests for resources that were not found.
  let ``Requests Not Found`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Not Found"; instance = instance }
  /// Requests Not Authorized: Number of requests failed due to unauthorized access.
  let ``Requests Not Authorized`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Not Authorized"; instance = instance }
  /// Requests In Application Queue: The number of requests in the application request queue.
  let ``Requests In Application Queue`` instance =
    { category = "ASP.NET Applications"; counter = "Requests In Application Queue"; instance = instance }
  /// Requests Timed Out: The number of requests that timed out.
  let ``Requests Timed Out`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Timed Out"; instance = instance }
  /// Requests Succeeded: The number of requests that executed successfully.
  let ``Requests Succeeded`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Succeeded"; instance = instance }
  /// Requests Total: The total number of requests since the application was started.
  let ``Requests Total`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Total"; instance = instance }
  /// Requests/Sec: The number of requests executed per second.
  let ``Requests/Sec`` instance =
    { category = "ASP.NET Applications"; counter = "Requests/Sec"; instance = instance }
  /// Sessions Active: The current number of sessions currently active.
  let ``Sessions Active`` instance =
    { category = "ASP.NET Applications"; counter = "Sessions Active"; instance = instance }
  /// Sessions Abandoned: The number of sessions that have been explicitly abandoned.
  let ``Sessions Abandoned`` instance =
    { category = "ASP.NET Applications"; counter = "Sessions Abandoned"; instance = instance }
  /// Sessions Timed Out: The number of sessions timed out.
  let ``Sessions Timed Out`` instance =
    { category = "ASP.NET Applications"; counter = "Sessions Timed Out"; instance = instance }
  /// Sessions Total: Total number of sessions since the application was started.
  let ``Sessions Total`` instance =
    { category = "ASP.NET Applications"; counter = "Sessions Total"; instance = instance }
  /// Transactions Aborted: The number of transactions aborted.
  let ``Transactions Aborted`` instance =
    { category = "ASP.NET Applications"; counter = "Transactions Aborted"; instance = instance }
  /// Transactions Committed: The number of transactions committed.
  let ``Transactions Committed`` instance =
    { category = "ASP.NET Applications"; counter = "Transactions Committed"; instance = instance }
  /// Transactions Pending: Number of transactions in progress.
  let ``Transactions Pending`` instance =
    { category = "ASP.NET Applications"; counter = "Transactions Pending"; instance = instance }
  /// Transactions Total: The total number of transactions since the application was started.
  let ``Transactions Total`` instance =
    { category = "ASP.NET Applications"; counter = "Transactions Total"; instance = instance }
  /// Transactions/Sec: Transactions started per second.
  let ``Transactions/Sec`` instance =
    { category = "ASP.NET Applications"; counter = "Transactions/Sec"; instance = instance }
  /// Session State Server connections total: The total number of connections to the State Server used by session state.
  let ``Session State Server connections total`` instance =
    { category = "ASP.NET Applications"; counter = "Session State Server connections total"; instance = instance }
  /// Session SQL Server connections total: The total number of connections to the SQL Server used by session state.
  let ``Session SQL Server connections total`` instance =
    { category = "ASP.NET Applications"; counter = "Session SQL Server connections total"; instance = instance }
  /// Events Raised: Total number of instrumentation events raised since the application was started.
  let ``Events Raised`` instance =
    { category = "ASP.NET Applications"; counter = "Events Raised"; instance = instance }
  /// Events Raised/Sec: Total number of instrumentation events per second.
  let ``Events Raised/Sec`` instance =
    { category = "ASP.NET Applications"; counter = "Events Raised/Sec"; instance = instance }
  /// Application Lifetime Events: Number of application events raised since the application was started.
  let ``Application Lifetime Events`` instance =
    { category = "ASP.NET Applications"; counter = "Application Lifetime Events"; instance = instance }
  /// Application Lifetime Events/Sec: Number of application events raised per second.
  let ``Application Lifetime Events/Sec`` instance =
    { category = "ASP.NET Applications"; counter = "Application Lifetime Events/Sec"; instance = instance }
  /// Error Events Raised: Number of error events raised since the application was started.
  let ``Error Events Raised`` instance =
    { category = "ASP.NET Applications"; counter = "Error Events Raised"; instance = instance }
  /// Error Events Raised/Sec: Number of error events per second.
  let ``Error Events Raised/Sec`` instance =
    { category = "ASP.NET Applications"; counter = "Error Events Raised/Sec"; instance = instance }
  /// Request Error Events Raised: Number of runtime error events raised since the application was started.
  let ``Request Error Events Raised`` instance =
    { category = "ASP.NET Applications"; counter = "Request Error Events Raised"; instance = instance }
  /// Request Error Events Raised/Sec: Number of runtime error events per second.
  let ``Request Error Events Raised/Sec`` instance =
    { category = "ASP.NET Applications"; counter = "Request Error Events Raised/Sec"; instance = instance }
  /// Infrastructure Error Events Raised: Number of HTTP error events raised since the application was started.
  let ``Infrastructure Error Events Raised`` instance =
    { category = "ASP.NET Applications"; counter = "Infrastructure Error Events Raised"; instance = instance }
  /// Infrastructure Error Events Raised/Sec: Number of HTTP error events raised per second.
  let ``Infrastructure Error Events Raised/Sec`` instance =
    { category = "ASP.NET Applications"; counter = "Infrastructure Error Events Raised/Sec"; instance = instance }
  /// Request Events Raised: Number of request events raised since the application was started
  let ``Request Events Raised`` instance =
    { category = "ASP.NET Applications"; counter = "Request Events Raised"; instance = instance }
  /// Request Events Raised/Sec: Number of request events raised per second.
  let ``Request Events Raised/Sec`` instance =
    { category = "ASP.NET Applications"; counter = "Request Events Raised/Sec"; instance = instance }
  /// Audit Success Events Raised: Number of audit successes in the application since it was started.
  let ``Audit Success Events Raised`` instance =
    { category = "ASP.NET Applications"; counter = "Audit Success Events Raised"; instance = instance }
  /// Audit Failure Events Raised: Number of audit failures in the application since it was started.
  let ``Audit Failure Events Raised`` instance =
    { category = "ASP.NET Applications"; counter = "Audit Failure Events Raised"; instance = instance }
  /// Membership Authentication Success: Number of successful membership credential validations since the application was started.
  let ``Membership Authentication Success`` instance =
    { category = "ASP.NET Applications"; counter = "Membership Authentication Success"; instance = instance }
  /// Membership Authentication Failure: Number of failed membership credential validations since the application was started.
  let ``Membership Authentication Failure`` instance =
    { category = "ASP.NET Applications"; counter = "Membership Authentication Failure"; instance = instance }
  /// Forms Authentication Success: Number of successful forms authentication ticket validations since the application was started.
  let ``Forms Authentication Success`` instance =
    { category = "ASP.NET Applications"; counter = "Forms Authentication Success"; instance = instance }
  /// Forms Authentication Failure: Number of failed forms authentication ticket validations since the application was started.
  let ``Forms Authentication Failure`` instance =
    { category = "ASP.NET Applications"; counter = "Forms Authentication Failure"; instance = instance }
  /// Viewstate MAC Validation Failure: Number of viewstate MAC validations that failed since the application was started.
  let ``Viewstate MAC Validation Failure`` instance =
    { category = "ASP.NET Applications"; counter = "Viewstate MAC Validation Failure"; instance = instance }
  /// Request Execution Time: The number of milliseconds that it took to execute the most recent request.
  let ``Request Execution Time`` instance =
    { category = "ASP.NET Applications"; counter = "Request Execution Time"; instance = instance }
  /// Requests Disconnected: The number of requests disconnected due to communication errors or user terminated.
  let ``Requests Disconnected`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Disconnected"; instance = instance }
  /// Requests Rejected: The number of requests rejected because the application request queue was full.
  let ``Requests Rejected`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Rejected"; instance = instance }
  /// Request Wait Time: The number of milliseconds the most recent request was waiting in the queue.
  let ``Request Wait Time`` instance =
    { category = "ASP.NET Applications"; counter = "Request Wait Time"; instance = instance }
  /// Cache % Machine Memory Limit Used: The amount of physical memory used by the machine divided by the physical memory limit for the cache, as a percentage.  When this reaches 100%, half of the cache entries will be forcibly removed.  The __Total__ instance is the average of all instances, and therefore cannot be used to determine when cache entries will be forcibly removed.
  let ``Cache % Machine Memory Limit Used`` instance =
    { category = "ASP.NET Applications"; counter = "Cache % Machine Memory Limit Used"; instance = instance }
  /// Cache % Machine Memory Limit Used Base: Cache % Machine Memory Limit Used Base
  let ``Cache % Machine Memory Limit Used Base`` instance =
    { category = "ASP.NET Applications"; counter = "Cache % Machine Memory Limit Used Base"; instance = instance }
  /// Cache % Process Memory Limit Used: The value of private bytes for the worker process divided by the private bytes memory limit for the cache, as a percentage.  When this reaches 100%, half of the cache entries will be forcibly removed.  The __Total__ instance is the average of all instances, and therefore cannot be used to determine when cache entries will be forcibly removed.
  let ``Cache % Process Memory Limit Used`` instance =
    { category = "ASP.NET Applications"; counter = "Cache % Process Memory Limit Used"; instance = instance }
  /// Cache % Process Memory Limit Used Base: Cache % Process Memory Limit Used Base
  let ``Cache % Process Memory Limit Used Base`` instance =
    { category = "ASP.NET Applications"; counter = "Cache % Process Memory Limit Used Base"; instance = instance }
  /// Cache Total Trims: Total number of entries forcibly removed from the cache due to memory pressure.
  let ``Cache Total Trims`` instance =
    { category = "ASP.NET Applications"; counter = "Cache Total Trims"; instance = instance }
  /// Cache API Trims: Total number of entries forcibly removed from the cache due to memory pressure that were originally inserted into the cache using one of the public cache APIs.
  let ``Cache API Trims`` instance =
    { category = "ASP.NET Applications"; counter = "Cache API Trims"; instance = instance }
  /// Output Cache Trims: Total number of entries forcibly removed from the cache due to memory pressure that were originally inserted into the cache by the output cache feature.
  let ``Output Cache Trims`` instance =
    { category = "ASP.NET Applications"; counter = "Output Cache Trims"; instance = instance }
  /// % Managed Processor Time (estimated): Estimated percentage of elapsed time that the processor spends executing managed application code.  This counter only tracks processor time of managed threads in the application.  It does not include additional processor time spent executing on non-managed threads.  Note that this counter is only updated with new data every five seconds.
  let ``% Managed Processor Time (estimated)`` instance =
    { category = "ASP.NET Applications"; counter = "% Managed Processor Time (estimated)"; instance = instance }
  /// % Managed Processor Time Base (estimated): % Managed Processor Time Base (estimated)
  let ``% Managed Processor Time Base (estimated)`` instance =
    { category = "ASP.NET Applications"; counter = "% Managed Processor Time Base (estimated)"; instance = instance }
  /// Managed Memory Used (estimated): Estimated managed heap memory consumption (in KB) by the application.  The accuracy of this counter varies depending on the duration of elapsed time since the last full managed memory heap collection.  Note that this counter is only updated with new data every five seconds.
  let ``Managed Memory Used (estimated)`` instance =
    { category = "ASP.NET Applications"; counter = "Managed Memory Used (estimated)"; instance = instance }
  /// Request Bytes In Total (WebSockets): The total size, in bytes, of data received by ASP.NET on WebSocket connections.
  let ``Request Bytes In Total (WebSockets)`` instance =
    { category = "ASP.NET Applications"; counter = "Request Bytes In Total (WebSockets)"; instance = instance }
  /// Request Bytes Out Total (WebSockets): The total size, in bytes, of data sent to a client on WebSocket connections.
  let ``Request Bytes Out Total (WebSockets)`` instance =
    { category = "ASP.NET Applications"; counter = "Request Bytes Out Total (WebSockets)"; instance = instance }
  /// Requests Executing (WebSockets): The number of WebSocket requests currently executing.
  let ``Requests Executing (WebSockets)`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Executing (WebSockets)"; instance = instance }
  /// Requests Failed (WebSockets): Total number of WebSocket requests that ended up in an aborted state.
  let ``Requests Failed (WebSockets)`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Failed (WebSockets)"; instance = instance }
  /// Requests Succeeded (WebSockets): Total number of WebSocket requests that completed gracefully.
  let ``Requests Succeeded (WebSockets)`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Succeeded (WebSockets)"; instance = instance }
  /// Requests Total (WebSockets): The total number of WebSocket requests since the application was started.
  let ``Requests Total (WebSockets)`` instance =
    { category = "ASP.NET Applications"; counter = "Requests Total (WebSockets)"; instance = instance }

  let allCounters =
    [ ``Anonymous Requests``
      ``Anonymous Requests/Sec``
      ``Cache Total Entries``
      ``Cache Total Turnover Rate``
      ``Cache Total Hits``
      ``Cache Total Misses``
      ``Cache Total Hit Ratio``
      ``Cache Total Hit Ratio Base``
      ``Cache API Entries``
      ``Cache API Turnover Rate``
      ``Cache API Hits``
      ``Cache API Misses``
      ``Cache API Hit Ratio``
      ``Cache API Hit Ratio Base``
      ``Output Cache Entries``
      ``Output Cache Turnover Rate``
      ``Output Cache Hits``
      ``Output Cache Misses``
      ``Output Cache Hit Ratio``
      ``Output Cache Hit Ratio Base``
      ``Compilations Total``
      ``Debugging Requests``
      ``Errors During Preprocessing``
      ``Errors During Compilation``
      ``Errors During Execution``
      ``Errors Unhandled During Execution``
      ``Errors Unhandled During Execution/Sec``
      ``Errors Total``
      ``Errors Total/Sec``
      ``Pipeline Instance Count``
      ``Request Bytes In Total``
      ``Request Bytes Out Total``
      ``Requests Executing``
      ``Requests Failed``
      ``Requests Not Found``
      ``Requests Not Authorized``
      ``Requests In Application Queue``
      ``Requests Timed Out``
      ``Requests Succeeded``
      ``Requests Total``
      ``Requests/Sec``
      ``Sessions Active``
      ``Sessions Abandoned``
      ``Sessions Timed Out``
      ``Sessions Total``
      ``Transactions Aborted``
      ``Transactions Committed``
      ``Transactions Pending``
      ``Transactions Total``
      ``Transactions/Sec``
      ``Session State Server connections total``
      ``Session SQL Server connections total``
      ``Events Raised``
      ``Events Raised/Sec``
      ``Application Lifetime Events``
      ``Application Lifetime Events/Sec``
      ``Error Events Raised``
      ``Error Events Raised/Sec``
      ``Request Error Events Raised``
      ``Request Error Events Raised/Sec``
      ``Infrastructure Error Events Raised``
      ``Infrastructure Error Events Raised/Sec``
      ``Request Events Raised``
      ``Request Events Raised/Sec``
      ``Audit Success Events Raised``
      ``Audit Failure Events Raised``
      ``Membership Authentication Success``
      ``Membership Authentication Failure``
      ``Forms Authentication Success``
      ``Forms Authentication Failure``
      ``Viewstate MAC Validation Failure``
      ``Request Execution Time``
      ``Requests Disconnected``
      ``Requests Rejected``
      ``Request Wait Time``
      ``Cache % Machine Memory Limit Used``
      ``Cache % Machine Memory Limit Used Base``
      ``Cache % Process Memory Limit Used``
      ``Cache % Process Memory Limit Used Base``
      ``Cache Total Trims``
      ``Cache API Trims``
      ``Output Cache Trims``
      ``% Managed Processor Time (estimated)``
      ``% Managed Processor Time Base (estimated)``
      ``Managed Memory Used (estimated)``
      ``Request Bytes In Total (WebSockets)``
      ``Request Bytes Out Total (WebSockets)``
      ``Requests Executing (WebSockets)``
      ``Requests Failed (WebSockets)``
      ``Requests Succeeded (WebSockets)``
      ``Requests Total (WebSockets)``
    ]

/// ASP.NET Apps v4.0.30319: ASP.NET application performance counters
///
/// This performance counter does not have non-instance based counters
module ``ASP_NET Apps v4_0_30319`` =

  [<Literal>]
  let Category = "ASP.NET Apps v4.0.30319"

  let PCC = getPCC Category
  /// Anonymous Requests: Number of requests utilizing anonymous authentication.
  let ``Anonymous Requests`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Anonymous Requests"; instance = instance }
  /// Anonymous Requests/Sec: Number of Authentication Anonymous Requests/Sec
  let ``Anonymous Requests/Sec`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Anonymous Requests/Sec"; instance = instance }
  /// Cache Total Entries: Total number of entries within the cache (both internal and user added)
  let ``Cache Total Entries`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache Total Entries"; instance = instance }
  /// Cache Total Turnover Rate: Number of additions and removals to the total cache per second.
  let ``Cache Total Turnover Rate`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache Total Turnover Rate"; instance = instance }
  /// Cache Total Hits: Total number of hits from the cache.
  let ``Cache Total Hits`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache Total Hits"; instance = instance }
  /// Cache Total Misses: Total number of cache misses.
  let ``Cache Total Misses`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache Total Misses"; instance = instance }
  /// Cache Total Hit Ratio: Ratio of hits from all cache calls.
  let ``Cache Total Hit Ratio`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache Total Hit Ratio"; instance = instance }
  /// Cache Total Hit Ratio Base: Cache Total Hit Ratio Base
  let ``Cache Total Hit Ratio Base`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache Total Hit Ratio Base"; instance = instance }
  /// Cache API Entries: Total number of entries within the cache added by the user.
  let ``Cache API Entries`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache API Entries"; instance = instance }
  /// Cache API Turnover Rate: Number of additions and removals to the API cache per second.
  let ``Cache API Turnover Rate`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache API Turnover Rate"; instance = instance }
  /// Cache API Hits: Number of cache hits from user code.
  let ``Cache API Hits`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache API Hits"; instance = instance }
  /// Cache API Misses: Number of cache misses called from user code.
  let ``Cache API Misses`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache API Misses"; instance = instance }
  /// Cache API Hit Ratio: Ratio of hits called from user code.
  let ``Cache API Hit Ratio`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache API Hit Ratio"; instance = instance }
  /// Cache API Hit Ratio Base: Cache API Hit Ratio Base
  let ``Cache API Hit Ratio Base`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache API Hit Ratio Base"; instance = instance }
  /// Output Cache Entries: Current number of entries in the output cache.
  let ``Output Cache Entries`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Output Cache Entries"; instance = instance }
  /// Output Cache Turnover Rate: Number of additions and removals to the output cache per second.
  let ``Output Cache Turnover Rate`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Output Cache Turnover Rate"; instance = instance }
  /// Output Cache Hits: Total number of output cacheable requests served from the output cache.
  let ``Output Cache Hits`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Output Cache Hits"; instance = instance }
  /// Output Cache Misses: Total number of output cacheable requests not served from the output cache.
  let ``Output Cache Misses`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Output Cache Misses"; instance = instance }
  /// Output Cache Hit Ratio: Ratio of hits to requests for output cacheable requests.
  let ``Output Cache Hit Ratio`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Output Cache Hit Ratio"; instance = instance }
  /// Output Cache Hit Ratio Base: Output Cache Hit Ratio Base
  let ``Output Cache Hit Ratio Base`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Output Cache Hit Ratio Base"; instance = instance }
  /// Compilations Total: Number of .asax, .ascx, .ashx, .asmx, or .aspx source files dynamically compiled.
  let ``Compilations Total`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Compilations Total"; instance = instance }
  /// Debugging Requests: Number of debugging requests processed.
  let ``Debugging Requests`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Debugging Requests"; instance = instance }
  /// Errors During Preprocessing: Number of errors that have occurred during parsing and configuration.
  let ``Errors During Preprocessing`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Errors During Preprocessing"; instance = instance }
  /// Errors During Compilation: Number of errors that have occurred during compilation.
  let ``Errors During Compilation`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Errors During Compilation"; instance = instance }
  /// Errors During Execution: Number of errors that have occurred during the processing of a request.
  let ``Errors During Execution`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Errors During Execution"; instance = instance }
  /// Errors Unhandled During Execution: Number of errors not handled by user code, but by the default error handler.
  let ``Errors Unhandled During Execution`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Errors Unhandled During Execution"; instance = instance }
  /// Errors Unhandled During Execution/Sec: Rate of unhandled errors.
  let ``Errors Unhandled During Execution/Sec`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Errors Unhandled During Execution/Sec"; instance = instance }
  /// Errors Total: Total number of errors occurred.
  let ``Errors Total`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Errors Total"; instance = instance }
  /// Errors Total/Sec: Rate of errors occurred.
  let ``Errors Total/Sec`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Errors Total/Sec"; instance = instance }
  /// Pipeline Instance Count: Number of active pipeline instances.
  let ``Pipeline Instance Count`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Pipeline Instance Count"; instance = instance }
  /// Request Bytes In Total: The total size, in bytes, of all requests.
  let ``Request Bytes In Total`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Request Bytes In Total"; instance = instance }
  /// Request Bytes Out Total: The total size, in bytes, of responses sent to a client.  This does not include standard HTTP response headers.
  let ``Request Bytes Out Total`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Request Bytes Out Total"; instance = instance }
  /// Requests Executing: The number of requests currently executing.
  let ``Requests Executing`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Executing"; instance = instance }
  /// Requests Failed: Total number of failed requests.
  let ``Requests Failed`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Failed"; instance = instance }
  /// Requests Not Found: The number of requests for resources that were not found.
  let ``Requests Not Found`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Not Found"; instance = instance }
  /// Requests Not Authorized: Number of requests failed due to unauthorized access.
  let ``Requests Not Authorized`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Not Authorized"; instance = instance }
  /// Requests In Application Queue: The number of requests in the application request queue.
  let ``Requests In Application Queue`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests In Application Queue"; instance = instance }
  /// Requests Timed Out: The number of requests that timed out.
  let ``Requests Timed Out`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Timed Out"; instance = instance }
  /// Requests Succeeded: The number of requests that executed successfully.
  let ``Requests Succeeded`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Succeeded"; instance = instance }
  /// Requests Total: The total number of requests since the application was started.
  let ``Requests Total`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Total"; instance = instance }
  /// Requests/Sec: The number of requests executed per second.
  let ``Requests/Sec`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests/Sec"; instance = instance }
  /// Sessions Active: The current number of sessions currently active.
  let ``Sessions Active`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Sessions Active"; instance = instance }
  /// Sessions Abandoned: The number of sessions that have been explicitly abandoned.
  let ``Sessions Abandoned`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Sessions Abandoned"; instance = instance }
  /// Sessions Timed Out: The number of sessions timed out.
  let ``Sessions Timed Out`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Sessions Timed Out"; instance = instance }
  /// Sessions Total: Total number of sessions since the application was started.
  let ``Sessions Total`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Sessions Total"; instance = instance }
  /// Transactions Aborted: The number of transactions aborted.
  let ``Transactions Aborted`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Transactions Aborted"; instance = instance }
  /// Transactions Committed: The number of transactions committed.
  let ``Transactions Committed`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Transactions Committed"; instance = instance }
  /// Transactions Pending: Number of transactions in progress.
  let ``Transactions Pending`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Transactions Pending"; instance = instance }
  /// Transactions Total: The total number of transactions since the application was started.
  let ``Transactions Total`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Transactions Total"; instance = instance }
  /// Transactions/Sec: Transactions started per second.
  let ``Transactions/Sec`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Transactions/Sec"; instance = instance }
  /// Session State Server connections total: The total number of connections to the State Server used by session state.
  let ``Session State Server connections total`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Session State Server connections total"; instance = instance }
  /// Session SQL Server connections total: The total number of connections to the SQL Server used by session state.
  let ``Session SQL Server connections total`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Session SQL Server connections total"; instance = instance }
  /// Events Raised: Total number of instrumentation events raised since the application was started.
  let ``Events Raised`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Events Raised"; instance = instance }
  /// Events Raised/Sec: Total number of instrumentation events per second.
  let ``Events Raised/Sec`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Events Raised/Sec"; instance = instance }
  /// Application Lifetime Events: Number of application events raised since the application was started.
  let ``Application Lifetime Events`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Application Lifetime Events"; instance = instance }
  /// Application Lifetime Events/Sec: Number of application events raised per second.
  let ``Application Lifetime Events/Sec`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Application Lifetime Events/Sec"; instance = instance }
  /// Error Events Raised: Number of error events raised since the application was started.
  let ``Error Events Raised`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Error Events Raised"; instance = instance }
  /// Error Events Raised/Sec: Number of error events per second.
  let ``Error Events Raised/Sec`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Error Events Raised/Sec"; instance = instance }
  /// Request Error Events Raised: Number of runtime error events raised since the application was started.
  let ``Request Error Events Raised`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Request Error Events Raised"; instance = instance }
  /// Request Error Events Raised/Sec: Number of runtime error events per second.
  let ``Request Error Events Raised/Sec`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Request Error Events Raised/Sec"; instance = instance }
  /// Infrastructure Error Events Raised: Number of HTTP error events raised since the application was started.
  let ``Infrastructure Error Events Raised`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Infrastructure Error Events Raised"; instance = instance }
  /// Infrastructure Error Events Raised/Sec: Number of HTTP error events raised per second.
  let ``Infrastructure Error Events Raised/Sec`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Infrastructure Error Events Raised/Sec"; instance = instance }
  /// Request Events Raised: Number of request events raised since the application was started
  let ``Request Events Raised`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Request Events Raised"; instance = instance }
  /// Request Events Raised/Sec: Number of request events raised per second.
  let ``Request Events Raised/Sec`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Request Events Raised/Sec"; instance = instance }
  /// Audit Success Events Raised: Number of audit successes in the application since it was started.
  let ``Audit Success Events Raised`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Audit Success Events Raised"; instance = instance }
  /// Audit Failure Events Raised: Number of audit failures in the application since it was started.
  let ``Audit Failure Events Raised`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Audit Failure Events Raised"; instance = instance }
  /// Membership Authentication Success: Number of successful membership credential validations since the application was started.
  let ``Membership Authentication Success`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Membership Authentication Success"; instance = instance }
  /// Membership Authentication Failure: Number of failed membership credential validations since the application was started.
  let ``Membership Authentication Failure`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Membership Authentication Failure"; instance = instance }
  /// Forms Authentication Success: Number of successful forms authentication ticket validations since the application was started.
  let ``Forms Authentication Success`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Forms Authentication Success"; instance = instance }
  /// Forms Authentication Failure: Number of failed forms authentication ticket validations since the application was started.
  let ``Forms Authentication Failure`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Forms Authentication Failure"; instance = instance }
  /// Viewstate MAC Validation Failure: Number of viewstate MAC validations that failed since the application was started.
  let ``Viewstate MAC Validation Failure`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Viewstate MAC Validation Failure"; instance = instance }
  /// Request Execution Time: The number of milliseconds that it took to execute the most recent request.
  let ``Request Execution Time`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Request Execution Time"; instance = instance }
  /// Requests Disconnected: The number of requests disconnected due to communication errors or user terminated.
  let ``Requests Disconnected`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Disconnected"; instance = instance }
  /// Requests Rejected: The number of requests rejected because the application request queue was full.
  let ``Requests Rejected`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Rejected"; instance = instance }
  /// Request Wait Time: The number of milliseconds the most recent request was waiting in the queue.
  let ``Request Wait Time`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Request Wait Time"; instance = instance }
  /// Cache % Machine Memory Limit Used: The amount of physical memory used by the machine divided by the physical memory limit for the cache, as a percentage.  When this reaches 100%, half of the cache entries will be forcibly removed.  The __Total__ instance is the average of all instances, and therefore cannot be used to determine when cache entries will be forcibly removed.
  let ``Cache % Machine Memory Limit Used`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache % Machine Memory Limit Used"; instance = instance }
  /// Cache % Machine Memory Limit Used Base: Cache % Machine Memory Limit Used Base
  let ``Cache % Machine Memory Limit Used Base`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache % Machine Memory Limit Used Base"; instance = instance }
  /// Cache % Process Memory Limit Used: The value of private bytes for the worker process divided by the private bytes memory limit for the cache, as a percentage.  When this reaches 100%, half of the cache entries will be forcibly removed.  The __Total__ instance is the average of all instances, and therefore cannot be used to determine when cache entries will be forcibly removed.
  let ``Cache % Process Memory Limit Used`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache % Process Memory Limit Used"; instance = instance }
  /// Cache % Process Memory Limit Used Base: Cache % Process Memory Limit Used Base
  let ``Cache % Process Memory Limit Used Base`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache % Process Memory Limit Used Base"; instance = instance }
  /// Cache Total Trims: Total number of entries forcibly removed from the cache due to memory pressure.
  let ``Cache Total Trims`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache Total Trims"; instance = instance }
  /// Cache API Trims: Total number of entries forcibly removed from the cache due to memory pressure that were originally inserted into the cache using one of the public cache APIs.
  let ``Cache API Trims`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Cache API Trims"; instance = instance }
  /// Output Cache Trims: Total number of entries forcibly removed from the cache due to memory pressure that were originally inserted into the cache by the output cache feature.
  let ``Output Cache Trims`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Output Cache Trims"; instance = instance }
  /// % Managed Processor Time (estimated): Estimated percentage of elapsed time that the processor spends executing managed application code.  This counter only tracks processor time of managed threads in the application.  It does not include additional processor time spent executing on non-managed threads.  Note that this counter is only updated with new data every five seconds.
  let ``% Managed Processor Time (estimated)`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "% Managed Processor Time (estimated)"; instance = instance }
  /// % Managed Processor Time Base (estimated): % Managed Processor Time Base (estimated)
  let ``% Managed Processor Time Base (estimated)`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "% Managed Processor Time Base (estimated)"; instance = instance }
  /// Managed Memory Used (estimated): Estimated managed heap memory consumption (in KB) by the application.  The accuracy of this counter varies depending on the duration of elapsed time since the last full managed memory heap collection.  Note that this counter is only updated with new data every five seconds.
  let ``Managed Memory Used (estimated)`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Managed Memory Used (estimated)"; instance = instance }
  /// Request Bytes In Total (WebSockets): The total size, in bytes, of data received by ASP.NET on WebSocket connections.
  let ``Request Bytes In Total (WebSockets)`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Request Bytes In Total (WebSockets)"; instance = instance }
  /// Request Bytes Out Total (WebSockets): The total size, in bytes, of data sent to a client on WebSocket connections.
  let ``Request Bytes Out Total (WebSockets)`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Request Bytes Out Total (WebSockets)"; instance = instance }
  /// Requests Executing (WebSockets): The number of WebSocket requests currently executing.
  let ``Requests Executing (WebSockets)`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Executing (WebSockets)"; instance = instance }
  /// Requests Failed (WebSockets): Total number of WebSocket requests that ended up in an aborted state.
  let ``Requests Failed (WebSockets)`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Failed (WebSockets)"; instance = instance }
  /// Requests Succeeded (WebSockets): Total number of WebSocket requests that completed gracefully.
  let ``Requests Succeeded (WebSockets)`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Succeeded (WebSockets)"; instance = instance }
  /// Requests Total (WebSockets): The total number of WebSocket requests since the application was started.
  let ``Requests Total (WebSockets)`` instance =
    { category = "ASP.NET Apps v4.0.30319"; counter = "Requests Total (WebSockets)"; instance = instance }

  let allCounters =
    [ ``Anonymous Requests``
      ``Anonymous Requests/Sec``
      ``Cache Total Entries``
      ``Cache Total Turnover Rate``
      ``Cache Total Hits``
      ``Cache Total Misses``
      ``Cache Total Hit Ratio``
      ``Cache Total Hit Ratio Base``
      ``Cache API Entries``
      ``Cache API Turnover Rate``
      ``Cache API Hits``
      ``Cache API Misses``
      ``Cache API Hit Ratio``
      ``Cache API Hit Ratio Base``
      ``Output Cache Entries``
      ``Output Cache Turnover Rate``
      ``Output Cache Hits``
      ``Output Cache Misses``
      ``Output Cache Hit Ratio``
      ``Output Cache Hit Ratio Base``
      ``Compilations Total``
      ``Debugging Requests``
      ``Errors During Preprocessing``
      ``Errors During Compilation``
      ``Errors During Execution``
      ``Errors Unhandled During Execution``
      ``Errors Unhandled During Execution/Sec``
      ``Errors Total``
      ``Errors Total/Sec``
      ``Pipeline Instance Count``
      ``Request Bytes In Total``
      ``Request Bytes Out Total``
      ``Requests Executing``
      ``Requests Failed``
      ``Requests Not Found``
      ``Requests Not Authorized``
      ``Requests In Application Queue``
      ``Requests Timed Out``
      ``Requests Succeeded``
      ``Requests Total``
      ``Requests/Sec``
      ``Sessions Active``
      ``Sessions Abandoned``
      ``Sessions Timed Out``
      ``Sessions Total``
      ``Transactions Aborted``
      ``Transactions Committed``
      ``Transactions Pending``
      ``Transactions Total``
      ``Transactions/Sec``
      ``Session State Server connections total``
      ``Session SQL Server connections total``
      ``Events Raised``
      ``Events Raised/Sec``
      ``Application Lifetime Events``
      ``Application Lifetime Events/Sec``
      ``Error Events Raised``
      ``Error Events Raised/Sec``
      ``Request Error Events Raised``
      ``Request Error Events Raised/Sec``
      ``Infrastructure Error Events Raised``
      ``Infrastructure Error Events Raised/Sec``
      ``Request Events Raised``
      ``Request Events Raised/Sec``
      ``Audit Success Events Raised``
      ``Audit Failure Events Raised``
      ``Membership Authentication Success``
      ``Membership Authentication Failure``
      ``Forms Authentication Success``
      ``Forms Authentication Failure``
      ``Viewstate MAC Validation Failure``
      ``Request Execution Time``
      ``Requests Disconnected``
      ``Requests Rejected``
      ``Request Wait Time``
      ``Cache % Machine Memory Limit Used``
      ``Cache % Machine Memory Limit Used Base``
      ``Cache % Process Memory Limit Used``
      ``Cache % Process Memory Limit Used Base``
      ``Cache Total Trims``
      ``Cache API Trims``
      ``Output Cache Trims``
      ``% Managed Processor Time (estimated)``
      ``% Managed Processor Time Base (estimated)``
      ``Managed Memory Used (estimated)``
      ``Request Bytes In Total (WebSockets)``
      ``Request Bytes Out Total (WebSockets)``
      ``Requests Executing (WebSockets)``
      ``Requests Failed (WebSockets)``
      ``Requests Succeeded (WebSockets)``
      ``Requests Total (WebSockets)``
    ]

/// ASP.NET State Service: ASP.NET State Service
///
/// This performance counter does not have instance based counters
module ``ASP_NET State Service`` =

  [<Literal>]
  let Category = "ASP.NET State Service"

  let PCC = getPCC Category
  /// State Server Sessions Active: The current number of sessions currently active.
  let ``State Server Sessions Active`` =
    { category = "ASP.NET State Service"; counter = "State Server Sessions Active"; instance = NotApplicable }
  /// State Server Sessions Abandoned: The number of sessions that have been explicitly abandoned.
  let ``State Server Sessions Abandoned`` =
    { category = "ASP.NET State Service"; counter = "State Server Sessions Abandoned"; instance = NotApplicable }
  /// State Server Sessions Timed Out: The number of sessions timed out.
  let ``State Server Sessions Timed Out`` =
    { category = "ASP.NET State Service"; counter = "State Server Sessions Timed Out"; instance = NotApplicable }
  /// State Server Sessions Total: The number of sessions total.
  let ``State Server Sessions Total`` =
    { category = "ASP.NET State Service"; counter = "State Server Sessions Total"; instance = NotApplicable }

  let allCounters =
    [ ``State Server Sessions Active``
      ``State Server Sessions Abandoned``
      ``State Server Sessions Timed Out``
      ``State Server Sessions Total``
    ]

/// ASP.NET v4.0.30319: ASP.NET global performance counters
///
/// This performance counter does not have instance based counters
module ``ASP_NET v4_0_30319`` =

  [<Literal>]
  let Category = "ASP.NET v4.0.30319"

  let PCC = getPCC Category
  /// Application Restarts: Number of times the application has been restarted during the web server's lifetime.
  let ``Application Restarts`` =
    { category = "ASP.NET v4.0.30319"; counter = "Application Restarts"; instance = NotApplicable }
  /// Applications Running: Number of currently running web applications.
  let ``Applications Running`` =
    { category = "ASP.NET v4.0.30319"; counter = "Applications Running"; instance = NotApplicable }
  /// Requests Disconnected: The number of requests disconnected due to communication errors or user terminated.
  let ``Requests Disconnected`` =
    { category = "ASP.NET v4.0.30319"; counter = "Requests Disconnected"; instance = NotApplicable }
  /// Request Execution Time: The number of milliseconds that it took to execute the most recent request.
  let ``Request Execution Time`` =
    { category = "ASP.NET v4.0.30319"; counter = "Request Execution Time"; instance = NotApplicable }
  /// Requests Rejected: The number of requests rejected because the request queue was full.
  let ``Requests Rejected`` =
    { category = "ASP.NET v4.0.30319"; counter = "Requests Rejected"; instance = NotApplicable }
  /// Requests Queued: The number of requests waiting to be processed.
  let ``Requests Queued`` =
    { category = "ASP.NET v4.0.30319"; counter = "Requests Queued"; instance = NotApplicable }
  /// Worker Processes Running: Number of worker processes running on the machine.
  let ``Worker Processes Running`` =
    { category = "ASP.NET v4.0.30319"; counter = "Worker Processes Running"; instance = NotApplicable }
  /// Worker Process Restarts: Number of times a worker process has restarted on the machine.
  let ``Worker Process Restarts`` =
    { category = "ASP.NET v4.0.30319"; counter = "Worker Process Restarts"; instance = NotApplicable }
  /// Request Wait Time: The number of milliseconds the most recent request was waiting in the queue.
  let ``Request Wait Time`` =
    { category = "ASP.NET v4.0.30319"; counter = "Request Wait Time"; instance = NotApplicable }
  /// State Server Sessions Active: The current number of sessions currently active.
  let ``State Server Sessions Active`` =
    { category = "ASP.NET v4.0.30319"; counter = "State Server Sessions Active"; instance = NotApplicable }
  /// State Server Sessions Abandoned: The number of sessions that have been explicitly abandoned.
  let ``State Server Sessions Abandoned`` =
    { category = "ASP.NET v4.0.30319"; counter = "State Server Sessions Abandoned"; instance = NotApplicable }
  /// State Server Sessions Timed Out: The number of sessions timed out.
  let ``State Server Sessions Timed Out`` =
    { category = "ASP.NET v4.0.30319"; counter = "State Server Sessions Timed Out"; instance = NotApplicable }
  /// State Server Sessions Total: The number of sessions total.
  let ``State Server Sessions Total`` =
    { category = "ASP.NET v4.0.30319"; counter = "State Server Sessions Total"; instance = NotApplicable }
  /// Requests Current: The current number of requests, including those that are queued, currently executing, or waiting to be written to the client.  Under the ASP.NET process model, when this counter exceeds the requestQueueLimit defined in the processModel configuration section, ASP.NET will begin rejecting requests.
  let ``Requests Current`` =
    { category = "ASP.NET v4.0.30319"; counter = "Requests Current"; instance = NotApplicable }
  /// Audit Success Events Raised: Number of audit successes in the application since it was started.
  let ``Audit Success Events Raised`` =
    { category = "ASP.NET v4.0.30319"; counter = "Audit Success Events Raised"; instance = NotApplicable }
  /// Audit Failure Events Raised: Number of audit failures in the application since it was started.
  let ``Audit Failure Events Raised`` =
    { category = "ASP.NET v4.0.30319"; counter = "Audit Failure Events Raised"; instance = NotApplicable }
  /// Error Events Raised: Number of error events raised since the application was started.
  let ``Error Events Raised`` =
    { category = "ASP.NET v4.0.30319"; counter = "Error Events Raised"; instance = NotApplicable }
  /// Request Error Events Raised: Number of runtime error events raised since the application was started.
  let ``Request Error Events Raised`` =
    { category = "ASP.NET v4.0.30319"; counter = "Request Error Events Raised"; instance = NotApplicable }
  /// Infrastructure Error Events Raised: Number of HTTP error events raised since the application was started.
  let ``Infrastructure Error Events Raised`` =
    { category = "ASP.NET v4.0.30319"; counter = "Infrastructure Error Events Raised"; instance = NotApplicable }
  /// Requests In Native Queue: Requests queued because the concurrency limits have been exceeded.
  let ``Requests In Native Queue`` =
    { category = "ASP.NET v4.0.30319"; counter = "Requests In Native Queue"; instance = NotApplicable }

  let allCounters =
    [ ``Application Restarts``
      ``Applications Running``
      ``Requests Disconnected``
      ``Request Execution Time``
      ``Requests Rejected``
      ``Requests Queued``
      ``Worker Processes Running``
      ``Worker Process Restarts``
      ``Request Wait Time``
      ``State Server Sessions Active``
      ``State Server Sessions Abandoned``
      ``State Server Sessions Timed Out``
      ``State Server Sessions Total``
      ``Requests Current``
      ``Audit Success Events Raised``
      ``Audit Failure Events Raised``
      ``Error Events Raised``
      ``Request Error Events Raised``
      ``Infrastructure Error Events Raised``
      ``Requests In Native Queue``
    ]

/// Authorization Manager Applications: The set of Counters for Authorization Manager application object
///
/// This performance counter does not have instance based counters
module ``Authorization Manager Applications`` =

  [<Literal>]
  let Category = "Authorization Manager Applications"

  let PCC = getPCC Category
  /// Total number of scopes: 
  let ``Total number of scopes`` instance =
    { category = "Authorization Manager Applications"; counter = "Total number of scopes"; instance = instance }
  /// Number of Scopes loaded in memory: 
  let ``Number of Scopes loaded in memory`` instance =
    { category = "Authorization Manager Applications"; counter = "Number of Scopes loaded in memory"; instance = instance }

  let allCounters =
    [ ``Total number of scopes``
      ``Number of Scopes loaded in memory``
    ]

/// BitLocker: BitLocker Drive Encryption performance counters
///
/// This performance counter does not have non-instance based counters
module ``BitLocker`` =

  [<Literal>]
  let Category = "BitLocker"

  let PCC = getPCC Category
  /// Min Read Split Size: Minimum read buffer split size in bytes during last interval
  let ``Min Read Split Size`` instance =
    { category = "BitLocker"; counter = "Min Read Split Size"; instance = instance }
  /// Max Read Split Size: Maximum read buffer split size in bytes during last interval
  let ``Max Read Split Size`` instance =
    { category = "BitLocker"; counter = "Max Read Split Size"; instance = instance }
  /// Min Write Split Size: Minimum write buffer split size in bytes during last interval
  let ``Min Write Split Size`` instance =
    { category = "BitLocker"; counter = "Min Write Split Size"; instance = instance }
  /// Max Write Split Size: Maximum write buffer split size in bytes during last interval
  let ``Max Write Split Size`` instance =
    { category = "BitLocker"; counter = "Max Write Split Size"; instance = instance }
  /// Read Requests/sec: Number of read requests received over the last second
  let ``Read Requests/sec`` instance =
    { category = "BitLocker"; counter = "Read Requests/sec"; instance = instance }
  /// Read Subrequests/sec: Number of read subrequests issued over the last second
  let ``Read Subrequests/sec`` instance =
    { category = "BitLocker"; counter = "Read Subrequests/sec"; instance = instance }
  /// Write Requests/sec: Number of write requests received over the last second
  let ``Write Requests/sec`` instance =
    { category = "BitLocker"; counter = "Write Requests/sec"; instance = instance }
  /// Write Subrequests/sec: Number of write subrequests issued over the last second
  let ``Write Subrequests/sec`` instance =
    { category = "BitLocker"; counter = "Write Subrequests/sec"; instance = instance }

  let allCounters =
    [ ``Min Read Split Size``
      ``Max Read Split Size``
      ``Min Write Split Size``
      ``Max Write Split Size``
      ``Read Requests/sec``
      ``Read Subrequests/sec``
      ``Write Requests/sec``
      ``Write Subrequests/sec``
    ]

/// BranchCache: Counters for measuring bandwidth and latency for BranchCache.
///
/// This performance counter does not have instance based counters
module ``BranchCache`` =

  [<Literal>]
  let Category = "BranchCache"

  let PCC = getPCC Category
  /// Retrieval: Bytes from server: Total number of bytes received from the original content source.
  let ``Retrieval: Bytes from server`` =
    { category = "BranchCache"; counter = "Retrieval: Bytes from server"; instance = NotApplicable }
  /// Retrieval: Bytes from cache: Total number of bytes received from the local cache or peers.
  let ``Retrieval: Bytes from cache`` =
    { category = "BranchCache"; counter = "Retrieval: Bytes from cache"; instance = NotApplicable }
  /// Retrieval: Bytes served: Total number of bytes served by this peer to other peers.
  let ``Retrieval: Bytes served`` =
    { category = "BranchCache"; counter = "Retrieval: Bytes served"; instance = NotApplicable }
  /// Discovery: Weighted average discovery time: Weighted average of time between when a peer discovery query was sent and when the first response arrived.
  let ``Discovery: Weighted average discovery time`` =
    { category = "BranchCache"; counter = "Discovery: Weighted average discovery time"; instance = NotApplicable }
  /// SMB: Bytes from cache: Total number of bytes received from the local cache or peers.
  let ``SMB: Bytes from cache`` =
    { category = "BranchCache"; counter = "SMB: Bytes from cache"; instance = NotApplicable }
  /// SMB: Bytes from server: Total number of bytes received from the original content source.
  let ``SMB: Bytes from server`` =
    { category = "BranchCache"; counter = "SMB: Bytes from server"; instance = NotApplicable }
  /// BITS: Bytes from cache: Total number of bytes received from the local cache or peers.
  let ``BITS: Bytes from cache`` =
    { category = "BranchCache"; counter = "BITS: Bytes from cache"; instance = NotApplicable }
  /// BITS: Bytes from server: Total number of bytes received from the original content source.
  let ``BITS: Bytes from server`` =
    { category = "BranchCache"; counter = "BITS: Bytes from server"; instance = NotApplicable }
  /// WININET: Bytes from cache: Total number of bytes received from the local cache or peers.
  let ``WININET: Bytes from cache`` =
    { category = "BranchCache"; counter = "WININET: Bytes from cache"; instance = NotApplicable }
  /// WININET: Bytes from server: Total number of bytes received from the original content source.
  let ``WININET: Bytes from server`` =
    { category = "BranchCache"; counter = "WININET: Bytes from server"; instance = NotApplicable }
  /// WINHTTP: Bytes from cache: Total number of bytes received from the local cache or peers.
  let ``WINHTTP: Bytes from cache`` =
    { category = "BranchCache"; counter = "WINHTTP: Bytes from cache"; instance = NotApplicable }
  /// WINHTTP: Bytes from server: Total number of bytes received from the original content source.
  let ``WINHTTP: Bytes from server`` =
    { category = "BranchCache"; counter = "WINHTTP: Bytes from server"; instance = NotApplicable }
  /// OTHER: Bytes from cache: Total number of bytes received from the local cache or peers.
  let ``OTHER: Bytes from cache`` =
    { category = "BranchCache"; counter = "OTHER: Bytes from cache"; instance = NotApplicable }
  /// OTHER: Bytes from server: Total number of bytes received from the original content source.
  let ``OTHER: Bytes from server`` =
    { category = "BranchCache"; counter = "OTHER: Bytes from server"; instance = NotApplicable }
  /// Discovery: Attempted discoveries: Total number of attempted peer discoveries.
  let ``Discovery: Attempted discoveries`` =
    { category = "BranchCache"; counter = "Discovery: Attempted discoveries"; instance = NotApplicable }
  /// Local Cache: Cache complete file segments: Count of complete, content validated, file segments.
  let ``Local Cache: Cache complete file segments`` =
    { category = "BranchCache"; counter = "Local Cache: Cache complete file segments"; instance = NotApplicable }
  /// Local Cache: Cache partial file segments: Count of incomplete file segments that need additional data and/or validation.
  let ``Local Cache: Cache partial file segments`` =
    { category = "BranchCache"; counter = "Local Cache: Cache partial file segments"; instance = NotApplicable }
  /// Hosted Cache: Client file segment offers made: Count of file segment offers made by peers.
  let ``Hosted Cache: Client file segment offers made`` =
    { category = "BranchCache"; counter = "Hosted Cache: Client file segment offers made"; instance = NotApplicable }
  /// Retrieval: Average branch rate: Average byte rate observed by the current peer while downloading contents from other peers in the branch.
  let ``Retrieval: Average branch rate`` =
    { category = "BranchCache"; counter = "Retrieval: Average branch rate"; instance = NotApplicable }
  /// Discovery: Successful discoveries: Total number of successful discoveries.
  let ``Discovery: Successful discoveries`` =
    { category = "BranchCache"; counter = "Discovery: Successful discoveries"; instance = NotApplicable }
  /// Hosted Cache: Segment offers queue size: Total number of segment offers queued for processing by the Hosted Cache.
  let ``Hosted Cache: Segment offers queue size`` =
    { category = "BranchCache"; counter = "Hosted Cache: Segment offers queue size"; instance = NotApplicable }
  /// Publication Cache: Published contents: Count of complete, hash persisted, published contents.
  let ``Publication Cache: Published contents`` =
    { category = "BranchCache"; counter = "Publication Cache: Published contents"; instance = NotApplicable }
  /// Local Cache: Average access time: Average local cache access time when serving content to other clients or Hosted Caches.
  let ``Local Cache: Average access time`` =
    { category = "BranchCache"; counter = "Local Cache: Average access time"; instance = NotApplicable }

  let allCounters =
    [ ``Retrieval: Bytes from server``
      ``Retrieval: Bytes from cache``
      ``Retrieval: Bytes served``
      ``Discovery: Weighted average discovery time``
      ``SMB: Bytes from cache``
      ``SMB: Bytes from server``
      ``BITS: Bytes from cache``
      ``BITS: Bytes from server``
      ``WININET: Bytes from cache``
      ``WININET: Bytes from server``
      ``WINHTTP: Bytes from cache``
      ``WINHTTP: Bytes from server``
      ``OTHER: Bytes from cache``
      ``OTHER: Bytes from server``
      ``Discovery: Attempted discoveries``
      ``Local Cache: Cache complete file segments``
      ``Local Cache: Cache partial file segments``
      ``Hosted Cache: Client file segment offers made``
      ``Retrieval: Average branch rate``
      ``Discovery: Successful discoveries``
      ``Hosted Cache: Segment offers queue size``
      ``Publication Cache: Published contents``
      ``Local Cache: Average access time``
    ]

/// Browser: The Browser performance object consists of counters that measure the rates of announcements, enumerations, and other Browser transmissions.
///
/// This performance counter does not have instance based counters
module ``Browser`` =

  [<Literal>]
  let Category = "Browser"

  let PCC = getPCC Category
  /// Announcements Server/sec: Announcements Server/sec is the rate at which the servers in this domain have announced themselves to this server.
  let ``Announcements Server/sec`` =
    { category = "Browser"; counter = "Announcements Server/sec"; instance = NotApplicable }
  /// Announcements Domain/sec: Announcements Domain/sec is the rate at which a domain has announced itself to the network.
  let ``Announcements Domain/sec`` =
    { category = "Browser"; counter = "Announcements Domain/sec"; instance = NotApplicable }
  /// Announcements Total/sec: Announcements Total/sec is the sum of Announcements Server/sec and Announcements Domain/sec.
  let ``Announcements Total/sec`` =
    { category = "Browser"; counter = "Announcements Total/sec"; instance = NotApplicable }
  /// Election Packets/sec: Election Packets/sec is the rate at which browser election packets have been received by this workstation.
  let ``Election Packets/sec`` =
    { category = "Browser"; counter = "Election Packets/sec"; instance = NotApplicable }
  /// Mailslot Writes/sec: Mailslot Writes/sec is the rate at which mailslot messages have been successfully received.
  let ``Mailslot Writes/sec`` =
    { category = "Browser"; counter = "Mailslot Writes/sec"; instance = NotApplicable }
  /// Server List Requests/sec: Server List Requests/sec is the rate at which requests to retrieve a list of browser servers have been processed by this workstation.
  let ``Server List Requests/sec`` =
    { category = "Browser"; counter = "Server List Requests/sec"; instance = NotApplicable }
  /// Enumerations Server/sec: Enumerations Server/sec is the rate at which server browse requests have been processed by this workstation.
  let ``Enumerations Server/sec`` =
    { category = "Browser"; counter = "Enumerations Server/sec"; instance = NotApplicable }
  /// Enumerations Domain/sec: Enumerations Domain/sec is the rate at which domain browse requests have been processed by this workstation.
  let ``Enumerations Domain/sec`` =
    { category = "Browser"; counter = "Enumerations Domain/sec"; instance = NotApplicable }
  /// Enumerations Other/sec: Enumerations Other/sec is the rate at which browse requests processed by this workstation are not domain or server browse requests.
  let ``Enumerations Other/sec`` =
    { category = "Browser"; counter = "Enumerations Other/sec"; instance = NotApplicable }
  /// Enumerations Total/sec: Enumerations Total/sec is the rate at which browse requests have been processed by this workstation.  This is the sum of Enumerations Server/sec, Enumerations Domain/sec, and Enumerations Other/sec.
  let ``Enumerations Total/sec`` =
    { category = "Browser"; counter = "Enumerations Total/sec"; instance = NotApplicable }
  /// Missed Server Announcements: Missed Server Announcements is the number of server announcements that have been missed due to configuration or allocation limits.
  let ``Missed Server Announcements`` =
    { category = "Browser"; counter = "Missed Server Announcements"; instance = NotApplicable }
  /// Missed Mailslot Datagrams: Missed Mailslot Datagrams is the number of Mailslot Datagrams that have been discarded due to configuration or allocation limits.
  let ``Missed Mailslot Datagrams`` =
    { category = "Browser"; counter = "Missed Mailslot Datagrams"; instance = NotApplicable }
  /// Missed Server List Requests: Missed Server List Requests is the number of requests to retrieve a list of browser servers that were received by this workstation, but could not be processed.
  let ``Missed Server List Requests`` =
    { category = "Browser"; counter = "Missed Server List Requests"; instance = NotApplicable }
  /// Server Announce Allocations Failed/sec: Server Announce Allocations Failed/sec is the rate at which server (or domain) announcements have failed due to lack of memory.
  let ``Server Announce Allocations Failed/sec`` =
    { category = "Browser"; counter = "Server Announce Allocations Failed/sec"; instance = NotApplicable }
  /// Mailslot Allocations Failed: Mailslot Allocations Failed is the number of times the datagram receiver has failed to allocate a buffer to hold a user mailslot write.
  let ``Mailslot Allocations Failed`` =
    { category = "Browser"; counter = "Mailslot Allocations Failed"; instance = NotApplicable }
  /// Mailslot Receives Failed: Mailslot Receives Failed indicates the number of mailslot messages that could not be received due to transport failures.
  let ``Mailslot Receives Failed`` =
    { category = "Browser"; counter = "Mailslot Receives Failed"; instance = NotApplicable }
  /// Mailslot Writes Failed: Mailslot Writes Failed is the total number of mailslot messages that have been successfully received, but that could not be written to the mailslot.
  let ``Mailslot Writes Failed`` =
    { category = "Browser"; counter = "Mailslot Writes Failed"; instance = NotApplicable }
  /// Mailslot Opens Failed/sec: Mailslot Opens Failed/sec indicates the rate at which mailslot messages to be delivered to mailslots that are not present are received by this workstation.
  let ``Mailslot Opens Failed/sec`` =
    { category = "Browser"; counter = "Mailslot Opens Failed/sec"; instance = NotApplicable }
  /// Duplicate Master Announcements: Duplicate Master Announcements indicates the number of times that the master browser has detected another master browser on the same domain.
  let ``Duplicate Master Announcements`` =
    { category = "Browser"; counter = "Duplicate Master Announcements"; instance = NotApplicable }
  /// Illegal Datagrams/sec: Illegal Datagrams/sec is the rate at which incorrectly formatted datagrams have been received by the workstation.
  let ``Illegal Datagrams/sec`` =
    { category = "Browser"; counter = "Illegal Datagrams/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Announcements Server/sec``
      ``Announcements Domain/sec``
      ``Announcements Total/sec``
      ``Election Packets/sec``
      ``Mailslot Writes/sec``
      ``Server List Requests/sec``
      ``Enumerations Server/sec``
      ``Enumerations Domain/sec``
      ``Enumerations Other/sec``
      ``Enumerations Total/sec``
      ``Missed Server Announcements``
      ``Missed Mailslot Datagrams``
      ``Missed Server List Requests``
      ``Server Announce Allocations Failed/sec``
      ``Mailslot Allocations Failed``
      ``Mailslot Receives Failed``
      ``Mailslot Writes Failed``
      ``Mailslot Opens Failed/sec``
      ``Duplicate Master Announcements``
      ``Illegal Datagrams/sec``
    ]

/// Cache: The Cache performance object  consists of counters that monitor the file system cache, an area of physical memory that stores recently used data as long as possible to permit access to the data without having to read from the disk.  Because applications typically use the cache, the cache is monitored as an indicator of application I/O operations.  When memory is plentiful, the cache can grow, but when memory is scarce, the cache can become too small to be effective.
///
/// This performance counter does not have instance based counters
module ``Cache`` =

  [<Literal>]
  let Category = "Cache"

  let PCC = getPCC Category
  /// Data Maps/sec: Data Maps/sec is the frequency that a file system such as NTFS, maps a page of a file into the file system cache to read the page.
  let ``Data Maps/sec`` =
    { category = "Cache"; counter = "Data Maps/sec"; instance = NotApplicable }
  /// Sync Data Maps/sec: Sync Data Maps/sec counts the frequency that a file system, such as NTFS, maps a page of a file into the file system cache to read the page, and wishes to wait for the page to be retrieved if it is not in main memory.
  let ``Sync Data Maps/sec`` =
    { category = "Cache"; counter = "Sync Data Maps/sec"; instance = NotApplicable }
  /// Async Data Maps/sec: Async Data Maps/sec is the frequency that an application using a file system, such as NTFS, to map a page of a file into the file system cache to read the page, and does not wait for the page to be retrieved if it is not in main memory.
  let ``Async Data Maps/sec`` =
    { category = "Cache"; counter = "Async Data Maps/sec"; instance = NotApplicable }
  /// Data Map Hits %: Data Map Hits is the percentage of data maps in the file system cache that could be resolved without having to retrieve a page from the disk, because the page was already in physical memory.
  let ``Data Map Hits %`` =
    { category = "Cache"; counter = "Data Map Hits %"; instance = NotApplicable }
  /// Data Map Pins/sec: Data Map Pins/sec is the frequency of data maps in the file system cache that resulted in pinning a page in main memory, an action usually preparatory to writing to the file on disk.   While pinned, a page's physical address in main memory and virtual address in the file system cache will not be altered.
  let ``Data Map Pins/sec`` =
    { category = "Cache"; counter = "Data Map Pins/sec"; instance = NotApplicable }
  /// Pin Reads/sec: Pin Reads/sec is the frequency of reading data into the file system cache preparatory to writing the data back to disk.  Pages read in this fashion are pinned in memory at the completion of the read.  While pinned, a page's physical address in the file system cache will not be altered.
  let ``Pin Reads/sec`` =
    { category = "Cache"; counter = "Pin Reads/sec"; instance = NotApplicable }
  /// Sync Pin Reads/sec: Sync Pin Reads/sec is the frequency of reading data into the file system cache preparatory to writing the data back to disk.  Pages read in this fashion are pinned in memory at the completion of the read.  The file system will not regain control until the page is pinned in the file system cache, in particular if the disk must be accessed to retrieve the page.  While pinned, a page's physical address in the file system cache will not be altered.
  let ``Sync Pin Reads/sec`` =
    { category = "Cache"; counter = "Sync Pin Reads/sec"; instance = NotApplicable }
  /// Async Pin Reads/sec: Async Pin Reads/sec is the frequency of reading data into the file system cache preparatory to writing the data back to disk.  Pages read in this fashion are pinned in memory at the completion of the read.  The file system will regain control immediately even if the disk must be accessed to retrieve the page.  While pinned, a page's physical address will not be altered.
  let ``Async Pin Reads/sec`` =
    { category = "Cache"; counter = "Async Pin Reads/sec"; instance = NotApplicable }
  /// Pin Read Hits %: Pin Read Hits is the percentage of pin read requests that hit the file system cache, i.e., did not require a disk read in order to provide access to the page in the file system cache.  While pinned, a page's physical address in the file system cache will not be altered.  The LAN Redirector uses this method for retrieving data from the cache, as does the LAN Server for small transfers.  This is usually the method used by the disk file systems as well.
  let ``Pin Read Hits %`` =
    { category = "Cache"; counter = "Pin Read Hits %"; instance = NotApplicable }
  /// Copy Reads/sec: Copy Reads/sec is the frequency of reads from pages of the file system cache that involve a memory copy of the data from the cache to the application's buffer.  The LAN Redirector uses this method for retrieving information from the file system cache, as does the LAN Server for small transfers.  This is a method used by the disk file systems as well.
  let ``Copy Reads/sec`` =
    { category = "Cache"; counter = "Copy Reads/sec"; instance = NotApplicable }
  /// Sync Copy Reads/sec: Sync Copy Reads/sec is the frequency of reads from pages of the file system cache that involve a memory copy of the data from the cache to the application's buffer.  The file system will not regain control until the copy operation is complete, even if the disk must be accessed to retrieve the page.
  let ``Sync Copy Reads/sec`` =
    { category = "Cache"; counter = "Sync Copy Reads/sec"; instance = NotApplicable }
  /// Async Copy Reads/sec: Async Copy Reads/sec is the frequency of reads from pages of the file system cache that involve a memory copy of the data from the cache to the application's buffer.  The application will regain control immediately even if the disk must be accessed to retrieve the page.
  let ``Async Copy Reads/sec`` =
    { category = "Cache"; counter = "Async Copy Reads/sec"; instance = NotApplicable }
  /// Copy Read Hits %: Copy Read Hits is the percentage of cache copy read requests that hit the cache, that is, they did not require a disk read in order to provide access to the page in the cache.  A copy read is a file read operation that is satisfied by a memory copy from a page in the cache to the application's buffer.  The LAN Redirector uses this method for retrieving information from the cache, as does the LAN Server for small transfers.  This is a method used by the disk file systems as well.
  let ``Copy Read Hits %`` =
    { category = "Cache"; counter = "Copy Read Hits %"; instance = NotApplicable }
  /// MDL Reads/sec: MDL Reads/sec is the frequency of reads from the file system cache that use a Memory Descriptor List (MDL) to access the data.  The MDL contains the physical address of each page involved in the transfer, and thus can employ a hardware Direct Memory Access (DMA) device to effect the copy.  The LAN Server uses this method for large transfers out of the server.
  let ``MDL Reads/sec`` =
    { category = "Cache"; counter = "MDL Reads/sec"; instance = NotApplicable }
  /// Sync MDL Reads/sec: Sync MDL Reads/sec is the frequency of reads from the file system cache that use a Memory Descriptor List (MDL) to access the pages.  The MDL contains the physical address of each page in the transfer, thus permitting Direct Memory Access (DMA) of the pages.  If the accessed page(s) are not in main memory, the caller will wait for the pages to fault in from the disk.
  let ``Sync MDL Reads/sec`` =
    { category = "Cache"; counter = "Sync MDL Reads/sec"; instance = NotApplicable }
  /// Async MDL Reads/sec: Async MDL Reads/sec is the frequency of reads from the file system cache that use a Memory Descriptor List (MDL) to access the pages.  The MDL contains the physical address of each page in the transfer, thus permitting Direct Memory Access (DMA) of the pages.  If the accessed page(s) are not in main memory, the calling application program will not wait for the pages to fault in from disk.
  let ``Async MDL Reads/sec`` =
    { category = "Cache"; counter = "Async MDL Reads/sec"; instance = NotApplicable }
  /// MDL Read Hits %: MDL Read Hits is the percentage of Memory Descriptor List (MDL) Read requests to the file system cache that hit the cache, i.e., did not require disk accesses in order to provide memory access to the page(s) in the cache.
  let ``MDL Read Hits %`` =
    { category = "Cache"; counter = "MDL Read Hits %"; instance = NotApplicable }
  /// Read Aheads/sec: Read Aheads/sec is the frequency of reads from the file system cache in which the Cache detects sequential access to a file.  The read aheads permit the data to be transferred in larger blocks than those being requested by the application, reducing the overhead per access.
  let ``Read Aheads/sec`` =
    { category = "Cache"; counter = "Read Aheads/sec"; instance = NotApplicable }
  /// Fast Reads/sec: Fast Reads/sec is the frequency of reads from the file system cache that bypass the installed file system and retrieve the data directly from the cache.  Normally, file I/O requests invoke the appropriate file system to retrieve data from a file, but this path permits direct retrieval of data from the cache without file system involvement if the data is in the cache.  Even if the data is not in the cache, one invocation of the file system is avoided.
  let ``Fast Reads/sec`` =
    { category = "Cache"; counter = "Fast Reads/sec"; instance = NotApplicable }
  /// Sync Fast Reads/sec: Sync Fast Reads/sec is the frequency of reads from the file system cache that bypass the installed file system and retrieve the data directly from the cache.  Normally, file I/O requests invoke the appropriate file system to retrieve data from a file, but this path permits direct retrieval of data from the cache without file system involvement if the data is in the cache.  Even if the data is not in the cache, one invocation of the file system is avoided.  If the data is not in the cache, the request (application program call) will wait until the data has been retrieved from disk.
  let ``Sync Fast Reads/sec`` =
    { category = "Cache"; counter = "Sync Fast Reads/sec"; instance = NotApplicable }
  /// Async Fast Reads/sec: Async Fast Reads/sec is the frequency of reads from the file system cache that bypass the installed file system and retrieve the data directly from the cache.  Normally, file I/O requests will invoke the appropriate file system to retrieve data from a file, but this path permits data to be retrieved from the cache directly (without file system involvement) if the data is in the cache.  Even if the data is not in the cache, one invocation of the file system is avoided.  If the data is not in the cache, the request (application program call) will not wait until the data has been retrieved from disk, but will get control immediately.
  let ``Async Fast Reads/sec`` =
    { category = "Cache"; counter = "Async Fast Reads/sec"; instance = NotApplicable }
  /// Fast Read Resource Misses/sec: Fast Read Resource Misses/sec is the frequency of cache misses necessitated by the lack of available resources to satisfy the request.
  let ``Fast Read Resource Misses/sec`` =
    { category = "Cache"; counter = "Fast Read Resource Misses/sec"; instance = NotApplicable }
  /// Fast Read Not Possibles/sec: Fast Read Not Possibles/sec is the frequency of attempts by an Application Program Interface (API) function call to bypass the file system to get to data in the file system cache that could not be honored without invoking the file system.
  let ``Fast Read Not Possibles/sec`` =
    { category = "Cache"; counter = "Fast Read Not Possibles/sec"; instance = NotApplicable }
  /// Lazy Write Flushes/sec: Lazy Write Flushes/sec is the rate at which the Lazy Writer thread has written to disk.  Lazy Writing is the process of updating the disk after the page has been changed in memory, so that the application that changed the file does not have to wait for the disk write to be complete before proceeding.  More than one page can be transferred by each write operation.
  let ``Lazy Write Flushes/sec`` =
    { category = "Cache"; counter = "Lazy Write Flushes/sec"; instance = NotApplicable }
  /// Lazy Write Pages/sec: Lazy Write Pages/sec is the rate at which the Lazy Writer thread has written to disk.  Lazy Writing is the process of updating the disk after the page has been changed in memory, so that the application that changed the file does not have to wait for the disk write to be complete before proceeding.  More than one page can be transferred on a single disk write operation.
  let ``Lazy Write Pages/sec`` =
    { category = "Cache"; counter = "Lazy Write Pages/sec"; instance = NotApplicable }
  /// Data Flushes/sec: Data Flushes/sec is the rate at which the file system cache has flushed its contents to disk as the result of a request to flush or to satisfy a write-through file write request.  More than one page can be transferred on each flush operation.
  let ``Data Flushes/sec`` =
    { category = "Cache"; counter = "Data Flushes/sec"; instance = NotApplicable }
  /// Data Flush Pages/sec: Data Flush Pages/sec is the number of pages the file system cache has flushed to disk as a result of a request to flush or to satisfy a write-through file write request.  More than one page can be transferred on each flush operation.
  let ``Data Flush Pages/sec`` =
    { category = "Cache"; counter = "Data Flush Pages/sec"; instance = NotApplicable }
  /// Dirty Pages: Total number of dirty pages on the system cache
  let ``Dirty Pages`` =
    { category = "Cache"; counter = "Dirty Pages"; instance = NotApplicable }
  /// Dirty Page Threshold: Threshold for number of dirty pages on system cache
  let ``Dirty Page Threshold`` =
    { category = "Cache"; counter = "Dirty Page Threshold"; instance = NotApplicable }

  let allCounters =
    [ ``Data Maps/sec``
      ``Sync Data Maps/sec``
      ``Async Data Maps/sec``
      ``Data Map Hits %``
      ``Data Map Pins/sec``
      ``Pin Reads/sec``
      ``Sync Pin Reads/sec``
      ``Async Pin Reads/sec``
      ``Pin Read Hits %``
      ``Copy Reads/sec``
      ``Sync Copy Reads/sec``
      ``Async Copy Reads/sec``
      ``Copy Read Hits %``
      ``MDL Reads/sec``
      ``Sync MDL Reads/sec``
      ``Async MDL Reads/sec``
      ``MDL Read Hits %``
      ``Read Aheads/sec``
      ``Fast Reads/sec``
      ``Sync Fast Reads/sec``
      ``Async Fast Reads/sec``
      ``Fast Read Resource Misses/sec``
      ``Fast Read Not Possibles/sec``
      ``Lazy Write Flushes/sec``
      ``Lazy Write Pages/sec``
      ``Data Flushes/sec``
      ``Data Flush Pages/sec``
      ``Dirty Pages``
      ``Dirty Page Threshold``
    ]

/// Classification Engine: Content Analysis Session: Classification Engine: Content Analysis Session
///
/// This performance counter does not have instance based counters
module ``Classification Engine: Content Analysis Session`` =

  [<Literal>]
  let Category = "Classification Engine: Content Analysis Session"

  let PCC = getPCC Category
  /// Average Time to Retrieve Data: 
  let ``Average Time to Retrieve Data`` instance =
    { category = "Classification Engine: Content Analysis Session"; counter = "Average Time to Retrieve Data"; instance = instance }
  /// Average Time to Classify All Rules: 
  let ``Average Time to Classify All Rules`` instance =
    { category = "Classification Engine: Content Analysis Session"; counter = "Average Time to Classify All Rules"; instance = instance }
  /// Average Time to Classify OOB Rules: 
  let ``Average Time to Classify OOB Rules`` instance =
    { category = "Classification Engine: Content Analysis Session"; counter = "Average Time to Classify OOB Rules"; instance = instance }

  let allCounters =
    [ ``Average Time to Retrieve Data``
      ``Average Time to Classify All Rules``
      ``Average Time to Classify OOB Rules``
    ]

/// Classification Engine: Rule Package Cache: Classification Engine: Rule Package Cache
///
/// This performance counter does not have instance based counters
module ``Classification Engine: Rule Package Cache`` =

  [<Literal>]
  let Category = "Classification Engine: Rule Package Cache"

  let PCC = getPCC Category
  /// Successful Cache Hits: 
  let ``Successful Cache Hits`` instance =
    { category = "Classification Engine: Rule Package Cache"; counter = "Successful Cache Hits"; instance = instance }
  /// Recoverable Cache Misses: 
  let ``Recoverable Cache Misses`` instance =
    { category = "Classification Engine: Rule Package Cache"; counter = "Recoverable Cache Misses"; instance = instance }
  /// Unrecoverable Cache Misses: 
  let ``Unrecoverable Cache Misses`` instance =
    { category = "Classification Engine: Rule Package Cache"; counter = "Unrecoverable Cache Misses"; instance = instance }
  /// Forced Rule Package Retrievals: 
  let ``Forced Rule Package Retrievals`` instance =
    { category = "Classification Engine: Rule Package Cache"; counter = "Forced Rule Package Retrievals"; instance = instance }
  /// Average Time to Retrieve Rules: 
  let ``Average Time to Retrieve Rules`` instance =
    { category = "Classification Engine: Rule Package Cache"; counter = "Average Time to Retrieve Rules"; instance = instance }
  /// Average Time to Load Rules: 
  let ``Average Time to Load Rules`` instance =
    { category = "Classification Engine: Rule Package Cache"; counter = "Average Time to Load Rules"; instance = instance }
  /// Rule Package Count Evictions: 
  let ``Rule Package Count Evictions`` instance =
    { category = "Classification Engine: Rule Package Cache"; counter = "Rule Package Count Evictions"; instance = instance }
  /// Rule Package Memory Evictions: 
  let ``Rule Package Memory Evictions`` instance =
    { category = "Classification Engine: Rule Package Cache"; counter = "Rule Package Memory Evictions"; instance = instance }

  let allCounters =
    [ ``Successful Cache Hits``
      ``Recoverable Cache Misses``
      ``Unrecoverable Cache Misses``
      ``Forced Rule Package Retrievals``
      ``Average Time to Retrieve Rules``
      ``Average Time to Load Rules``
      ``Rule Package Count Evictions``
      ``Rule Package Memory Evictions``
    ]

/// Client Side Caching: Performance counters for SMB BranchCache for reduced bandwidth consumption
///
/// This performance counter does not have instance based counters
module ``Client Side Caching`` =

  [<Literal>]
  let Category = "Client Side Caching"

  let PCC = getPCC Category
  /// SMB BranchCache Bytes Requested: Bytes requested from BranchCache
  let ``SMB BranchCache Bytes Requested`` =
    { category = "Client Side Caching"; counter = "SMB BranchCache Bytes Requested"; instance = NotApplicable }
  /// SMB BranchCache Bytes Received: Bytes received from BranchCache
  let ``SMB BranchCache Bytes Received`` =
    { category = "Client Side Caching"; counter = "SMB BranchCache Bytes Received"; instance = NotApplicable }
  /// SMB BranchCache Bytes Published: Bytes published back to BranchCache
  let ``SMB BranchCache Bytes Published`` =
    { category = "Client Side Caching"; counter = "SMB BranchCache Bytes Published"; instance = NotApplicable }
  /// SMB BranchCache Bytes Requested From Server: Bytes not found in BranchCache and retrieved from the server
  let ``SMB BranchCache Bytes Requested From Server`` =
    { category = "Client Side Caching"; counter = "SMB BranchCache Bytes Requested From Server"; instance = NotApplicable }
  /// SMB BranchCache Hashes Requested: Count of hash requests sent to the server for BranchCache lookup
  let ``SMB BranchCache Hashes Requested`` =
    { category = "Client Side Caching"; counter = "SMB BranchCache Hashes Requested"; instance = NotApplicable }
  /// SMB BranchCache Hashes Received: Count of hash requests successfully receieved back from the server for BranchCache lookup
  let ``SMB BranchCache Hashes Received`` =
    { category = "Client Side Caching"; counter = "SMB BranchCache Hashes Received"; instance = NotApplicable }
  /// SMB BranchCache Hash Bytes Received: Bytes of hash data successfully received back from the server for BranchCache lookup
  let ``SMB BranchCache Hash Bytes Received`` =
    { category = "Client Side Caching"; counter = "SMB BranchCache Hash Bytes Received"; instance = NotApplicable }
  /// Prefetch Operations Queued: Count of prefetch operations queued to retrieve or publish BranchCache data
  let ``Prefetch Operations Queued`` =
    { category = "Client Side Caching"; counter = "Prefetch Operations Queued"; instance = NotApplicable }
  /// Prefetch Bytes Read From Cache: Bytes read by the BranchCache prefetcher service from the Client Side Cache
  let ``Prefetch Bytes Read From Cache`` =
    { category = "Client Side Caching"; counter = "Prefetch Bytes Read From Cache"; instance = NotApplicable }
  /// Prefetch Bytes Read From Server: Bytes read by the BranchCache prefetcher from the server
  let ``Prefetch Bytes Read From Server`` =
    { category = "Client Side Caching"; counter = "Prefetch Bytes Read From Server"; instance = NotApplicable }
  /// Application Bytes Read From Cache: Transparently cached bytes read by applications from the Client Side Cache
  let ``Application Bytes Read From Cache`` =
    { category = "Client Side Caching"; counter = "Application Bytes Read From Cache"; instance = NotApplicable }
  /// Application Bytes Read From Server: Transparently cached bytes read by applications from the server
  let ``Application Bytes Read From Server`` =
    { category = "Client Side Caching"; counter = "Application Bytes Read From Server"; instance = NotApplicable }
  /// Application Bytes Read From Server (Not Cached): Transparently cached bytes read by applications from the server and not cached by the client
  let ``Application Bytes Read From Server (Not Cached)`` =
    { category = "Client Side Caching"; counter = "Application Bytes Read From Server (Not Cached)"; instance = NotApplicable }

  let allCounters =
    [ ``SMB BranchCache Bytes Requested``
      ``SMB BranchCache Bytes Received``
      ``SMB BranchCache Bytes Published``
      ``SMB BranchCache Bytes Requested From Server``
      ``SMB BranchCache Hashes Requested``
      ``SMB BranchCache Hashes Received``
      ``SMB BranchCache Hash Bytes Received``
      ``Prefetch Operations Queued``
      ``Prefetch Bytes Read From Cache``
      ``Prefetch Bytes Read From Server``
      ``Application Bytes Read From Cache``
      ``Application Bytes Read From Server``
      ``Application Bytes Read From Server (Not Cached)``
    ]

/// DNS64 Global: Statistics of DNS64 on this machine.
///
/// This performance counter does not have non-instance based counters
module ``DNS64 Global`` =

  [<Literal>]
  let Category = "DNS64 Global"

  let PCC = getPCC Category
  /// AAAA queries - Successful: Number of AAAA queries successfully served by the DNS64 server.
  let ``AAAA queries - Successful`` instance =
    { category = "DNS64 Global"; counter = "AAAA queries - Successful"; instance = instance }
  /// AAAA queries - Failed: Number of AAAA queries unsuccessfully served by the DNS64 server.
  let ``AAAA queries - Failed`` instance =
    { category = "DNS64 Global"; counter = "AAAA queries - Failed"; instance = instance }
  /// IP6.ARPA queries - Matched: Number of IP6.ARPA PTR queries, matched configured prefixes.
  let ``IP6.ARPA queries - Matched`` instance =
    { category = "DNS64 Global"; counter = "IP6.ARPA queries - Matched"; instance = instance }
  /// Other queries - Successful: Number of successfully served pass-through queries.
  let ``Other queries - Successful`` instance =
    { category = "DNS64 Global"; counter = "Other queries - Successful"; instance = instance }
  /// Other queries - Failed: Number of unsuccessfully served pass-through queries.
  let ``Other queries - Failed`` instance =
    { category = "DNS64 Global"; counter = "Other queries - Failed"; instance = instance }
  /// AAAA - Synthesized records: Number of synthesized AAAA records.
  let ``AAAA - Synthesized records`` instance =
    { category = "DNS64 Global"; counter = "AAAA - Synthesized records"; instance = instance }

  let allCounters =
    [ ``AAAA queries - Successful``
      ``AAAA queries - Failed``
      ``IP6.ARPA queries - Matched``
      ``Other queries - Successful``
      ``Other queries - Failed``
      ``AAAA - Synthesized records``
    ]

/// Distributed Routing Table: The Distributed Routing Table (DRT) performance object consists of counters that monitor the local DRT cache as well as counters that measure the rates at which DRT protocol messages are sent and received.
///
/// This performance counter does not have instance based counters
module ``Distributed Routing Table`` =

  [<Literal>]
  let Category = "Distributed Routing Table"

  let PCC = getPCC Category
  /// Registrations: 
  let ``Registrations`` instance =
    { category = "Distributed Routing Table"; counter = "Registrations"; instance = instance }
  /// Searches: 
  let ``Searches`` instance =
    { category = "Distributed Routing Table"; counter = "Searches"; instance = instance }
  /// Cache Entries: 
  let ``Cache Entries`` instance =
    { category = "Distributed Routing Table"; counter = "Cache Entries"; instance = instance }
  /// Average Bytes/second Sent: 
  let ``Average Bytes/second Sent`` instance =
    { category = "Distributed Routing Table"; counter = "Average Bytes/second Sent"; instance = instance }
  /// Average Bytes/second Received: 
  let ``Average Bytes/second Received`` instance =
    { category = "Distributed Routing Table"; counter = "Average Bytes/second Received"; instance = instance }
  /// Estimated cloud size: 
  let ``Estimated cloud size`` instance =
    { category = "Distributed Routing Table"; counter = "Estimated cloud size"; instance = instance }
  /// Stale Cache Entries: 
  let ``Stale Cache Entries`` instance =
    { category = "Distributed Routing Table"; counter = "Stale Cache Entries"; instance = instance }
  /// Send Failures: 
  let ``Send Failures`` instance =
    { category = "Distributed Routing Table"; counter = "Send Failures"; instance = instance }
  /// Receive Failures: 
  let ``Receive Failures`` instance =
    { category = "Distributed Routing Table"; counter = "Receive Failures"; instance = instance }
  /// Solicit Messages Sent/second: 
  let ``Solicit Messages Sent/second`` instance =
    { category = "Distributed Routing Table"; counter = "Solicit Messages Sent/second"; instance = instance }
  /// Solicit Messages Received/second: 
  let ``Solicit Messages Received/second`` instance =
    { category = "Distributed Routing Table"; counter = "Solicit Messages Received/second"; instance = instance }
  /// Advertise Messages Sent/second: 
  let ``Advertise Messages Sent/second`` instance =
    { category = "Distributed Routing Table"; counter = "Advertise Messages Sent/second"; instance = instance }
  /// Advertise Messages Received/second: 
  let ``Advertise Messages Received/second`` instance =
    { category = "Distributed Routing Table"; counter = "Advertise Messages Received/second"; instance = instance }
  /// Request Messages Sent/second: 
  let ``Request Messages Sent/second`` instance =
    { category = "Distributed Routing Table"; counter = "Request Messages Sent/second"; instance = instance }
  /// Request Messages Received/second: 
  let ``Request Messages Received/second`` instance =
    { category = "Distributed Routing Table"; counter = "Request Messages Received/second"; instance = instance }
  /// Flood Messages Sent/second: 
  let ``Flood Messages Sent/second`` instance =
    { category = "Distributed Routing Table"; counter = "Flood Messages Sent/second"; instance = instance }
  /// Flood Messages Received/second: 
  let ``Flood Messages Received/second`` instance =
    { category = "Distributed Routing Table"; counter = "Flood Messages Received/second"; instance = instance }
  /// Inquire Messages Sent/second: 
  let ``Inquire Messages Sent/second`` instance =
    { category = "Distributed Routing Table"; counter = "Inquire Messages Sent/second"; instance = instance }
  /// Inquire Messages Received/second: 
  let ``Inquire Messages Received/second`` instance =
    { category = "Distributed Routing Table"; counter = "Inquire Messages Received/second"; instance = instance }
  /// Authority Sent/second: 
  let ``Authority Sent/second`` instance =
    { category = "Distributed Routing Table"; counter = "Authority Sent/second"; instance = instance }
  /// Authority Messages Received/second: 
  let ``Authority Messages Received/second`` instance =
    { category = "Distributed Routing Table"; counter = "Authority Messages Received/second"; instance = instance }
  /// Ack Messages Sent/second: 
  let ``Ack Messages Sent/second`` instance =
    { category = "Distributed Routing Table"; counter = "Ack Messages Sent/second"; instance = instance }
  /// Ack Messages Received/second: 
  let ``Ack Messages Received/second`` instance =
    { category = "Distributed Routing Table"; counter = "Ack Messages Received/second"; instance = instance }
  /// Lookup Messages Sent/second: 
  let ``Lookup Messages Sent/second`` instance =
    { category = "Distributed Routing Table"; counter = "Lookup Messages Sent/second"; instance = instance }
  /// Lookup Messages Received/second: 
  let ``Lookup Messages Received/second`` instance =
    { category = "Distributed Routing Table"; counter = "Lookup Messages Received/second"; instance = instance }
  /// Unrecognized Messages Received: 
  let ``Unrecognized Messages Received`` instance =
    { category = "Distributed Routing Table"; counter = "Unrecognized Messages Received"; instance = instance }

  let allCounters =
    [ ``Registrations``
      ``Searches``
      ``Cache Entries``
      ``Average Bytes/second Sent``
      ``Average Bytes/second Received``
      ``Estimated cloud size``
      ``Stale Cache Entries``
      ``Send Failures``
      ``Receive Failures``
      ``Solicit Messages Sent/second``
      ``Solicit Messages Received/second``
      ``Advertise Messages Sent/second``
      ``Advertise Messages Received/second``
      ``Request Messages Sent/second``
      ``Request Messages Received/second``
      ``Flood Messages Sent/second``
      ``Flood Messages Received/second``
      ``Inquire Messages Sent/second``
      ``Inquire Messages Received/second``
      ``Authority Sent/second``
      ``Authority Messages Received/second``
      ``Ack Messages Sent/second``
      ``Ack Messages Received/second``
      ``Lookup Messages Sent/second``
      ``Lookup Messages Received/second``
      ``Unrecognized Messages Received``
    ]

/// Distributed Transaction Coordinator: Microsoft Distributed Transaction Coordinator performance counters
///
/// This performance counter does not have instance based counters
module ``Distributed Transaction Coordinator`` =

  [<Literal>]
  let Category = "Distributed Transaction Coordinator"

  let PCC = getPCC Category
  /// Active Transactions: Number of currently active transactions
  let ``Active Transactions`` =
    { category = "Distributed Transaction Coordinator"; counter = "Active Transactions"; instance = NotApplicable }
  /// Committed Transactions: Number of committed transactions
  let ``Committed Transactions`` =
    { category = "Distributed Transaction Coordinator"; counter = "Committed Transactions"; instance = NotApplicable }
  /// Aborted Transactions: Number of aborted transactions
  let ``Aborted Transactions`` =
    { category = "Distributed Transaction Coordinator"; counter = "Aborted Transactions"; instance = NotApplicable }
  /// In Doubt Transactions: Number of in doubt transactions
  let ``In Doubt Transactions`` =
    { category = "Distributed Transaction Coordinator"; counter = "In Doubt Transactions"; instance = NotApplicable }
  /// Active Transactions Maximum: Maximum number of transactions ever concurrently active
  let ``Active Transactions Maximum`` =
    { category = "Distributed Transaction Coordinator"; counter = "Active Transactions Maximum"; instance = NotApplicable }
  /// Force Committed Transactions: Number of transactions committed by the system administrator
  let ``Force Committed Transactions`` =
    { category = "Distributed Transaction Coordinator"; counter = "Force Committed Transactions"; instance = NotApplicable }
  /// Force Aborted Transactions: Number of transactions aborted by the system administrator
  let ``Force Aborted Transactions`` =
    { category = "Distributed Transaction Coordinator"; counter = "Force Aborted Transactions"; instance = NotApplicable }
  /// Response Time -- Minimum: Minimum time delta between transaction begin and commit
  let ``Response Time -- Minimum`` =
    { category = "Distributed Transaction Coordinator"; counter = "Response Time -- Minimum"; instance = NotApplicable }
  /// Response Time -- Average: Average time delta between transaction begin and commit
  let ``Response Time -- Average`` =
    { category = "Distributed Transaction Coordinator"; counter = "Response Time -- Average"; instance = NotApplicable }
  /// Response Time -- Maximum: Maximum time delta between transaction begin and commit
  let ``Response Time -- Maximum`` =
    { category = "Distributed Transaction Coordinator"; counter = "Response Time -- Maximum"; instance = NotApplicable }
  /// Transactions/sec: Transactions performed per second
  let ``Transactions/sec`` =
    { category = "Distributed Transaction Coordinator"; counter = "Transactions/sec"; instance = NotApplicable }
  /// Committed Transactions/sec: Transactions committed per second
  let ``Committed Transactions/sec`` =
    { category = "Distributed Transaction Coordinator"; counter = "Committed Transactions/sec"; instance = NotApplicable }
  /// Aborted Transactions/sec: Transactions aborted per second
  let ``Aborted Transactions/sec`` =
    { category = "Distributed Transaction Coordinator"; counter = "Aborted Transactions/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Active Transactions``
      ``Committed Transactions``
      ``Aborted Transactions``
      ``In Doubt Transactions``
      ``Active Transactions Maximum``
      ``Force Committed Transactions``
      ``Force Aborted Transactions``
      ``Response Time -- Minimum``
      ``Response Time -- Average``
      ``Response Time -- Maximum``
      ``Transactions/sec``
      ``Committed Transactions/sec``
      ``Aborted Transactions/sec``
    ]

/// Event Tracing for Windows: The counters in this collection refer to system-wide metrics about the performance of the Event Tracing for Windows subsystem.
///
/// This performance counter does not have instance based counters
module ``Event Tracing for Windows`` =

  [<Literal>]
  let Category = "Event Tracing for Windows"

  let PCC = getPCC Category
  /// Total Number of Distinct Enabled Providers: Number of distinct event providers that are enabled to ETW sessions; multiple instances of a provider are counted only once.
  let ``Total Number of Distinct Enabled Providers`` =
    { category = "Event Tracing for Windows"; counter = "Total Number of Distinct Enabled Providers"; instance = NotApplicable }
  /// Total Number of Distinct Pre-Enabled Providers: Number of unique tracing providers that have been enabled to a trace session but have not yet registered with ETW.
  let ``Total Number of Distinct Pre-Enabled Providers`` =
    { category = "Event Tracing for Windows"; counter = "Total Number of Distinct Pre-Enabled Providers"; instance = NotApplicable }
  /// Total Number of Distinct Disabled Providers: Number of unique tracing providers that are registered with the tracing subsystem but are not actively enabled to any trace session; multiple registered instances of a provider are counted only once.
  let ``Total Number of Distinct Disabled Providers`` =
    { category = "Event Tracing for Windows"; counter = "Total Number of Distinct Disabled Providers"; instance = NotApplicable }
  /// Total Number of Active Sessions: Number of ETW tracing sessions currently active.
  let ``Total Number of Active Sessions`` =
    { category = "Event Tracing for Windows"; counter = "Total Number of Active Sessions"; instance = NotApplicable }
  /// Total Memory Usage --- Paged Pool: Current size of paged memory allocated for the buffers associated with all active sessions (in bytes).
  let ``Total Memory Usage --- Paged Pool`` =
    { category = "Event Tracing for Windows"; counter = "Total Memory Usage --- Paged Pool"; instance = NotApplicable }
  /// Total Memory Usage --- Non-Paged Pool: Current size of non-paged memory allocated for the buffers associated with all active sessions (in bytes).
  let ``Total Memory Usage --- Non-Paged Pool`` =
    { category = "Event Tracing for Windows"; counter = "Total Memory Usage --- Non-Paged Pool"; instance = NotApplicable }

  let allCounters =
    [ ``Total Number of Distinct Enabled Providers``
      ``Total Number of Distinct Pre-Enabled Providers``
      ``Total Number of Distinct Disabled Providers``
      ``Total Number of Active Sessions``
      ``Total Memory Usage --- Paged Pool``
      ``Total Memory Usage --- Non-Paged Pool``
    ]

/// Event Tracing for Windows Session: The counters in this collection are related to individual Event Tracing for Windows sessions.
///
/// This performance counter does not have non-instance based counters
module ``Event Tracing for Windows Session`` =

  [<Literal>]
  let Category = "Event Tracing for Windows Session"

  let PCC = getPCC Category
  /// Buffer Memory Usage -- Paged Pool: Current size of paged memory allocated for the buffers associated with this session (in bytes).
  let ``Buffer Memory Usage -- Paged Pool`` instance =
    { category = "Event Tracing for Windows Session"; counter = "Buffer Memory Usage -- Paged Pool"; instance = instance }
  /// Buffer Memory Usage -- Non-Paged Pool: Current size of non-paged memory allocated for the buffers associated with this session (in bytes).
  let ``Buffer Memory Usage -- Non-Paged Pool`` instance =
    { category = "Event Tracing for Windows Session"; counter = "Buffer Memory Usage -- Non-Paged Pool"; instance = instance }
  /// Events Logged per sec: Rate at which events are logged to this session by providers that are enabled to this session (events/sec).
  let ``Events Logged per sec`` instance =
    { category = "Event Tracing for Windows Session"; counter = "Events Logged per sec"; instance = instance }
  /// Events Lost: Total number of events that were not successfully logged since the start of the tracing session.  Events are lost due to limited space in the session's buffers.  To avoid lost events, consider increasing the buffer size or the number of buffers.
  let ``Events Lost`` instance =
    { category = "Event Tracing for Windows Session"; counter = "Events Lost"; instance = instance }
  /// Number of Real-Time Consumers: Number of consumers currently reading events from this session in real-time mode.
  let ``Number of Real-Time Consumers`` instance =
    { category = "Event Tracing for Windows Session"; counter = "Number of Real-Time Consumers"; instance = instance }

  let allCounters =
    [ ``Buffer Memory Usage -- Paged Pool``
      ``Buffer Memory Usage -- Non-Paged Pool``
      ``Events Logged per sec``
      ``Events Lost``
      ``Number of Real-Time Consumers``
    ]

/// Fax Service: Fax Service Counter Set
///
/// This performance counter does not have instance based counters
module ``Fax Service`` =

  [<Literal>]
  let Category = "Fax Service"

  let PCC = getPCC Category
  /// Total minutes sending and receiving: Total number of minutes that the service sent and received faxes.
  let ``Total minutes sending and receiving`` =
    { category = "Fax Service"; counter = "Total minutes sending and receiving"; instance = NotApplicable }
  /// Total pages: Total number of pages sent and received.
  let ``Total pages`` =
    { category = "Fax Service"; counter = "Total pages"; instance = NotApplicable }
  /// Total faxes sent and received: Total number of faxes sent and received.
  let ``Total faxes sent and received`` =
    { category = "Fax Service"; counter = "Total faxes sent and received"; instance = NotApplicable }
  /// Total bytes: Total number of bytes sent and received.
  let ``Total bytes`` =
    { category = "Fax Service"; counter = "Total bytes"; instance = NotApplicable }
  /// Failed faxes transmissions: Number of faxes that failed.
  let ``Failed faxes transmissions`` =
    { category = "Fax Service"; counter = "Failed faxes transmissions"; instance = NotApplicable }
  /// Failed outgoing connections: Number of outgoing connections that failed.
  let ``Failed outgoing connections`` =
    { category = "Fax Service"; counter = "Failed outgoing connections"; instance = NotApplicable }
  /// Minutes sending: Number of minutes that the service spent in sending successfully transmitted faxes.
  let ``Minutes sending`` =
    { category = "Fax Service"; counter = "Minutes sending"; instance = NotApplicable }
  /// Pages sent: Number of pages sent.
  let ``Pages sent`` =
    { category = "Fax Service"; counter = "Pages sent"; instance = NotApplicable }
  /// Faxes sent: Number of faxes successfully sent.
  let ``Faxes sent`` =
    { category = "Fax Service"; counter = "Faxes sent"; instance = NotApplicable }
  /// Bytes sent: Number of bytes sent.
  let ``Bytes sent`` =
    { category = "Fax Service"; counter = "Bytes sent"; instance = NotApplicable }
  /// Failed receptions: Number of faxes that service failed to receive.
  let ``Failed receptions`` =
    { category = "Fax Service"; counter = "Failed receptions"; instance = NotApplicable }
  /// Minutes receiving: Number of minutes that the service received faxes.
  let ``Minutes receiving`` =
    { category = "Fax Service"; counter = "Minutes receiving"; instance = NotApplicable }
  /// Received pages: Number of pages received.
  let ``Received pages`` =
    { category = "Fax Service"; counter = "Received pages"; instance = NotApplicable }
  /// Received faxes: Number of successfully received faxes.
  let ``Received faxes`` =
    { category = "Fax Service"; counter = "Received faxes"; instance = NotApplicable }
  /// Bytes received: Number of bytes received.
  let ``Bytes received`` =
    { category = "Fax Service"; counter = "Bytes received"; instance = NotApplicable }

  let allCounters =
    [ ``Total minutes sending and receiving``
      ``Total pages``
      ``Total faxes sent and received``
      ``Total bytes``
      ``Failed faxes transmissions``
      ``Failed outgoing connections``
      ``Minutes sending``
      ``Pages sent``
      ``Faxes sent``
      ``Bytes sent``
      ``Failed receptions``
      ``Minutes receiving``
      ``Received pages``
      ``Received faxes``
      ``Bytes received``
    ]

/// FileSystem Disk Activity: The FileSystem Disk Activity performance counter set consists of counters that measure the aspect of filesystem's IO Activity.  This counter set measures the number of bytes filesystem read from and wrote to the disk drive.
///
/// This performance counter does not have non-instance based counters
module ``FileSystem Disk Activity`` =

  [<Literal>]
  let Category = "FileSystem Disk Activity"

  let PCC = getPCC Category
  /// FileSystem Bytes Read: Total Bytes Read by the FileSystem from disk drive
  let ``FileSystem Bytes Read`` instance =
    { category = "FileSystem Disk Activity"; counter = "FileSystem Bytes Read"; instance = instance }
  /// FileSystem Bytes Written: Total Bytes Written by the FileSystem from disk drive
  let ``FileSystem Bytes Written`` instance =
    { category = "FileSystem Disk Activity"; counter = "FileSystem Bytes Written"; instance = instance }

  let allCounters =
    [ ``FileSystem Bytes Read``
      ``FileSystem Bytes Written``
    ]

/// Generic IKEv1, AuthIP, and IKEv2: Generic IKEv1, AuthIP, and IKEv2 is the set of Internet Protocol security (IPsec) Internet Key Exchange Version 1 (IKEv1), Authenticated IP (AuthIP), and Internet Key Exchange Version 2 (IKEv2) counters that are generic and do not apply to a specific Internet Protocol version.
///
/// This performance counter does not have instance based counters
module ``Generic IKEv1_ AuthIP_ and IKEv2`` =

  [<Literal>]
  let Category = "Generic IKEv1, AuthIP, and IKEv2"

  let PCC = getPCC Category
  /// IKEv1 Main Mode Negotiation Time: IKEv1 Main Mode Negotiation Time is the number of milliseconds taken for the last IKEv1 main mode security association negotiated.
  let ``IKEv1 Main Mode Negotiation Time`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "IKEv1 Main Mode Negotiation Time"; instance = NotApplicable }
  /// AuthIP Main Mode Negotiation Time: AuthIP Main Mode Negotiation Time is the number of milliseconds taken for the last Authenticated IP main mode security association negotiated.
  let ``AuthIP Main Mode Negotiation Time`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "AuthIP Main Mode Negotiation Time"; instance = NotApplicable }
  /// IKEv1 Quick Mode Negotiation Time: IKEv1 Quick Mode Negotiation Time is the number of milliseconds taken for the last IKEv1 quick mode security association negotiated.
  let ``IKEv1 Quick Mode Negotiation Time`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "IKEv1 Quick Mode Negotiation Time"; instance = NotApplicable }
  /// AuthIP Quick Mode Negotiation Time: AuthIP Quick Mode Negotiation Time is the number of milliseconds taken for the last Authenticated IP quick mode security association negotiated.
  let ``AuthIP Quick Mode Negotiation Time`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "AuthIP Quick Mode Negotiation Time"; instance = NotApplicable }
  /// Extended Mode Negotiation Time: Extended Mode Negotiation Time is the number of milliseconds taken for the last extended mode security association negotiated.
  let ``Extended Mode Negotiation Time`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "Extended Mode Negotiation Time"; instance = NotApplicable }
  /// Packets Received/sec: Packets Received per Second is the rate at which validated IPsec packets are being received.
  let ``Packets Received/sec`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "Packets Received/sec"; instance = NotApplicable }
  /// Invalid Packets Received/sec: Invalid Packets Received per Second is the rate at which invalid IPsec packets are being received.
  let ``Invalid Packets Received/sec`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "Invalid Packets Received/sec"; instance = NotApplicable }
  /// Successful Negotiations: Successful Negotiations is the number of negotiations completed for IKEv1, AuthIP, and IKEv2 since IPsec was last started.
  let ``Successful Negotiations`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "Successful Negotiations"; instance = NotApplicable }
  /// Successful Negotiations/sec: Successful Negotiations per Second is the rate of negotiations completed for IKEv1, AuthIP, and IKEv2.
  let ``Successful Negotiations/sec`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "Successful Negotiations/sec"; instance = NotApplicable }
  /// Failed Negotiations: Failed Negotiations is the number of failed negotiations for IKEv1, AuthIP, and IKEv2 since IPsec was last started.
  let ``Failed Negotiations`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "Failed Negotiations"; instance = NotApplicable }
  /// Failed Negotiations/sec: Failed Negotiations per Second is the rate of failed negotiations attempted for IKEv1, AuthIP, and IKEv2.
  let ``Failed Negotiations/sec`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "Failed Negotiations/sec"; instance = NotApplicable }
  /// IKEv2 Main Mode Negotiation Time: IKEv2 Main Mode Negotiation Time is the number of milliseconds taken for the last IKEv2 main mode security association negotiated.
  let ``IKEv2 Main Mode Negotiation Time`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "IKEv2 Main Mode Negotiation Time"; instance = NotApplicable }
  /// IKEv2 Quick Mode Negotiation Time: IKEv2 Quick Mode Negotiation Time is the number of milliseconds taken for the last IKEv2 quick mode security association negotiated.
  let ``IKEv2 Quick Mode Negotiation Time`` =
    { category = "Generic IKEv1, AuthIP, and IKEv2"; counter = "IKEv2 Quick Mode Negotiation Time"; instance = NotApplicable }

  let allCounters =
    [ ``IKEv1 Main Mode Negotiation Time``
      ``AuthIP Main Mode Negotiation Time``
      ``IKEv1 Quick Mode Negotiation Time``
      ``AuthIP Quick Mode Negotiation Time``
      ``Extended Mode Negotiation Time``
      ``Packets Received/sec``
      ``Invalid Packets Received/sec``
      ``Successful Negotiations``
      ``Successful Negotiations/sec``
      ``Failed Negotiations``
      ``Failed Negotiations/sec``
      ``IKEv2 Main Mode Negotiation Time``
      ``IKEv2 Quick Mode Negotiation Time``
    ]

/// HTTP Service: Set of HTTP service counters
///
/// This performance counter does not have instance based counters
module ``HTTP Service`` =

  [<Literal>]
  let Category = "HTTP Service"

  let PCC = getPCC Category
  /// CurrentUrisCached: Total number of URIs currently cached by the kernel
  let ``CurrentUrisCached`` =
    { category = "HTTP Service"; counter = "CurrentUrisCached"; instance = NotApplicable }
  /// TotalUrisCached: Total number of URIs added to the kernel since service startup
  let ``TotalUrisCached`` =
    { category = "HTTP Service"; counter = "TotalUrisCached"; instance = NotApplicable }
  /// UriCacheHits: Total number of successful lookups in the kernel URI cache
  let ``UriCacheHits`` =
    { category = "HTTP Service"; counter = "UriCacheHits"; instance = NotApplicable }
  /// UriCacheMisses: Total number of unsuccessful lookups in the kernel URI cache
  let ``UriCacheMisses`` =
    { category = "HTTP Service"; counter = "UriCacheMisses"; instance = NotApplicable }
  /// UriCacheFlushes: Total number of kernel URI cache flushes (complete or partial) since service startup
  let ``UriCacheFlushes`` =
    { category = "HTTP Service"; counter = "UriCacheFlushes"; instance = NotApplicable }
  /// TotalFlushedUris: Total number of URIs that have been removed from the kernel URI cache since service startup
  let ``TotalFlushedUris`` =
    { category = "HTTP Service"; counter = "TotalFlushedUris"; instance = NotApplicable }

  let allCounters =
    [ ``CurrentUrisCached``
      ``TotalUrisCached``
      ``UriCacheHits``
      ``UriCacheMisses``
      ``UriCacheFlushes``
      ``TotalFlushedUris``
    ]

/// HTTP Service Request Queues: Set of request queue counters
///
/// This performance counter does not have non-instance based counters
module ``HTTP Service Request Queues`` =

  [<Literal>]
  let Category = "HTTP Service Request Queues"

  let PCC = getPCC Category
  /// CurrentQueueSize: Number of requests in the queue
  let ``CurrentQueueSize`` instance =
    { category = "HTTP Service Request Queues"; counter = "CurrentQueueSize"; instance = instance }
  /// MaxQueueItemAge: Age of the oldest request in the queue
  let ``MaxQueueItemAge`` instance =
    { category = "HTTP Service Request Queues"; counter = "MaxQueueItemAge"; instance = instance }
  /// ArrivalRate: Rate at which requests are arriving in the queue
  let ``ArrivalRate`` instance =
    { category = "HTTP Service Request Queues"; counter = "ArrivalRate"; instance = instance }
  /// RejectionRate: Rate at which requests are rejected from the queue
  let ``RejectionRate`` instance =
    { category = "HTTP Service Request Queues"; counter = "RejectionRate"; instance = instance }
  /// RejectedRequests: Total number of requests rejected from the queue
  let ``RejectedRequests`` instance =
    { category = "HTTP Service Request Queues"; counter = "RejectedRequests"; instance = instance }
  /// CacheHitRate: Rate of cache hits for the queue
  let ``CacheHitRate`` instance =
    { category = "HTTP Service Request Queues"; counter = "CacheHitRate"; instance = instance }

  let allCounters =
    [ ``CurrentQueueSize``
      ``MaxQueueItemAge``
      ``ArrivalRate``
      ``RejectionRate``
      ``RejectedRequests``
      ``CacheHitRate``
    ]

/// HTTP Service Url Groups: Set of URL Group-specific counters
///
/// This performance counter does not have non-instance based counters
module ``HTTP Service Url Groups`` =

  [<Literal>]
  let Category = "HTTP Service Url Groups"

  let PCC = getPCC Category
  /// BytesSentRate: Rate of sending data by HTTP service for this site
  let ``BytesSentRate`` instance =
    { category = "HTTP Service Url Groups"; counter = "BytesSentRate"; instance = instance }
  /// BytesReceivedRate: Rate of received data by HTTP service for this site
  let ``BytesReceivedRate`` instance =
    { category = "HTTP Service Url Groups"; counter = "BytesReceivedRate"; instance = instance }
  /// BytesTransferredRate: Rate of total bytes transferred (sent and received) by HTTP service for this site
  let ``BytesTransferredRate`` instance =
    { category = "HTTP Service Url Groups"; counter = "BytesTransferredRate"; instance = instance }
  /// CurrentConnections: Number of current connections established for this site
  let ``CurrentConnections`` instance =
    { category = "HTTP Service Url Groups"; counter = "CurrentConnections"; instance = instance }
  /// MaxConnections: Maximum number of concurrent connections established for this site
  let ``MaxConnections`` instance =
    { category = "HTTP Service Url Groups"; counter = "MaxConnections"; instance = instance }
  /// ConnectionAttempts: Rate at which connection attempts are being made for this site
  let ``ConnectionAttempts`` instance =
    { category = "HTTP Service Url Groups"; counter = "ConnectionAttempts"; instance = instance }
  /// GetRequests: Rate at which GET method requests are made for this site
  let ``GetRequests`` instance =
    { category = "HTTP Service Url Groups"; counter = "GetRequests"; instance = instance }
  /// HeadRequests: Rate at which HEAD method requests are made for this site
  let ``HeadRequests`` instance =
    { category = "HTTP Service Url Groups"; counter = "HeadRequests"; instance = instance }
  /// AllRequests: Total number of HTTP requests made for this site
  let ``AllRequests`` instance =
    { category = "HTTP Service Url Groups"; counter = "AllRequests"; instance = instance }

  let allCounters =
    [ ``BytesSentRate``
      ``BytesReceivedRate``
      ``BytesTransferredRate``
      ``CurrentConnections``
      ``MaxConnections``
      ``ConnectionAttempts``
      ``GetRequests``
      ``HeadRequests``
      ``AllRequests``
    ]

/// Hyper-V Dynamic Memory Integration Service: This counter set represents the statistics for Dynamic Memory Integration Services
///
/// This performance counter does not have instance based counters
module ``Hyper-V Dynamic Memory Integration Service`` =

  [<Literal>]
  let Category = "Hyper-V Dynamic Memory Integration Service"

  let PCC = getPCC Category
  /// Maximum Memory, Mbytes: 
  let ``Maximum Memory, Mbytes`` =
    { category = "Hyper-V Dynamic Memory Integration Service"; counter = "Maximum Memory, Mbytes"; instance = NotApplicable }

  let allCounters =
    [ ``Maximum Memory, Mbytes``

    ]

/// ICMP: The ICMP performance object consists of counters that measure the rates at which messages are sent and received by using ICMP protocols.  It also includes counters that monitor ICMP protocol errors.
///
/// This performance counter does not have instance based counters
module ``ICMP`` =

  [<Literal>]
  let Category = "ICMP"

  let PCC = getPCC Category
  /// Messages/sec: Messages/sec is the total rate, in incidents per second, at which ICMP messages were sent and received by the entity. The rate includes messages received or sent in error.
  let ``Messages/sec`` =
    { category = "ICMP"; counter = "Messages/sec"; instance = NotApplicable }
  /// Messages Received/sec: Messages Received/sec is the rate, in incidents per second at which ICMP messages were received. The rate includes messages received in error.
  let ``Messages Received/sec`` =
    { category = "ICMP"; counter = "Messages Received/sec"; instance = NotApplicable }
  /// Messages Received Errors: Messages Received Errors is the number of ICMP messages that the entity received but had errors, such as bad ICMP checksums, bad length, etc.
  let ``Messages Received Errors`` =
    { category = "ICMP"; counter = "Messages Received Errors"; instance = NotApplicable }
  /// Received Dest. Unreachable: Received Destination Unreachable is the number of ICMP Destination Unreachable messages received.
  let ``Received Dest. Unreachable`` =
    { category = "ICMP"; counter = "Received Dest. Unreachable"; instance = NotApplicable }
  /// Received Time Exceeded: Received Time Exceeded is the number of ICMP Time Exceeded messages received.
  let ``Received Time Exceeded`` =
    { category = "ICMP"; counter = "Received Time Exceeded"; instance = NotApplicable }
  /// Received Parameter Problem: Received Parameter Problem is the number of ICMP Parameter Problem messages received.
  let ``Received Parameter Problem`` =
    { category = "ICMP"; counter = "Received Parameter Problem"; instance = NotApplicable }
  /// Received Source Quench: Received Source Quench is the number of ICMP Source Quench messages received.
  let ``Received Source Quench`` =
    { category = "ICMP"; counter = "Received Source Quench"; instance = NotApplicable }
  /// Received Redirect/sec: Received Redirect/sec is the rate, in incidents per second, at which ICMP Redirect messages were received.
  let ``Received Redirect/sec`` =
    { category = "ICMP"; counter = "Received Redirect/sec"; instance = NotApplicable }
  /// Received Echo/sec: Received Echo/sec is the rate, in incidents per second, at which ICMP Echo messages were received.
  let ``Received Echo/sec`` =
    { category = "ICMP"; counter = "Received Echo/sec"; instance = NotApplicable }
  /// Received Echo Reply/sec: Received Echo Reply/sec is the rate, in incidents per second, at which ICMP Echo Reply messages were received.
  let ``Received Echo Reply/sec`` =
    { category = "ICMP"; counter = "Received Echo Reply/sec"; instance = NotApplicable }
  /// Received Timestamp/sec: Received Timestamp/sec is the rate, in incidents per second at which ICMP Timestamp Request messages were received.
  let ``Received Timestamp/sec`` =
    { category = "ICMP"; counter = "Received Timestamp/sec"; instance = NotApplicable }
  /// Received Timestamp Reply/sec: Received Timestamp Reply/sec is the rate of ICMP Timestamp Reply messages received.
  let ``Received Timestamp Reply/sec`` =
    { category = "ICMP"; counter = "Received Timestamp Reply/sec"; instance = NotApplicable }
  /// Received Address Mask: Received Address Mask is the number of ICMP Address Mask Request messages received.
  let ``Received Address Mask`` =
    { category = "ICMP"; counter = "Received Address Mask"; instance = NotApplicable }
  /// Received Address Mask Reply: Received Address Mask Reply is the number of ICMP Address Mask Reply messages received.
  let ``Received Address Mask Reply`` =
    { category = "ICMP"; counter = "Received Address Mask Reply"; instance = NotApplicable }
  /// Messages Sent/sec: Messages Sent/sec is the rate, in incidents per second, at which the server attempted to send. The rate includes those messages sent in error.
  let ``Messages Sent/sec`` =
    { category = "ICMP"; counter = "Messages Sent/sec"; instance = NotApplicable }
  /// Messages Outbound Errors: Messages Outbound Errors is the number of ICMP messages that were not send due to problems within ICMP, such as lack of buffers.  This value does not include errors discovered outside the ICMP layer, such as those recording the failure of IP to route the resultant datagram.  In some implementations, none of the error types are included in the value of this counter.
  let ``Messages Outbound Errors`` =
    { category = "ICMP"; counter = "Messages Outbound Errors"; instance = NotApplicable }
  /// Sent Destination Unreachable: Sent Destination Unreachable is the number of ICMP Destination Unreachable messages sent.
  let ``Sent Destination Unreachable`` =
    { category = "ICMP"; counter = "Sent Destination Unreachable"; instance = NotApplicable }
  /// Sent Time Exceeded: Sent Time Exceeded is the number of ICMP Time Exceeded messages sent.
  let ``Sent Time Exceeded`` =
    { category = "ICMP"; counter = "Sent Time Exceeded"; instance = NotApplicable }
  /// Sent Parameter Problem: Sent Parameter Problem is the number of ICMP Parameter Problem messages sent.
  let ``Sent Parameter Problem`` =
    { category = "ICMP"; counter = "Sent Parameter Problem"; instance = NotApplicable }
  /// Sent Source Quench: Sent Source Quench is the number of ICMP Source Quench messages sent.
  let ``Sent Source Quench`` =
    { category = "ICMP"; counter = "Sent Source Quench"; instance = NotApplicable }
  /// Sent Redirect/sec: Sent Redirect/sec is the rate, in incidents per second, at which ICMP Redirect messages were sent.
  let ``Sent Redirect/sec`` =
    { category = "ICMP"; counter = "Sent Redirect/sec"; instance = NotApplicable }
  /// Sent Echo/sec: Sent Echo/sec is the rate of ICMP Echo messages sent.
  let ``Sent Echo/sec`` =
    { category = "ICMP"; counter = "Sent Echo/sec"; instance = NotApplicable }
  /// Sent Echo Reply/sec: Sent Echo Reply/sec is the rate, in incidents per second, at which ICMP Echo Reply messages were sent.
  let ``Sent Echo Reply/sec`` =
    { category = "ICMP"; counter = "Sent Echo Reply/sec"; instance = NotApplicable }
  /// Sent Timestamp/sec: Sent Timestamp/sec is the rate, in incidents per second, at which ICMP Timestamp Request messages were sent.
  let ``Sent Timestamp/sec`` =
    { category = "ICMP"; counter = "Sent Timestamp/sec"; instance = NotApplicable }
  /// Sent Timestamp Reply/sec: Sent Timestamp Reply/sec is the rate, in incidents per second,  at which ICMP Timestamp Reply messages were sent.
  let ``Sent Timestamp Reply/sec`` =
    { category = "ICMP"; counter = "Sent Timestamp Reply/sec"; instance = NotApplicable }
  /// Sent Address Mask: Sent Address Mask is the number of ICMP Address Mask Request messages sent.
  let ``Sent Address Mask`` =
    { category = "ICMP"; counter = "Sent Address Mask"; instance = NotApplicable }
  /// Sent Address Mask Reply: Sent Address Mask Reply is the number of ICMP Address Mask Reply messages sent.
  let ``Sent Address Mask Reply`` =
    { category = "ICMP"; counter = "Sent Address Mask Reply"; instance = NotApplicable }

  let allCounters =
    [ ``Messages/sec``
      ``Messages Received/sec``
      ``Messages Received Errors``
      ``Received Dest. Unreachable``
      ``Received Time Exceeded``
      ``Received Parameter Problem``
      ``Received Source Quench``
      ``Received Redirect/sec``
      ``Received Echo/sec``
      ``Received Echo Reply/sec``
      ``Received Timestamp/sec``
      ``Received Timestamp Reply/sec``
      ``Received Address Mask``
      ``Received Address Mask Reply``
      ``Messages Sent/sec``
      ``Messages Outbound Errors``
      ``Sent Destination Unreachable``
      ``Sent Time Exceeded``
      ``Sent Parameter Problem``
      ``Sent Source Quench``
      ``Sent Redirect/sec``
      ``Sent Echo/sec``
      ``Sent Echo Reply/sec``
      ``Sent Timestamp/sec``
      ``Sent Timestamp Reply/sec``
      ``Sent Address Mask``
      ``Sent Address Mask Reply``
    ]

/// ICMPv6: The ICMP performance object consists of counters that measure the rates at which messages are sent and received by using ICMP protocols.  It also includes counters that monitor ICMP protocol errors.
///
/// This performance counter does not have instance based counters
module ``ICMPv6`` =

  [<Literal>]
  let Category = "ICMPv6"

  let PCC = getPCC Category
  /// Messages/sec: Messages/sec is the total rate, in incidents per second, at which ICMP messages were sent and received by the entity. The rate includes messages received or sent in error.
  let ``Messages/sec`` =
    { category = "ICMPv6"; counter = "Messages/sec"; instance = NotApplicable }
  /// Messages Received/sec: Messages Received/sec is the rate, in incidents per second at which ICMP messages were received. The rate includes messages received in error.
  let ``Messages Received/sec`` =
    { category = "ICMPv6"; counter = "Messages Received/sec"; instance = NotApplicable }
  /// Messages Received Errors: Messages Received Errors is the number of ICMP messages that the entity received but had errors, such as bad ICMP checksums, bad length, etc.
  let ``Messages Received Errors`` =
    { category = "ICMPv6"; counter = "Messages Received Errors"; instance = NotApplicable }
  /// Received Dest. Unreachable: Received Destination Unreachable is the number of ICMP Destination Unreachable messages received.
  let ``Received Dest. Unreachable`` =
    { category = "ICMPv6"; counter = "Received Dest. Unreachable"; instance = NotApplicable }
  /// Received Packet Too Big: Received Packet Too Big is the number of received packets thatare larger than anticipated.
  let ``Received Packet Too Big`` =
    { category = "ICMPv6"; counter = "Received Packet Too Big"; instance = NotApplicable }
  /// Received Time Exceeded: Received Time Exceeded is the number of ICMP Time Exceeded messages received.
  let ``Received Time Exceeded`` =
    { category = "ICMPv6"; counter = "Received Time Exceeded"; instance = NotApplicable }
  /// Received Parameter Problem: Received Parameter Problem is the number of ICMP Parameter Problem messages received.
  let ``Received Parameter Problem`` =
    { category = "ICMPv6"; counter = "Received Parameter Problem"; instance = NotApplicable }
  /// Received Echo/sec: Received Echo/sec is the rate, in incidents per second, at which ICMP Echo messages were received.
  let ``Received Echo/sec`` =
    { category = "ICMPv6"; counter = "Received Echo/sec"; instance = NotApplicable }
  /// Received Echo Reply/sec: Received Echo Reply/sec is the rate, in incidents per second, at which ICMP Echo Reply messages were received.
  let ``Received Echo Reply/sec`` =
    { category = "ICMPv6"; counter = "Received Echo Reply/sec"; instance = NotApplicable }
  /// Received Membership Query: Received Membership Query is the number of packets received thatquery their membership to a group.
  let ``Received Membership Query`` =
    { category = "ICMPv6"; counter = "Received Membership Query"; instance = NotApplicable }
  /// Received Membership Report: Received Membership Report is the number of packets received thatreport their membership to a group.
  let ``Received Membership Report`` =
    { category = "ICMPv6"; counter = "Received Membership Report"; instance = NotApplicable }
  /// Received Membership Reduction: Received Membership Reduction is the number of packets received thatcancelled their membership to a group.
  let ``Received Membership Reduction`` =
    { category = "ICMPv6"; counter = "Received Membership Reduction"; instance = NotApplicable }
  /// Received Router Solicit: Received Router Solicit is the number of packets received thatsolicit the router.
  let ``Received Router Solicit`` =
    { category = "ICMPv6"; counter = "Received Router Solicit"; instance = NotApplicable }
  /// Received Router Advert: Received Router Advert is the number of packets received thatadvert the router.
  let ``Received Router Advert`` =
    { category = "ICMPv6"; counter = "Received Router Advert"; instance = NotApplicable }
  /// Received Neighbor Solicit: Received Neighbor Solicit is the number of packets received thatsolicit a neighbor.
  let ``Received Neighbor Solicit`` =
    { category = "ICMPv6"; counter = "Received Neighbor Solicit"; instance = NotApplicable }
  /// Received Neighbor Advert: Received Neighbor Advert is the number of packets received thatadvert a neighbor.
  let ``Received Neighbor Advert`` =
    { category = "ICMPv6"; counter = "Received Neighbor Advert"; instance = NotApplicable }
  /// Received Redirect/sec: Received Redirect/sec is the rate, in incidents per second, at which ICMP Redirect messages were received.
  let ``Received Redirect/sec`` =
    { category = "ICMPv6"; counter = "Received Redirect/sec"; instance = NotApplicable }
  /// Messages Sent/sec: Messages Sent/sec is the rate, in incidents per second, at which the server attempted to send. The rate includes those messages sent in error.
  let ``Messages Sent/sec`` =
    { category = "ICMPv6"; counter = "Messages Sent/sec"; instance = NotApplicable }
  /// Messages Outbound Errors: Messages Outbound Errors is the number of ICMP messages that were not send due to problems within ICMP, such as lack of buffers.  This value does not include errors discovered outside the ICMP layer, such as those recording the failure of IP to route the resultant datagram.  In some implementations, none of the error types are included in the value of this counter.
  let ``Messages Outbound Errors`` =
    { category = "ICMPv6"; counter = "Messages Outbound Errors"; instance = NotApplicable }
  /// Sent Destination Unreachable: Sent Destination Unreachable is the number of ICMP Destination Unreachable messages sent.
  let ``Sent Destination Unreachable`` =
    { category = "ICMPv6"; counter = "Sent Destination Unreachable"; instance = NotApplicable }
  /// Sent Packet Too Big: Sent Packet Too Big is the number of sent packets thatare larger than anticipated.
  let ``Sent Packet Too Big`` =
    { category = "ICMPv6"; counter = "Sent Packet Too Big"; instance = NotApplicable }
  /// Sent Time Exceeded: Sent Time Exceeded is the number of ICMP Time Exceeded messages sent.
  let ``Sent Time Exceeded`` =
    { category = "ICMPv6"; counter = "Sent Time Exceeded"; instance = NotApplicable }
  /// Sent Parameter Problem: Sent Parameter Problem is the number of ICMP Parameter Problem messages sent.
  let ``Sent Parameter Problem`` =
    { category = "ICMPv6"; counter = "Sent Parameter Problem"; instance = NotApplicable }
  /// Sent Echo/sec: Sent Echo/sec is the rate of ICMP Echo messages sent.
  let ``Sent Echo/sec`` =
    { category = "ICMPv6"; counter = "Sent Echo/sec"; instance = NotApplicable }
  /// Sent Echo Reply/sec: Sent Echo Reply/sec is the rate, in incidents per second, at which ICMP Echo Reply messages were sent.
  let ``Sent Echo Reply/sec`` =
    { category = "ICMPv6"; counter = "Sent Echo Reply/sec"; instance = NotApplicable }
  /// Sent Membership Query: Sent Membership Query is the number of packets sent thatquery their membership to a group.
  let ``Sent Membership Query`` =
    { category = "ICMPv6"; counter = "Sent Membership Query"; instance = NotApplicable }
  /// Sent Membership Report: Sent Membership Report is the number of packets sent thatreport their membership to a group.
  let ``Sent Membership Report`` =
    { category = "ICMPv6"; counter = "Sent Membership Report"; instance = NotApplicable }
  /// Sent Membership Reduction: Sent Membership Reduction is the number of packets sent thatcancelled their membership to a group.
  let ``Sent Membership Reduction`` =
    { category = "ICMPv6"; counter = "Sent Membership Reduction"; instance = NotApplicable }
  /// Sent Router Solicit: Sent Router Solicit is the number of packets sent thatsolicit the router.
  let ``Sent Router Solicit`` =
    { category = "ICMPv6"; counter = "Sent Router Solicit"; instance = NotApplicable }
  /// Sent Router Advert: Sent Router Advert is the number of packets sent thatadvert the router.
  let ``Sent Router Advert`` =
    { category = "ICMPv6"; counter = "Sent Router Advert"; instance = NotApplicable }
  /// Sent Neighbor Solicit: Sent Neighbor Solicit is the number of packets sent thatsolicit a neighbor.
  let ``Sent Neighbor Solicit`` =
    { category = "ICMPv6"; counter = "Sent Neighbor Solicit"; instance = NotApplicable }
  /// Sent Neighbor Advert: Sent Neighbor Advert is the number of packets sent thatadvert a neighbor.
  let ``Sent Neighbor Advert`` =
    { category = "ICMPv6"; counter = "Sent Neighbor Advert"; instance = NotApplicable }
  /// Sent Redirect/sec: Sent Redirect/sec is the rate, in incidents per second, at which ICMP Redirect messages were sent.
  let ``Sent Redirect/sec`` =
    { category = "ICMPv6"; counter = "Sent Redirect/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Messages/sec``
      ``Messages Received/sec``
      ``Messages Received Errors``
      ``Received Dest. Unreachable``
      ``Received Packet Too Big``
      ``Received Time Exceeded``
      ``Received Parameter Problem``
      ``Received Echo/sec``
      ``Received Echo Reply/sec``
      ``Received Membership Query``
      ``Received Membership Report``
      ``Received Membership Reduction``
      ``Received Router Solicit``
      ``Received Router Advert``
      ``Received Neighbor Solicit``
      ``Received Neighbor Advert``
      ``Received Redirect/sec``
      ``Messages Sent/sec``
      ``Messages Outbound Errors``
      ``Sent Destination Unreachable``
      ``Sent Packet Too Big``
      ``Sent Time Exceeded``
      ``Sent Parameter Problem``
      ``Sent Echo/sec``
      ``Sent Echo Reply/sec``
      ``Sent Membership Query``
      ``Sent Membership Report``
      ``Sent Membership Reduction``
      ``Sent Router Solicit``
      ``Sent Router Advert``
      ``Sent Neighbor Solicit``
      ``Sent Neighbor Advert``
      ``Sent Redirect/sec``
    ]

/// IPHTTPS Global: Statistics of IPHTTPS server on this machine.
///
/// This performance counter does not have non-instance based counters
module ``IPHTTPS Global`` =

  [<Literal>]
  let Category = "IPHTTPS Global"

  let PCC = getPCC Category
  /// In - Total bytes received: Total bytes received on the IPHTTPS server.
  let ``In - Total bytes received`` instance =
    { category = "IPHTTPS Global"; counter = "In - Total bytes received"; instance = instance }
  /// Out - Total bytes sent: Total bytes sent on the IPHTTPS server.
  let ``Out - Total bytes sent`` instance =
    { category = "IPHTTPS Global"; counter = "Out - Total bytes sent"; instance = instance }
  /// Drops - Neighbor resolution timeouts: Total packets dropped waiting for neighbor resolution.
  let ``Drops - Neighbor resolution timeouts`` instance =
    { category = "IPHTTPS Global"; counter = "Drops - Neighbor resolution timeouts"; instance = instance }
  /// Errors - Authentication Errors: Total authentication errors.
  let ``Errors - Authentication Errors`` instance =
    { category = "IPHTTPS Global"; counter = "Errors - Authentication Errors"; instance = instance }
  /// Out - Total bytes forwarded: Total bytes forwarded at link layer.
  let ``Out - Total bytes forwarded`` instance =
    { category = "IPHTTPS Global"; counter = "Out - Total bytes forwarded"; instance = instance }
  /// Errors - Transmit errors on the server: Total transmit errors on the server.
  let ``Errors - Transmit errors on the server`` instance =
    { category = "IPHTTPS Global"; counter = "Errors - Transmit errors on the server"; instance = instance }
  /// Errors - Receive errors on the server: Total receive errors on the server.
  let ``Errors - Receive errors on the server`` instance =
    { category = "IPHTTPS Global"; counter = "Errors - Receive errors on the server"; instance = instance }
  /// In - Total packets received: Total packets received on the server.
  let ``In - Total packets received`` instance =
    { category = "IPHTTPS Global"; counter = "In - Total packets received"; instance = instance }
  /// Out - Total packets sent: Total packets sent from the server.
  let ``Out - Total packets sent`` instance =
    { category = "IPHTTPS Global"; counter = "Out - Total packets sent"; instance = instance }
  /// Sessions - Total sessions: Total number of sessions on the server.
  let ``Sessions - Total sessions`` instance =
    { category = "IPHTTPS Global"; counter = "Sessions - Total sessions"; instance = instance }

  let allCounters =
    [ ``In - Total bytes received``
      ``Out - Total bytes sent``
      ``Drops - Neighbor resolution timeouts``
      ``Errors - Authentication Errors``
      ``Out - Total bytes forwarded``
      ``Errors - Transmit errors on the server``
      ``Errors - Receive errors on the server``
      ``In - Total packets received``
      ``Out - Total packets sent``
      ``Sessions - Total sessions``
    ]

/// IPHTTPS Session: Per session statistics on this IPHTTPS server.
///
/// This performance counter does not have instance based counters
module ``IPHTTPS Session`` =

  [<Literal>]
  let Category = "IPHTTPS Session"

  let PCC = getPCC Category
  /// Packets received on this session: 
  let ``Packets received on this session`` instance =
    { category = "IPHTTPS Session"; counter = "Packets received on this session"; instance = instance }
  /// Packets sent on this session: 
  let ``Packets sent on this session`` instance =
    { category = "IPHTTPS Session"; counter = "Packets sent on this session"; instance = instance }
  /// Bytes received on this session: 
  let ``Bytes received on this session`` instance =
    { category = "IPHTTPS Session"; counter = "Bytes received on this session"; instance = instance }
  /// Bytes sent on this session: 
  let ``Bytes sent on this session`` instance =
    { category = "IPHTTPS Session"; counter = "Bytes sent on this session"; instance = instance }
  /// Errors - Transmit errors on this session: 
  let ``Errors - Transmit errors on this session`` instance =
    { category = "IPHTTPS Session"; counter = "Errors - Transmit errors on this session"; instance = instance }
  /// Errors - Receive errors on this session: 
  let ``Errors - Receive errors on this session`` instance =
    { category = "IPHTTPS Session"; counter = "Errors - Receive errors on this session"; instance = instance }
  /// Duration - Duration of the session (Seconds): 
  let ``Duration - Duration of the session (Seconds)`` instance =
    { category = "IPHTTPS Session"; counter = "Duration - Duration of the session (Seconds)"; instance = instance }

  let allCounters =
    [ ``Packets received on this session``
      ``Packets sent on this session``
      ``Bytes received on this session``
      ``Bytes sent on this session``
      ``Errors - Transmit errors on this session``
      ``Errors - Receive errors on this session``
      ``Duration - Duration of the session (Seconds)``
    ]

/// IPsec AuthIP IPv4: IPsec AuthIP IPv4 is the set of Internet Protocol security (IPsec) Authenticated IP (AuthIP) counters that apply to traffic and connections over Internet Protocol version 4.
///
/// This performance counter does not have instance based counters
module ``IPsec AuthIP IPv4`` =

  [<Literal>]
  let Category = "IPsec AuthIP IPv4"

  let PCC = getPCC Category
  /// Active Main Mode SAs: Active Main Mode SAs is the number of currently active main mode security associations.
  let ``Active Main Mode SAs`` =
    { category = "IPsec AuthIP IPv4"; counter = "Active Main Mode SAs"; instance = NotApplicable }
  /// Pending Main Mode Negotiations: Pending Main Mode Negotiations is the number of pending main mode negotiations.
  let ``Pending Main Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Pending Main Mode Negotiations"; instance = NotApplicable }
  /// Main Mode Negotiations: Main Mode Negotiations is the number of main mode negotiations attempted since IPsec was last started.
  let ``Main Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Main Mode Negotiations"; instance = NotApplicable }
  /// Main Mode Negotiations/sec: Main Mode Negotiations per Second is the rate at which main mode negotiations are being attempted.
  let ``Main Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv4"; counter = "Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Main Mode Negotiations: Successful Main Mode Negotiations is the number of main mode negotiations completed since IPsec was last started.
  let ``Successful Main Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Successful Main Mode Negotiations"; instance = NotApplicable }
  /// Successful Main Mode Negotiations/sec: Successful Main Mode Negotiations per Second is the rate of main mode negotiations completed.
  let ``Successful Main Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv4"; counter = "Successful Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Failed Main Mode Negotiations: Failed Main Mode Negotiations is the number of failed main mode negotiations since IPsec was last started.
  let ``Failed Main Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Failed Main Mode Negotiations"; instance = NotApplicable }
  /// Failed Main Mode Negotiations/sec: Failed Main Mode Negotiations per Second is the rate of failed main mode negotiations.
  let ``Failed Main Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv4"; counter = "Failed Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received: Main Mode Negotiation Requests Received is the number of main mode negotiations initiated by a peer since IPsec was last started.
  let ``Main Mode Negotiation Requests Received`` =
    { category = "IPsec AuthIP IPv4"; counter = "Main Mode Negotiation Requests Received"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received/sec: Main Mode Negotiation Requests Received per Second is the rate of main mode negotiations initiated by a peer.
  let ``Main Mode Negotiation Requests Received/sec`` =
    { category = "IPsec AuthIP IPv4"; counter = "Main Mode Negotiation Requests Received/sec"; instance = NotApplicable }
  /// Main Mode SAs That Used Impersonation: Main Mode SAs That Used Impersonation is the number of main mode security associations completed using impersonation since IPsec was last started.
  let ``Main Mode SAs That Used Impersonation`` =
    { category = "IPsec AuthIP IPv4"; counter = "Main Mode SAs That Used Impersonation"; instance = NotApplicable }
  /// Main Mode SAs That Used Impersonation/sec: Main Mode SAs That Used Impersonation per Second is the rate of main mode security associations completed using impersonation.
  let ``Main Mode SAs That Used Impersonation/sec`` =
    { category = "IPsec AuthIP IPv4"; counter = "Main Mode SAs That Used Impersonation/sec"; instance = NotApplicable }
  /// Active Quick Mode SAs: Active Quick Mode SAs is the number of currently active quick mode security associations.
  let ``Active Quick Mode SAs`` =
    { category = "IPsec AuthIP IPv4"; counter = "Active Quick Mode SAs"; instance = NotApplicable }
  /// Pending Quick Mode Negotiations: Pending Quick Mode Negotiations is the number of pending quick mode negotiations.
  let ``Pending Quick Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Pending Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations: Quick Mode Negotiations is the number of quick mode negotiations attempted since IPsec was last started.
  let ``Quick Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations/sec: Quick Mode Negotiations per Second is the rate at which quick mode negotiations are being attempted.
  let ``Quick Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv4"; counter = "Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations: Successful Quick Mode Negotiations is the number of quick mode negotiations completed since IPsec was last started.
  let ``Successful Quick Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Successful Quick Mode Negotiations"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations/sec: Successful Quick Mode Negotiations per Second is the rate of quick mode negotiations completed.
  let ``Successful Quick Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv4"; counter = "Successful Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations: Failed Quick Mode Negotiations is the number of failed quick mode negotiations since IPsec was last started.
  let ``Failed Quick Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Failed Quick Mode Negotiations"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations/sec: Failed Quick Mode Negotiations per Second is the rate of failed quick mode negotiations.
  let ``Failed Quick Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv4"; counter = "Failed Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Active Extended Mode SAs: Active Extended Mode SAs is the number of currently active extended mode security associations.
  let ``Active Extended Mode SAs`` =
    { category = "IPsec AuthIP IPv4"; counter = "Active Extended Mode SAs"; instance = NotApplicable }
  /// Pending Extended Mode Negotiations: Pending Extended Mode Negotiations is the number of pending extended mode negotiations.
  let ``Pending Extended Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Pending Extended Mode Negotiations"; instance = NotApplicable }
  /// Extended Mode Negotiations: Extended Mode Negotiations is the number of extended mode negotiations attempted since IPsec was last started.
  let ``Extended Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Extended Mode Negotiations"; instance = NotApplicable }
  /// Extended Mode Negotiations/sec: Extended Mode Negotiations per Second is the rate at which extended mode negotiations are being attempted.
  let ``Extended Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv4"; counter = "Extended Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Extended Mode Negotiations: Successful Extended Mode Negotiations is the number of extended mode negotiations completed since IPsec was last started.
  let ``Successful Extended Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Successful Extended Mode Negotiations"; instance = NotApplicable }
  /// Successful Extended Mode Negotiations/sec: Successful Extended Mode Negotiations per Second is the rate of extended mode negotiations completed.
  let ``Successful Extended Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv4"; counter = "Successful Extended Mode Negotiations/sec"; instance = NotApplicable }
  /// Failed Extended Mode Negotiations: Failed Extended Mode Negotiations is the number of failed extended mode negotiations since IPsec was last started.
  let ``Failed Extended Mode Negotiations`` =
    { category = "IPsec AuthIP IPv4"; counter = "Failed Extended Mode Negotiations"; instance = NotApplicable }
  /// Failed Extended Mode Negotiations/sec: Failed Extended Mode Negotiations per Second is the rate of failed extended mode negotiations.
  let ``Failed Extended Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv4"; counter = "Failed Extended Mode Negotiations/sec"; instance = NotApplicable }
  /// Extended Mode SAs That Used Impersonation: Extended Mode SAs That Used Impersonation is the number of extended mode security associations completed using impersonation since IPsec was last started.
  let ``Extended Mode SAs That Used Impersonation`` =
    { category = "IPsec AuthIP IPv4"; counter = "Extended Mode SAs That Used Impersonation"; instance = NotApplicable }

  let allCounters =
    [ ``Active Main Mode SAs``
      ``Pending Main Mode Negotiations``
      ``Main Mode Negotiations``
      ``Main Mode Negotiations/sec``
      ``Successful Main Mode Negotiations``
      ``Successful Main Mode Negotiations/sec``
      ``Failed Main Mode Negotiations``
      ``Failed Main Mode Negotiations/sec``
      ``Main Mode Negotiation Requests Received``
      ``Main Mode Negotiation Requests Received/sec``
      ``Main Mode SAs That Used Impersonation``
      ``Main Mode SAs That Used Impersonation/sec``
      ``Active Quick Mode SAs``
      ``Pending Quick Mode Negotiations``
      ``Quick Mode Negotiations``
      ``Quick Mode Negotiations/sec``
      ``Successful Quick Mode Negotiations``
      ``Successful Quick Mode Negotiations/sec``
      ``Failed Quick Mode Negotiations``
      ``Failed Quick Mode Negotiations/sec``
      ``Active Extended Mode SAs``
      ``Pending Extended Mode Negotiations``
      ``Extended Mode Negotiations``
      ``Extended Mode Negotiations/sec``
      ``Successful Extended Mode Negotiations``
      ``Successful Extended Mode Negotiations/sec``
      ``Failed Extended Mode Negotiations``
      ``Failed Extended Mode Negotiations/sec``
      ``Extended Mode SAs That Used Impersonation``
    ]

/// IPsec AuthIP IPv6: IPsec AuthIP IPv6 is the set of Internet Protocol security (IPsec) Authenticated IP (AuthIP) counters that apply to traffic and connections over Internet Protocol version 6.
///
/// This performance counter does not have instance based counters
module ``IPsec AuthIP IPv6`` =

  [<Literal>]
  let Category = "IPsec AuthIP IPv6"

  let PCC = getPCC Category
  /// Active Main Mode SAs: Active Main Mode SAs is the number of currently active main mode security associations.
  let ``Active Main Mode SAs`` =
    { category = "IPsec AuthIP IPv6"; counter = "Active Main Mode SAs"; instance = NotApplicable }
  /// Pending Main Mode Negotiations: Pending Main Mode Negotiations is the number of pending main mode negotiations.
  let ``Pending Main Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Pending Main Mode Negotiations"; instance = NotApplicable }
  /// Main Mode Negotiations: Main Mode Negotiations is the number of main mode negotiations attempted since IPsec was last started.
  let ``Main Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Main Mode Negotiations"; instance = NotApplicable }
  /// Main Mode Negotiations/sec: Main Mode Negotiations per Second is the rate at which main mode negotiations are being attempted.
  let ``Main Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv6"; counter = "Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Main Mode Negotiations: Successful Main Mode Negotiations is the number of main mode negotiations completed since IPsec was last started.
  let ``Successful Main Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Successful Main Mode Negotiations"; instance = NotApplicable }
  /// Successful Main Mode Negotiations/sec: Successful Main Mode Negotiations per Second is the rate of main mode negotiations completed.
  let ``Successful Main Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv6"; counter = "Successful Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Failed Main Mode Negotiations: Failed Main Mode Negotiations is the number of failed main mode negotiations since IPsec was last started.
  let ``Failed Main Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Failed Main Mode Negotiations"; instance = NotApplicable }
  /// Failed Main Mode Negotiations/sec: Failed Main Mode Negotiations per Second is the rate of failed main mode negotiations.
  let ``Failed Main Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv6"; counter = "Failed Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received: Main Mode Negotiation Requests Received is the number of main mode negotiations initiated by a peer since IPsec was last started.
  let ``Main Mode Negotiation Requests Received`` =
    { category = "IPsec AuthIP IPv6"; counter = "Main Mode Negotiation Requests Received"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received/sec: Main Mode Negotiation Requests Received per Second is the rate of main mode negotiations initiated by a peer.
  let ``Main Mode Negotiation Requests Received/sec`` =
    { category = "IPsec AuthIP IPv6"; counter = "Main Mode Negotiation Requests Received/sec"; instance = NotApplicable }
  /// Main Mode SAs That Used Impersonation: Main Mode SAs That Used Impersonation is the number of main mode security associations completed using impersonation since IPsec was last started.
  let ``Main Mode SAs That Used Impersonation`` =
    { category = "IPsec AuthIP IPv6"; counter = "Main Mode SAs That Used Impersonation"; instance = NotApplicable }
  /// Main Mode SAs That Used Impersonation/sec: Main Mode SAs That Used Impersonation per Second is the rate of main mode security associations completed using impersonation.
  let ``Main Mode SAs That Used Impersonation/sec`` =
    { category = "IPsec AuthIP IPv6"; counter = "Main Mode SAs That Used Impersonation/sec"; instance = NotApplicable }
  /// Active Quick Mode SAs: Active Quick Mode SAs is the number of currently active quick mode security associations.
  let ``Active Quick Mode SAs`` =
    { category = "IPsec AuthIP IPv6"; counter = "Active Quick Mode SAs"; instance = NotApplicable }
  /// Pending Quick Mode Negotiations: Pending Quick Mode Negotiations is the number of pending quick mode negotiations.
  let ``Pending Quick Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Pending Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations: Quick Mode Negotiations is the number of quick mode negotiations attempted since IPsec was last started.
  let ``Quick Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations/sec: Quick Mode Negotiations per Second is the rate at which quick mode negotiations are being attempted.
  let ``Quick Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv6"; counter = "Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations: Successful Quick Mode Negotiations is the number of quick mode negotiations completed since IPsec was last started.
  let ``Successful Quick Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Successful Quick Mode Negotiations"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations/sec: Successful Quick Mode Negotiations per Second is the rate of quick mode negotiations completed.
  let ``Successful Quick Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv6"; counter = "Successful Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations: Failed Quick Mode Negotiations is the number of failed quick mode negotiations since IPsec was last started.
  let ``Failed Quick Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Failed Quick Mode Negotiations"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations/sec: Failed Quick Mode Negotiations per Second is the rate of failed quick mode negotiations.
  let ``Failed Quick Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv6"; counter = "Failed Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Active Extended Mode SAs: Active Extended Mode SAs is the number of currently active extended mode security associations.
  let ``Active Extended Mode SAs`` =
    { category = "IPsec AuthIP IPv6"; counter = "Active Extended Mode SAs"; instance = NotApplicable }
  /// Pending Extended Mode Negotiations: Pending Extended Mode Negotiations is the number of pending extended mode negotiations.
  let ``Pending Extended Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Pending Extended Mode Negotiations"; instance = NotApplicable }
  /// Extended Mode Negotiations: Extended Mode Negotiations is the number of extended mode negotiations attempted since IPsec was last started.
  let ``Extended Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Extended Mode Negotiations"; instance = NotApplicable }
  /// Extended Mode Negotiations/sec: Extended Mode Negotiations per Second is the rate at which extended mode negotiations are being attempted.
  let ``Extended Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv6"; counter = "Extended Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Extended Mode Negotiations: Successful Extended Mode Negotiations is the number of extended mode negotiations completed since IPsec was last started.
  let ``Successful Extended Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Successful Extended Mode Negotiations"; instance = NotApplicable }
  /// Successful Extended Mode Negotiations/sec: Successful Extended Mode Negotiations per Second is the rate of extended mode negotiations completed.
  let ``Successful Extended Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv6"; counter = "Successful Extended Mode Negotiations/sec"; instance = NotApplicable }
  /// Failed Extended Mode Negotiations: Failed Extended Mode Negotiations is the number of failed extended mode negotiations since IPsec was last started.
  let ``Failed Extended Mode Negotiations`` =
    { category = "IPsec AuthIP IPv6"; counter = "Failed Extended Mode Negotiations"; instance = NotApplicable }
  /// Failed Extended Mode Negotiations/sec: Failed Extended Mode Negotiations per Second is the rate of failed extended mode negotiations.
  let ``Failed Extended Mode Negotiations/sec`` =
    { category = "IPsec AuthIP IPv6"; counter = "Failed Extended Mode Negotiations/sec"; instance = NotApplicable }
  /// Extended Mode SAs That Used Impersonation: Extended Mode SAs That Used Impersonation is the number of extended mode security associations completed using impersonation since IPsec was last started.
  let ``Extended Mode SAs That Used Impersonation`` =
    { category = "IPsec AuthIP IPv6"; counter = "Extended Mode SAs That Used Impersonation"; instance = NotApplicable }

  let allCounters =
    [ ``Active Main Mode SAs``
      ``Pending Main Mode Negotiations``
      ``Main Mode Negotiations``
      ``Main Mode Negotiations/sec``
      ``Successful Main Mode Negotiations``
      ``Successful Main Mode Negotiations/sec``
      ``Failed Main Mode Negotiations``
      ``Failed Main Mode Negotiations/sec``
      ``Main Mode Negotiation Requests Received``
      ``Main Mode Negotiation Requests Received/sec``
      ``Main Mode SAs That Used Impersonation``
      ``Main Mode SAs That Used Impersonation/sec``
      ``Active Quick Mode SAs``
      ``Pending Quick Mode Negotiations``
      ``Quick Mode Negotiations``
      ``Quick Mode Negotiations/sec``
      ``Successful Quick Mode Negotiations``
      ``Successful Quick Mode Negotiations/sec``
      ``Failed Quick Mode Negotiations``
      ``Failed Quick Mode Negotiations/sec``
      ``Active Extended Mode SAs``
      ``Pending Extended Mode Negotiations``
      ``Extended Mode Negotiations``
      ``Extended Mode Negotiations/sec``
      ``Successful Extended Mode Negotiations``
      ``Successful Extended Mode Negotiations/sec``
      ``Failed Extended Mode Negotiations``
      ``Failed Extended Mode Negotiations/sec``
      ``Extended Mode SAs That Used Impersonation``
    ]

/// IPsec Connections: IPsec Connections is the set of Internet Protocol security (IPsec) counters that apply to IPsec encapsulated connections.
///
/// This performance counter does not have instance based counters
module ``IPsec Connections`` =

  [<Literal>]
  let Category = "IPsec Connections"

  let PCC = getPCC Category
  /// Total Number current Connections: Total Number current Connections
  let ``Total Number current Connections`` =
    { category = "IPsec Connections"; counter = "Total Number current Connections"; instance = NotApplicable }
  /// Total number of cumulative connections since boot: Total number of cumulative connections since boot
  let ``Total number of cumulative connections since boot`` =
    { category = "IPsec Connections"; counter = "Total number of cumulative connections since boot"; instance = NotApplicable }
  /// Max number of connections since boot: Max number of connections since boot
  let ``Max number of connections since boot`` =
    { category = "IPsec Connections"; counter = "Max number of connections since boot"; instance = NotApplicable }
  /// Total Bytes In since start: Total Bytes In since boot
  let ``Total Bytes In since start`` =
    { category = "IPsec Connections"; counter = "Total Bytes In since start"; instance = NotApplicable }
  /// Total Bytes Out since start: Total Bytes Out since boot
  let ``Total Bytes Out since start`` =
    { category = "IPsec Connections"; counter = "Total Bytes Out since start"; instance = NotApplicable }
  /// Number of failed authentications: Number of failed authentications
  let ``Number of failed authentications`` =
    { category = "IPsec Connections"; counter = "Number of failed authentications"; instance = NotApplicable }

  let allCounters =
    [ ``Total Number current Connections``
      ``Total number of cumulative connections since boot``
      ``Max number of connections since boot``
      ``Total Bytes In since start``
      ``Total Bytes Out since start``
      ``Number of failed authentications``
    ]

/// IPsec Driver: IPsec Driver is the set of Internet Protocol security (IPsec) driver counters that apply to traffic over Internet Protocol version 4 and Internet Protocol version 6.
///
/// This performance counter does not have instance based counters
module ``IPsec Driver`` =

  [<Literal>]
  let Category = "IPsec Driver"

  let PCC = getPCC Category
  /// Active Security Associations: Active Security Associations is the number of active quick mode security associations.
  let ``Active Security Associations`` =
    { category = "IPsec Driver"; counter = "Active Security Associations"; instance = NotApplicable }
  /// Pending Security Associations: Pending Security Associations is the number of pending quick mode security associations.
  let ``Pending Security Associations`` =
    { category = "IPsec Driver"; counter = "Pending Security Associations"; instance = NotApplicable }
  /// Incorrect SPI Packets: Incorrect SPI packets is the number of packets for which the Security Parameter Index (SPI) was incorrect since the computer was last started. A large number of packets with bad SPIs within a short amount of time might indicate a packet spoofing attack.
  let ``Incorrect SPI Packets`` =
    { category = "IPsec Driver"; counter = "Incorrect SPI Packets"; instance = NotApplicable }
  /// Incorrect SPI Packets/sec: Incorrect SPI packets per Second is the rate of packets for which the Security Parameter Index (SPI) was incorrect since the computer was last started. A large number of packets with bad SPIs within a short amount of time might indicate a packet spoofing attack.
  let ``Incorrect SPI Packets/sec`` =
    { category = "IPsec Driver"; counter = "Incorrect SPI Packets/sec"; instance = NotApplicable }
  /// Bytes Received in Tunnel Mode/sec: Bytes Received in Tunnel Mode per Second is the rate of bytes received using tunnel mode.
  let ``Bytes Received in Tunnel Mode/sec`` =
    { category = "IPsec Driver"; counter = "Bytes Received in Tunnel Mode/sec"; instance = NotApplicable }
  /// Bytes Sent in Tunnel Mode/sec: Bytes Sent in Tunnel Mode per Second is the rate of bytes sent using tunnel mode.
  let ``Bytes Sent in Tunnel Mode/sec`` =
    { category = "IPsec Driver"; counter = "Bytes Sent in Tunnel Mode/sec"; instance = NotApplicable }
  /// Bytes Received in Transport Mode/sec: Bytes Received in Transport Mode per Second is the rate of bytes received using transport mode.
  let ``Bytes Received in Transport Mode/sec`` =
    { category = "IPsec Driver"; counter = "Bytes Received in Transport Mode/sec"; instance = NotApplicable }
  /// Bytes Sent in Transport Mode/sec: Bytes Sent in Transport Mode per Second is the rate of bytes sent using transport mode.
  let ``Bytes Sent in Transport Mode/sec`` =
    { category = "IPsec Driver"; counter = "Bytes Sent in Transport Mode/sec"; instance = NotApplicable }
  /// Offloaded Security Associations: Offloaded Security Associations is the number of active quick mode security associations offloaded to hardware. Certain network adapters can accelerate IPsec processing by performing hardware offload of IPsec cryptographic functions.
  let ``Offloaded Security Associations`` =
    { category = "IPsec Driver"; counter = "Offloaded Security Associations"; instance = NotApplicable }
  /// Offloaded Bytes Received/sec: Offloaded Bytes Received per Second is the rate of bytes received using IPsec hardware offload. Certain network adapters can accelerate IPsec processing by performing hardware offload of IPsec cryptographic functions.
  let ``Offloaded Bytes Received/sec`` =
    { category = "IPsec Driver"; counter = "Offloaded Bytes Received/sec"; instance = NotApplicable }
  /// Offloaded Bytes Sent/sec: Offloaded Bytes Sent per Second is the rate of bytes sent using IPsec hardware offload. Certain network adapters can accelerate IPsec processing by performing hardware offload of IPsec cryptographic functions.
  let ``Offloaded Bytes Sent/sec`` =
    { category = "IPsec Driver"; counter = "Offloaded Bytes Sent/sec"; instance = NotApplicable }
  /// Packets That Failed Replay Detection: Packets That Failed Replay Detection is the number of packets that contained an invalid sequence number since the computer was last started. Increases in this counter might indicate a network problem or replay attack.
  let ``Packets That Failed Replay Detection`` =
    { category = "IPsec Driver"; counter = "Packets That Failed Replay Detection"; instance = NotApplicable }
  /// Packets That Failed Replay Detection/sec: Packets That Failed Replay Detection per Second is the rate of packets that contained an invalid sequence number since the computer was last started. Increases in this counter might indicate a network problem or replay attack.
  let ``Packets That Failed Replay Detection/sec`` =
    { category = "IPsec Driver"; counter = "Packets That Failed Replay Detection/sec"; instance = NotApplicable }
  /// Packets Not Authenticated: Packets Not Authenticated is the number of packets for which data could not be verified (for which the integrity hash verification failed) since the computer was last started. Increases in this counter might indicate an IPsec packet spoofing or modification attack, or packet corruption by network devices.
  let ``Packets Not Authenticated`` =
    { category = "IPsec Driver"; counter = "Packets Not Authenticated"; instance = NotApplicable }
  /// Packets Not Authenticated/sec: Packets Not Authenticated per Second is the rate of packets for which data could not be verified (for which the integrity hash verification failed) since the computer was last started. Increases in this counter might indicate an IPsec packet spoofing or modification attack, or packet corruption by network devices.
  let ``Packets Not Authenticated/sec`` =
    { category = "IPsec Driver"; counter = "Packets Not Authenticated/sec"; instance = NotApplicable }
  /// Packets Not Decrypted: Packets Not Decrypted is the number of packets that could not be decrypted since the computer was last started. A packet might not be decrypted if it fails a validation check.
  let ``Packets Not Decrypted`` =
    { category = "IPsec Driver"; counter = "Packets Not Decrypted"; instance = NotApplicable }
  /// Packets Not Decrypted/sec: Packets Not Decrypted per Second is the rate of packets that could not be decrypted since the computer was last started. A packet might not be decrypted if it fails a validation check.
  let ``Packets Not Decrypted/sec`` =
    { category = "IPsec Driver"; counter = "Packets Not Decrypted/sec"; instance = NotApplicable }
  /// SA Rekeys: SA Rekeys is the number of successful rekey operations for quick mode security associations since the computer was last started.
  let ``SA Rekeys`` =
    { category = "IPsec Driver"; counter = "SA Rekeys"; instance = NotApplicable }
  /// Security Associations Added: Security Associations Added is the number of security associations added since the computer was last started.
  let ``Security Associations Added`` =
    { category = "IPsec Driver"; counter = "Security Associations Added"; instance = NotApplicable }
  /// Packets That Failed ESP Validation: Packets That Failed ESP Validation is the number of packets received that failed ESP validation since the computer was last started.
  let ``Packets That Failed ESP Validation`` =
    { category = "IPsec Driver"; counter = "Packets That Failed ESP Validation"; instance = NotApplicable }
  /// Packets That Failed ESP Validation/sec: Packets That Failed ESP Validation per Second is the rate of packets received that failed ESP validation since the computer was last started.
  let ``Packets That Failed ESP Validation/sec`` =
    { category = "IPsec Driver"; counter = "Packets That Failed ESP Validation/sec"; instance = NotApplicable }
  /// Packets That Failed UDP-ESP Validation: Packets That Failed UDP-ESP Validation is the number of packets received that failed UDP-ESP validation (used for NAT traversal) since the computer was last started.
  let ``Packets That Failed UDP-ESP Validation`` =
    { category = "IPsec Driver"; counter = "Packets That Failed UDP-ESP Validation"; instance = NotApplicable }
  /// Packets That Failed UDP-ESP Validation/sec: Packets That Failed UDP-ESP Validation per Second is the rate of packets received that failed UDP-ESP validation (used for NAT traversal) since the computer was last started.
  let ``Packets That Failed UDP-ESP Validation/sec`` =
    { category = "IPsec Driver"; counter = "Packets That Failed UDP-ESP Validation/sec"; instance = NotApplicable }
  /// Packets Received Over Wrong SA: Packets Received Over Wrong SA is the number of packets received over the wrong security association since the computer was last started.
  let ``Packets Received Over Wrong SA`` =
    { category = "IPsec Driver"; counter = "Packets Received Over Wrong SA"; instance = NotApplicable }
  /// Packets Received Over Wrong SA/sec: Packets Received Over Wrong SA per Second is the rate of packets received over the wrong security association since the computer was last started.
  let ``Packets Received Over Wrong SA/sec`` =
    { category = "IPsec Driver"; counter = "Packets Received Over Wrong SA/sec"; instance = NotApplicable }
  /// Plaintext Packets Received: Plaintext Packets Received is the number of clear text packets received since the computer was last started.
  let ``Plaintext Packets Received`` =
    { category = "IPsec Driver"; counter = "Plaintext Packets Received"; instance = NotApplicable }
  /// Plaintext Packets Received/sec: Plaintext Packets Received per Second is the rate of clear text packets received since the computer was last started.
  let ``Plaintext Packets Received/sec`` =
    { category = "IPsec Driver"; counter = "Plaintext Packets Received/sec"; instance = NotApplicable }
  /// Total Inbound Packets Received: Total Inbound Packets Received is the total number of inbound packets successfully processed by IPsec, since the computer was last started.
  let ``Total Inbound Packets Received`` =
    { category = "IPsec Driver"; counter = "Total Inbound Packets Received"; instance = NotApplicable }
  /// Inbound Packets Received/sec: Inbound Packets Received per Second is the rate of inbound packets successfully processed by IPsec.
  let ``Inbound Packets Received/sec`` =
    { category = "IPsec Driver"; counter = "Inbound Packets Received/sec"; instance = NotApplicable }
  /// Total Inbound Packets Dropped: Total Inbound Packets Dropped is the total number of inbound packets dropped by IPsec, since the computer was last started.
  let ``Total Inbound Packets Dropped`` =
    { category = "IPsec Driver"; counter = "Total Inbound Packets Dropped"; instance = NotApplicable }
  /// Inbound Packets Dropped/sec: Inbound Packets Dropped per Second is the rate of inbound packets dropped by IPsec.
  let ``Inbound Packets Dropped/sec`` =
    { category = "IPsec Driver"; counter = "Inbound Packets Dropped/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Active Security Associations``
      ``Pending Security Associations``
      ``Incorrect SPI Packets``
      ``Incorrect SPI Packets/sec``
      ``Bytes Received in Tunnel Mode/sec``
      ``Bytes Sent in Tunnel Mode/sec``
      ``Bytes Received in Transport Mode/sec``
      ``Bytes Sent in Transport Mode/sec``
      ``Offloaded Security Associations``
      ``Offloaded Bytes Received/sec``
      ``Offloaded Bytes Sent/sec``
      ``Packets That Failed Replay Detection``
      ``Packets That Failed Replay Detection/sec``
      ``Packets Not Authenticated``
      ``Packets Not Authenticated/sec``
      ``Packets Not Decrypted``
      ``Packets Not Decrypted/sec``
      ``SA Rekeys``
      ``Security Associations Added``
      ``Packets That Failed ESP Validation``
      ``Packets That Failed ESP Validation/sec``
      ``Packets That Failed UDP-ESP Validation``
      ``Packets That Failed UDP-ESP Validation/sec``
      ``Packets Received Over Wrong SA``
      ``Packets Received Over Wrong SA/sec``
      ``Plaintext Packets Received``
      ``Plaintext Packets Received/sec``
      ``Total Inbound Packets Received``
      ``Inbound Packets Received/sec``
      ``Total Inbound Packets Dropped``
      ``Inbound Packets Dropped/sec``
    ]

/// IPsec IKEv1 IPv4: IPsec IKEv1 IPv4 is the set of Internet Protocol security (IPsec) Internet Key Exchange version 1 (IKEv1) counters that apply to traffic and connections over Internet Protocol version 4.
///
/// This performance counter does not have instance based counters
module ``IPsec IKEv1 IPv4`` =

  [<Literal>]
  let Category = "IPsec IKEv1 IPv4"

  let PCC = getPCC Category
  /// Active Main Mode SAs: Active Main Mode SAs is the number of currently active main mode security associations.
  let ``Active Main Mode SAs`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Active Main Mode SAs"; instance = NotApplicable }
  /// Pending Main Mode Negotiations: Pending Main Mode Negotiations is the number of pending main mode negotiations.
  let ``Pending Main Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Pending Main Mode Negotiations"; instance = NotApplicable }
  /// Main Mode Negotiations: Main Mode Negotiations is the number of main mode negotiations attempted since IPsec was last started.
  let ``Main Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Main Mode Negotiations"; instance = NotApplicable }
  /// Main Mode Negotiations/sec: Main Mode Negotiations per Second is the rate at which main mode negotiations are being attempted.
  let ``Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Main Mode Negotiations: Successful Main Mode Negotiations is the number of main mode negotiations completed since IPsec was last started.
  let ``Successful Main Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Successful Main Mode Negotiations"; instance = NotApplicable }
  /// Successful Main Mode Negotiations/sec: Successful Main Mode Negotiations per Second is the rate of main mode negotiations completed.
  let ``Successful Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Successful Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Failed Main Mode Negotiations: Failed Main Mode Negotiations is the number of failed main mode negotiations since IPsec was last started.
  let ``Failed Main Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Failed Main Mode Negotiations"; instance = NotApplicable }
  /// Failed Main Mode Negotiations/sec: Failed Main Mode Negotiations per Second is the rate of failed main mode negotiations.
  let ``Failed Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Failed Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received: Main Mode Negotiation Requests Received is the number of main mode negotiations initiated by a peer since IPsec was last started.
  let ``Main Mode Negotiation Requests Received`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Main Mode Negotiation Requests Received"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received/sec: Main Mode Negotiation Requests Received per Second is the rate of main mode negotiations initiated by a peer.
  let ``Main Mode Negotiation Requests Received/sec`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Main Mode Negotiation Requests Received/sec"; instance = NotApplicable }
  /// Active Quick Mode SAs: Active Quick Mode SAs is the number of currently active quick mode security associations.
  let ``Active Quick Mode SAs`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Active Quick Mode SAs"; instance = NotApplicable }
  /// Pending Quick Mode Negotiations: Pending Quick Mode Negotiations is the number of pending quick mode negotiations.
  let ``Pending Quick Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Pending Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations: Quick Mode Negotiations is the number of quick mode negotiations attempted since IPsec was last started.
  let ``Quick Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations/sec: Quick Mode Negotiations per Second is the rate at which quick mode negotiations are being attempted.
  let ``Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations: Successful Quick Mode Negotiations is the number of quick mode negotiations completed since IPsec was last started.
  let ``Successful Quick Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Successful Quick Mode Negotiations"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations/sec: Successful Quick Mode Negotiations per Second is the rate of quick mode negotiations completed.
  let ``Successful Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Successful Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations: Failed Quick Mode Negotiations is the number of failed quick mode negotiations since IPsec was last started.
  let ``Failed Quick Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Failed Quick Mode Negotiations"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations/sec: Failed Quick Mode Negotiations per Second is the rate of failed quick mode negotiations.
  let ``Failed Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv4"; counter = "Failed Quick Mode Negotiations/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Active Main Mode SAs``
      ``Pending Main Mode Negotiations``
      ``Main Mode Negotiations``
      ``Main Mode Negotiations/sec``
      ``Successful Main Mode Negotiations``
      ``Successful Main Mode Negotiations/sec``
      ``Failed Main Mode Negotiations``
      ``Failed Main Mode Negotiations/sec``
      ``Main Mode Negotiation Requests Received``
      ``Main Mode Negotiation Requests Received/sec``
      ``Active Quick Mode SAs``
      ``Pending Quick Mode Negotiations``
      ``Quick Mode Negotiations``
      ``Quick Mode Negotiations/sec``
      ``Successful Quick Mode Negotiations``
      ``Successful Quick Mode Negotiations/sec``
      ``Failed Quick Mode Negotiations``
      ``Failed Quick Mode Negotiations/sec``
    ]

/// IPsec IKEv1 IPv6: IPsec IKEv1 IPv6 is the set of Internet Protocol security (IPsec) Internet Key Exchange version 1 (IKEv1) counters that apply to traffic and connections over Internet Protocol version 6.
///
/// This performance counter does not have instance based counters
module ``IPsec IKEv1 IPv6`` =

  [<Literal>]
  let Category = "IPsec IKEv1 IPv6"

  let PCC = getPCC Category
  /// Active Main Mode SAs: Active Main Mode SAs is the number of currently active main mode security associations.
  let ``Active Main Mode SAs`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Active Main Mode SAs"; instance = NotApplicable }
  /// Pending Main Mode Negotiations: Pending Main Mode Negotiations is the number of pending main mode negotiations.
  let ``Pending Main Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Pending Main Mode Negotiations"; instance = NotApplicable }
  /// Main Mode Negotiations: Main Mode Negotiations is the number of main mode negotiations attempted since IPsec was last started.
  let ``Main Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Main Mode Negotiations"; instance = NotApplicable }
  /// Main Mode Negotiations/sec: Main Mode Negotiations per Second is the rate at which main mode negotiations are being attempted.
  let ``Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Main Mode Negotiations: Successful Main Mode Negotiations is the number of main mode negotiations completed since IPsec was last started.
  let ``Successful Main Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Successful Main Mode Negotiations"; instance = NotApplicable }
  /// Successful Main Mode Negotiations/sec: Successful Main Mode Negotiations per Second is the rate of main mode negotiations completed.
  let ``Successful Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Successful Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Failed Main Mode Negotiations: Failed Main Mode Negotiations is the number of failed main mode negotiations since IPsec was last started.
  let ``Failed Main Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Failed Main Mode Negotiations"; instance = NotApplicable }
  /// Failed Main Mode Negotiations/sec: Failed Main Mode Negotiations per Second is the rate of failed main mode negotiations.
  let ``Failed Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Failed Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received: Main Mode Negotiation Requests Received is the number of main mode negotiations initiated by a peer since IPsec was last started.
  let ``Main Mode Negotiation Requests Received`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Main Mode Negotiation Requests Received"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received/sec: Main Mode Negotiation Requests Received per Second is the rate of main mode negotiations initiated by a peer.
  let ``Main Mode Negotiation Requests Received/sec`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Main Mode Negotiation Requests Received/sec"; instance = NotApplicable }
  /// Active Quick Mode SAs: Active Quick Mode SAs is the number of currently active quick mode security associations.
  let ``Active Quick Mode SAs`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Active Quick Mode SAs"; instance = NotApplicable }
  /// Pending Quick Mode Negotiations: Pending Quick Mode Negotiations is the number of pending quick mode negotiations.
  let ``Pending Quick Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Pending Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations: Quick Mode Negotiations is the number of quick mode negotiations attempted since IPsec was last started.
  let ``Quick Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations/sec: Quick Mode Negotiations per Second is the rate at which quick mode negotiations are being attempted.
  let ``Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations: Successful Quick Mode Negotiations is the number of quick mode negotiations completed since IPsec was last started.
  let ``Successful Quick Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Successful Quick Mode Negotiations"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations/sec: Successful Quick Mode Negotiations per Second is the rate of quick mode negotiations completed.
  let ``Successful Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Successful Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations: Failed Quick Mode Negotiations is the number of failed quick mode negotiations since IPsec was last started.
  let ``Failed Quick Mode Negotiations`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Failed Quick Mode Negotiations"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations/sec: Failed Quick Mode Negotiations per Second is the rate of failed quick mode negotiations.
  let ``Failed Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv1 IPv6"; counter = "Failed Quick Mode Negotiations/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Active Main Mode SAs``
      ``Pending Main Mode Negotiations``
      ``Main Mode Negotiations``
      ``Main Mode Negotiations/sec``
      ``Successful Main Mode Negotiations``
      ``Successful Main Mode Negotiations/sec``
      ``Failed Main Mode Negotiations``
      ``Failed Main Mode Negotiations/sec``
      ``Main Mode Negotiation Requests Received``
      ``Main Mode Negotiation Requests Received/sec``
      ``Active Quick Mode SAs``
      ``Pending Quick Mode Negotiations``
      ``Quick Mode Negotiations``
      ``Quick Mode Negotiations/sec``
      ``Successful Quick Mode Negotiations``
      ``Successful Quick Mode Negotiations/sec``
      ``Failed Quick Mode Negotiations``
      ``Failed Quick Mode Negotiations/sec``
    ]

/// IPsec IKEv2 IPv4: IPsec IKEv2 IPv4 is the set of Internet Protocol security (IPsec) Internet Key Exchange version 2 (IKEv2) counters that apply to traffic and connections over Internet Protocol version 4.
///
/// This performance counter does not have instance based counters
module ``IPsec IKEv2 IPv4`` =

  [<Literal>]
  let Category = "IPsec IKEv2 IPv4"

  let PCC = getPCC Category
  /// Active Main Mode SAs: Active Main Mode SAs is the number of currently active main mode security associations.
  let ``Active Main Mode SAs`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Active Main Mode SAs"; instance = NotApplicable }
  /// Pending Main Mode Negotiations: Pending Main Mode Negotiations is the number of pending main mode negotiations.
  let ``Pending Main Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Pending Main Mode Negotiations"; instance = NotApplicable }
  /// Main Mode Negotiations: Main Mode Negotiations is the number of main mode negotiations attempted since IPsec was last started.
  let ``Main Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Main Mode Negotiations"; instance = NotApplicable }
  /// Main Mode Negotiations/sec: Main Mode Negotiations per Second is the rate at which main mode negotiations are being attempted.
  let ``Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Main Mode Negotiations: Successful Main Mode Negotiations is the number of main mode negotiations completed since IPsec was last started.
  let ``Successful Main Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Successful Main Mode Negotiations"; instance = NotApplicable }
  /// Successful Main Mode Negotiations/sec: Successful Main Mode Negotiations per Second is the rate of main mode negotiations completed.
  let ``Successful Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Successful Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Failed Main Mode Negotiations: Failed Main Mode Negotiations is the number of failed main mode negotiations since IPsec was last started.
  let ``Failed Main Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Failed Main Mode Negotiations"; instance = NotApplicable }
  /// Failed Main Mode Negotiations/sec: Failed Main Mode Negotiations per Second is the rate of failed main mode negotiations.
  let ``Failed Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Failed Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received: Main Mode Negotiation Requests Received is the number of main mode negotiations initiated by a peer since IPsec was last started.
  let ``Main Mode Negotiation Requests Received`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Main Mode Negotiation Requests Received"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received/sec: Main Mode Negotiation Requests Received per Second is the rate of main mode negotiations initiated by a peer.
  let ``Main Mode Negotiation Requests Received/sec`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Main Mode Negotiation Requests Received/sec"; instance = NotApplicable }
  /// Active Quick Mode SAs: Active Quick Mode SAs is the number of currently active quick mode security associations.
  let ``Active Quick Mode SAs`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Active Quick Mode SAs"; instance = NotApplicable }
  /// Pending Quick Mode Negotiations: Pending Quick Mode Negotiations is the number of pending quick mode negotiations.
  let ``Pending Quick Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Pending Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations: Quick Mode Negotiations is the number of quick mode negotiations attempted since IPsec was last started.
  let ``Quick Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations/sec: Quick Mode Negotiations per Second is the rate at which quick mode negotiations are being attempted.
  let ``Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations: Successful Quick Mode Negotiations is the number of quick mode negotiations completed since IPsec was last started.
  let ``Successful Quick Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Successful Quick Mode Negotiations"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations/sec: Successful Quick Mode Negotiations per Second is the rate of quick mode negotiations completed.
  let ``Successful Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Successful Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations: Failed Quick Mode Negotiations is the number of failed quick mode negotiations since IPsec was last started.
  let ``Failed Quick Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Failed Quick Mode Negotiations"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations/sec: Failed Quick Mode Negotiations per Second is the rate of failed quick mode negotiations.
  let ``Failed Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv4"; counter = "Failed Quick Mode Negotiations/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Active Main Mode SAs``
      ``Pending Main Mode Negotiations``
      ``Main Mode Negotiations``
      ``Main Mode Negotiations/sec``
      ``Successful Main Mode Negotiations``
      ``Successful Main Mode Negotiations/sec``
      ``Failed Main Mode Negotiations``
      ``Failed Main Mode Negotiations/sec``
      ``Main Mode Negotiation Requests Received``
      ``Main Mode Negotiation Requests Received/sec``
      ``Active Quick Mode SAs``
      ``Pending Quick Mode Negotiations``
      ``Quick Mode Negotiations``
      ``Quick Mode Negotiations/sec``
      ``Successful Quick Mode Negotiations``
      ``Successful Quick Mode Negotiations/sec``
      ``Failed Quick Mode Negotiations``
      ``Failed Quick Mode Negotiations/sec``
    ]

/// IPsec IKEv2 IPv6: IPsec IKEv2 IPv6 is the set of Internet Protocol security (IPsec) Internet Key Exchange version 2 (IKEv2) counters that apply to traffic and connections over Internet Protocol version 6.
///
/// This performance counter does not have instance based counters
module ``IPsec IKEv2 IPv6`` =

  [<Literal>]
  let Category = "IPsec IKEv2 IPv6"

  let PCC = getPCC Category
  /// Active Main Mode SAs: Active Main Mode SAs is the number of currently active main mode security associations.
  let ``Active Main Mode SAs`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Active Main Mode SAs"; instance = NotApplicable }
  /// Pending Main Mode Negotiations: Pending Main Mode Negotiations is the number of pending main mode negotiations.
  let ``Pending Main Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Pending Main Mode Negotiations"; instance = NotApplicable }
  /// Main Mode Negotiations: Main Mode Negotiations is the number of main mode negotiations attempted since IPsec was last started.
  let ``Main Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Main Mode Negotiations"; instance = NotApplicable }
  /// Main Mode Negotiations/sec: Main Mode Negotiations per Second is the rate at which main mode negotiations are being attempted.
  let ``Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Main Mode Negotiations: Successful Main Mode Negotiations is the number of main mode negotiations completed since IPsec was last started.
  let ``Successful Main Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Successful Main Mode Negotiations"; instance = NotApplicable }
  /// Successful Main Mode Negotiations/sec: Successful Main Mode Negotiations per Second is the rate of main mode negotiations completed.
  let ``Successful Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Successful Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Failed Main Mode Negotiations: Failed Main Mode Negotiations is the number of failed main mode negotiations since IPsec was last started.
  let ``Failed Main Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Failed Main Mode Negotiations"; instance = NotApplicable }
  /// Failed Main Mode Negotiations/sec: Failed Main Mode Negotiations per Second is the rate of failed main mode negotiations.
  let ``Failed Main Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Failed Main Mode Negotiations/sec"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received: Main Mode Negotiation Requests Received is the number of main mode negotiations initiated by a peer since IPsec was last started.
  let ``Main Mode Negotiation Requests Received`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Main Mode Negotiation Requests Received"; instance = NotApplicable }
  /// Main Mode Negotiation Requests Received/sec: Main Mode Negotiation Requests Received per Second is the rate of main mode negotiations initiated by a peer.
  let ``Main Mode Negotiation Requests Received/sec`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Main Mode Negotiation Requests Received/sec"; instance = NotApplicable }
  /// Active Quick Mode SAs: Active Quick Mode SAs is the number of currently active quick mode security associations.
  let ``Active Quick Mode SAs`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Active Quick Mode SAs"; instance = NotApplicable }
  /// Pending Quick Mode Negotiations: Pending Quick Mode Negotiations is the number of pending quick mode negotiations.
  let ``Pending Quick Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Pending Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations: Quick Mode Negotiations is the number of quick mode negotiations attempted since IPsec was last started.
  let ``Quick Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Quick Mode Negotiations"; instance = NotApplicable }
  /// Quick Mode Negotiations/sec: Quick Mode Negotiations per Second is the rate at which quick mode negotiations are being attempted.
  let ``Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations: Successful Quick Mode Negotiations is the number of quick mode negotiations completed since IPsec was last started.
  let ``Successful Quick Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Successful Quick Mode Negotiations"; instance = NotApplicable }
  /// Successful Quick Mode Negotiations/sec: Successful Quick Mode Negotiations per Second is the rate of quick mode negotiations completed.
  let ``Successful Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Successful Quick Mode Negotiations/sec"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations: Failed Quick Mode Negotiations is the number of failed quick mode negotiations since IPsec was last started.
  let ``Failed Quick Mode Negotiations`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Failed Quick Mode Negotiations"; instance = NotApplicable }
  /// Failed Quick Mode Negotiations/sec: Failed Quick Mode Negotiations per Second is the rate of failed quick mode negotiations.
  let ``Failed Quick Mode Negotiations/sec`` =
    { category = "IPsec IKEv2 IPv6"; counter = "Failed Quick Mode Negotiations/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Active Main Mode SAs``
      ``Pending Main Mode Negotiations``
      ``Main Mode Negotiations``
      ``Main Mode Negotiations/sec``
      ``Successful Main Mode Negotiations``
      ``Successful Main Mode Negotiations/sec``
      ``Failed Main Mode Negotiations``
      ``Failed Main Mode Negotiations/sec``
      ``Main Mode Negotiation Requests Received``
      ``Main Mode Negotiation Requests Received/sec``
      ``Active Quick Mode SAs``
      ``Pending Quick Mode Negotiations``
      ``Quick Mode Negotiations``
      ``Quick Mode Negotiations/sec``
      ``Successful Quick Mode Negotiations``
      ``Successful Quick Mode Negotiations/sec``
      ``Failed Quick Mode Negotiations``
      ``Failed Quick Mode Negotiations/sec``
    ]

/// IPv4: The IP performance object consists of counters that measure the rates at which IP datagrams are sent and received by using IP protocols.  It also includes counters that monitor IP protocol errors.
///
/// This performance counter does not have instance based counters
module ``IPv4`` =

  [<Literal>]
  let Category = "IPv4"

  let PCC = getPCC Category
  /// Datagrams/sec: Datagrams/sec is the rate, in incidents per second, at which IP datagrams were received from or sent to the interfaces, including those in error. Forwarded datagrams are not included in this rate.
  let ``Datagrams/sec`` =
    { category = "IPv4"; counter = "Datagrams/sec"; instance = NotApplicable }
  /// Datagrams Received/sec: Datagrams Received/sec is the rate, in incidents per second, at which IP datagrams are received from the interfaces, including those in error. Datagrams Received/sec is a subset of Datagrams/sec.
  let ``Datagrams Received/sec`` =
    { category = "IPv4"; counter = "Datagrams Received/sec"; instance = NotApplicable }
  /// Datagrams Received Header Errors: Datagrams Received Header Errors is the number of input datagrams that were discarded due to errors in the IP headers, including bad checksums, version number mismatch, other format errors, time-to-live exceeded, errors discovered in processing their IP options, etc.
  let ``Datagrams Received Header Errors`` =
    { category = "IPv4"; counter = "Datagrams Received Header Errors"; instance = NotApplicable }
  /// Datagrams Received Address Errors: Datagrams Received Address Errors is the number of input datagrams that were discarded because the IP address in their IP header destination field was not valid for the computer. This count includes invalid addresses (for example, 0.0.  0.0) and addresses of unsupported Classes (for example, Class E). For entities that are not IP gateways and do not forward datagrams, this counter includes datagrams that were discarded because the destination address was not a local address.
  let ``Datagrams Received Address Errors`` =
    { category = "IPv4"; counter = "Datagrams Received Address Errors"; instance = NotApplicable }
  /// Datagrams Forwarded/sec: Datagrams Forwarded/sec is the rate, in incidents per second, at which attemps were made to find routes to forward input datagrams their final destination, because the local server was not the final IP destination. In servers that do not act as IP Gateways, this rate includes only packets that were source-routed via this entity, where the source-route option processing was successful.
  let ``Datagrams Forwarded/sec`` =
    { category = "IPv4"; counter = "Datagrams Forwarded/sec"; instance = NotApplicable }
  /// Datagrams Received Unknown Protocol: Datagrams Received Unknown Protocol is the number of locally-addressed datagrams that were successfully received but were discarded because of an unknown or unsupported protocol.
  let ``Datagrams Received Unknown Protocol`` =
    { category = "IPv4"; counter = "Datagrams Received Unknown Protocol"; instance = NotApplicable }
  /// Datagrams Received Discarded: Datagrams Received Discarded is the number of input IP datagrams that were discarded even though problems prevented their continued processing (for example, lack of buffer space). This counter does not include any datagrams discarded while awaiting re-assembly.
  let ``Datagrams Received Discarded`` =
    { category = "IPv4"; counter = "Datagrams Received Discarded"; instance = NotApplicable }
  /// Datagrams Received Delivered/sec: Datagrams Received Delivered/sec is the rate, in incidents per second, at which input datagrams were successfully delivered to IP user-protocols, including Internet Control Message Protocol (ICMP).
  let ``Datagrams Received Delivered/sec`` =
    { category = "IPv4"; counter = "Datagrams Received Delivered/sec"; instance = NotApplicable }
  /// Datagrams Sent/sec: Datagrams Sent/sec is the rate, in incidents per second, at which IP datagrams were supplied for transmission by local IP user-protocols (including ICMP). This counter does not include any datagrams counted in Datagrams Forwarded/sec. Datagrams Sent/sec is a subset of Datagrams/sec.
  let ``Datagrams Sent/sec`` =
    { category = "IPv4"; counter = "Datagrams Sent/sec"; instance = NotApplicable }
  /// Datagrams Outbound Discarded: Datagrams Outbound Discarded is the number of output IP datagrams that were discarded even though no problems were encountered to prevent their transmission to their destination (for example, lack of buffer space). This counter includes datagrams counted in Datagrams Forwarded/sec that meet this criterion.
  let ``Datagrams Outbound Discarded`` =
    { category = "IPv4"; counter = "Datagrams Outbound Discarded"; instance = NotApplicable }
  /// Datagrams Outbound No Route: Datagrams Outbound No Route is the number of IP datagrams that were discarded because no route could be found to transmit them to their destination.  This counter includes any packets counted in Datagrams Forwarded/sec that meet this `no route' criterion.
  let ``Datagrams Outbound No Route`` =
    { category = "IPv4"; counter = "Datagrams Outbound No Route"; instance = NotApplicable }
  /// Fragments Received/sec: Fragments Received/sec is the rate, in incidents per second, at which IP fragments that need to be reassembled at this entity are received.
  let ``Fragments Received/sec`` =
    { category = "IPv4"; counter = "Fragments Received/sec"; instance = NotApplicable }
  /// Fragments Re-assembled/sec: Fragments Re-assembled/sec is the rate, in incidents per second, at which IP fragments were successfully reassembled.
  let ``Fragments Re-assembled/sec`` =
    { category = "IPv4"; counter = "Fragments Re-assembled/sec"; instance = NotApplicable }
  /// Fragment Re-assembly Failures: Fragment Re-assembly Failures is the number of failures detected by the IP reassembly algorithm, such as time outs, errors, etc.  This is not necessarily a count of discarded IP fragments since some algorithms (notably RFC 815) lose track of the number of fragments by combining them as they are received.
  let ``Fragment Re-assembly Failures`` =
    { category = "IPv4"; counter = "Fragment Re-assembly Failures"; instance = NotApplicable }
  /// Fragmented Datagrams/sec: Fragmented Datagrams/sec is the rate, in incidents per second, at which datagrams are successfully fragmented.
  let ``Fragmented Datagrams/sec`` =
    { category = "IPv4"; counter = "Fragmented Datagrams/sec"; instance = NotApplicable }
  /// Fragmentation Failures: Fragmentation Failures is the number of IP datagrams that were discarded because they needed to be fragmented at but could not be (for example, because the `Don't Fragment' flag was set).
  let ``Fragmentation Failures`` =
    { category = "IPv4"; counter = "Fragmentation Failures"; instance = NotApplicable }
  /// Fragments Created/sec: Fragments Created/sec is the rate, in incidents per second, at which IP datagram fragments were generated as a result of fragmentation.
  let ``Fragments Created/sec`` =
    { category = "IPv4"; counter = "Fragments Created/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Datagrams/sec``
      ``Datagrams Received/sec``
      ``Datagrams Received Header Errors``
      ``Datagrams Received Address Errors``
      ``Datagrams Forwarded/sec``
      ``Datagrams Received Unknown Protocol``
      ``Datagrams Received Discarded``
      ``Datagrams Received Delivered/sec``
      ``Datagrams Sent/sec``
      ``Datagrams Outbound Discarded``
      ``Datagrams Outbound No Route``
      ``Fragments Received/sec``
      ``Fragments Re-assembled/sec``
      ``Fragment Re-assembly Failures``
      ``Fragmented Datagrams/sec``
      ``Fragmentation Failures``
      ``Fragments Created/sec``
    ]

/// IPv6: The IP performance object consists of counters that measure the rates at which IP datagrams are sent and received by using IP protocols.  It also includes counters that monitor IP protocol errors.
///
/// This performance counter does not have instance based counters
module ``IPv6`` =

  [<Literal>]
  let Category = "IPv6"

  let PCC = getPCC Category
  /// Datagrams/sec: Datagrams/sec is the rate, in incidents per second, at which IP datagrams were received from or sent to the interfaces, including those in error. Forwarded datagrams are not included in this rate.
  let ``Datagrams/sec`` =
    { category = "IPv6"; counter = "Datagrams/sec"; instance = NotApplicable }
  /// Datagrams Received/sec: Datagrams Received/sec is the rate, in incidents per second, at which IP datagrams are received from the interfaces, including those in error. Datagrams Received/sec is a subset of Datagrams/sec.
  let ``Datagrams Received/sec`` =
    { category = "IPv6"; counter = "Datagrams Received/sec"; instance = NotApplicable }
  /// Datagrams Received Header Errors: Datagrams Received Header Errors is the number of input datagrams that were discarded due to errors in the IP headers, including bad checksums, version number mismatch, other format errors, time-to-live exceeded, errors discovered in processing their IP options, etc.
  let ``Datagrams Received Header Errors`` =
    { category = "IPv6"; counter = "Datagrams Received Header Errors"; instance = NotApplicable }
  /// Datagrams Received Address Errors: Datagrams Received Address Errors is the number of input datagrams that were discarded because the IP address in their IP header destination field was not valid for the computer. This count includes invalid addresses (for example, 0.0.  0.0) and addresses of unsupported Classes (for example, Class E). For entities that are not IP gateways and do not forward datagrams, this counter includes datagrams that were discarded because the destination address was not a local address.
  let ``Datagrams Received Address Errors`` =
    { category = "IPv6"; counter = "Datagrams Received Address Errors"; instance = NotApplicable }
  /// Datagrams Forwarded/sec: Datagrams Forwarded/sec is the rate, in incidents per second, at which attemps were made to find routes to forward input datagrams their final destination, because the local server was not the final IP destination. In servers that do not act as IP Gateways, this rate includes only packets that were source-routed via this entity, where the source-route option processing was successful.
  let ``Datagrams Forwarded/sec`` =
    { category = "IPv6"; counter = "Datagrams Forwarded/sec"; instance = NotApplicable }
  /// Datagrams Received Unknown Protocol: Datagrams Received Unknown Protocol is the number of locally-addressed datagrams that were successfully received but were discarded because of an unknown or unsupported protocol.
  let ``Datagrams Received Unknown Protocol`` =
    { category = "IPv6"; counter = "Datagrams Received Unknown Protocol"; instance = NotApplicable }
  /// Datagrams Received Discarded: Datagrams Received Discarded is the number of input IP datagrams that were discarded even though problems prevented their continued processing (for example, lack of buffer space). This counter does not include any datagrams discarded while awaiting re-assembly.
  let ``Datagrams Received Discarded`` =
    { category = "IPv6"; counter = "Datagrams Received Discarded"; instance = NotApplicable }
  /// Datagrams Received Delivered/sec: Datagrams Received Delivered/sec is the rate, in incidents per second, at which input datagrams were successfully delivered to IP user-protocols, including Internet Control Message Protocol (ICMP).
  let ``Datagrams Received Delivered/sec`` =
    { category = "IPv6"; counter = "Datagrams Received Delivered/sec"; instance = NotApplicable }
  /// Datagrams Sent/sec: Datagrams Sent/sec is the rate, in incidents per second, at which IP datagrams were supplied for transmission by local IP user-protocols (including ICMP). This counter does not include any datagrams counted in Datagrams Forwarded/sec. Datagrams Sent/sec is a subset of Datagrams/sec.
  let ``Datagrams Sent/sec`` =
    { category = "IPv6"; counter = "Datagrams Sent/sec"; instance = NotApplicable }
  /// Datagrams Outbound Discarded: Datagrams Outbound Discarded is the number of output IP datagrams that were discarded even though no problems were encountered to prevent their transmission to their destination (for example, lack of buffer space). This counter includes datagrams counted in Datagrams Forwarded/sec that meet this criterion.
  let ``Datagrams Outbound Discarded`` =
    { category = "IPv6"; counter = "Datagrams Outbound Discarded"; instance = NotApplicable }
  /// Datagrams Outbound No Route: Datagrams Outbound No Route is the number of IP datagrams that were discarded because no route could be found to transmit them to their destination.  This counter includes any packets counted in Datagrams Forwarded/sec that meet this `no route' criterion.
  let ``Datagrams Outbound No Route`` =
    { category = "IPv6"; counter = "Datagrams Outbound No Route"; instance = NotApplicable }
  /// Fragments Received/sec: Fragments Received/sec is the rate, in incidents per second, at which IP fragments that need to be reassembled at this entity are received.
  let ``Fragments Received/sec`` =
    { category = "IPv6"; counter = "Fragments Received/sec"; instance = NotApplicable }
  /// Fragments Re-assembled/sec: Fragments Re-assembled/sec is the rate, in incidents per second, at which IP fragments were successfully reassembled.
  let ``Fragments Re-assembled/sec`` =
    { category = "IPv6"; counter = "Fragments Re-assembled/sec"; instance = NotApplicable }
  /// Fragment Re-assembly Failures: Fragment Re-assembly Failures is the number of failures detected by the IP reassembly algorithm, such as time outs, errors, etc.  This is not necessarily a count of discarded IP fragments since some algorithms (notably RFC 815) lose track of the number of fragments by combining them as they are received.
  let ``Fragment Re-assembly Failures`` =
    { category = "IPv6"; counter = "Fragment Re-assembly Failures"; instance = NotApplicable }
  /// Fragmented Datagrams/sec: Fragmented Datagrams/sec is the rate, in incidents per second, at which datagrams are successfully fragmented.
  let ``Fragmented Datagrams/sec`` =
    { category = "IPv6"; counter = "Fragmented Datagrams/sec"; instance = NotApplicable }
  /// Fragmentation Failures: Fragmentation Failures is the number of IP datagrams that were discarded because they needed to be fragmented at but could not be (for example, because the `Don't Fragment' flag was set).
  let ``Fragmentation Failures`` =
    { category = "IPv6"; counter = "Fragmentation Failures"; instance = NotApplicable }
  /// Fragments Created/sec: Fragments Created/sec is the rate, in incidents per second, at which IP datagram fragments were generated as a result of fragmentation.
  let ``Fragments Created/sec`` =
    { category = "IPv6"; counter = "Fragments Created/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Datagrams/sec``
      ``Datagrams Received/sec``
      ``Datagrams Received Header Errors``
      ``Datagrams Received Address Errors``
      ``Datagrams Forwarded/sec``
      ``Datagrams Received Unknown Protocol``
      ``Datagrams Received Discarded``
      ``Datagrams Received Delivered/sec``
      ``Datagrams Sent/sec``
      ``Datagrams Outbound Discarded``
      ``Datagrams Outbound No Route``
      ``Fragments Received/sec``
      ``Fragments Re-assembled/sec``
      ``Fragment Re-assembly Failures``
      ``Fragmented Datagrams/sec``
      ``Fragmentation Failures``
      ``Fragments Created/sec``
    ]

/// Job Object: Reports the accounting and processor usage data collected by each active named Job object.
///
/// This performance counter does not have instance based counters
module ``Job Object`` =

  [<Literal>]
  let Category = "Job Object"

  let PCC = getPCC Category
  /// Current % Processor Time: 
  let ``Current % Processor Time`` instance =
    { category = "Job Object"; counter = "Current % Processor Time"; instance = instance }
  /// Current % User Mode Time: 
  let ``Current % User Mode Time`` instance =
    { category = "Job Object"; counter = "Current % User Mode Time"; instance = instance }
  /// Current % Kernel Mode Time: 
  let ``Current % Kernel Mode Time`` instance =
    { category = "Job Object"; counter = "Current % Kernel Mode Time"; instance = instance }
  /// This Period mSec - Processor: 
  let ``This Period mSec - Processor`` instance =
    { category = "Job Object"; counter = "This Period mSec - Processor"; instance = instance }
  /// This Period mSec - User Mode: 
  let ``This Period mSec - User Mode`` instance =
    { category = "Job Object"; counter = "This Period mSec - User Mode"; instance = instance }
  /// This Period mSec - Kernel Mode: 
  let ``This Period mSec - Kernel Mode`` instance =
    { category = "Job Object"; counter = "This Period mSec - Kernel Mode"; instance = instance }
  /// Total mSec - Processor: 
  let ``Total mSec - Processor`` instance =
    { category = "Job Object"; counter = "Total mSec - Processor"; instance = instance }
  /// Total mSec - User Mode: 
  let ``Total mSec - User Mode`` instance =
    { category = "Job Object"; counter = "Total mSec - User Mode"; instance = instance }
  /// Total mSec - Kernel Mode: 
  let ``Total mSec - Kernel Mode`` instance =
    { category = "Job Object"; counter = "Total mSec - Kernel Mode"; instance = instance }
  /// Pages/Sec: 
  let ``Pages/Sec`` instance =
    { category = "Job Object"; counter = "Pages/Sec"; instance = instance }
  /// Process Count - Total: 
  let ``Process Count - Total`` instance =
    { category = "Job Object"; counter = "Process Count - Total"; instance = instance }
  /// Process Count - Active: 
  let ``Process Count - Active`` instance =
    { category = "Job Object"; counter = "Process Count - Active"; instance = instance }
  /// Process Count - Terminated: 
  let ``Process Count - Terminated`` instance =
    { category = "Job Object"; counter = "Process Count - Terminated"; instance = instance }

  let allCounters =
    [ ``Current % Processor Time``
      ``Current % User Mode Time``
      ``Current % Kernel Mode Time``
      ``This Period mSec - Processor``
      ``This Period mSec - User Mode``
      ``This Period mSec - Kernel Mode``
      ``Total mSec - Processor``
      ``Total mSec - User Mode``
      ``Total mSec - Kernel Mode``
      ``Pages/Sec``
      ``Process Count - Total``
      ``Process Count - Active``
      ``Process Count - Terminated``
    ]

/// Job Object Details: % Job object Details shows detailed performance information about the active processes that make up a Job object.
///
/// This performance counter does not have instance based counters
module ``Job Object Details`` =

  [<Literal>]
  let Category = "Job Object Details"

  let PCC = getPCC Category
  /// % Processor Time: 
  let ``% Processor Time`` instance =
    { category = "Job Object Details"; counter = "% Processor Time"; instance = instance }
  /// % User Time: 
  let ``% User Time`` instance =
    { category = "Job Object Details"; counter = "% User Time"; instance = instance }
  /// % Privileged Time: 
  let ``% Privileged Time`` instance =
    { category = "Job Object Details"; counter = "% Privileged Time"; instance = instance }
  /// Virtual Bytes Peak: 
  let ``Virtual Bytes Peak`` instance =
    { category = "Job Object Details"; counter = "Virtual Bytes Peak"; instance = instance }
  /// Virtual Bytes: 
  let ``Virtual Bytes`` instance =
    { category = "Job Object Details"; counter = "Virtual Bytes"; instance = instance }
  /// Page Faults/sec: 
  let ``Page Faults/sec`` instance =
    { category = "Job Object Details"; counter = "Page Faults/sec"; instance = instance }
  /// Working Set Peak: 
  let ``Working Set Peak`` instance =
    { category = "Job Object Details"; counter = "Working Set Peak"; instance = instance }
  /// Working Set: 
  let ``Working Set`` instance =
    { category = "Job Object Details"; counter = "Working Set"; instance = instance }
  /// Page File Bytes Peak: 
  let ``Page File Bytes Peak`` instance =
    { category = "Job Object Details"; counter = "Page File Bytes Peak"; instance = instance }
  /// Page File Bytes: 
  let ``Page File Bytes`` instance =
    { category = "Job Object Details"; counter = "Page File Bytes"; instance = instance }
  /// Private Bytes: 
  let ``Private Bytes`` instance =
    { category = "Job Object Details"; counter = "Private Bytes"; instance = instance }
  /// Thread Count: 
  let ``Thread Count`` instance =
    { category = "Job Object Details"; counter = "Thread Count"; instance = instance }
  /// Priority Base: 
  let ``Priority Base`` instance =
    { category = "Job Object Details"; counter = "Priority Base"; instance = instance }
  /// Elapsed Time: 
  let ``Elapsed Time`` instance =
    { category = "Job Object Details"; counter = "Elapsed Time"; instance = instance }
  /// ID Process: 
  let ``ID Process`` instance =
    { category = "Job Object Details"; counter = "ID Process"; instance = instance }
  /// Creating Process ID: 
  let ``Creating Process ID`` instance =
    { category = "Job Object Details"; counter = "Creating Process ID"; instance = instance }
  /// Pool Paged Bytes: 
  let ``Pool Paged Bytes`` instance =
    { category = "Job Object Details"; counter = "Pool Paged Bytes"; instance = instance }
  /// Pool Nonpaged Bytes: 
  let ``Pool Nonpaged Bytes`` instance =
    { category = "Job Object Details"; counter = "Pool Nonpaged Bytes"; instance = instance }
  /// Handle Count: 
  let ``Handle Count`` instance =
    { category = "Job Object Details"; counter = "Handle Count"; instance = instance }
  /// IO Read Operations/sec: 
  let ``IO Read Operations/sec`` instance =
    { category = "Job Object Details"; counter = "IO Read Operations/sec"; instance = instance }
  /// IO Write Operations/sec: 
  let ``IO Write Operations/sec`` instance =
    { category = "Job Object Details"; counter = "IO Write Operations/sec"; instance = instance }
  /// IO Data Operations/sec: 
  let ``IO Data Operations/sec`` instance =
    { category = "Job Object Details"; counter = "IO Data Operations/sec"; instance = instance }
  /// IO Other Operations/sec: 
  let ``IO Other Operations/sec`` instance =
    { category = "Job Object Details"; counter = "IO Other Operations/sec"; instance = instance }
  /// IO Read Bytes/sec: 
  let ``IO Read Bytes/sec`` instance =
    { category = "Job Object Details"; counter = "IO Read Bytes/sec"; instance = instance }
  /// IO Write Bytes/sec: 
  let ``IO Write Bytes/sec`` instance =
    { category = "Job Object Details"; counter = "IO Write Bytes/sec"; instance = instance }
  /// IO Data Bytes/sec: 
  let ``IO Data Bytes/sec`` instance =
    { category = "Job Object Details"; counter = "IO Data Bytes/sec"; instance = instance }
  /// IO Other Bytes/sec: 
  let ``IO Other Bytes/sec`` instance =
    { category = "Job Object Details"; counter = "IO Other Bytes/sec"; instance = instance }

  let allCounters =
    [ ``% Processor Time``
      ``% User Time``
      ``% Privileged Time``
      ``Virtual Bytes Peak``
      ``Virtual Bytes``
      ``Page Faults/sec``
      ``Working Set Peak``
      ``Working Set``
      ``Page File Bytes Peak``
      ``Page File Bytes``
      ``Private Bytes``
      ``Thread Count``
      ``Priority Base``
      ``Elapsed Time``
      ``ID Process``
      ``Creating Process ID``
      ``Pool Paged Bytes``
      ``Pool Nonpaged Bytes``
      ``Handle Count``
      ``IO Read Operations/sec``
      ``IO Write Operations/sec``
      ``IO Data Operations/sec``
      ``IO Other Operations/sec``
      ``IO Read Bytes/sec``
      ``IO Write Bytes/sec``
      ``IO Data Bytes/sec``
      ``IO Other Bytes/sec``
    ]

/// LogicalDisk: The Logical Disk performance object consists of counters that monitor logical partitions of a hard or fixed disk drives.  Performance Monitor identifies logical disks by their a drive letter, such as C.
///
/// This performance counter does not have non-instance based counters
module ``LogicalDisk`` =

  [<Literal>]
  let Category = "LogicalDisk"

  let PCC = getPCC Category
  /// % Free Space: % Free Space is the percentage of total usable space on the selected logical disk drive that was free.
  let ``% Free Space`` instance =
    { category = "LogicalDisk"; counter = "% Free Space"; instance = instance }
  /// Free Megabytes: Free Megabytes displays the unallocated space, in megabytes, on the disk drive in megabytes. One megabyte is equal to 1,048,576 bytes.
  let ``Free Megabytes`` instance =
    { category = "LogicalDisk"; counter = "Free Megabytes"; instance = instance }
  /// Current Disk Queue Length: Current Disk Queue Length is the number of requests outstanding on the disk at the time the performance data is collected. It also includes requests in service at the time of the collection. This is a instantaneous snapshot, not an average over the time interval. Multi-spindle disk devices can have multiple requests that are active at one time, but other concurrent requests are awaiting service. This counter might reflect a transitory high or low queue length, but if there is a sustained load on the disk drive, it is likely that this will be consistently high. Requests experience delays proportional to the length of this queue minus the number of spindles on the disks. For good performance, this difference should average less than two.
  let ``Current Disk Queue Length`` instance =
    { category = "LogicalDisk"; counter = "Current Disk Queue Length"; instance = instance }
  /// % Disk Time: % Disk Time is the percentage of elapsed time that the selected disk drive was busy servicing read or write requests.
  let ``% Disk Time`` instance =
    { category = "LogicalDisk"; counter = "% Disk Time"; instance = instance }
  /// Avg. Disk Queue Length: Avg. Disk Queue Length is the average number of both read and write requests that were queued for the selected disk during the sample interval.
  let ``Avg. Disk Queue Length`` instance =
    { category = "LogicalDisk"; counter = "Avg. Disk Queue Length"; instance = instance }
  /// % Disk Read Time: % Disk Read Time is the percentage of elapsed time that the selected disk drive was busy servicing read requests.
  let ``% Disk Read Time`` instance =
    { category = "LogicalDisk"; counter = "% Disk Read Time"; instance = instance }
  /// Avg. Disk Read Queue Length: Avg. Disk Read Queue Length is the average number of read requests that were queued for the selected disk during the sample interval.
  let ``Avg. Disk Read Queue Length`` instance =
    { category = "LogicalDisk"; counter = "Avg. Disk Read Queue Length"; instance = instance }
  /// % Disk Write Time: % Disk Write Time is the percentage of elapsed time that the selected disk drive was busy servicing write requests.
  let ``% Disk Write Time`` instance =
    { category = "LogicalDisk"; counter = "% Disk Write Time"; instance = instance }
  /// Avg. Disk Write Queue Length: Avg. Disk Write Queue Length is the average number of write requests that were queued for the selected disk during the sample interval.
  let ``Avg. Disk Write Queue Length`` instance =
    { category = "LogicalDisk"; counter = "Avg. Disk Write Queue Length"; instance = instance }
  /// Avg. Disk sec/Transfer: Avg. Disk sec/Transfer is the time, in seconds, of the average disk transfer.
  let ``Avg. Disk sec/Transfer`` instance =
    { category = "LogicalDisk"; counter = "Avg. Disk sec/Transfer"; instance = instance }
  /// Avg. Disk sec/Read: Avg. Disk sec/Read is the average time, in seconds, of a read of data from the disk.
  let ``Avg. Disk sec/Read`` instance =
    { category = "LogicalDisk"; counter = "Avg. Disk sec/Read"; instance = instance }
  /// Avg. Disk sec/Write: Avg. Disk sec/Write is the average time, in seconds, of a write of data to the disk.
  let ``Avg. Disk sec/Write`` instance =
    { category = "LogicalDisk"; counter = "Avg. Disk sec/Write"; instance = instance }
  /// Disk Transfers/sec: Disk Transfers/sec is the rate of read and write operations on the disk.
  let ``Disk Transfers/sec`` instance =
    { category = "LogicalDisk"; counter = "Disk Transfers/sec"; instance = instance }
  /// Disk Reads/sec: Disk Reads/sec is the rate of read operations on the disk.
  let ``Disk Reads/sec`` instance =
    { category = "LogicalDisk"; counter = "Disk Reads/sec"; instance = instance }
  /// Disk Writes/sec: Disk Writes/sec is the rate of write operations on the disk.
  let ``Disk Writes/sec`` instance =
    { category = "LogicalDisk"; counter = "Disk Writes/sec"; instance = instance }
  /// Disk Bytes/sec: Disk Bytes/sec is the rate bytes are transferred to or from the disk during write or read operations.
  let ``Disk Bytes/sec`` instance =
    { category = "LogicalDisk"; counter = "Disk Bytes/sec"; instance = instance }
  /// Disk Read Bytes/sec: Disk Read Bytes/sec is the rate at which bytes are transferred from the disk during read operations.
  let ``Disk Read Bytes/sec`` instance =
    { category = "LogicalDisk"; counter = "Disk Read Bytes/sec"; instance = instance }
  /// Disk Write Bytes/sec: Disk Write Bytes/sec is rate at which bytes are transferred to the disk during write operations.
  let ``Disk Write Bytes/sec`` instance =
    { category = "LogicalDisk"; counter = "Disk Write Bytes/sec"; instance = instance }
  /// Avg. Disk Bytes/Transfer: Avg. Disk Bytes/Transfer is the average number of bytes transferred to or from the disk during write or read operations.
  let ``Avg. Disk Bytes/Transfer`` instance =
    { category = "LogicalDisk"; counter = "Avg. Disk Bytes/Transfer"; instance = instance }
  /// Avg. Disk Bytes/Read: Avg. Disk Bytes/Read is the average number of bytes transferred from the disk during read operations.
  let ``Avg. Disk Bytes/Read`` instance =
    { category = "LogicalDisk"; counter = "Avg. Disk Bytes/Read"; instance = instance }
  /// Avg. Disk Bytes/Write: Avg. Disk Bytes/Write is the average number of bytes transferred to the disk during write operations.
  let ``Avg. Disk Bytes/Write`` instance =
    { category = "LogicalDisk"; counter = "Avg. Disk Bytes/Write"; instance = instance }
  /// % Idle Time: % Idle Time reports the percentage of time during the sample interval that the disk was idle.
  let ``% Idle Time`` instance =
    { category = "LogicalDisk"; counter = "% Idle Time"; instance = instance }
  /// Split IO/Sec: Split IO/Sec reports the rate at which I/Os to the disk were split into multiple I/Os. A split I/O may result from requesting data of a size that is too large to fit into a single I/O or that the disk is fragmented.
  let ``Split IO/Sec`` instance =
    { category = "LogicalDisk"; counter = "Split IO/Sec"; instance = instance }

  let allCounters =
    [ ``% Free Space``
      ``Free Megabytes``
      ``Current Disk Queue Length``
      ``% Disk Time``
      ``Avg. Disk Queue Length``
      ``% Disk Read Time``
      ``Avg. Disk Read Queue Length``
      ``% Disk Write Time``
      ``Avg. Disk Write Queue Length``
      ``Avg. Disk sec/Transfer``
      ``Avg. Disk sec/Read``
      ``Avg. Disk sec/Write``
      ``Disk Transfers/sec``
      ``Disk Reads/sec``
      ``Disk Writes/sec``
      ``Disk Bytes/sec``
      ``Disk Read Bytes/sec``
      ``Disk Write Bytes/sec``
      ``Avg. Disk Bytes/Transfer``
      ``Avg. Disk Bytes/Read``
      ``Avg. Disk Bytes/Write``
      ``% Idle Time``
      ``Split IO/Sec``
    ]

/// MSDTC Bridge 3.0.0.0: MSDTC Bridge 3.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``MSDTC Bridge 3_0_0_0`` =

  [<Literal>]
  let Category = "MSDTC Bridge 3.0.0.0"

  let PCC = getPCC Category
  /// Message send failures/sec: The number of WS-AT protocol messages that the WS-AT service failed to send per second.
  let ``Message send failures/sec`` =
    { category = "MSDTC Bridge 3.0.0.0"; counter = "Message send failures/sec"; instance = NotApplicable }
  /// Prepare retry count/sec: The number of Prepare retry messages that the WS-AT service has sent per second.
  let ``Prepare retry count/sec`` =
    { category = "MSDTC Bridge 3.0.0.0"; counter = "Prepare retry count/sec"; instance = NotApplicable }
  /// Commit retry count/sec: The number of Commit retry messages that the WS-AT service has sent per second.
  let ``Commit retry count/sec`` =
    { category = "MSDTC Bridge 3.0.0.0"; counter = "Commit retry count/sec"; instance = NotApplicable }
  /// Prepared retry count/sec: The number of Prepared retry messages that the WS-AT service has sent per second.
  let ``Prepared retry count/sec`` =
    { category = "MSDTC Bridge 3.0.0.0"; counter = "Prepared retry count/sec"; instance = NotApplicable }
  /// Replay retry count/sec: The number of Replay retry messages that the WS-AT service has sent per second.
  let ``Replay retry count/sec`` =
    { category = "MSDTC Bridge 3.0.0.0"; counter = "Replay retry count/sec"; instance = NotApplicable }
  /// Faults received count/sec: The number of Fault messages that the WS-AT service has received per second.
  let ``Faults received count/sec`` =
    { category = "MSDTC Bridge 3.0.0.0"; counter = "Faults received count/sec"; instance = NotApplicable }
  /// Faults sent count/sec: The number of Fault messages that the WS-AT service has sent per second.
  let ``Faults sent count/sec`` =
    { category = "MSDTC Bridge 3.0.0.0"; counter = "Faults sent count/sec"; instance = NotApplicable }
  /// Average participant prepare response time: Average time in milliseconds for the WS-AT service to receive a Prepare message response from a participant.
  let ``Average participant prepare response time`` =
    { category = "MSDTC Bridge 3.0.0.0"; counter = "Average participant prepare response time"; instance = NotApplicable }
  /// Average participant prepare response time Base: Base counter for the 'Average participant prepare response time' counter.
  let ``Average participant prepare response time Base`` =
    { category = "MSDTC Bridge 3.0.0.0"; counter = "Average participant prepare response time Base"; instance = NotApplicable }
  /// Average participant commit response time: Average time in milliseconds for the WS-AT service to receive a Commit message response from a participant.
  let ``Average participant commit response time`` =
    { category = "MSDTC Bridge 3.0.0.0"; counter = "Average participant commit response time"; instance = NotApplicable }
  /// Average participant commit response time Base: Base counter for the 'Average participant commit response time' counter.
  let ``Average participant commit response time Base`` =
    { category = "MSDTC Bridge 3.0.0.0"; counter = "Average participant commit response time Base"; instance = NotApplicable }

  let allCounters =
    [ ``Message send failures/sec``
      ``Prepare retry count/sec``
      ``Commit retry count/sec``
      ``Prepared retry count/sec``
      ``Replay retry count/sec``
      ``Faults received count/sec``
      ``Faults sent count/sec``
      ``Average participant prepare response time``
      ``Average participant prepare response time Base``
      ``Average participant commit response time``
      ``Average participant commit response time Base``
    ]

/// MSDTC Bridge 4.0.0.0: MSDTC Bridge 4.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``MSDTC Bridge 4_0_0_0`` =

  [<Literal>]
  let Category = "MSDTC Bridge 4.0.0.0"

  let PCC = getPCC Category
  /// Message send failures/sec: The number of WS-AT protocol messages that the WS-AT service failed to send per second.
  let ``Message send failures/sec`` =
    { category = "MSDTC Bridge 4.0.0.0"; counter = "Message send failures/sec"; instance = NotApplicable }
  /// Prepare retry count/sec: The number of Prepare retry messages that the WS-AT service has sent per second.
  let ``Prepare retry count/sec`` =
    { category = "MSDTC Bridge 4.0.0.0"; counter = "Prepare retry count/sec"; instance = NotApplicable }
  /// Commit retry count/sec: The number of Commit retry messages that the WS-AT service has sent per second.
  let ``Commit retry count/sec`` =
    { category = "MSDTC Bridge 4.0.0.0"; counter = "Commit retry count/sec"; instance = NotApplicable }
  /// Prepared retry count/sec: The number of Prepared retry messages that the WS-AT service has sent per second.
  let ``Prepared retry count/sec`` =
    { category = "MSDTC Bridge 4.0.0.0"; counter = "Prepared retry count/sec"; instance = NotApplicable }
  /// Replay retry count/sec: The number of Replay retry messages that the WS-AT service has sent per second.
  let ``Replay retry count/sec`` =
    { category = "MSDTC Bridge 4.0.0.0"; counter = "Replay retry count/sec"; instance = NotApplicable }
  /// Faults received count/sec: The number of Fault messages that the WS-AT service has received per second.
  let ``Faults received count/sec`` =
    { category = "MSDTC Bridge 4.0.0.0"; counter = "Faults received count/sec"; instance = NotApplicable }
  /// Faults sent count/sec: The number of Fault messages that the WS-AT service has sent per second.
  let ``Faults sent count/sec`` =
    { category = "MSDTC Bridge 4.0.0.0"; counter = "Faults sent count/sec"; instance = NotApplicable }
  /// Average participant prepare response time: Average time in milliseconds for the WS-AT service to receive a Prepare message response from a participant.
  let ``Average participant prepare response time`` =
    { category = "MSDTC Bridge 4.0.0.0"; counter = "Average participant prepare response time"; instance = NotApplicable }
  /// Average participant prepare response time Base: Base counter for the 'Average participant prepare response time' counter.
  let ``Average participant prepare response time Base`` =
    { category = "MSDTC Bridge 4.0.0.0"; counter = "Average participant prepare response time Base"; instance = NotApplicable }
  /// Average participant commit response time: Average time in milliseconds for the WS-AT service to receive a Commit message response from a participant.
  let ``Average participant commit response time`` =
    { category = "MSDTC Bridge 4.0.0.0"; counter = "Average participant commit response time"; instance = NotApplicable }
  /// Average participant commit response time Base: Base counter for the 'Average participant commit response time' counter.
  let ``Average participant commit response time Base`` =
    { category = "MSDTC Bridge 4.0.0.0"; counter = "Average participant commit response time Base"; instance = NotApplicable }

  let allCounters =
    [ ``Message send failures/sec``
      ``Prepare retry count/sec``
      ``Commit retry count/sec``
      ``Prepared retry count/sec``
      ``Replay retry count/sec``
      ``Faults received count/sec``
      ``Faults sent count/sec``
      ``Average participant prepare response time``
      ``Average participant prepare response time Base``
      ``Average participant commit response time``
      ``Average participant commit response time Base``
    ]

/// MSRS 2011 Web Service: MSRS 2011 Web Service
///
/// This performance counter does not have instance based counters
module ``MSRS 2011 Web Service`` =

  [<Literal>]
  let Category = "MSRS 2011 Web Service"

  let PCC = getPCC Category
  /// Report Requests: 
  let ``Report Requests`` instance =
    { category = "MSRS 2011 Web Service"; counter = "Report Requests"; instance = instance }
  /// Total Reports Executed: 
  let ``Total Reports Executed`` instance =
    { category = "MSRS 2011 Web Service"; counter = "Total Reports Executed"; instance = instance }
  /// Reports Executed/Sec: 
  let ``Reports Executed/Sec`` instance =
    { category = "MSRS 2011 Web Service"; counter = "Reports Executed/Sec"; instance = instance }
  /// Total Processing Failures: 
  let ``Total Processing Failures`` instance =
    { category = "MSRS 2011 Web Service"; counter = "Total Processing Failures"; instance = instance }
  /// Total Rejected Threads: 
  let ``Total Rejected Threads`` instance =
    { category = "MSRS 2011 Web Service"; counter = "Total Rejected Threads"; instance = instance }
  /// Active Sessions: 
  let ``Active Sessions`` instance =
    { category = "MSRS 2011 Web Service"; counter = "Active Sessions"; instance = instance }
  /// First Session Requests/Sec: 
  let ``First Session Requests/Sec`` instance =
    { category = "MSRS 2011 Web Service"; counter = "First Session Requests/Sec"; instance = instance }
  /// Next Session Requests/Sec: 
  let ``Next Session Requests/Sec`` instance =
    { category = "MSRS 2011 Web Service"; counter = "Next Session Requests/Sec"; instance = instance }
  /// Total Cache Hits: 
  let ``Total Cache Hits`` instance =
    { category = "MSRS 2011 Web Service"; counter = "Total Cache Hits"; instance = instance }
  /// Cache Hits/Sec: 
  let ``Cache Hits/Sec`` instance =
    { category = "MSRS 2011 Web Service"; counter = "Cache Hits/Sec"; instance = instance }
  /// Total Cache Misses: 
  let ``Total Cache Misses`` instance =
    { category = "MSRS 2011 Web Service"; counter = "Total Cache Misses"; instance = instance }
  /// Cache Misses/Sec: 
  let ``Cache Misses/Sec`` instance =
    { category = "MSRS 2011 Web Service"; counter = "Cache Misses/Sec"; instance = instance }
  /// Total Requests: 
  let ``Total Requests`` instance =
    { category = "MSRS 2011 Web Service"; counter = "Total Requests"; instance = instance }
  /// Requests/Sec: 
  let ``Requests/Sec`` instance =
    { category = "MSRS 2011 Web Service"; counter = "Requests/Sec"; instance = instance }
  /// Total Memory Cache Hits: 
  let ``Total Memory Cache Hits`` instance =
    { category = "MSRS 2011 Web Service"; counter = "Total Memory Cache Hits"; instance = instance }
  /// Memory Cache Hits/Sec: 
  let ``Memory Cache Hits/Sec`` instance =
    { category = "MSRS 2011 Web Service"; counter = "Memory Cache Hits/Sec"; instance = instance }
  /// Total Memory Cache Misses: 
  let ``Total Memory Cache Misses`` instance =
    { category = "MSRS 2011 Web Service"; counter = "Total Memory Cache Misses"; instance = instance }
  /// Memory Cache Miss/Sec: 
  let ``Memory Cache Miss/Sec`` instance =
    { category = "MSRS 2011 Web Service"; counter = "Memory Cache Miss/Sec"; instance = instance }
  /// Total Cache Hits (Semantic Models): 
  let ``Total Cache Hits (Semantic Models)`` instance =
    { category = "MSRS 2011 Web Service"; counter = "Total Cache Hits (Semantic Models)"; instance = instance }
  /// Cache Hits/Sec (Semantic Models): 
  let ``Cache Hits/Sec (Semantic Models)`` instance =
    { category = "MSRS 2011 Web Service"; counter = "Cache Hits/Sec (Semantic Models)"; instance = instance }
  /// Total Cache Misses (Semantic Models): 
  let ``Total Cache Misses (Semantic Models)`` instance =
    { category = "MSRS 2011 Web Service"; counter = "Total Cache Misses (Semantic Models)"; instance = instance }
  /// Cache Misses/Sec (Semantic Models): 
  let ``Cache Misses/Sec (Semantic Models)`` instance =
    { category = "MSRS 2011 Web Service"; counter = "Cache Misses/Sec (Semantic Models)"; instance = instance }

  let allCounters =
    [ ``Report Requests``
      ``Total Reports Executed``
      ``Reports Executed/Sec``
      ``Total Processing Failures``
      ``Total Rejected Threads``
      ``Active Sessions``
      ``First Session Requests/Sec``
      ``Next Session Requests/Sec``
      ``Total Cache Hits``
      ``Cache Hits/Sec``
      ``Total Cache Misses``
      ``Cache Misses/Sec``
      ``Total Requests``
      ``Requests/Sec``
      ``Total Memory Cache Hits``
      ``Memory Cache Hits/Sec``
      ``Total Memory Cache Misses``
      ``Memory Cache Miss/Sec``
      ``Total Cache Hits (Semantic Models)``
      ``Cache Hits/Sec (Semantic Models)``
      ``Total Cache Misses (Semantic Models)``
      ``Cache Misses/Sec (Semantic Models)``
    ]

/// MSRS 2011 Windows Service: MSRS 2011 Windows Service
///
/// This performance counter does not have non-instance based counters
module ``MSRS 2011 Windows Service`` =

  [<Literal>]
  let Category = "MSRS 2011 Windows Service"

  let PCC = getPCC Category
  /// Report Requests: Number of active report requests.
  let ``Report Requests`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Report Requests"; instance = instance }
  /// Total Reports Executed: Total number of reports executed.
  let ``Total Reports Executed`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Total Reports Executed"; instance = instance }
  /// Reports Executed/Sec: Number of reports executed per second.
  let ``Reports Executed/Sec`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Reports Executed/Sec"; instance = instance }
  /// Total Processing Failures: Total number of processing failures.
  let ``Total Processing Failures`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Total Processing Failures"; instance = instance }
  /// Total Rejected Threads: Total number of rejected threads as a result of thread pressure.
  let ``Total Rejected Threads`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Total Rejected Threads"; instance = instance }
  /// Active Sessions: Number of active sessions.
  let ``Active Sessions`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Active Sessions"; instance = instance }
  /// First Session Requests/Sec: Number of new user sessions that are started per second.
  let ``First Session Requests/Sec`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "First Session Requests/Sec"; instance = instance }
  /// Next Session Requests/Sec: Number of requests per second for reports that are open in an existing session.
  let ``Next Session Requests/Sec`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Next Session Requests/Sec"; instance = instance }
  /// Total Cache Hits: Total number of report server cache hits.
  let ``Total Cache Hits`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Total Cache Hits"; instance = instance }
  /// Cache Hits/Sec: Number of report server cache hits per second.
  let ``Cache Hits/Sec`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Cache Hits/Sec"; instance = instance }
  /// Total Cache Misses: Total number of cache misses.
  let ``Total Cache Misses`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Total Cache Misses"; instance = instance }
  /// Cache Misses/Sec: Number of times per second that reports cannot be retrieved from cache.
  let ``Cache Misses/Sec`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Cache Misses/Sec"; instance = instance }
  /// Total Requests: Total number of requests being processed.
  let ``Total Requests`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Total Requests"; instance = instance }
  /// Requests/Sec: Number of requests per second.
  let ``Requests/Sec`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Requests/Sec"; instance = instance }
  /// Total Memory Cache Hits: Total number of cache hits made in the in memory cache.
  let ``Total Memory Cache Hits`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Total Memory Cache Hits"; instance = instance }
  /// Memory Cache Hits/Sec: Number of times per second that reports can be retrieved from the in memory cache.
  let ``Memory Cache Hits/Sec`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Memory Cache Hits/Sec"; instance = instance }
  /// Total Memory Cache Misses: Total number of cache misses made in the in memory cache.
  let ``Total Memory Cache Misses`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Total Memory Cache Misses"; instance = instance }
  /// Memory Cache Miss/Sec: Number of times per second that reports cannot be retrieved from the in memory cache.
  let ``Memory Cache Miss/Sec`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Memory Cache Miss/Sec"; instance = instance }
  /// Total Cache Hits (Semantic Models): Total number of cache hits made in the model cache.
  let ``Total Cache Hits (Semantic Models)`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Total Cache Hits (Semantic Models)"; instance = instance }
  /// Cache Hits/Sec (Semantic Models): Number of times per second that models can be retrieved from the cache.
  let ``Cache Hits/Sec (Semantic Models)`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Cache Hits/Sec (Semantic Models)"; instance = instance }
  /// Total Cache Misses (Semantic Models): Total number of cache misses made in the model cache.
  let ``Total Cache Misses (Semantic Models)`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Total Cache Misses (Semantic Models)"; instance = instance }
  /// Cache Misses/Sec (Semantic Models): Number of times per second that models cannot be retrieved from the cache.
  let ``Cache Misses/Sec (Semantic Models)`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Cache Misses/Sec (Semantic Models)"; instance = instance }
  /// Total App Domain Recycles: Total number of application domain recycles.
  let ``Total App Domain Recycles`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Total App Domain Recycles"; instance = instance }
  /// Total Deliveries: Total number of deliveries.
  let ``Total Deliveries`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Total Deliveries"; instance = instance }
  /// Delivers/Sec: Number of delivers deliveries per second.
  let ``Delivers/Sec`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Delivers/Sec"; instance = instance }
  /// Total Events: Total number of events.
  let ``Total Events`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Total Events"; instance = instance }
  /// Events/Sec: Number of events per second.
  let ``Events/Sec`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Events/Sec"; instance = instance }
  /// Total Snapshot Updates: Total number of report execution snapshot updates.
  let ``Total Snapshot Updates`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Total Snapshot Updates"; instance = instance }
  /// Snapshot Updates/Sec: Number of snapshot updates per second.
  let ``Snapshot Updates/Sec`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Snapshot Updates/Sec"; instance = instance }
  /// Total Cache Flushes: Total number of report execution server cache updates.
  let ``Total Cache Flushes`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Total Cache Flushes"; instance = instance }
  /// Cache Flushes/Sec: Number of cache flushes per second.
  let ``Cache Flushes/Sec`` instance =
    { category = "MSRS 2011 Windows Service"; counter = "Cache Flushes/Sec"; instance = instance }

  let allCounters =
    [ ``Report Requests``
      ``Total Reports Executed``
      ``Reports Executed/Sec``
      ``Total Processing Failures``
      ``Total Rejected Threads``
      ``Active Sessions``
      ``First Session Requests/Sec``
      ``Next Session Requests/Sec``
      ``Total Cache Hits``
      ``Cache Hits/Sec``
      ``Total Cache Misses``
      ``Cache Misses/Sec``
      ``Total Requests``
      ``Requests/Sec``
      ``Total Memory Cache Hits``
      ``Memory Cache Hits/Sec``
      ``Total Memory Cache Misses``
      ``Memory Cache Miss/Sec``
      ``Total Cache Hits (Semantic Models)``
      ``Cache Hits/Sec (Semantic Models)``
      ``Total Cache Misses (Semantic Models)``
      ``Cache Misses/Sec (Semantic Models)``
      ``Total App Domain Recycles``
      ``Total Deliveries``
      ``Delivers/Sec``
      ``Total Events``
      ``Events/Sec``
      ``Total Snapshot Updates``
      ``Snapshot Updates/Sec``
      ``Total Cache Flushes``
      ``Cache Flushes/Sec``
    ]

/// Memory: The Memory performance object  consists of counters that describe the behavior of physical and virtual memory on the computer.  Physical memory is the amount of random access memory on the computer.  Virtual memory consists of the space in physical memory and on disk.  Many of the memory counters monitor paging, which is the movement of pages of code and data between disk and physical memory.  Excessive paging, a symptom of a memory shortage, can cause delays which interfere with all system processes.
///
/// This performance counter does not have instance based counters
module ``Memory`` =

  [<Literal>]
  let Category = "Memory"

  let PCC = getPCC Category
  /// Page Faults/sec: Page Faults/sec is the average number of pages faulted per second. It is measured in number of pages faulted per second because only one page is faulted in each fault operation, hence this is also equal to the number of page fault operations. This counter includes both hard faults (those that require disk access) and soft faults (where the faulted page is found elsewhere in physical memory.) Most processors can handle large numbers of soft faults without significant consequence. However, hard faults, which require disk access, can cause significant delays.
  let ``Page Faults/sec`` =
    { category = "Memory"; counter = "Page Faults/sec"; instance = NotApplicable }
  /// Available Bytes: Available Bytes is the amount of physical memory, in bytes, immediately available for allocation to a process or for system use. It is equal to the sum of memory assigned to the standby (cached), free and zero page lists.
  let ``Available Bytes`` =
    { category = "Memory"; counter = "Available Bytes"; instance = NotApplicable }
  /// Committed Bytes: Committed Bytes is the amount of committed virtual memory, in bytes. Committed memory is the physical memory which has space reserved on the disk paging file(s). There can be one or more paging files on each physical drive. This counter displays the last observed value only; it is not an average.
  let ``Committed Bytes`` =
    { category = "Memory"; counter = "Committed Bytes"; instance = NotApplicable }
  /// Commit Limit: Commit Limit is the amount of virtual memory that can be committed without having to extend the paging file(s).  It is measured in bytes. Committed memory is the physical memory which has space reserved on the disk paging files. There can be one paging file on each logical drive). If the paging file(s) are be expanded, this limit increases accordingly.  This counter displays the last observed value only; it is not an average.
  let ``Commit Limit`` =
    { category = "Memory"; counter = "Commit Limit"; instance = NotApplicable }
  /// Write Copies/sec: Write Copies/sec is the rate at which page faults are caused by attempts to write that have been satisfied by coping of the page from elsewhere in physical memory. This is an economical way of sharing data since pages are only copied when they are written to; otherwise, the page is shared. This counter shows the number of copies, without regard for the number of pages copied in each operation.
  let ``Write Copies/sec`` =
    { category = "Memory"; counter = "Write Copies/sec"; instance = NotApplicable }
  /// Transition Faults/sec: Transition Faults/sec is the rate at which page faults are resolved by recovering pages that were being used by another process sharing the page, or were on the modified page list or the standby list, or were being written to disk at the time of the page fault. The pages were recovered without additional disk activity. Transition faults are counted in numbers of faults; because only one page is faulted in each operation, it is also equal to the number of pages faulted.
  let ``Transition Faults/sec`` =
    { category = "Memory"; counter = "Transition Faults/sec"; instance = NotApplicable }
  /// Cache Faults/sec: Cache Faults/sec is the rate at which faults occur when a page sought in the file system cache is not found and must be retrieved from elsewhere in memory (a soft fault) or from disk (a hard fault). The file system cache is an area of physical memory that stores recently used pages of data for applications. Cache activity is a reliable indicator of most application I/O operations. This counter shows the number of faults, without regard for the number of pages faulted in each operation.
  let ``Cache Faults/sec`` =
    { category = "Memory"; counter = "Cache Faults/sec"; instance = NotApplicable }
  /// Demand Zero Faults/sec: Demand Zero Faults/sec is the rate at which a zeroed page is required to satisfy the fault.  Zeroed pages, pages emptied of previously stored data and filled with zeros, are a security feature of Windows that prevent processes from seeing data stored by earlier processes that used the memory space. Windows maintains a list of zeroed pages to accelerate this process. This counter shows the number of faults, without regard to the number of pages retrieved to satisfy the fault. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Demand Zero Faults/sec`` =
    { category = "Memory"; counter = "Demand Zero Faults/sec"; instance = NotApplicable }
  /// Pages/sec: Pages/sec is the rate at which pages are read from or written to disk to resolve hard page faults. This counter is a primary indicator of the kinds of faults that cause system-wide delays.  It is the sum of Memory\\Pages Input/sec and Memory\\Pages Output/sec.  It is counted in numbers of pages, so it can be compared to other counts of pages, such as Memory\\Page Faults/sec, without conversion. It includes pages retrieved to satisfy faults in the file system cache (usually requested by applications) non-cached mapped memory files.
  let ``Pages/sec`` =
    { category = "Memory"; counter = "Pages/sec"; instance = NotApplicable }
  /// Pages Input/sec: Pages Input/sec is the rate at which pages are read from disk to resolve hard page faults. Hard page faults occur when a process refers to a page in virtual memory that is not in its working set or elsewhere in physical memory, and must be retrieved from disk. When a page is faulted, the system tries to read multiple contiguous pages into memory to maximize the benefit of the read operation. Compare the value of Memory\\Pages Input/sec to the value of  Memory\\Page Reads/sec to determine the average number of pages read into memory during each read operation.
  let ``Pages Input/sec`` =
    { category = "Memory"; counter = "Pages Input/sec"; instance = NotApplicable }
  /// Page Reads/sec: Page Reads/sec is the rate at which the disk was read to resolve hard page faults. It shows the number of reads operations, without regard to the number of pages retrieved in each operation. Hard page faults occur when a process references a page in virtual memory that is not in working set or elsewhere in physical memory, and must be retrieved from disk. This counter is a primary indicator of the kinds of faults that cause system-wide delays. It includes read operations to satisfy faults in the file system cache (usually requested by applications) and in non-cached mapped memory files. Compare the value of Memory\\Pages Reads/sec to the value of Memory\\Pages Input/sec to determine the average number of pages read during each operation.
  let ``Page Reads/sec`` =
    { category = "Memory"; counter = "Page Reads/sec"; instance = NotApplicable }
  /// Pages Output/sec: Pages Output/sec is the rate at which pages are written to disk to free up space in physical memory. Pages are written back to disk only if they are changed in physical memory, so they are likely to hold data, not code. A high rate of pages output might indicate a memory shortage. Windows writes more pages back to disk to free up space when physical memory is in short supply.  This counter shows the number of pages, and can be compared to other counts of pages, without conversion.
  let ``Pages Output/sec`` =
    { category = "Memory"; counter = "Pages Output/sec"; instance = NotApplicable }
  /// Pool Paged Bytes: Pool Paged Bytes is the size, in bytes, of the paged pool, an area of the system virtual memory that is used for objects that can be written to disk when they are not being used.  Memory\\Pool Paged Bytes is calculated differently than Process\\Pool Paged Bytes, so it might not equal Process(_Total)\\Pool Paged Bytes. This counter displays the last observed value only; it is not an average.
  let ``Pool Paged Bytes`` =
    { category = "Memory"; counter = "Pool Paged Bytes"; instance = NotApplicable }
  /// Pool Nonpaged Bytes: Pool Nonpaged Bytes is the size, in bytes, of the nonpaged pool, an area of the system virtual memory that is used for objects that cannot be written to disk, but must remain in physical memory as long as they are allocated.  Memory\\Pool Nonpaged Bytes is calculated differently than Process\\Pool Nonpaged Bytes, so it might not equal Process(_Total)\\Pool Nonpaged Bytes.  This counter displays the last observed value only; it is not an average.
  let ``Pool Nonpaged Bytes`` =
    { category = "Memory"; counter = "Pool Nonpaged Bytes"; instance = NotApplicable }
  /// Page Writes/sec: Page Writes/sec is the rate at which pages are written to disk to free up space in physical memory. Pages are written to disk only if they are changed while in physical memory, so they are likely to hold data, not code.  This counter shows write operations, without regard to the number of pages written in each operation.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Page Writes/sec`` =
    { category = "Memory"; counter = "Page Writes/sec"; instance = NotApplicable }
  /// Pool Paged Allocs: Pool Paged Allocs is the number of calls to allocate space in the paged pool. The paged pool is an area of the system virtual memory that is used for objects that can be written to disk when they are not being used. It is measured in numbers of calls to allocate space, regardless of the amount of space allocated in each call.  This counter displays the last observed value only; it is not an average.
  let ``Pool Paged Allocs`` =
    { category = "Memory"; counter = "Pool Paged Allocs"; instance = NotApplicable }
  /// Pool Nonpaged Allocs: Pool Nonpaged Allocs is the number of calls to allocate space in the nonpaged pool. The nonpaged pool is an area of system memory area for objects that cannot be written to disk, and must remain in physical memory as long as they are allocated.  It is measured in numbers of calls to allocate space, regardless of the amount of space allocated in each call.  This counter displays the last observed value only; it is not an average.
  let ``Pool Nonpaged Allocs`` =
    { category = "Memory"; counter = "Pool Nonpaged Allocs"; instance = NotApplicable }
  /// Free System Page Table Entries: Free System Page Table Entries is the number of page table entries not currently in used by the system.  This counter displays the last observed value only; it is not an average.
  let ``Free System Page Table Entries`` =
    { category = "Memory"; counter = "Free System Page Table Entries"; instance = NotApplicable }
  /// Cache Bytes: Cache Bytes the size, in bytes, of the portion of the system file cache which is currently resident and active in physical memory. The Cache Bytes and Memory\\System Cache Resident Bytes counters are equivalent.  This counter displays the last observed value only; it is not an average.
  let ``Cache Bytes`` =
    { category = "Memory"; counter = "Cache Bytes"; instance = NotApplicable }
  /// Cache Bytes Peak: Cache Bytes Peak is the maximum number of bytes used by the system file cache since the system was last restarted. This might be larger than the current size of the cache. This counter displays the last observed value only; it is not an average.
  let ``Cache Bytes Peak`` =
    { category = "Memory"; counter = "Cache Bytes Peak"; instance = NotApplicable }
  /// Pool Paged Resident Bytes: Pool Paged Resident Bytes is the size, in bytes, of the portion of the paged pool that is currently resident and active in physical memory. The paged pool is an area of the system virtual memory that is used for objects that can be written to disk when they are not being used. This counter displays the last observed value only; it is not an average.
  let ``Pool Paged Resident Bytes`` =
    { category = "Memory"; counter = "Pool Paged Resident Bytes"; instance = NotApplicable }
  /// System Code Total Bytes: System Code Total Bytes is the size, in bytes, of the pageable operating system code currently mapped into the system virtual address space. This value is calculated by summing the bytes in Ntoskrnl.exe, Hal.dll, the boot drivers, and file systems loaded by Ntldr/osloader.  This counter does not include code that must remain in physical memory and cannot be written to disk. This counter displays the last observed value only; it is not an average.
  let ``System Code Total Bytes`` =
    { category = "Memory"; counter = "System Code Total Bytes"; instance = NotApplicable }
  /// System Code Resident Bytes: System Code Resident Bytes is the size, in bytes, of the pageable operating system code that is currently resident and active in physical memory. This value is a component of Memory\\System Code Total Bytes. Memory\\System Code Resident Bytes (and Memory\\System Code Total Bytes) does not include code that must remain in physical memory and cannot be written to disk. This counter displays the last observed value only; it is not an average.
  let ``System Code Resident Bytes`` =
    { category = "Memory"; counter = "System Code Resident Bytes"; instance = NotApplicable }
  /// System Driver Total Bytes: System Driver Total Bytes is the size, in bytes, of the pageable virtual memory currently being used by device drivers. Pageable memory can be written to disk when it is not being used. It includes both physical memory (Memory\\System Driver Resident Bytes) and code and data paged to disk. It is a component of Memory\\System Code Total Bytes. This counter displays the last observed value only; it is not an average.
  let ``System Driver Total Bytes`` =
    { category = "Memory"; counter = "System Driver Total Bytes"; instance = NotApplicable }
  /// System Driver Resident Bytes: System Driver Resident Bytes is the size, in bytes, of the pageable physical memory being used by device drivers. It is the working set (physical memory area) of the drivers. This value is a component of Memory\\System Driver Total Bytes, which also includes driver memory that has been written to disk. Neither Memory\\System Driver Resident Bytes nor Memory\\System Driver Total Bytes includes memory that cannot be written to disk.
  let ``System Driver Resident Bytes`` =
    { category = "Memory"; counter = "System Driver Resident Bytes"; instance = NotApplicable }
  /// System Cache Resident Bytes: System Cache Resident Bytes is the size, in bytes, of the portion of the system file cache which is currently resident and active in physical memory. The System Cache Resident Bytes and Memory\\Cache Bytes counters are equivalent.  This counter displays the last observed value only; it is not an average.
  let ``System Cache Resident Bytes`` =
    { category = "Memory"; counter = "System Cache Resident Bytes"; instance = NotApplicable }
  /// % Committed Bytes In Use: % Committed Bytes In Use is the ratio of Memory\\Committed Bytes to the Memory\\Commit Limit. Committed memory is the physical memory in use for which space has been reserved in the paging file should it need to be written to disk. The commit limit is determined by the size of the paging file.  If the paging file is enlarged, the commit limit increases, and the ratio is reduced). This counter displays the current percentage value only; it is not an average.
  let ``% Committed Bytes In Use`` =
    { category = "Memory"; counter = "% Committed Bytes In Use"; instance = NotApplicable }
  /// Available KBytes: Available KBytes is the amount of physical memory, in Kilobytes, immediately available for allocation to a process or for system use. It is equal to the sum of memory assigned to the standby (cached), free and zero page lists.
  let ``Available KBytes`` =
    { category = "Memory"; counter = "Available KBytes"; instance = NotApplicable }
  /// Available MBytes: Available MBytes is the amount of physical memory, in Megabytes, immediately available for allocation to a process or for system use. It is equal to the sum of memory assigned to the standby (cached), free and zero page lists.
  let ``Available MBytes`` =
    { category = "Memory"; counter = "Available MBytes"; instance = NotApplicable }
  /// Transition Pages RePurposed/sec: Transition Pages RePurposed is the rate at which the number of transition cache pages were reused for a different purpose.  These pages would have otherwise remained in the page cache to provide a (fast) soft fault (instead of retrieving it from backing store) in the event the page was accessed in the future.  Note these pages can contain private or sharable memory.
  let ``Transition Pages RePurposed/sec`` =
    { category = "Memory"; counter = "Transition Pages RePurposed/sec"; instance = NotApplicable }
  /// Free & Zero Page List Bytes: Free & Zero Page List Bytes is the amount of physical memory, in bytes, that is assigned to the free and zero page lists. This memory does not contain cached data. It is immediately available for allocation to a process or for system use.
  let ``Free & Zero Page List Bytes`` =
    { category = "Memory"; counter = "Free & Zero Page List Bytes"; instance = NotApplicable }
  /// Modified Page List Bytes: Modified Page List Bytes is the amount of physical memory, in bytes, that is assigned to the modified page list. This memory contains cached data and code that is not actively in use by processes, the system and the system cache. This memory needs to be written out before it will be available for allocation to a process or for system use.
  let ``Modified Page List Bytes`` =
    { category = "Memory"; counter = "Modified Page List Bytes"; instance = NotApplicable }
  /// Standby Cache Reserve Bytes: Standby Cache Reserve Bytes is the amount of physical memory, in bytes, that is assigned to the reserve standby cache page lists. This memory contains cached data and code that is not actively in use by processes, the system and the system cache. It is immediately available for allocation to a process or for system use. If the system runs out of available free and zero memory, memory on lower priority standby cache page lists will be repurposed before memory on higher priority standby cache page lists.
  let ``Standby Cache Reserve Bytes`` =
    { category = "Memory"; counter = "Standby Cache Reserve Bytes"; instance = NotApplicable }
  /// Standby Cache Normal Priority Bytes: Standby Cache Normal Priority Bytes is the amount of physical memory, in bytes, that is assigned to the normal priority standby cache page lists. This memory contains cached data and code that is not actively in use by processes, the system and the system cache. It is immediately available for allocation to a process or for system use. If the system runs out of available free and zero memory, memory on lower priority standby cache page lists will be repurposed before memory on higher priority standby cache page lists.
  let ``Standby Cache Normal Priority Bytes`` =
    { category = "Memory"; counter = "Standby Cache Normal Priority Bytes"; instance = NotApplicable }
  /// Standby Cache Core Bytes: Standby Cache Core Bytes is the amount of physical memory, in bytes, that is assigned to the core standby cache page lists. This memory contains cached data and code that is not actively in use by processes, the system and the system cache. It is immediately available for allocation to a process or for system use. If the system runs out of available free and zero memory, memory on lower priority standby cache page lists will be repurposed before memory on higher priority standby cache page lists.
  let ``Standby Cache Core Bytes`` =
    { category = "Memory"; counter = "Standby Cache Core Bytes"; instance = NotApplicable }
  /// Long-Term Average Standby Cache Lifetime (s): Long-Term Average Standby Cache Lifetime, in seconds. The average lifetime of data in the standby cache over a long interval is measured.
  let ``Long-Term Average Standby Cache Lifetime (s)`` =
    { category = "Memory"; counter = "Long-Term Average Standby Cache Lifetime (s)"; instance = NotApplicable }

  let allCounters =
    [ ``Page Faults/sec``
      ``Available Bytes``
      ``Committed Bytes``
      ``Commit Limit``
      ``Write Copies/sec``
      ``Transition Faults/sec``
      ``Cache Faults/sec``
      ``Demand Zero Faults/sec``
      ``Pages/sec``
      ``Pages Input/sec``
      ``Page Reads/sec``
      ``Pages Output/sec``
      ``Pool Paged Bytes``
      ``Pool Nonpaged Bytes``
      ``Page Writes/sec``
      ``Pool Paged Allocs``
      ``Pool Nonpaged Allocs``
      ``Free System Page Table Entries``
      ``Cache Bytes``
      ``Cache Bytes Peak``
      ``Pool Paged Resident Bytes``
      ``System Code Total Bytes``
      ``System Code Resident Bytes``
      ``System Driver Total Bytes``
      ``System Driver Resident Bytes``
      ``System Cache Resident Bytes``
      ``% Committed Bytes In Use``
      ``Available KBytes``
      ``Available MBytes``
      ``Transition Pages RePurposed/sec``
      ``Free & Zero Page List Bytes``
      ``Modified Page List Bytes``
      ``Standby Cache Reserve Bytes``
      ``Standby Cache Normal Priority Bytes``
      ``Standby Cache Core Bytes``
      ``Long-Term Average Standby Cache Lifetime (s)``
    ]

/// Microsoft Winsock BSP: Global performance counters for Microsoft Winsock Base Service Provider
///
/// This performance counter does not have instance based counters
module ``Microsoft Winsock BSP`` =

  [<Literal>]
  let Category = "Microsoft Winsock BSP"

  let PCC = getPCC Category
  /// Dropped Datagrams/sec: Dropped Datagrams/sec due to receive buffer limit on any datagram socket
  let ``Dropped Datagrams/sec`` =
    { category = "Microsoft Winsock BSP"; counter = "Dropped Datagrams/sec"; instance = NotApplicable }
  /// Dropped Datagrams: Dropped Datagrams due to receive buffer limit on any datagram socket
  let ``Dropped Datagrams`` =
    { category = "Microsoft Winsock BSP"; counter = "Dropped Datagrams"; instance = NotApplicable }
  /// Rejected Connections/sec: Rejected Connections/sec due to backlog limit on any TCP listening socket
  let ``Rejected Connections/sec`` =
    { category = "Microsoft Winsock BSP"; counter = "Rejected Connections/sec"; instance = NotApplicable }
  /// Rejected Connections: Rejected Connections due to backlog limit on any TCP listening socket
  let ``Rejected Connections`` =
    { category = "Microsoft Winsock BSP"; counter = "Rejected Connections"; instance = NotApplicable }

  let allCounters =
    [ ``Dropped Datagrams/sec``
      ``Dropped Datagrams``
      ``Rejected Connections/sec``
      ``Rejected Connections``
    ]

/// NBT Connection: The NBT Connection performance object consists of counters that measure the rates at which bytes are sent and received over the NBT connection between the local computer and a remote computer.  The connection is identified by the name of the remote computer.
///
/// This performance counter does not have non-instance based counters
module ``NBT Connection`` =

  [<Literal>]
  let Category = "NBT Connection"

  let PCC = getPCC Category
  /// Bytes Received/sec: Bytes Received/sec is the rate at which bytes are received by the local computer over an NBT connection to some remote computer.  All the bytes received by the local computer over the particular NBT connection are counted.
  let ``Bytes Received/sec`` instance =
    { category = "NBT Connection"; counter = "Bytes Received/sec"; instance = instance }
  /// Bytes Sent/sec: Bytes Sent/sec is the rate at which bytes are sent by the local computer over an NBT connection to some remote computer.  All the bytes sent by the local computer over the particular NBT connection are counted.
  let ``Bytes Sent/sec`` instance =
    { category = "NBT Connection"; counter = "Bytes Sent/sec"; instance = instance }
  /// Bytes Total/sec: Bytes Total/sec is the rate at which bytes are sent or received by the local computer over an NBT connection to some remote computer.  All the bytes sent or received by the local computer over the particular NBT connection are counted.
  let ``Bytes Total/sec`` instance =
    { category = "NBT Connection"; counter = "Bytes Total/sec"; instance = instance }

  let allCounters =
    [ ``Bytes Received/sec``
      ``Bytes Sent/sec``
      ``Bytes Total/sec``
    ]

/// NUMA Node Memory: Counters that report approximate memory utilization statistics per node on NUMA systems.
///
/// This performance counter does not have non-instance based counters
module ``NUMA Node Memory`` =

  [<Literal>]
  let Category = "NUMA Node Memory"

  let PCC = getPCC Category
  /// Total MBytes: Total amount of physical memory associated with a NUMA node in megabytes.
  let ``Total MBytes`` instance =
    { category = "NUMA Node Memory"; counter = "Total MBytes"; instance = instance }
  /// Free & Zero Page List MBytes: Approximate amount of physical memory on the free and zero page lists for a NUMA node, in megabytes.
  let ``Free & Zero Page List MBytes`` instance =
    { category = "NUMA Node Memory"; counter = "Free & Zero Page List MBytes"; instance = instance }

  let allCounters =
    [ ``Total MBytes``
      ``Free & Zero Page List MBytes``
    ]

/// Netlogon: Counters for measuring the performance of Netlogon.
///
/// This performance counter does not have non-instance based counters
module ``Netlogon`` =

  [<Literal>]
  let Category = "Netlogon"

  let PCC = getPCC Category
  /// Semaphore Waiters: Number of thread currently waiting to acquire the semaphore.
  let ``Semaphore Waiters`` instance =
    { category = "Netlogon"; counter = "Semaphore Waiters"; instance = instance }
  /// Semaphore Holders: Number of thread currently holding the semaphore.
  let ``Semaphore Holders`` instance =
    { category = "Netlogon"; counter = "Semaphore Holders"; instance = instance }
  /// Semaphore Acquires: The total number of times the semaphore has been acquired over the lifetime of the Secure Channel connection (or since system boot for _Total).
  let ``Semaphore Acquires`` instance =
    { category = "Netlogon"; counter = "Semaphore Acquires"; instance = instance }
  /// Semaphore Timeouts: The total number of times a thread has timed out waiting for the semaphore over the lifetime of the Secure Channel connection (or since system boot for _Total).
  let ``Semaphore Timeouts`` instance =
    { category = "Netlogon"; counter = "Semaphore Timeouts"; instance = instance }
  /// Average Semaphore Hold Time: The average amount of time the semaphore is held over the last sample.
  let ``Average Semaphore Hold Time`` instance =
    { category = "Netlogon"; counter = "Average Semaphore Hold Time"; instance = instance }

  let allCounters =
    [ ``Semaphore Waiters``
      ``Semaphore Holders``
      ``Semaphore Acquires``
      ``Semaphore Timeouts``
      ``Average Semaphore Hold Time``
    ]

/// Network Adapter: The Network Adapter performance object consists of counters that measure the rates at which bytes and packets are sent and received over a physical or virtual network connection.  It includes counters that monitor connection errors.
///
/// This performance counter does not have non-instance based counters
module ``Network Adapter`` =

  [<Literal>]
  let Category = "Network Adapter"

  let PCC = getPCC Category
  /// Bytes Total/sec: Bytes Total/sec is the rate at which bytes are sent and received over each network adapter, including framing characters. Network Interface\Bytes Total/sec is a sum of Network Interface\Bytes Received/sec and Network Interface\Bytes Sent/sec.
  let ``Bytes Total/sec`` instance =
    { category = "Network Adapter"; counter = "Bytes Total/sec"; instance = instance }
  /// Packets/sec: Packets/sec is the rate at which packets are sent and received on the network interface.
  let ``Packets/sec`` instance =
    { category = "Network Adapter"; counter = "Packets/sec"; instance = instance }
  /// Packets Received/sec: Packets Received/sec is the rate at which packets are received on the network interface.
  let ``Packets Received/sec`` instance =
    { category = "Network Adapter"; counter = "Packets Received/sec"; instance = instance }
  /// Packets Sent/sec: Packets Sent/sec is the rate at which packets are sent on the network interface.
  let ``Packets Sent/sec`` instance =
    { category = "Network Adapter"; counter = "Packets Sent/sec"; instance = instance }
  /// Current Bandwidth: Current Bandwidth is an estimate of the current bandwidth of the network interface in bits per second (BPS).  For interfaces that do not vary in bandwidth or for those where no accurate estimation can be made, this value is the nominal bandwidth.
  let ``Current Bandwidth`` instance =
    { category = "Network Adapter"; counter = "Current Bandwidth"; instance = instance }
  /// Bytes Received/sec: Bytes Received/sec is the rate at which bytes are received over each network adapter, including framing characters. Network Interface\Bytes Received/sec is a subset of Network Interface\Bytes Total/sec.
  let ``Bytes Received/sec`` instance =
    { category = "Network Adapter"; counter = "Bytes Received/sec"; instance = instance }
  /// Packets Received Unicast/sec: Packets Received Unicast/sec is the rate at which (subnet) unicast packets are delivered to a higher-layer protocol.
  let ``Packets Received Unicast/sec`` instance =
    { category = "Network Adapter"; counter = "Packets Received Unicast/sec"; instance = instance }
  /// Packets Received Non-Unicast/sec: Packets Received Non-Unicast/sec is the rate at which non-unicast (subnet broadcast or subnet multicast) packets are delivered to a higher-layer protocol.
  let ``Packets Received Non-Unicast/sec`` instance =
    { category = "Network Adapter"; counter = "Packets Received Non-Unicast/sec"; instance = instance }
  /// Packets Received Discarded: Packets Received Discarded is the number of inbound packets that were chosen to be discarded even though no errors had been detected to prevent their delivery to a higher-layer protocol.  One possible reason for discarding packets could be to free up buffer space.
  let ``Packets Received Discarded`` instance =
    { category = "Network Adapter"; counter = "Packets Received Discarded"; instance = instance }
  /// Packets Received Errors: Packets Received Errors is the number of inbound packets that contained errors preventing them from being deliverable to a higher-layer protocol.
  let ``Packets Received Errors`` instance =
    { category = "Network Adapter"; counter = "Packets Received Errors"; instance = instance }
  /// Packets Received Unknown: Packets Received Unknown is the number of packets received through the interface that were discarded because of an unknown or unsupported protocol.
  let ``Packets Received Unknown`` instance =
    { category = "Network Adapter"; counter = "Packets Received Unknown"; instance = instance }
  /// Bytes Sent/sec: Bytes Sent/sec is the rate at which bytes are sent over each network adapter, including framing characters. Network Interface\Bytes Sent/sec is a subset of Network Interface\Bytes Total/sec.
  let ``Bytes Sent/sec`` instance =
    { category = "Network Adapter"; counter = "Bytes Sent/sec"; instance = instance }
  /// Packets Sent Unicast/sec: Packets Sent Unicast/sec is the rate at which packets are requested to be transmitted to subnet-unicast addresses by higher-level protocols.  The rate includes the packets that were discarded or not sent.
  let ``Packets Sent Unicast/sec`` instance =
    { category = "Network Adapter"; counter = "Packets Sent Unicast/sec"; instance = instance }
  /// Packets Sent Non-Unicast/sec: Packets Sent Non-Unicast/sec is the rate at which packets are requested to be transmitted to non-unicast (subnet broadcast or subnet multicast) addresses by higher-level protocols.  The rate includes the packets that were discarded or not sent.
  let ``Packets Sent Non-Unicast/sec`` instance =
    { category = "Network Adapter"; counter = "Packets Sent Non-Unicast/sec"; instance = instance }
  /// Packets Outbound Discarded: Packets Outbound Discarded is the number of outbound packets that were chosen to be discarded even though no errors had been detected to prevent transmission. One possible reason for discarding packets could be to free up buffer space.
  let ``Packets Outbound Discarded`` instance =
    { category = "Network Adapter"; counter = "Packets Outbound Discarded"; instance = instance }
  /// Packets Outbound Errors: Packets Outbound Errors is the number of outbound packets that could not be transmitted because of errors.
  let ``Packets Outbound Errors`` instance =
    { category = "Network Adapter"; counter = "Packets Outbound Errors"; instance = instance }
  /// Output Queue Length: Output Queue Length is the length of the output packet queue (in packets). If this is longer than two, there are delays and the bottleneck should be found and eliminated, if possible. Since the requests are queued by the Network Driver Interface Specification (NDIS) in this implementation, this will always be 0.
  let ``Output Queue Length`` instance =
    { category = "Network Adapter"; counter = "Output Queue Length"; instance = instance }
  /// Offloaded Connections: Offloaded Connections is the number of TCP connections (over both IPv4 and IPv6) that are currently handled by the TCP chimney offload capable network adapter.
  let ``Offloaded Connections`` instance =
    { category = "Network Adapter"; counter = "Offloaded Connections"; instance = instance }
  /// TCP Active RSC Connections: TCP Active RSC Connections is the number of TCP connections (over both IPv4 and IPv6) that are currently receiving large packets from the RSC capable network adapter on this network interface.
  let ``TCP Active RSC Connections`` instance =
    { category = "Network Adapter"; counter = "TCP Active RSC Connections"; instance = instance }
  /// TCP RSC Coalesced Packets/sec: TCP RSC Coalesced Packets/sec shows the large packet receive rate across all TCP connections on this network interface.
  let ``TCP RSC Coalesced Packets/sec`` instance =
    { category = "Network Adapter"; counter = "TCP RSC Coalesced Packets/sec"; instance = instance }
  /// TCP RSC Exceptions/sec: TCP RSC Exceptions/sec shows the RSC exception rate for receive packets across all TCP connections on this network interface.
  let ``TCP RSC Exceptions/sec`` instance =
    { category = "Network Adapter"; counter = "TCP RSC Exceptions/sec"; instance = instance }
  /// TCP RSC Average Packet Size: TCP RSC Average Packet Size is the average size in bytes of received packets across all TCP connections on this network interface.
  let ``TCP RSC Average Packet Size`` instance =
    { category = "Network Adapter"; counter = "TCP RSC Average Packet Size"; instance = instance }

  let allCounters =
    [ ``Bytes Total/sec``
      ``Packets/sec``
      ``Packets Received/sec``
      ``Packets Sent/sec``
      ``Current Bandwidth``
      ``Bytes Received/sec``
      ``Packets Received Unicast/sec``
      ``Packets Received Non-Unicast/sec``
      ``Packets Received Discarded``
      ``Packets Received Errors``
      ``Packets Received Unknown``
      ``Bytes Sent/sec``
      ``Packets Sent Unicast/sec``
      ``Packets Sent Non-Unicast/sec``
      ``Packets Outbound Discarded``
      ``Packets Outbound Errors``
      ``Output Queue Length``
      ``Offloaded Connections``
      ``TCP Active RSC Connections``
      ``TCP RSC Coalesced Packets/sec``
      ``TCP RSC Exceptions/sec``
      ``TCP RSC Average Packet Size``
    ]

/// Network Interface: The Network Interface performance object consists of counters that measure the rates at which bytes and packets are sent and received over a network connection.  It includes counters that monitor connection errors.
///
/// This performance counter does not have non-instance based counters
module ``Network Interface`` =

  [<Literal>]
  let Category = "Network Interface"

  let PCC = getPCC Category
  /// Bytes Total/sec: Bytes Total/sec is the rate at which bytes are sent and received over each network adapter, including framing characters. Network Interface\Bytes Total/sec is a sum of Network Interface\Bytes Received/sec and Network Interface\Bytes Sent/sec.
  let ``Bytes Total/sec`` instance =
    { category = "Network Interface"; counter = "Bytes Total/sec"; instance = instance }
  /// Packets/sec: Packets/sec is the rate at which packets are sent and received on the network interface.
  let ``Packets/sec`` instance =
    { category = "Network Interface"; counter = "Packets/sec"; instance = instance }
  /// Packets Received/sec: Packets Received/sec is the rate at which packets are received on the network interface.
  let ``Packets Received/sec`` instance =
    { category = "Network Interface"; counter = "Packets Received/sec"; instance = instance }
  /// Packets Sent/sec: Packets Sent/sec is the rate at which packets are sent on the network interface.
  let ``Packets Sent/sec`` instance =
    { category = "Network Interface"; counter = "Packets Sent/sec"; instance = instance }
  /// Current Bandwidth: Current Bandwidth is an estimate of the current bandwidth of the network interface in bits per second (BPS).  For interfaces that do not vary in bandwidth or for those where no accurate estimation can be made, this value is the nominal bandwidth.
  let ``Current Bandwidth`` instance =
    { category = "Network Interface"; counter = "Current Bandwidth"; instance = instance }
  /// Bytes Received/sec: Bytes Received/sec is the rate at which bytes are received over each network adapter, including framing characters. Network Interface\Bytes Received/sec is a subset of Network Interface\Bytes Total/sec.
  let ``Bytes Received/sec`` instance =
    { category = "Network Interface"; counter = "Bytes Received/sec"; instance = instance }
  /// Packets Received Unicast/sec: Packets Received Unicast/sec is the rate at which (subnet) unicast packets are delivered to a higher-layer protocol.
  let ``Packets Received Unicast/sec`` instance =
    { category = "Network Interface"; counter = "Packets Received Unicast/sec"; instance = instance }
  /// Packets Received Non-Unicast/sec: Packets Received Non-Unicast/sec is the rate at which non-unicast (subnet broadcast or subnet multicast) packets are delivered to a higher-layer protocol.
  let ``Packets Received Non-Unicast/sec`` instance =
    { category = "Network Interface"; counter = "Packets Received Non-Unicast/sec"; instance = instance }
  /// Packets Received Discarded: Packets Received Discarded is the number of inbound packets that were chosen to be discarded even though no errors had been detected to prevent their delivery to a higher-layer protocol.  One possible reason for discarding packets could be to free up buffer space.
  let ``Packets Received Discarded`` instance =
    { category = "Network Interface"; counter = "Packets Received Discarded"; instance = instance }
  /// Packets Received Errors: Packets Received Errors is the number of inbound packets that contained errors preventing them from being deliverable to a higher-layer protocol.
  let ``Packets Received Errors`` instance =
    { category = "Network Interface"; counter = "Packets Received Errors"; instance = instance }
  /// Packets Received Unknown: Packets Received Unknown is the number of packets received through the interface that were discarded because of an unknown or unsupported protocol.
  let ``Packets Received Unknown`` instance =
    { category = "Network Interface"; counter = "Packets Received Unknown"; instance = instance }
  /// Bytes Sent/sec: Bytes Sent/sec is the rate at which bytes are sent over each network adapter, including framing characters. Network Interface\Bytes Sent/sec is a subset of Network Interface\Bytes Total/sec.
  let ``Bytes Sent/sec`` instance =
    { category = "Network Interface"; counter = "Bytes Sent/sec"; instance = instance }
  /// Packets Sent Unicast/sec: Packets Sent Unicast/sec is the rate at which packets are requested to be transmitted to subnet-unicast addresses by higher-level protocols.  The rate includes the packets that were discarded or not sent.
  let ``Packets Sent Unicast/sec`` instance =
    { category = "Network Interface"; counter = "Packets Sent Unicast/sec"; instance = instance }
  /// Packets Sent Non-Unicast/sec: Packets Sent Non-Unicast/sec is the rate at which packets are requested to be transmitted to non-unicast (subnet broadcast or subnet multicast) addresses by higher-level protocols.  The rate includes the packets that were discarded or not sent.
  let ``Packets Sent Non-Unicast/sec`` instance =
    { category = "Network Interface"; counter = "Packets Sent Non-Unicast/sec"; instance = instance }
  /// Packets Outbound Discarded: Packets Outbound Discarded is the number of outbound packets that were chosen to be discarded even though no errors had been detected to prevent transmission. One possible reason for discarding packets could be to free up buffer space.
  let ``Packets Outbound Discarded`` instance =
    { category = "Network Interface"; counter = "Packets Outbound Discarded"; instance = instance }
  /// Packets Outbound Errors: Packets Outbound Errors is the number of outbound packets that could not be transmitted because of errors.
  let ``Packets Outbound Errors`` instance =
    { category = "Network Interface"; counter = "Packets Outbound Errors"; instance = instance }
  /// Output Queue Length: Output Queue Length is the length of the output packet queue (in packets). If this is longer than two, there are delays and the bottleneck should be found and eliminated, if possible. Since the requests are queued by the Network Driver Interface Specification (NDIS) in this implementation, this will always be 0.
  let ``Output Queue Length`` instance =
    { category = "Network Interface"; counter = "Output Queue Length"; instance = instance }
  /// Offloaded Connections: Offloaded Connections is the number of TCP connections (over both IPv4 and IPv6) that are currently handled by the TCP chimney offload capable network adapter.
  let ``Offloaded Connections`` instance =
    { category = "Network Interface"; counter = "Offloaded Connections"; instance = instance }
  /// TCP Active RSC Connections: TCP Active RSC Connections is the number of TCP connections (over both IPv4 and IPv6) that are currently receiving large packets from the RSC capable network adapter on this network interface.
  let ``TCP Active RSC Connections`` instance =
    { category = "Network Interface"; counter = "TCP Active RSC Connections"; instance = instance }
  /// TCP RSC Coalesced Packets/sec: TCP RSC Coalesced Packets/sec shows the large packet receive rate across all TCP connections on this network interface.
  let ``TCP RSC Coalesced Packets/sec`` instance =
    { category = "Network Interface"; counter = "TCP RSC Coalesced Packets/sec"; instance = instance }
  /// TCP RSC Exceptions/sec: TCP RSC Exceptions/sec shows the RSC exception rate for receive packets across all TCP connections on this network interface.
  let ``TCP RSC Exceptions/sec`` instance =
    { category = "Network Interface"; counter = "TCP RSC Exceptions/sec"; instance = instance }
  /// TCP RSC Average Packet Size: TCP RSC Average Packet Size is the average size in bytes of received packets across all TCP connections on this network interface.
  let ``TCP RSC Average Packet Size`` instance =
    { category = "Network Interface"; counter = "TCP RSC Average Packet Size"; instance = instance }

  let allCounters =
    [ ``Bytes Total/sec``
      ``Packets/sec``
      ``Packets Received/sec``
      ``Packets Sent/sec``
      ``Current Bandwidth``
      ``Bytes Received/sec``
      ``Packets Received Unicast/sec``
      ``Packets Received Non-Unicast/sec``
      ``Packets Received Discarded``
      ``Packets Received Errors``
      ``Packets Received Unknown``
      ``Bytes Sent/sec``
      ``Packets Sent Unicast/sec``
      ``Packets Sent Non-Unicast/sec``
      ``Packets Outbound Discarded``
      ``Packets Outbound Errors``
      ``Output Queue Length``
      ``Offloaded Connections``
      ``TCP Active RSC Connections``
      ``TCP RSC Coalesced Packets/sec``
      ``TCP RSC Exceptions/sec``
      ``TCP RSC Average Packet Size``
    ]

/// Network QoS Policy: This counter set consists of flow statistics specific to a network QoS policy.
///
/// This performance counter does not have instance based counters
module ``Network QoS Policy`` =

  [<Literal>]
  let Category = "Network QoS Policy"

  let PCC = getPCC Category
  /// Packets transmitted: 
  let ``Packets transmitted`` instance =
    { category = "Network QoS Policy"; counter = "Packets transmitted"; instance = instance }
  /// Packets transmitted/sec: 
  let ``Packets transmitted/sec`` instance =
    { category = "Network QoS Policy"; counter = "Packets transmitted/sec"; instance = instance }
  /// Bytes transmitted: 
  let ``Bytes transmitted`` instance =
    { category = "Network QoS Policy"; counter = "Bytes transmitted"; instance = instance }
  /// Bytes transmitted/sec: 
  let ``Bytes transmitted/sec`` instance =
    { category = "Network QoS Policy"; counter = "Bytes transmitted/sec"; instance = instance }
  /// Packets dropped: 
  let ``Packets dropped`` instance =
    { category = "Network QoS Policy"; counter = "Packets dropped"; instance = instance }
  /// Packets dropped/sec: 
  let ``Packets dropped/sec`` instance =
    { category = "Network QoS Policy"; counter = "Packets dropped/sec"; instance = instance }

  let allCounters =
    [ ``Packets transmitted``
      ``Packets transmitted/sec``
      ``Bytes transmitted``
      ``Bytes transmitted/sec``
      ``Packets dropped``
      ``Packets dropped/sec``
    ]

/// Objects: The Object performance object consists of counters that monitor  logical objects in the system, such as processes, threads, mutexes, and semaphores.  This information can be used to detect the unnecessary consumption of computer resources.  Each object requires memory to store basic information about the object.
///
/// This performance counter does not have instance based counters
module ``Objects`` =

  [<Literal>]
  let Category = "Objects"

  let PCC = getPCC Category
  /// Processes: Processes is the number of processes in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  Each process represents the running of a program.
  let ``Processes`` =
    { category = "Objects"; counter = "Processes"; instance = NotApplicable }
  /// Threads: Threads is the number of threads in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  A thread is the basic executable entity that can execute instructions in a processor.
  let ``Threads`` =
    { category = "Objects"; counter = "Threads"; instance = NotApplicable }
  /// Events: Events is the number of events in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  An event is used when two or more threads try to synchronize execution.
  let ``Events`` =
    { category = "Objects"; counter = "Events"; instance = NotApplicable }
  /// Semaphores: Semaphores is the number of semaphores in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  Threads use semaphores to obtain exclusive access to data structures that they share with other threads.
  let ``Semaphores`` =
    { category = "Objects"; counter = "Semaphores"; instance = NotApplicable }
  /// Mutexes: Mutexes counts the number of mutexes in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  Mutexes are used by threads to assure only one thread is executing a particular section of code.
  let ``Mutexes`` =
    { category = "Objects"; counter = "Mutexes"; instance = NotApplicable }
  /// Sections: Sections is the number of sections in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  A section is a portion of virtual memory created by a process for storing data. A process can share sections with other processes.
  let ``Sections`` =
    { category = "Objects"; counter = "Sections"; instance = NotApplicable }

  let allCounters =
    [ ``Processes``
      ``Threads``
      ``Events``
      ``Semaphores``
      ``Mutexes``
      ``Sections``
    ]

/// Offline Files: Performance counters for Offline Files
///
/// This performance counter does not have instance based counters
module ``Offline Files`` =

  [<Literal>]
  let Category = "Offline Files"

  let PCC = getPCC Category
  /// Bytes Received: Bytes synchronized from server to client
  let ``Bytes Received`` =
    { category = "Offline Files"; counter = "Bytes Received"; instance = NotApplicable }
  /// Bytes Transmitted: Bytes synchronized from client to server
  let ``Bytes Transmitted`` =
    { category = "Offline Files"; counter = "Bytes Transmitted"; instance = NotApplicable }
  /// Bytes Transmitted/sec: Bytes synchronized per second, client to server
  let ``Bytes Transmitted/sec`` =
    { category = "Offline Files"; counter = "Bytes Transmitted/sec"; instance = NotApplicable }
  /// Bytes Received/sec: Bytes synchronized per second, server to client
  let ``Bytes Received/sec`` =
    { category = "Offline Files"; counter = "Bytes Received/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Bytes Received``
      ``Bytes Transmitted``
      ``Bytes Transmitted/sec``
      ``Bytes Received/sec``
    ]

/// Outlook: Gives performance metrics for outlook server connectivity.
///
/// This performance counter does not have instance based counters
module ``Outlook`` =

  [<Literal>]
  let Category = "Outlook"

  let PCC = getPCC Category
  /// RPCs Attempted: Number of RPCs that outlook attempted to send to the server.
  let ``RPCs Attempted`` =
    { category = "Outlook"; counter = "RPCs Attempted"; instance = NotApplicable }
  /// RPCs Succeeded: Number of RPCs that outlook successfully sent to the server.
  let ``RPCs Succeeded`` =
    { category = "Outlook"; counter = "RPCs Succeeded"; instance = NotApplicable }
  /// RPCs Failed: Number of RPCs that were attempted, but failed.
  let ``RPCs Failed`` =
    { category = "Outlook"; counter = "RPCs Failed"; instance = NotApplicable }
  /// RPCs Cancelled: Number of RPCs that were sent to the server, but the user cancelled.
  let ``RPCs Cancelled`` =
    { category = "Outlook"; counter = "RPCs Cancelled"; instance = NotApplicable }
  /// RPCs UI Shown: Number of RPCs that were sent to the server, and took long enough to show progress UI.
  let ``RPCs UI Shown`` =
    { category = "Outlook"; counter = "RPCs UI Shown"; instance = NotApplicable }
  /// RPCs Attempted - UI: Number of RPCs that outlook attempted that blocked the UI.
  let ``RPCs Attempted - UI`` =
    { category = "Outlook"; counter = "RPCs Attempted - UI"; instance = NotApplicable }
  /// Time Avg (all): The average amount of time (ms) it took for all RPCs to complete successfully.
  let ``Time Avg (all)`` =
    { category = "Outlook"; counter = "Time Avg (all)"; instance = NotApplicable }
  /// Time Avg (10): The average amount of time (ms)it took for the last 10 RPCs to complete successfully.
  let ``Time Avg (10)`` =
    { category = "Outlook"; counter = "Time Avg (10)"; instance = NotApplicable }
  /// Time Avg (50): The average amount of time (ms) it took for the last 50 RPCs to complete successfully.
  let ``Time Avg (50)`` =
    { category = "Outlook"; counter = "Time Avg (50)"; instance = NotApplicable }
  /// Time Avg (200): The average amount of time (ms) it took for the last 200 RPCs to complete successfully.
  let ``Time Avg (200)`` =
    { category = "Outlook"; counter = "Time Avg (200)"; instance = NotApplicable }
  /// Time Min: The minimum amount of time (ms) it took for an RPC to complete successfully.
  let ``Time Min`` =
    { category = "Outlook"; counter = "Time Min"; instance = NotApplicable }
  /// Time Max: The maximum amount of time (ms) it took for an RPC to complete successfully.
  let ``Time Max`` =
    { category = "Outlook"; counter = "Time Max"; instance = NotApplicable }
  /// Count obj connection: The number of connection objects that are currently being used.
  let ``Count obj connection`` =
    { category = "Outlook"; counter = "Count obj connection"; instance = NotApplicable }

  let allCounters =
    [ ``RPCs Attempted``
      ``RPCs Succeeded``
      ``RPCs Failed``
      ``RPCs Cancelled``
      ``RPCs UI Shown``
      ``RPCs Attempted - UI``
      ``Time Avg (all)``
      ``Time Avg (10)``
      ``Time Avg (50)``
      ``Time Avg (200)``
      ``Time Min``
      ``Time Max``
      ``Count obj connection``
    ]

/// Pacer Flow: The Pacer Flow performance counter set consists of flow statistics from the packet scheduler.
///
/// This performance counter does not have instance based counters
module ``Pacer Flow`` =

  [<Literal>]
  let Category = "Pacer Flow"

  let PCC = getPCC Category
  /// Packets dropped: 
  let ``Packets dropped`` instance =
    { category = "Pacer Flow"; counter = "Packets dropped"; instance = instance }
  /// Packets scheduled: 
  let ``Packets scheduled`` instance =
    { category = "Pacer Flow"; counter = "Packets scheduled"; instance = instance }
  /// Packets transmitted: 
  let ``Packets transmitted`` instance =
    { category = "Pacer Flow"; counter = "Packets transmitted"; instance = instance }
  /// Bytes scheduled: 
  let ``Bytes scheduled`` instance =
    { category = "Pacer Flow"; counter = "Bytes scheduled"; instance = instance }
  /// Bytes transmitted: 
  let ``Bytes transmitted`` instance =
    { category = "Pacer Flow"; counter = "Bytes transmitted"; instance = instance }
  /// Bytes transmitted/sec: 
  let ``Bytes transmitted/sec`` instance =
    { category = "Pacer Flow"; counter = "Bytes transmitted/sec"; instance = instance }
  /// Bytes scheduled/sec: 
  let ``Bytes scheduled/sec`` instance =
    { category = "Pacer Flow"; counter = "Bytes scheduled/sec"; instance = instance }
  /// Packets transmitted/sec: 
  let ``Packets transmitted/sec`` instance =
    { category = "Pacer Flow"; counter = "Packets transmitted/sec"; instance = instance }
  /// Packets scheduled/sec: 
  let ``Packets scheduled/sec`` instance =
    { category = "Pacer Flow"; counter = "Packets scheduled/sec"; instance = instance }
  /// Packets dropped/sec: 
  let ``Packets dropped/sec`` instance =
    { category = "Pacer Flow"; counter = "Packets dropped/sec"; instance = instance }
  /// Nonconforming packets scheduled: 
  let ``Nonconforming packets scheduled`` instance =
    { category = "Pacer Flow"; counter = "Nonconforming packets scheduled"; instance = instance }
  /// Nonconforming packets scheduled/sec: 
  let ``Nonconforming packets scheduled/sec`` instance =
    { category = "Pacer Flow"; counter = "Nonconforming packets scheduled/sec"; instance = instance }
  /// Average packets in shaper: 
  let ``Average packets in shaper`` instance =
    { category = "Pacer Flow"; counter = "Average packets in shaper"; instance = instance }
  /// Max packets in shaper: 
  let ``Max packets in shaper`` instance =
    { category = "Pacer Flow"; counter = "Max packets in shaper"; instance = instance }
  /// Average packets in sequencer: 
  let ``Average packets in sequencer`` instance =
    { category = "Pacer Flow"; counter = "Average packets in sequencer"; instance = instance }
  /// Max packets in sequencer: 
  let ``Max packets in sequencer`` instance =
    { category = "Pacer Flow"; counter = "Max packets in sequencer"; instance = instance }
  /// Maximum packets in netcard: 
  let ``Maximum packets in netcard`` instance =
    { category = "Pacer Flow"; counter = "Maximum packets in netcard"; instance = instance }
  /// Average packets in netcard: 
  let ``Average packets in netcard`` instance =
    { category = "Pacer Flow"; counter = "Average packets in netcard"; instance = instance }
  /// Nonconforming packets transmitted: 
  let ``Nonconforming packets transmitted`` instance =
    { category = "Pacer Flow"; counter = "Nonconforming packets transmitted"; instance = instance }
  /// Nonconforming packets transmitted/sec: 
  let ``Nonconforming packets transmitted/sec`` instance =
    { category = "Pacer Flow"; counter = "Nonconforming packets transmitted/sec"; instance = instance }

  let allCounters =
    [ ``Packets dropped``
      ``Packets scheduled``
      ``Packets transmitted``
      ``Bytes scheduled``
      ``Bytes transmitted``
      ``Bytes transmitted/sec``
      ``Bytes scheduled/sec``
      ``Packets transmitted/sec``
      ``Packets scheduled/sec``
      ``Packets dropped/sec``
      ``Nonconforming packets scheduled``
      ``Nonconforming packets scheduled/sec``
      ``Average packets in shaper``
      ``Max packets in shaper``
      ``Average packets in sequencer``
      ``Max packets in sequencer``
      ``Maximum packets in netcard``
      ``Average packets in netcard``
      ``Nonconforming packets transmitted``
      ``Nonconforming packets transmitted/sec``
    ]

/// Pacer Pipe: The Pacer Pipe performance counter set consists of pipe statistics from the packet scheduler.
///
/// This performance counter does not have non-instance based counters
module ``Pacer Pipe`` =

  [<Literal>]
  let Category = "Pacer Pipe"

  let PCC = getPCC Category
  /// Out of packets: The number of times Pacer has been unable to allocate a packet.
  let ``Out of packets`` instance =
    { category = "Pacer Pipe"; counter = "Out of packets"; instance = instance }
  /// Flows opened: The number of flows opened on this pipe (some of which may now be closed).
  let ``Flows opened`` instance =
    { category = "Pacer Pipe"; counter = "Flows opened"; instance = instance }
  /// Flows closed: The number of flows that have been closed.
  let ``Flows closed`` instance =
    { category = "Pacer Pipe"; counter = "Flows closed"; instance = instance }
  /// Flows rejected: The number of flow creations that were rejected.
  let ``Flows rejected`` instance =
    { category = "Pacer Pipe"; counter = "Flows rejected"; instance = instance }
  /// Flows modified: The number of times a flow has been modified.
  let ``Flows modified`` instance =
    { category = "Pacer Pipe"; counter = "Flows modified"; instance = instance }
  /// Flow mods rejected: The number of times a flow modification has been rejected.
  let ``Flow mods rejected`` instance =
    { category = "Pacer Pipe"; counter = "Flow mods rejected"; instance = instance }
  /// Max simultaneous flows: The maximum number of flows that have been simultaneously open on this pipe.
  let ``Max simultaneous flows`` instance =
    { category = "Pacer Pipe"; counter = "Max simultaneous flows"; instance = instance }
  /// Nonconforming packets scheduled: The number of packets that have entered the packet scheduler at a rate which exceeded that packet's flow parameters.
  let ``Nonconforming packets scheduled`` instance =
    { category = "Pacer Pipe"; counter = "Nonconforming packets scheduled"; instance = instance }
  /// Nonconforming packets scheduled/sec: The rate at which nonconforming packets have entered the packet scheduler.
  let ``Nonconforming packets scheduled/sec`` instance =
    { category = "Pacer Pipe"; counter = "Nonconforming packets scheduled/sec"; instance = instance }
  /// Average packets in shaper: The average number of packets in the shaper over the last sampling period.
  let ``Average packets in shaper`` instance =
    { category = "Pacer Pipe"; counter = "Average packets in shaper"; instance = instance }
  /// Max packets in shaper: The maximum number of packets that have ever simultaneously been in the shaper.
  let ``Max packets in shaper`` instance =
    { category = "Pacer Pipe"; counter = "Max packets in shaper"; instance = instance }
  /// Average packets in sequencer: The average number of packets in the sequencer over the last sampling period.
  let ``Average packets in sequencer`` instance =
    { category = "Pacer Pipe"; counter = "Average packets in sequencer"; instance = instance }
  /// Max packets in sequencer: The maximum number of packets that have ever simultaneously been in the sequencer.
  let ``Max packets in sequencer`` instance =
    { category = "Pacer Pipe"; counter = "Max packets in sequencer"; instance = instance }
  /// Max packets in netcard: The maximum number of packets ever simultaneously in the network card.
  let ``Max packets in netcard`` instance =
    { category = "Pacer Pipe"; counter = "Max packets in netcard"; instance = instance }
  /// Average packets in netcard: The average number of packets in the network card over the last sampling period.
  let ``Average packets in netcard`` instance =
    { category = "Pacer Pipe"; counter = "Average packets in netcard"; instance = instance }
  /// Nonconforming packets transmitted: The number of packets that have been sent by the packet scheduler at a rate which exceeded that packet's flow parameters.
  let ``Nonconforming packets transmitted`` instance =
    { category = "Pacer Pipe"; counter = "Nonconforming packets transmitted"; instance = instance }
  /// Nonconforming packets transmitted/sec: The rate at which nonconforming packets have been sent by the packet scheduler.
  let ``Nonconforming packets transmitted/sec`` instance =
    { category = "Pacer Pipe"; counter = "Nonconforming packets transmitted/sec"; instance = instance }

  let allCounters =
    [ ``Out of packets``
      ``Flows opened``
      ``Flows closed``
      ``Flows rejected``
      ``Flows modified``
      ``Flow mods rejected``
      ``Max simultaneous flows``
      ``Nonconforming packets scheduled``
      ``Nonconforming packets scheduled/sec``
      ``Average packets in shaper``
      ``Max packets in shaper``
      ``Average packets in sequencer``
      ``Max packets in sequencer``
      ``Max packets in netcard``
      ``Average packets in netcard``
      ``Nonconforming packets transmitted``
      ``Nonconforming packets transmitted/sec``
    ]

/// Paging File: The Paging File performance object consists of counters that monitor the paging file(s) on the computer.  The paging file is a reserved space on disk that backs up committed physical memory on the computer.
///
/// This performance counter does not have non-instance based counters
module ``Paging File`` =

  [<Literal>]
  let Category = "Paging File"

  let PCC = getPCC Category
  /// % Usage: The amount of the Page File instance in use in percent.  See also Process\\Page File Bytes.
  let ``% Usage`` instance =
    { category = "Paging File"; counter = "% Usage"; instance = instance }
  /// % Usage Peak: The peak usage of the Page File instance in percent.  See also Process\\Page File Bytes Peak.
  let ``% Usage Peak`` instance =
    { category = "Paging File"; counter = "% Usage Peak"; instance = instance }

  let allCounters =
    [ ``% Usage``
      ``% Usage Peak``
    ]

/// Peer Name Resolution Protocol: The Peer Name Resolution Protocol (PNRP) performance object consists of counters that monitor each of available PNRP clouds.  These counters monitor the local PNRP cache and measure the rates at which PNRP protocol messages are sent and received.
///
/// This performance counter does not have instance based counters
module ``Peer Name Resolution Protocol`` =

  [<Literal>]
  let Category = "Peer Name Resolution Protocol"

  let PCC = getPCC Category
  /// Registration: 
  let ``Registration`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Registration"; instance = instance }
  /// Resolve: 
  let ``Resolve`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Resolve"; instance = instance }
  /// Cache Entry: 
  let ``Cache Entry`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Cache Entry"; instance = instance }
  /// Average bytes sent: 
  let ``Average bytes sent`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Average bytes sent"; instance = instance }
  /// Average bytes received: 
  let ``Average bytes received`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Average bytes received"; instance = instance }
  /// Estimated cloud size: 
  let ``Estimated cloud size`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Estimated cloud size"; instance = instance }
  /// Stale cache entry: 
  let ``Stale cache entry`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Stale cache entry"; instance = instance }
  /// Send failures: 
  let ``Send failures`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Send failures"; instance = instance }
  /// Receive failures: 
  let ``Receive failures`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Receive failures"; instance = instance }
  /// Solicit sent per second: 
  let ``Solicit sent per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Solicit sent per second"; instance = instance }
  /// Solicit received per second: 
  let ``Solicit received per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Solicit received per second"; instance = instance }
  /// Advertise sent per second: 
  let ``Advertise sent per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Advertise sent per second"; instance = instance }
  /// Advertise received per second: 
  let ``Advertise received per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Advertise received per second"; instance = instance }
  /// Request sent per second: 
  let ``Request sent per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Request sent per second"; instance = instance }
  /// Request received per second: 
  let ``Request received per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Request received per second"; instance = instance }
  /// Flood sent per second: 
  let ``Flood sent per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Flood sent per second"; instance = instance }
  /// Flood received per second: 
  let ``Flood received per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Flood received per second"; instance = instance }
  /// Inquire sent per second: 
  let ``Inquire sent per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Inquire sent per second"; instance = instance }
  /// Inquire received per second: 
  let ``Inquire received per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Inquire received per second"; instance = instance }
  /// Authority sent per second: 
  let ``Authority sent per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Authority sent per second"; instance = instance }
  /// Authority received per second: 
  let ``Authority received per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Authority received per second"; instance = instance }
  /// Ack sent per second: 
  let ``Ack sent per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Ack sent per second"; instance = instance }
  /// Ack received per second: 
  let ``Ack received per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Ack received per second"; instance = instance }
  /// Lookup sent per second: 
  let ``Lookup sent per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Lookup sent per second"; instance = instance }
  /// Lookup received per second: 
  let ``Lookup received per second`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Lookup received per second"; instance = instance }
  /// Unknown message type received: 
  let ``Unknown message type received`` instance =
    { category = "Peer Name Resolution Protocol"; counter = "Unknown message type received"; instance = instance }

  let allCounters =
    [ ``Registration``
      ``Resolve``
      ``Cache Entry``
      ``Average bytes sent``
      ``Average bytes received``
      ``Estimated cloud size``
      ``Stale cache entry``
      ``Send failures``
      ``Receive failures``
      ``Solicit sent per second``
      ``Solicit received per second``
      ``Advertise sent per second``
      ``Advertise received per second``
      ``Request sent per second``
      ``Request received per second``
      ``Flood sent per second``
      ``Flood received per second``
      ``Inquire sent per second``
      ``Inquire received per second``
      ``Authority sent per second``
      ``Authority received per second``
      ``Ack sent per second``
      ``Ack received per second``
      ``Lookup sent per second``
      ``Lookup received per second``
      ``Unknown message type received``
    ]

/// Per Processor Network Activity Cycles: The Per Processor Network Activity Cycles counter set measures processor cycles due to network activity of an interface on each processor.
///
/// This performance counter does not have non-instance based counters
module ``Per Processor Network Activity Cycles`` =

  [<Literal>]
  let Category = "Per Processor Network Activity Cycles"

  let PCC = getPCC Category
  /// Interrupt DPC Cycles/sec: Interrupt DPC Cycles/sec is the average rate, in cycles per second, at which NDIS processed a Deferred Procedure Call (DPC) for an interface.
  let ``Interrupt DPC Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "Interrupt DPC Cycles/sec"; instance = instance }
  /// Interrupt Cycles/sec: Interrupt Cycles/sec is the average rate, in cycles per second, at which NDIS processed hardware interrupts for an interface.
  let ``Interrupt Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "Interrupt Cycles/sec"; instance = instance }
  /// NDIS Receive Indication Cycles/sec: NDIS Receive Indication Cycles/sec is the average rate, in cycles per second, at which NDIS processed a receive indication call from an interface.
  let ``NDIS Receive Indication Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "NDIS Receive Indication Cycles/sec"; instance = instance }
  /// Stack Receive Indication Cycles/sec: Stack Receive Indication Cycles/sec is the average rate, in cycles per second, at which the stack processed a receive indication call from an interface.
  let ``Stack Receive Indication Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "Stack Receive Indication Cycles/sec"; instance = instance }
  /// NDIS Return Packet Cycles/sec: NDIS Return Packet Cycles/sec is the average rate, in cycles per second, at which NDIS processed returning received packets to an interface.
  let ``NDIS Return Packet Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "NDIS Return Packet Cycles/sec"; instance = instance }
  /// Miniport Return Packet Cycles/sec: Miniport Return Packet Cycles/sec is the average rate, in cycles per second, at which an interface processed returning received packets.
  let ``Miniport Return Packet Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "Miniport Return Packet Cycles/sec"; instance = instance }
  /// NDIS Send Cycles/sec: NDIS Send Cycles/sec is the average rate, in cycles per second, at which NDIS processed transmit requests from the stack for an interface.
  let ``NDIS Send Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "NDIS Send Cycles/sec"; instance = instance }
  /// Miniport Send Cycles/sec: Miniport Send Cycles/sec is the average rate, in cycles per second, at which an interface processed transmitting packets.
  let ``Miniport Send Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "Miniport Send Cycles/sec"; instance = instance }
  /// NDIS Send Complete Cycles/sec: NDIS Send Complete Cycles/sec is the average rate, in cycles per second, at which NDIS processed transmit-complete notifications from an interface.
  let ``NDIS Send Complete Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "NDIS Send Complete Cycles/sec"; instance = instance }
  /// Build Scatter Gather Cycles/sec: Build Scatter Gather Cycles/sec is the average rate, in cycles per second, at which NDIS processed building Scatter Gather DMA lists for an interface.
  let ``Build Scatter Gather Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "Build Scatter Gather Cycles/sec"; instance = instance }
  /// Miniport RSS Indirection Table Change Cycles: Miniport RSS Indirection Table Change Cycles is the average rate, in cycles per second, at which an interface processed changing the RSS indirection table.
  let ``Miniport RSS Indirection Table Change Cycles`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "Miniport RSS Indirection Table Change Cycles"; instance = instance }
  /// Stack Send Complete Cycles/sec: Stack Send Complete Cycles/sec is the average rate, in cycles per second, at which the stack processed transmit-complete notifications from an interface.
  let ``Stack Send Complete Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "Stack Send Complete Cycles/sec"; instance = instance }
  /// Interrupt DPC Latency Cycles/sec: Interrupt DPC Latency Cycles/sec is the amount of time, in cycles per second, between an interrupt and its DPC.
  let ``Interrupt DPC Latency Cycles/sec`` instance =
    { category = "Per Processor Network Activity Cycles"; counter = "Interrupt DPC Latency Cycles/sec"; instance = instance }

  let allCounters =
    [ ``Interrupt DPC Cycles/sec``
      ``Interrupt Cycles/sec``
      ``NDIS Receive Indication Cycles/sec``
      ``Stack Receive Indication Cycles/sec``
      ``NDIS Return Packet Cycles/sec``
      ``Miniport Return Packet Cycles/sec``
      ``NDIS Send Cycles/sec``
      ``Miniport Send Cycles/sec``
      ``NDIS Send Complete Cycles/sec``
      ``Build Scatter Gather Cycles/sec``
      ``Miniport RSS Indirection Table Change Cycles``
      ``Stack Send Complete Cycles/sec``
      ``Interrupt DPC Latency Cycles/sec``
    ]

/// Per Processor Network Interface Card Activity: The Per Processor Network Interface Card Activity counter set measures network activity of a network interface card per processor.
///
/// This performance counter does not have non-instance based counters
module ``Per Processor Network Interface Card Activity`` =

  [<Literal>]
  let Category = "Per Processor Network Interface Card Activity"

  let PCC = getPCC Category
  /// DPCs Queued/sec: DPCs Queued/sec is the average rate, in incidents per second, at which NDIS queued a Deferred Procedure Call (DPC) for an interface.
  let ``DPCs Queued/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "DPCs Queued/sec"; instance = instance }
  /// Interrupts/sec: Interrupts/sec is the average rate, in incidents per second, at which NDIS received and serviced hardware interrupts for an interface.
  let ``Interrupts/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Interrupts/sec"; instance = instance }
  /// Receive Indications/sec: Receive Indications/sec is the average rate, in incidents per second, at which NDIS received a receive indication call from an interface.
  let ``Receive Indications/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Receive Indications/sec"; instance = instance }
  /// Return Packet Calls/sec: Return Packet Calls/sec is the average rate, in incidents per second, at which the stack returned received packets to an interface.
  let ``Return Packet Calls/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Return Packet Calls/sec"; instance = instance }
  /// Received Packets/sec: Received Packets/sec is the average rate, in packets per second, at which NDIS received packets from an interface.
  let ``Received Packets/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Received Packets/sec"; instance = instance }
  /// Returned Packets/sec: Returned Packets/sec is the average rate, in packets per second, at which the stack returned received packets to an interface.
  let ``Returned Packets/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Returned Packets/sec"; instance = instance }
  /// DPCs Queued on Other CPUs/sec: DPCs Queued on Other CPUs/sec is the average rate, in incidents per second, at which the miniport queued a DPC on one CPU from a different CPU.
  let ``DPCs Queued on Other CPUs/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "DPCs Queued on Other CPUs/sec"; instance = instance }
  /// Send Request Calls/sec: Send Request Calls/sec is the average rate, in incidents per second, at which the stack requested a transmit on an interface.
  let ``Send Request Calls/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Send Request Calls/sec"; instance = instance }
  /// Send Complete Calls/sec: Send Complete Calls/sec is the average rate, in incidents per second, at which NDIS received a transmit-complete notification from an interface.
  let ``Send Complete Calls/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Send Complete Calls/sec"; instance = instance }
  /// Sent Packets/sec: Sent Packets/sec is the average rate, in packets per second, at which the stack requested a transmit on an interface.
  let ``Sent Packets/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Sent Packets/sec"; instance = instance }
  /// Sent Complete Packets/sec: Sent Complete Packets/sec is the average rate, in packets per second, at which NDIS received a transmit-complete notification from an interface.
  let ``Sent Complete Packets/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Sent Complete Packets/sec"; instance = instance }
  /// Build Scatter Gather List Calls/sec: Build Scatter Gather List Calls/sec is the average rate, in incidents per second, at which NDIS received a request from an interface to build a scatter gather DMA list.
  let ``Build Scatter Gather List Calls/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Build Scatter Gather List Calls/sec"; instance = instance }
  /// RSS Indirection Table Change Calls/sec: RSS Indirection Table Change Calls/sec is the average rate, in incidents per second, at which the stack submitted a request to change the RSS indirection table of an interface.
  let ``RSS Indirection Table Change Calls/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "RSS Indirection Table Change Calls/sec"; instance = instance }
  /// Low Resource Receive Indications/sec: Low Resource Receive Indications/sec is the average rate, in incidents per second, at which NDIS received a receive indication call from an interface with low receive resources.
  let ``Low Resource Receive Indications/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Low Resource Receive Indications/sec"; instance = instance }
  /// Low Resource Received Packets/sec: Low Resource Received Packets/sec is the average rate, in packets per second, at which NDIS received packets from an interface with low receive resources.
  let ``Low Resource Received Packets/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Low Resource Received Packets/sec"; instance = instance }
  /// Tcp Offload Receive Indications/sec: Tcp Offload Receive Indications/sec is the average rate, in incidents per second, at which NDIS received a TCP offload receive indication call from a network interface.
  let ``Tcp Offload Receive Indications/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Tcp Offload Receive Indications/sec"; instance = instance }
  /// Tcp Offload Send Request Calls/sec: Tcp Offload Send Request Calls/sec is the average rate, in incidents per second, at which the TCP/IP protocol requested a TCP offload transmission on a network interface.
  let ``Tcp Offload Send Request Calls/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Tcp Offload Send Request Calls/sec"; instance = instance }
  /// Tcp Offload Receive bytes/sec: Tcp Offload Receive bytes/sec is the average rate, in bytes per second, at which data was delivered by a network interface using the TCP offload receive indication call.
  let ``Tcp Offload Receive bytes/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Tcp Offload Receive bytes/sec"; instance = instance }
  /// Tcp Offload Send bytes/sec: Tcp Offload Send bytes/sec is the average rate, in bytes per second, at which data was delivered to a network interface using the TCP offload send request call.
  let ``Tcp Offload Send bytes/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Tcp Offload Send bytes/sec"; instance = instance }
  /// DPCs Deferred/sec: DPCs Deferred/sec is the average rate, in incidents per second, at which DPCs are deferred from executing immediately to avoid starving usermode threads.
  let ``DPCs Deferred/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "DPCs Deferred/sec"; instance = instance }
  /// Packets Coalesced/sec: Packets Coalesced/sec is the average rate, in packets per second, at which NDIS received packets that were subjected to coalescing by a network interface before interrupting the host CPU.
  let ``Packets Coalesced/sec`` instance =
    { category = "Per Processor Network Interface Card Activity"; counter = "Packets Coalesced/sec"; instance = instance }

  let allCounters =
    [ ``DPCs Queued/sec``
      ``Interrupts/sec``
      ``Receive Indications/sec``
      ``Return Packet Calls/sec``
      ``Received Packets/sec``
      ``Returned Packets/sec``
      ``DPCs Queued on Other CPUs/sec``
      ``Send Request Calls/sec``
      ``Send Complete Calls/sec``
      ``Sent Packets/sec``
      ``Sent Complete Packets/sec``
      ``Build Scatter Gather List Calls/sec``
      ``RSS Indirection Table Change Calls/sec``
      ``Low Resource Receive Indications/sec``
      ``Low Resource Received Packets/sec``
      ``Tcp Offload Receive Indications/sec``
      ``Tcp Offload Send Request Calls/sec``
      ``Tcp Offload Receive bytes/sec``
      ``Tcp Offload Send bytes/sec``
      ``DPCs Deferred/sec``
      ``Packets Coalesced/sec``
    ]

/// Physical Network Interface Card Activity: The Physical Network Interface Card Activity counter set measures events on a physical network card.
///
/// This performance counter does not have non-instance based counters
module ``Physical Network Interface Card Activity`` =

  [<Literal>]
  let Category = "Physical Network Interface Card Activity"

  let PCC = getPCC Category
  /// Device Power State: Device Power State is the current power state of the network interface card.  Power state 0 is the active operating state, while power state 3 is the device's lowest power state.  Intermediate states 1 and 2 are device-specific sleep states.  For example, a USB NIC uses power state 2 to allow remote-wakeup.
  let ``Device Power State`` instance =
    { category = "Physical Network Interface Card Activity"; counter = "Device Power State"; instance = instance }
  /// % Time Suspended (Instantaneous): % Time Suspended (Instantaneous) measures the amount of time that the network interface card is in a low-power suspended state.  The percentage is calculated over the duration of the sample interval.
  let ``% Time Suspended (Instantaneous)`` instance =
    { category = "Physical Network Interface Card Activity"; counter = "% Time Suspended (Instantaneous)"; instance = instance }
  /// % Time Suspended (Lifetime): % Time Suspended (Lifetime) measures the amount of time that the network interface card is in a low-power suspended state.  The percentage is calculated over the entire lifetime of the network card.
  let ``% Time Suspended (Lifetime)`` instance =
    { category = "Physical Network Interface Card Activity"; counter = "% Time Suspended (Lifetime)"; instance = instance }
  /// Low Power Transitions (Lifetime): Low Power Transitions (Lifetime) measures the number of successful low-power transitions over the lifetime of the network interface card.  The counter includes only transitions from the active high-power state to a low-power state.
  let ``Low Power Transitions (Lifetime)`` instance =
    { category = "Physical Network Interface Card Activity"; counter = "Low Power Transitions (Lifetime)"; instance = instance }

  let allCounters =
    [ ``Device Power State``
      ``% Time Suspended (Instantaneous)``
      ``% Time Suspended (Lifetime)``
      ``Low Power Transitions (Lifetime)``
    ]

/// PhysicalDisk: The Physical Disk performance object consists of counters that monitor hard or fixed disk drive on a computer.  Disks are used to store file, program, and paging data and are read to retrieve these items, and written to record changes to them.  The values of physical disk counters are sums of the values of the logical disks (or partitions) into which they are divided.
///
/// This performance counter does not have non-instance based counters
module ``PhysicalDisk`` =

  [<Literal>]
  let Category = "PhysicalDisk"

  let PCC = getPCC Category
  /// Current Disk Queue Length: Current Disk Queue Length is the number of requests outstanding on the disk at the time the performance data is collected. It also includes requests in service at the time of the collection. This is a instantaneous snapshot, not an average over the time interval. Multi-spindle disk devices can have multiple requests that are active at one time, but other concurrent requests are awaiting service. This counter might reflect a transitory high or low queue length, but if there is a sustained load on the disk drive, it is likely that this will be consistently high. Requests experience delays proportional to the length of this queue minus the number of spindles on the disks. For good performance, this difference should average less than two.
  let ``Current Disk Queue Length`` instance =
    { category = "PhysicalDisk"; counter = "Current Disk Queue Length"; instance = instance }
  /// % Disk Time: % Disk Time is the percentage of elapsed time that the selected disk drive was busy servicing read or write requests.
  let ``% Disk Time`` instance =
    { category = "PhysicalDisk"; counter = "% Disk Time"; instance = instance }
  /// Avg. Disk Queue Length: Avg. Disk Queue Length is the average number of both read and write requests that were queued for the selected disk during the sample interval.
  let ``Avg. Disk Queue Length`` instance =
    { category = "PhysicalDisk"; counter = "Avg. Disk Queue Length"; instance = instance }
  /// % Disk Read Time: % Disk Read Time is the percentage of elapsed time that the selected disk drive was busy servicing read requests.
  let ``% Disk Read Time`` instance =
    { category = "PhysicalDisk"; counter = "% Disk Read Time"; instance = instance }
  /// Avg. Disk Read Queue Length: Avg. Disk Read Queue Length is the average number of read requests that were queued for the selected disk during the sample interval.
  let ``Avg. Disk Read Queue Length`` instance =
    { category = "PhysicalDisk"; counter = "Avg. Disk Read Queue Length"; instance = instance }
  /// % Disk Write Time: % Disk Write Time is the percentage of elapsed time that the selected disk drive was busy servicing write requests.
  let ``% Disk Write Time`` instance =
    { category = "PhysicalDisk"; counter = "% Disk Write Time"; instance = instance }
  /// Avg. Disk Write Queue Length: Avg. Disk Write Queue Length is the average number of write requests that were queued for the selected disk during the sample interval.
  let ``Avg. Disk Write Queue Length`` instance =
    { category = "PhysicalDisk"; counter = "Avg. Disk Write Queue Length"; instance = instance }
  /// Avg. Disk sec/Transfer: Avg. Disk sec/Transfer is the time, in seconds, of the average disk transfer.
  let ``Avg. Disk sec/Transfer`` instance =
    { category = "PhysicalDisk"; counter = "Avg. Disk sec/Transfer"; instance = instance }
  /// Avg. Disk sec/Read: Avg. Disk sec/Read is the average time, in seconds, of a read of data from the disk.
  let ``Avg. Disk sec/Read`` instance =
    { category = "PhysicalDisk"; counter = "Avg. Disk sec/Read"; instance = instance }
  /// Avg. Disk sec/Write: Avg. Disk sec/Write is the average time, in seconds, of a write of data to the disk.
  let ``Avg. Disk sec/Write`` instance =
    { category = "PhysicalDisk"; counter = "Avg. Disk sec/Write"; instance = instance }
  /// Disk Transfers/sec: Disk Transfers/sec is the rate of read and write operations on the disk.
  let ``Disk Transfers/sec`` instance =
    { category = "PhysicalDisk"; counter = "Disk Transfers/sec"; instance = instance }
  /// Disk Reads/sec: Disk Reads/sec is the rate of read operations on the disk.
  let ``Disk Reads/sec`` instance =
    { category = "PhysicalDisk"; counter = "Disk Reads/sec"; instance = instance }
  /// Disk Writes/sec: Disk Writes/sec is the rate of write operations on the disk.
  let ``Disk Writes/sec`` instance =
    { category = "PhysicalDisk"; counter = "Disk Writes/sec"; instance = instance }
  /// Disk Bytes/sec: Disk Bytes/sec is the rate bytes are transferred to or from the disk during write or read operations.
  let ``Disk Bytes/sec`` instance =
    { category = "PhysicalDisk"; counter = "Disk Bytes/sec"; instance = instance }
  /// Disk Read Bytes/sec: Disk Read Bytes/sec is the rate at which bytes are transferred from the disk during read operations.
  let ``Disk Read Bytes/sec`` instance =
    { category = "PhysicalDisk"; counter = "Disk Read Bytes/sec"; instance = instance }
  /// Disk Write Bytes/sec: Disk Write Bytes/sec is rate at which bytes are transferred to the disk during write operations.
  let ``Disk Write Bytes/sec`` instance =
    { category = "PhysicalDisk"; counter = "Disk Write Bytes/sec"; instance = instance }
  /// Avg. Disk Bytes/Transfer: Avg. Disk Bytes/Transfer is the average number of bytes transferred to or from the disk during write or read operations.
  let ``Avg. Disk Bytes/Transfer`` instance =
    { category = "PhysicalDisk"; counter = "Avg. Disk Bytes/Transfer"; instance = instance }
  /// Avg. Disk Bytes/Read: Avg. Disk Bytes/Read is the average number of bytes transferred from the disk during read operations.
  let ``Avg. Disk Bytes/Read`` instance =
    { category = "PhysicalDisk"; counter = "Avg. Disk Bytes/Read"; instance = instance }
  /// Avg. Disk Bytes/Write: Avg. Disk Bytes/Write is the average number of bytes transferred to the disk during write operations.
  let ``Avg. Disk Bytes/Write`` instance =
    { category = "PhysicalDisk"; counter = "Avg. Disk Bytes/Write"; instance = instance }
  /// % Idle Time: % Idle Time reports the percentage of time during the sample interval that the disk was idle.
  let ``% Idle Time`` instance =
    { category = "PhysicalDisk"; counter = "% Idle Time"; instance = instance }
  /// Split IO/Sec: Split IO/Sec reports the rate at which I/Os to the disk were split into multiple I/Os. A split I/O may result from requesting data of a size that is too large to fit into a single I/O or that the disk is fragmented.
  let ``Split IO/Sec`` instance =
    { category = "PhysicalDisk"; counter = "Split IO/Sec"; instance = instance }

  let allCounters =
    [ ``Current Disk Queue Length``
      ``% Disk Time``
      ``Avg. Disk Queue Length``
      ``% Disk Read Time``
      ``Avg. Disk Read Queue Length``
      ``% Disk Write Time``
      ``Avg. Disk Write Queue Length``
      ``Avg. Disk sec/Transfer``
      ``Avg. Disk sec/Read``
      ``Avg. Disk sec/Write``
      ``Disk Transfers/sec``
      ``Disk Reads/sec``
      ``Disk Writes/sec``
      ``Disk Bytes/sec``
      ``Disk Read Bytes/sec``
      ``Disk Write Bytes/sec``
      ``Avg. Disk Bytes/Transfer``
      ``Avg. Disk Bytes/Read``
      ``Avg. Disk Bytes/Write``
      ``% Idle Time``
      ``Split IO/Sec``
    ]

/// Power Meter: This counter set displays power metering and budgeting information
///
/// This performance counter does not have non-instance based counters
module ``Power Meter`` =

  [<Literal>]
  let Category = "Power Meter"

  let PCC = getPCC Category
  /// Power: This counter displays power consumption in milliwatts.
  let ``Power`` instance =
    { category = "Power Meter"; counter = "Power"; instance = instance }
  /// Power Budget: This counter displays the power budget for this device or subcomponent in milliwatts.
  let ``Power Budget`` instance =
    { category = "Power Meter"; counter = "Power Budget"; instance = instance }

  let allCounters =
    [ ``Power``
      ``Power Budget``
    ]

/// PowerShell Workflow: Displays performance counters for PowerShell Workflow engine.
///
/// This performance counter does not have instance based counters
module ``PowerShell Workflow`` =

  [<Literal>]
  let Category = "PowerShell Workflow"

  let PCC = getPCC Category
  /// # of failed workflow jobs: 
  let ``# of failed workflow jobs`` instance =
    { category = "PowerShell Workflow"; counter = "# of failed workflow jobs"; instance = instance }
  /// # of failed workflow jobs/sec: 
  let ``# of failed workflow jobs/sec`` instance =
    { category = "PowerShell Workflow"; counter = "# of failed workflow jobs/sec"; instance = instance }
  /// # of resumed workflow jobs: 
  let ``# of resumed workflow jobs`` instance =
    { category = "PowerShell Workflow"; counter = "# of resumed workflow jobs"; instance = instance }
  /// # of resumed workflow jobs/sec: 
  let ``# of resumed workflow jobs/sec`` instance =
    { category = "PowerShell Workflow"; counter = "# of resumed workflow jobs/sec"; instance = instance }
  /// # of running workflow jobs: 
  let ``# of running workflow jobs`` instance =
    { category = "PowerShell Workflow"; counter = "# of running workflow jobs"; instance = instance }
  /// # of running workflow jobs / sec: 
  let ``# of running workflow jobs / sec`` instance =
    { category = "PowerShell Workflow"; counter = "# of running workflow jobs / sec"; instance = instance }
  /// # of stopped workflow jobs: 
  let ``# of stopped workflow jobs`` instance =
    { category = "PowerShell Workflow"; counter = "# of stopped workflow jobs"; instance = instance }
  /// # of stopped workflow jobs / sec: 
  let ``# of stopped workflow jobs / sec`` instance =
    { category = "PowerShell Workflow"; counter = "# of stopped workflow jobs / sec"; instance = instance }
  /// # of succeeded workflow jobs: 
  let ``# of succeeded workflow jobs`` instance =
    { category = "PowerShell Workflow"; counter = "# of succeeded workflow jobs"; instance = instance }
  /// # of succeeded workflow jobs/sec: 
  let ``# of succeeded workflow jobs/sec`` instance =
    { category = "PowerShell Workflow"; counter = "# of succeeded workflow jobs/sec"; instance = instance }
  /// # of suspended workflow jobs: 
  let ``# of suspended workflow jobs`` instance =
    { category = "PowerShell Workflow"; counter = "# of suspended workflow jobs"; instance = instance }
  /// # of suspended workflow jobs/sec: 
  let ``# of suspended workflow jobs/sec`` instance =
    { category = "PowerShell Workflow"; counter = "# of suspended workflow jobs/sec"; instance = instance }
  /// # of terminated workflow jobs: 
  let ``# of terminated workflow jobs`` instance =
    { category = "PowerShell Workflow"; counter = "# of terminated workflow jobs"; instance = instance }
  /// # of terminated workflow jobs / sec: 
  let ``# of terminated workflow jobs / sec`` instance =
    { category = "PowerShell Workflow"; counter = "# of terminated workflow jobs / sec"; instance = instance }
  /// # of waiting workflow jobs: 
  let ``# of waiting workflow jobs`` instance =
    { category = "PowerShell Workflow"; counter = "# of waiting workflow jobs"; instance = instance }
  /// Activity Host Manager: # of busy host processes: 
  let ``Activity Host Manager: # of busy host processes`` instance =
    { category = "PowerShell Workflow"; counter = "Activity Host Manager: # of busy host processes"; instance = instance }
  /// Activity Host Manager: # of failed requests/sec: 
  let ``Activity Host Manager: # of failed requests/sec`` instance =
    { category = "PowerShell Workflow"; counter = "Activity Host Manager: # of failed requests/sec"; instance = instance }
  /// Activity Host Manager: # of failed requests in queue: 
  let ``Activity Host Manager: # of failed requests in queue`` instance =
    { category = "PowerShell Workflow"; counter = "Activity Host Manager: # of failed requests in queue"; instance = instance }
  /// Activity Host Manager: # of incoming requests/sec: 
  let ``Activity Host Manager: # of incoming requests/sec`` instance =
    { category = "PowerShell Workflow"; counter = "Activity Host Manager: # of incoming requests/sec"; instance = instance }
  /// Activity Host Manager: # of pending requests in queue: 
  let ``Activity Host Manager: # of pending requests in queue`` instance =
    { category = "PowerShell Workflow"; counter = "Activity Host Manager: # of pending requests in queue"; instance = instance }
  /// Activity Host Manager: # of created host processes: 
  let ``Activity Host Manager: # of created host processes`` instance =
    { category = "PowerShell Workflow"; counter = "Activity Host Manager: # of created host processes"; instance = instance }
  /// Activity Host Manager: # of disposed host processes: 
  let ``Activity Host Manager: # of disposed host processes`` instance =
    { category = "PowerShell Workflow"; counter = "Activity Host Manager: # of disposed host processes"; instance = instance }
  /// Activity Host Manager: host processes pool size: 
  let ``Activity Host Manager: host processes pool size`` instance =
    { category = "PowerShell Workflow"; counter = "Activity Host Manager: host processes pool size"; instance = instance }
  /// PowerShell Remoting: # of pending requests in queue: 
  let ``PowerShell Remoting: # of pending requests in queue`` instance =
    { category = "PowerShell Workflow"; counter = "PowerShell Remoting: # of pending requests in queue"; instance = instance }
  /// PowerShell Remoting: # of requests being serviced: 
  let ``PowerShell Remoting: # of requests being serviced`` instance =
    { category = "PowerShell Workflow"; counter = "PowerShell Remoting: # of requests being serviced"; instance = instance }
  /// PowerShell Remoting: # of forced to wait requests in queue: 
  let ``PowerShell Remoting: # of forced to wait requests in queue`` instance =
    { category = "PowerShell Workflow"; counter = "PowerShell Remoting: # of forced to wait requests in queue"; instance = instance }
  /// PowerShell Remoting: # of created connections: 
  let ``PowerShell Remoting: # of created connections`` instance =
    { category = "PowerShell Workflow"; counter = "PowerShell Remoting: # of created connections"; instance = instance }
  /// PowerShell Remoting: # of disposed connections: 
  let ``PowerShell Remoting: # of disposed connections`` instance =
    { category = "PowerShell Workflow"; counter = "PowerShell Remoting: # of disposed connections"; instance = instance }
  /// PowerShell Remoting: # of connections closed-reopened: 
  let ``PowerShell Remoting: # of connections closed-reopened`` instance =
    { category = "PowerShell Workflow"; counter = "PowerShell Remoting: # of connections closed-reopened"; instance = instance }

  let allCounters =
    [ ``# of failed workflow jobs``
      ``# of failed workflow jobs/sec``
      ``# of resumed workflow jobs``
      ``# of resumed workflow jobs/sec``
      ``# of running workflow jobs``
      ``# of running workflow jobs / sec``
      ``# of stopped workflow jobs``
      ``# of stopped workflow jobs / sec``
      ``# of succeeded workflow jobs``
      ``# of succeeded workflow jobs/sec``
      ``# of suspended workflow jobs``
      ``# of suspended workflow jobs/sec``
      ``# of terminated workflow jobs``
      ``# of terminated workflow jobs / sec``
      ``# of waiting workflow jobs``
      ``Activity Host Manager: # of busy host processes``
      ``Activity Host Manager: # of failed requests/sec``
      ``Activity Host Manager: # of failed requests in queue``
      ``Activity Host Manager: # of incoming requests/sec``
      ``Activity Host Manager: # of pending requests in queue``
      ``Activity Host Manager: # of created host processes``
      ``Activity Host Manager: # of disposed host processes``
      ``Activity Host Manager: host processes pool size``
      ``PowerShell Remoting: # of pending requests in queue``
      ``PowerShell Remoting: # of requests being serviced``
      ``PowerShell Remoting: # of forced to wait requests in queue``
      ``PowerShell Remoting: # of created connections``
      ``PowerShell Remoting: # of disposed connections``
      ``PowerShell Remoting: # of connections closed-reopened``
    ]

/// Print Queue: Displays performance statistics about a Print Queue.
///
/// This performance counter does not have non-instance based counters
module ``Print Queue`` =

  [<Literal>]
  let Category = "Print Queue"

  let PCC = getPCC Category
  /// Total Jobs Printed: Total number of jobs printed on a print queue since the last restart.
  let ``Total Jobs Printed`` instance =
    { category = "Print Queue"; counter = "Total Jobs Printed"; instance = instance }
  /// Bytes Printed/sec: Number of bytes per second printed on a print queue.
  let ``Bytes Printed/sec`` instance =
    { category = "Print Queue"; counter = "Bytes Printed/sec"; instance = instance }
  /// Total Pages Printed: Total number of pages printed through GDI on a print queue since the last restart.
  let ``Total Pages Printed`` instance =
    { category = "Print Queue"; counter = "Total Pages Printed"; instance = instance }
  /// Jobs: Current number of jobs in a print queue.
  let ``Jobs`` instance =
    { category = "Print Queue"; counter = "Jobs"; instance = instance }
  /// References: Current number of references (open handles) to this printer.
  let ``References`` instance =
    { category = "Print Queue"; counter = "References"; instance = instance }
  /// Max References: Peak number of references (open handles) to this printer.
  let ``Max References`` instance =
    { category = "Print Queue"; counter = "Max References"; instance = instance }
  /// Jobs Spooling: Current number of spooling jobs in a print queue.
  let ``Jobs Spooling`` instance =
    { category = "Print Queue"; counter = "Jobs Spooling"; instance = instance }
  /// Max Jobs Spooling: Maximum number of spooling jobs in a print queue since last restart.
  let ``Max Jobs Spooling`` instance =
    { category = "Print Queue"; counter = "Max Jobs Spooling"; instance = instance }
  /// Out of Paper Errors: Total number of out of paper errors in a print queue since the last restart.
  let ``Out of Paper Errors`` instance =
    { category = "Print Queue"; counter = "Out of Paper Errors"; instance = instance }
  /// Not Ready Errors: Total number of printer not ready errors in a print queue since the last restart.
  let ``Not Ready Errors`` instance =
    { category = "Print Queue"; counter = "Not Ready Errors"; instance = instance }
  /// Job Errors: Total number of job errors in a print queue since last restart.
  let ``Job Errors`` instance =
    { category = "Print Queue"; counter = "Job Errors"; instance = instance }
  /// Enumerate Network Printer Calls: Total number of calls from browse clients to this print server to request network browse lists since last restart.
  let ``Enumerate Network Printer Calls`` instance =
    { category = "Print Queue"; counter = "Enumerate Network Printer Calls"; instance = instance }
  /// Add Network Printer Calls: Total number of calls from other print servers to add shared network printers to this server since last restart.
  let ``Add Network Printer Calls`` instance =
    { category = "Print Queue"; counter = "Add Network Printer Calls"; instance = instance }

  let allCounters =
    [ ``Total Jobs Printed``
      ``Bytes Printed/sec``
      ``Total Pages Printed``
      ``Jobs``
      ``References``
      ``Max References``
      ``Jobs Spooling``
      ``Max Jobs Spooling``
      ``Out of Paper Errors``
      ``Not Ready Errors``
      ``Job Errors``
      ``Enumerate Network Printer Calls``
      ``Add Network Printer Calls``
    ]

/// Process: The Process performance object consists of counters that monitor running application program and system processes.  All the threads in a process share the same address space and have access to the same data.
///
/// This performance counter does not have non-instance based counters
module ``Process`` =

  [<Literal>]
  let Category = "Process"

  let PCC = getPCC Category
  /// % Processor Time: % Processor Time is the percentage of elapsed time that all of process threads used the processor to execution instructions. An instruction is the basic unit of execution in a computer, a thread is the object that executes instructions, and a process is the object created when a program is run. Code executed to handle some hardware interrupts and trap conditions are included in this count.
  let ``% Processor Time`` instance =
    { category = "Process"; counter = "% Processor Time"; instance = instance }
  /// % User Time: % User Time is the percentage of elapsed time that the process threads spent executing code in user mode. Applications, environment subsystems, and integral subsystems execute in user mode. Code executing in user mode cannot damage the integrity of the Windows executive, kernel, and device drivers. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.
  let ``% User Time`` instance =
    { category = "Process"; counter = "% User Time"; instance = instance }
  /// % Privileged Time: % Privileged Time is the percentage of elapsed time that the process threads spent executing code in privileged mode. When a Windows system service is called, the service will often run in privileged mode to gain access to system-private data. Such data is protected from access by threads executing in user mode. Calls to the system can be explicit or implicit, such as page faults or interrupts. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.
  let ``% Privileged Time`` instance =
    { category = "Process"; counter = "% Privileged Time"; instance = instance }
  /// Virtual Bytes Peak: Virtual Bytes Peak is the maximum size, in bytes, of virtual address space the process has used at any one time. Use of virtual address space does not necessarily imply corresponding use of either disk or main memory pages. However, virtual space is finite, and the process might limit its ability to load libraries.
  let ``Virtual Bytes Peak`` instance =
    { category = "Process"; counter = "Virtual Bytes Peak"; instance = instance }
  /// Virtual Bytes: Virtual Bytes is the current size, in bytes, of the virtual address space the process is using. Use of virtual address space does not necessarily imply corresponding use of either disk or main memory pages. Virtual space is finite, and the process can limit its ability to load libraries.
  let ``Virtual Bytes`` instance =
    { category = "Process"; counter = "Virtual Bytes"; instance = instance }
  /// Page Faults/sec: Page Faults/sec is the rate at which page faults by the threads executing in this process are occurring.  A page fault occurs when a thread refers to a virtual memory page that is not in its working set in main memory. This may not cause the page to be fetched from disk if it is on the standby list and hence already in main memory, or if it is in use by another process with whom the page is shared.
  let ``Page Faults/sec`` instance =
    { category = "Process"; counter = "Page Faults/sec"; instance = instance }
  /// Working Set Peak: Working Set Peak is the maximum size, in bytes, of the Working Set of this process at any point in time. The Working Set is the set of memory pages touched recently by the threads in the process. If free memory in the computer is above a threshold, pages are left in the Working Set of a process even if they are not in use. When free memory falls below a threshold, pages are trimmed from Working Sets. If they are needed they will then be soft-faulted back into the Working Set before they leave main memory.
  let ``Working Set Peak`` instance =
    { category = "Process"; counter = "Working Set Peak"; instance = instance }
  /// Working Set: Working Set is the current size, in bytes, of the Working Set of this process. The Working Set is the set of memory pages touched recently by the threads in the process. If free memory in the computer is above a threshold, pages are left in the Working Set of a process even if they are not in use.  When free memory falls below a threshold, pages are trimmed from Working Sets. If they are needed they will then be soft-faulted back into the Working Set before leaving main memory.
  let ``Working Set`` instance =
    { category = "Process"; counter = "Working Set"; instance = instance }
  /// Page File Bytes Peak: Page File Bytes Peak is the maximum amount of virtual memory, in bytes, that this process has reserved for use in the paging file(s). Paging files are used to store pages of memory used by the process that are not contained in other files.  Paging files are shared by all processes, and the lack of space in paging files can prevent other processes from allocating memory. If there is no paging file, this counter reflects the maximum amount of virtual memory that the process has reserved for use in physical memory.
  let ``Page File Bytes Peak`` instance =
    { category = "Process"; counter = "Page File Bytes Peak"; instance = instance }
  /// Page File Bytes: Page File Bytes is the current amount of virtual memory, in bytes, that this process has reserved for use in the paging file(s). Paging files are used to store pages of memory used by the process that are not contained in other files. Paging files are shared by all processes, and the lack of space in paging files can prevent other processes from allocating memory. If there is no paging file, this counter reflects the current amount of virtual memory that the process has reserved for use in physical memory.
  let ``Page File Bytes`` instance =
    { category = "Process"; counter = "Page File Bytes"; instance = instance }
  /// Private Bytes: Private Bytes is the current size, in bytes, of memory that this process has allocated that cannot be shared with other processes.
  let ``Private Bytes`` instance =
    { category = "Process"; counter = "Private Bytes"; instance = instance }
  /// Thread Count: The number of threads currently active in this process. An instruction is the basic unit of execution in a processor, and a thread is the object that executes instructions. Every running process has at least one thread.
  let ``Thread Count`` instance =
    { category = "Process"; counter = "Thread Count"; instance = instance }
  /// Priority Base: The current base priority of this process. Threads within a process can raise and lower their own base priority relative to the process' base priority.
  let ``Priority Base`` instance =
    { category = "Process"; counter = "Priority Base"; instance = instance }
  /// Elapsed Time: The total elapsed time, in seconds, that this process has been running.
  let ``Elapsed Time`` instance =
    { category = "Process"; counter = "Elapsed Time"; instance = instance }
  /// ID Process: ID Process is the unique identifier of this process. ID Process numbers are reused, so they only identify a process for the lifetime of that process.
  let ``ID Process`` instance =
    { category = "Process"; counter = "ID Process"; instance = instance }
  /// Creating Process ID: The Creating Process ID value is the Process ID of the process that created the process. The creating process may have terminated, so this value may no longer identify a running process.
  let ``Creating Process ID`` instance =
    { category = "Process"; counter = "Creating Process ID"; instance = instance }
  /// Pool Paged Bytes: Pool Paged Bytes is the size, in bytes, of the paged pool, an area of the system virtual memory that is used for objects that can be written to disk when they are not being used.  Memory\\Pool Paged Bytes is calculated differently than Process\\Pool Paged Bytes, so it might not equal Process(_Total)\\Pool Paged Bytes. This counter displays the last observed value only; it is not an average.
  let ``Pool Paged Bytes`` instance =
    { category = "Process"; counter = "Pool Paged Bytes"; instance = instance }
  /// Pool Nonpaged Bytes: Pool Nonpaged Bytes is the size, in bytes, of the nonpaged pool, an area of the system virtual memory that is used for objects that cannot be written to disk, but must remain in physical memory as long as they are allocated.  Memory\\Pool Nonpaged Bytes is calculated differently than Process\\Pool Nonpaged Bytes, so it might not equal Process(_Total)\\Pool Nonpaged Bytes.  This counter displays the last observed value only; it is not an average.
  let ``Pool Nonpaged Bytes`` instance =
    { category = "Process"; counter = "Pool Nonpaged Bytes"; instance = instance }
  /// Handle Count: The total number of handles currently open by this process. This number is equal to the sum of the handles currently open by each thread in this process.
  let ``Handle Count`` instance =
    { category = "Process"; counter = "Handle Count"; instance = instance }
  /// IO Read Operations/sec: The rate at which the process is issuing read I/O operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Read Operations/sec`` instance =
    { category = "Process"; counter = "IO Read Operations/sec"; instance = instance }
  /// IO Write Operations/sec: The rate at which the process is issuing write I/O operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Write Operations/sec`` instance =
    { category = "Process"; counter = "IO Write Operations/sec"; instance = instance }
  /// IO Data Operations/sec: The rate at which the process is issuing read and write I/O operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Data Operations/sec`` instance =
    { category = "Process"; counter = "IO Data Operations/sec"; instance = instance }
  /// IO Other Operations/sec: The rate at which the process is issuing I/O operations that are neither read nor write operations (for example, a control function). This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Other Operations/sec`` instance =
    { category = "Process"; counter = "IO Other Operations/sec"; instance = instance }
  /// IO Read Bytes/sec: The rate at which the process is reading bytes from I/O operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Read Bytes/sec`` instance =
    { category = "Process"; counter = "IO Read Bytes/sec"; instance = instance }
  /// IO Write Bytes/sec: The rate at which the process is writing bytes to I/O operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Write Bytes/sec`` instance =
    { category = "Process"; counter = "IO Write Bytes/sec"; instance = instance }
  /// IO Data Bytes/sec: The rate at which the process is reading and writing bytes in I/O operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Data Bytes/sec`` instance =
    { category = "Process"; counter = "IO Data Bytes/sec"; instance = instance }
  /// IO Other Bytes/sec: The rate at which the process is issuing bytes to I/O operations that do not involve data such as control operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.
  let ``IO Other Bytes/sec`` instance =
    { category = "Process"; counter = "IO Other Bytes/sec"; instance = instance }
  /// Working Set - Private: Working Set - Private displays the size of the working set, in bytes, that is use for this process only and not shared nor sharable by other processes.
  let ``Working Set - Private`` instance =
    { category = "Process"; counter = "Working Set - Private"; instance = instance }

  let allCounters =
    [ ``% Processor Time``
      ``% User Time``
      ``% Privileged Time``
      ``Virtual Bytes Peak``
      ``Virtual Bytes``
      ``Page Faults/sec``
      ``Working Set Peak``
      ``Working Set``
      ``Page File Bytes Peak``
      ``Page File Bytes``
      ``Private Bytes``
      ``Thread Count``
      ``Priority Base``
      ``Elapsed Time``
      ``ID Process``
      ``Creating Process ID``
      ``Pool Paged Bytes``
      ``Pool Nonpaged Bytes``
      ``Handle Count``
      ``IO Read Operations/sec``
      ``IO Write Operations/sec``
      ``IO Data Operations/sec``
      ``IO Other Operations/sec``
      ``IO Read Bytes/sec``
      ``IO Write Bytes/sec``
      ``IO Data Bytes/sec``
      ``IO Other Bytes/sec``
      ``Working Set - Private``
    ]

/// Processor: The Processor performance object consists of counters that measure aspects of processor activity. The processor is the part of the computer that performs arithmetic and logical computations, initiates operations on peripherals, and runs the threads of processes.  A computer can have multiple processors.  The processor object represents each processor as an instance of the object.
///
/// This performance counter does not have non-instance based counters
module ``Processor`` =

  [<Literal>]
  let Category = "Processor"

  let PCC = getPCC Category
  /// % Processor Time: % Processor Time is the percentage of elapsed time that the processor spends to execute a non-Idle thread. It is calculated by measuring the percentage of time that the processor spends executing the idle thread and then subtracting that value from 100%. (Each processor has an idle thread that consumes cycles when no other threads are ready to run). This counter is the primary indicator of processor activity, and displays the average percentage of busy time observed during the sample interval. It should be noted that the accounting calculation of whether the processor is idle is performed at an internal sampling interval of the system clock (10ms). On todays fast processors, % Processor Time can therefore underestimate the processor utilization as the processor may be spending a lot of time servicing threads between the system clock sampling interval. Workload based timer applications are one example  of applications  which are more likely to be measured inaccurately as timers are signaled just after the sample is taken.
  let ``% Processor Time`` instance =
    { category = "Processor"; counter = "% Processor Time"; instance = instance }
  /// % User Time: % User Time is the percentage of elapsed time the processor spends in the user mode. User mode is a restricted processing mode designed for applications, environment subsystems, and integral subsystems.  The alternative, privileged mode, is designed for operating system components and allows direct access to hardware and all memory.  The operating system switches application threads to privileged mode to access operating system services. This counter displays the average busy time as a percentage of the sample time.
  let ``% User Time`` instance =
    { category = "Processor"; counter = "% User Time"; instance = instance }
  /// % Privileged Time: % Privileged Time is the percentage of elapsed time that the process threads spent executing code in privileged mode.  When a Windows system service in called, the service will often run in privileged mode to gain access to system-private data. Such data is protected from access by threads executing in user mode. Calls to the system can be explicit or implicit, such as page faults or interrupts. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.
  let ``% Privileged Time`` instance =
    { category = "Processor"; counter = "% Privileged Time"; instance = instance }
  /// Interrupts/sec: Interrupts/sec is the average rate, in incidents per second, at which the processor received and serviced hardware interrupts. It does not include deferred procedure calls (DPCs), which are counted separately. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards, and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention. Normal thread execution is suspended. The system clock typically interrupts the processor every 10 milliseconds, creating a background of interrupt activity. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Interrupts/sec`` instance =
    { category = "Processor"; counter = "Interrupts/sec"; instance = instance }
  /// % DPC Time: % DPC Time is the percentage of time that the processor spent receiving and servicing deferred procedure calls (DPCs) during the sample interval. DPCs are interrupts that run at a lower priority than standard interrupts. % DPC Time is a component of % Privileged Time because DPCs are executed in privileged mode. They are counted separately and are not a component of the interrupt counters. This counter displays the average busy time as a percentage of the sample time.
  let ``% DPC Time`` instance =
    { category = "Processor"; counter = "% DPC Time"; instance = instance }
  /// % Interrupt Time: % Interrupt Time is the time the processor spends receiving and servicing hardware interrupts during sample intervals. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention. Normal thread execution is suspended during interrupts. Most system clocks interrupt the processor every 10 milliseconds, creating a background of interrupt activity. suspends normal thread execution during interrupts. This counter displays the average busy time as a percentage of the sample time.
  let ``% Interrupt Time`` instance =
    { category = "Processor"; counter = "% Interrupt Time"; instance = instance }
  /// DPCs Queued/sec: DPCs Queued/sec is the average rate, in incidents per second, at which deferred procedure calls (DPCs) were added to the processor's DPC queue. DPCs are interrupts that run at a lower priority than standard interrupts.  Each processor has its own DPC queue. This counter measures the rate that DPCs are added to the queue, not the number of DPCs in the queue.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``DPCs Queued/sec`` instance =
    { category = "Processor"; counter = "DPCs Queued/sec"; instance = instance }
  /// DPC Rate: DPC Rate is the rate at which deferred procedure calls (DPCs) were added to the processors DPC queues between the timer ticks of the processor clock. DPCs are interrupts that run at alower priority than standard interrupts.  Each processor has its own DPC queue. This counter measures the rate that DPCs were added to the queue, not the number of DPCs in the queue. This counter displays the last observed value only; it is not an average.
  let ``DPC Rate`` instance =
    { category = "Processor"; counter = "DPC Rate"; instance = instance }
  /// % Idle Time: % Idle Time is the percentage of time the processor is idle during the sample interval
  let ``% Idle Time`` instance =
    { category = "Processor"; counter = "% Idle Time"; instance = instance }
  /// % C1 Time: % C1 Time is the percentage of time the processor spends in the C1 low-power idle state. % C1 Time is a subset of the total processor idle time. C1 low-power idle state enables the processor to maintain its entire context and quickly return to the running state. Not all systems support the % C1 state.
  let ``% C1 Time`` instance =
    { category = "Processor"; counter = "% C1 Time"; instance = instance }
  /// % C2 Time: % C2 Time is the percentage of time the processor spends in the C2 low-power idle state. % C2 Time is a subset of the total processor idle time. C2 low-power idle state enables the processor to maintain the context of the system caches. The C2 power state is a lower power and higher exit latency state than C1. Not all systems support the C2 state.
  let ``% C2 Time`` instance =
    { category = "Processor"; counter = "% C2 Time"; instance = instance }
  /// % C3 Time: % C3 Time is the percentage of time the processor spends in the C3 low-power idle state. % C3 Time is a subset of the total processor idle time. When the processor is in the C3 low-power idle state it is unable to maintain the coherency of its caches. The C3 power state is a lower power and higher exit latency state than C2. Not all systems support the C3 state.
  let ``% C3 Time`` instance =
    { category = "Processor"; counter = "% C3 Time"; instance = instance }
  /// C1 Transitions/sec: C1 Transitions/sec is the rate that the CPU enters the C1 low-power idle state. The CPU enters the C1 state when it is sufficiently idle and exits this state on any interrupt. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``C1 Transitions/sec`` instance =
    { category = "Processor"; counter = "C1 Transitions/sec"; instance = instance }
  /// C2 Transitions/sec: C2 Transitions/sec is the rate that the CPU enters the C2 low-power idle state. The CPU enters the C2 state when it is sufficiently idle and exits this state on any interrupt. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``C2 Transitions/sec`` instance =
    { category = "Processor"; counter = "C2 Transitions/sec"; instance = instance }
  /// C3 Transitions/sec: C3 Transitions/sec is the rate that the CPU enters the C3 low-power idle state. The CPU enters the C3 state when it is sufficiently idle and exits this state on any interrupt. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``C3 Transitions/sec`` instance =
    { category = "Processor"; counter = "C3 Transitions/sec"; instance = instance }

  let allCounters =
    [ ``% Processor Time``
      ``% User Time``
      ``% Privileged Time``
      ``Interrupts/sec``
      ``% DPC Time``
      ``% Interrupt Time``
      ``DPCs Queued/sec``
      ``DPC Rate``
      ``% Idle Time``
      ``% C1 Time``
      ``% C2 Time``
      ``% C3 Time``
      ``C1 Transitions/sec``
      ``C2 Transitions/sec``
      ``C3 Transitions/sec``
    ]

/// Processor Information: The Processor Information performance counter set consists of counters that measure aspects of processor activity. The processor is the part of the computer that performs arithmetic and logical computations, initiates operations on peripherals, and runs the threads of processes. A computer can have multiple processors. On some computers, processors are organized in NUMA nodes that share hardware resources such as physical memory. The Processor Information counter set represents each processor as a pair of numbers, where the first number is the NUMA node number and the second number is the zero-based index of the processor within that NUMA node. If the computer does not use NUMA nodes, the first number is zero.
///
/// This performance counter does not have non-instance based counters
module ``Processor Information`` =

  [<Literal>]
  let Category = "Processor Information"

  let PCC = getPCC Category
  /// % Processor Time: % Processor Time is the percentage of elapsed time that the processor spends to execute a non-Idle thread. It is calculated by measuring the percentage of time that the processor spends executing the idle thread and then subtracting that value from 100%. (Each processor has an idle thread to which time is accumulated when no other threads are ready to run). This counter is the primary indicator of processor activity, and displays the average percentage of busy time observed during the sample interval. It should be noted that the accounting calculation of whether the processor is idle is performed at an internal sampling interval of the system clock tick. On todays fast processors, % Processor Time can therefore underestimate the processor utilization as the processor may be spending a lot of time servicing threads between the system clock sampling interval. Workload based timer applications are one example  of applications  which are more likely to be measured inaccurately as timers are signaled just after the sample is taken.
  let ``% Processor Time`` instance =
    { category = "Processor Information"; counter = "% Processor Time"; instance = instance }
  /// % User Time: % User Time is the percentage of elapsed time the processor spends in the user mode. User mode is a restricted processing mode designed for applications, environment subsystems, and integral subsystems.  The alternative, privileged mode, is designed for operating system components and allows direct access to hardware and all memory.  The operating system switches application threads to privileged mode to access operating system services. This counter displays the average busy time as a percentage of the sample time.
  let ``% User Time`` instance =
    { category = "Processor Information"; counter = "% User Time"; instance = instance }
  /// % Privileged Time: % Privileged Time is the percentage of elapsed time that the process threads spent executing code in privileged mode.  When a Windows system service in called, the service will often run in privileged mode to gain access to system-private data. Such data is protected from access by threads executing in user mode. Calls to the system can be explicit or implicit, such as page faults or interrupts. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.
  let ``% Privileged Time`` instance =
    { category = "Processor Information"; counter = "% Privileged Time"; instance = instance }
  /// Interrupts/sec: Interrupts/sec is the average rate, in incidents per second, at which the processor received and serviced hardware interrupts. It does not include deferred procedure calls (DPCs), which are counted separately. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards, and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention. Normal thread execution is suspended. The system clock typically interrupts the processor every 10 milliseconds, creating a background of interrupt activity. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Interrupts/sec`` instance =
    { category = "Processor Information"; counter = "Interrupts/sec"; instance = instance }
  /// % DPC Time: % DPC Time is the percentage of time that the processor spent receiving and servicing deferred procedure calls (DPCs) during the sample interval. DPCs are interrupts that run at a lower priority than standard interrupts. % DPC Time is a component of % Privileged Time because DPCs are executed in privileged mode. They are counted separately and are not a component of the interrupt counters. This counter displays the average busy time as a percentage of the sample time.
  let ``% DPC Time`` instance =
    { category = "Processor Information"; counter = "% DPC Time"; instance = instance }
  /// % Interrupt Time: % Interrupt Time is the time the processor spends receiving and servicing hardware interrupts during sample intervals. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention. Normal thread execution is suspended during interrupts. Most system clocks interrupt the processor every 10 milliseconds, creating a background of interrupt activity. suspends normal thread execution during interrupts. This counter displays the average busy time as a percentage of the sample time.
  let ``% Interrupt Time`` instance =
    { category = "Processor Information"; counter = "% Interrupt Time"; instance = instance }
  /// DPCs Queued/sec: DPCs Queued/sec is the average rate, in incidents per second, at which deferred procedure calls (DPCs) were added to the processor's DPC queue. DPCs are interrupts that run at a lower priority than standard interrupts.  Each processor has its own DPC queue. This counter measures the rate that DPCs are added to the queue, not the number of DPCs in the queue.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``DPCs Queued/sec`` instance =
    { category = "Processor Information"; counter = "DPCs Queued/sec"; instance = instance }
  /// DPC Rate: DPC Rate is the rate at which deferred procedure calls (DPCs) were added to the processors DPC queues between the timer ticks of the processor clock. DPCs are interrupts that run at alower priority than standard interrupts.  Each processor has its own DPC queue. This counter measures the rate that DPCs were added to the queue, not the number of DPCs in the queue. This counter displays the last observed value only; it is not an average.
  let ``DPC Rate`` instance =
    { category = "Processor Information"; counter = "DPC Rate"; instance = instance }
  /// % Idle Time: % Idle Time is the percentage of time the processor is idle during the sample interval
  let ``% Idle Time`` instance =
    { category = "Processor Information"; counter = "% Idle Time"; instance = instance }
  /// % C1 Time: % C1 Time is the percentage of time the processor spends in the C1 low-power idle state. % C1 Time is a subset of the total processor idle time. C1 low-power idle state enables the processor to maintain its entire context and quickly return to the running state. Not all systems support the % C1 state.
  let ``% C1 Time`` instance =
    { category = "Processor Information"; counter = "% C1 Time"; instance = instance }
  /// % C2 Time: % C2 Time is the percentage of time the processor spends in the C2 low-power idle state. % C2 Time is a subset of the total processor idle time. C2 low-power idle state enables the processor to maintain the context of the system caches. The C2 power state is a lower power and higher exit latency state than C1. Not all systems support the C2 state.
  let ``% C2 Time`` instance =
    { category = "Processor Information"; counter = "% C2 Time"; instance = instance }
  /// % C3 Time: % C3 Time is the percentage of time the processor spends in the C3 low-power idle state. % C3 Time is a subset of the total processor idle time. When the processor is in the C3 low-power idle state it is unable to maintain the coherency of its caches. The C3 power state is a lower power and higher exit latency state than C2. Not all systems support the C3 state.
  let ``% C3 Time`` instance =
    { category = "Processor Information"; counter = "% C3 Time"; instance = instance }
  /// C1 Transitions/sec: C1 Transitions/sec is the rate that the CPU enters the C1 low-power idle state. The CPU enters the C1 state when it is sufficiently idle and exits this state on any interrupt. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``C1 Transitions/sec`` instance =
    { category = "Processor Information"; counter = "C1 Transitions/sec"; instance = instance }
  /// C2 Transitions/sec: C2 Transitions/sec is the rate that the CPU enters the C2 low-power idle state. The CPU enters the C2 state when it is sufficiently idle and exits this state on any interrupt. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``C2 Transitions/sec`` instance =
    { category = "Processor Information"; counter = "C2 Transitions/sec"; instance = instance }
  /// C3 Transitions/sec: C3 Transitions/sec is the rate that the CPU enters the C3 low-power idle state. The CPU enters the C3 state when it is sufficiently idle and exits this state on any interrupt. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``C3 Transitions/sec`` instance =
    { category = "Processor Information"; counter = "C3 Transitions/sec"; instance = instance }
  /// % Priority Time: % Priority Time is the percentage of elapsed time that the processor spends executing threads that are not low priority. It is calculated by measuring the percentage of time that the processor spends executing low priority threads or the idle thread and then subtracting that value from 100%. (Each processor has an idle thread to which time is accumulated when no other threads are ready to run). This counter displays the average percentage of busy time observed during the sample interval excluding low priority background work. It should be noted that the accounting calculation of whether the processor is idle is performed at an internal sampling interval of the system clock tick. % Priority Time can therefore underestimate the processor utilization as the processor may be spending a lot of time servicing threads between the system clock sampling interval. Workload based timer applications are one example  of applications  which are more likely to be measured inaccurately as timers are signaled just after the sample is taken.
  let ``% Priority Time`` instance =
    { category = "Processor Information"; counter = "% Priority Time"; instance = instance }
  /// Parking Status: Parking Status represents whether a processor is parked or not.
  let ``Parking Status`` instance =
    { category = "Processor Information"; counter = "Parking Status"; instance = instance }
  /// Processor Frequency: Processor Frequency is the frequency of the current processor in megahertz.
  let ``Processor Frequency`` instance =
    { category = "Processor Information"; counter = "Processor Frequency"; instance = instance }
  /// % of Maximum Frequency: % of Maximum Frequency is the percentage of the current processor's maximum frequency.
  let ``% of Maximum Frequency`` instance =
    { category = "Processor Information"; counter = "% of Maximum Frequency"; instance = instance }
  /// Processor State Flags: Processor State Flags
  let ``Processor State Flags`` instance =
    { category = "Processor Information"; counter = "Processor State Flags"; instance = instance }
  /// Clock Interrupts/sec: Clock Interrupts/sec is the average rate, in incidents per second, at which the processor received and serviced clock tick interrupts. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Clock Interrupts/sec`` instance =
    { category = "Processor Information"; counter = "Clock Interrupts/sec"; instance = instance }
  /// Average Idle Time: Average Idle Time is the average idle duration in 100ns units observed between the last two samples.
  let ``Average Idle Time`` instance =
    { category = "Processor Information"; counter = "Average Idle Time"; instance = instance }
  /// Idle Break Events/sec: Idle Break Events/sec is the average rate, in incidents per second, at which the processor wakes from idle.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Idle Break Events/sec`` instance =
    { category = "Processor Information"; counter = "Idle Break Events/sec"; instance = instance }
  /// % Processor Performance: Processor Performance is the average performance of the processor while it is executing instructions, as a percentage of the nominal performance of the processor. On some processors, Processor Performance may exceed 100%.
  let ``% Processor Performance`` instance =
    { category = "Processor Information"; counter = "% Processor Performance"; instance = instance }
  /// % Processor Utility: Processor Utility is the amount of work a processor is completing, as a percentage of the amount of work the processor could complete if it were running at its nominal performance and never idle. On some processors, Processor Utility may exceed 100%.
  let ``% Processor Utility`` instance =
    { category = "Processor Information"; counter = "% Processor Utility"; instance = instance }
  /// % Privileged Utility: Privileged Utility is the amount of work a processor is completing while executing in privileged mode, as a percentage of the amount of work the processor could complete if it were running at its nominal performance and never idle. On some processors, Privileged Utility may exceed 100%.
  let ``% Privileged Utility`` instance =
    { category = "Processor Information"; counter = "% Privileged Utility"; instance = instance }
  /// % Performance Limit: % Performance Limit is the performance the processor guarantees it can provide, as a percentage of the nominal performance of the processor. Performance can be limited by Windows power policy, or by the platform as a result of a power budget, overheating, or other hardware issues.
  let ``% Performance Limit`` instance =
    { category = "Processor Information"; counter = "% Performance Limit"; instance = instance }
  /// Performance Limit Flags: Performance Limit Flags indicate reasons why the processor performance was limited.
  let ``Performance Limit Flags`` instance =
    { category = "Processor Information"; counter = "Performance Limit Flags"; instance = instance }

  let allCounters =
    [ ``% Processor Time``
      ``% User Time``
      ``% Privileged Time``
      ``Interrupts/sec``
      ``% DPC Time``
      ``% Interrupt Time``
      ``DPCs Queued/sec``
      ``DPC Rate``
      ``% Idle Time``
      ``% C1 Time``
      ``% C2 Time``
      ``% C3 Time``
      ``C1 Transitions/sec``
      ``C2 Transitions/sec``
      ``C3 Transitions/sec``
      ``% Priority Time``
      ``Parking Status``
      ``Processor Frequency``
      ``% of Maximum Frequency``
      ``Processor State Flags``
      ``Clock Interrupts/sec``
      ``Average Idle Time``
      ``Idle Break Events/sec``
      ``% Processor Performance``
      ``% Processor Utility``
      ``% Privileged Utility``
      ``% Performance Limit``
      ``Performance Limit Flags``
    ]

/// RAS: VPN counters which keep track of their values since service start
///
/// This performance counter does not have instance based counters
module ``RAS`` =

  [<Literal>]
  let Category = "RAS"

  let PCC = getPCC Category
  /// Total Clients: Total number of cumulative remote clients connected to server since service start
  let ``Total Clients`` =
    { category = "RAS"; counter = "Total Clients"; instance = NotApplicable }
  /// Max Clients: Maximum number of remote clients connected to server since service start
  let ``Max Clients`` =
    { category = "RAS"; counter = "Max Clients"; instance = NotApplicable }
  /// Failed Authentications: Number of failed authentications since service start
  let ``Failed Authentications`` =
    { category = "RAS"; counter = "Failed Authentications"; instance = NotApplicable }
  /// Bytes Received By Disconnected Clients: Total number of bytes received by all the disconnected clients since service start
  let ``Bytes Received By Disconnected Clients`` =
    { category = "RAS"; counter = "Bytes Received By Disconnected Clients"; instance = NotApplicable }
  /// Bytes Transmitted By Disconnected Clients: Total number of bytes transmitted by all the disconnected clients since service start
  let ``Bytes Transmitted By Disconnected Clients`` =
    { category = "RAS"; counter = "Bytes Transmitted By Disconnected Clients"; instance = NotApplicable }

  let allCounters =
    [ ``Total Clients``
      ``Max Clients``
      ``Failed Authentications``
      ``Bytes Received By Disconnected Clients``
      ``Bytes Transmitted By Disconnected Clients``
    ]

/// RAS Port: The RAS Object Type handles individual ports of the RAS device on your system.
///
/// This performance counter does not have instance based counters
module ``RAS Port`` =

  [<Literal>]
  let Category = "RAS Port"

  let PCC = getPCC Category
  /// Bytes Transmitted: 
  let ``Bytes Transmitted`` instance =
    { category = "RAS Port"; counter = "Bytes Transmitted"; instance = instance }
  /// Bytes Received: 
  let ``Bytes Received`` instance =
    { category = "RAS Port"; counter = "Bytes Received"; instance = instance }
  /// Frames Transmitted: 
  let ``Frames Transmitted`` instance =
    { category = "RAS Port"; counter = "Frames Transmitted"; instance = instance }
  /// Frames Received: 
  let ``Frames Received`` instance =
    { category = "RAS Port"; counter = "Frames Received"; instance = instance }
  /// Percent Compression Out: 
  let ``Percent Compression Out`` instance =
    { category = "RAS Port"; counter = "Percent Compression Out"; instance = instance }
  /// Percent Compression In: 
  let ``Percent Compression In`` instance =
    { category = "RAS Port"; counter = "Percent Compression In"; instance = instance }
  /// CRC Errors: 
  let ``CRC Errors`` instance =
    { category = "RAS Port"; counter = "CRC Errors"; instance = instance }
  /// Timeout Errors: 
  let ``Timeout Errors`` instance =
    { category = "RAS Port"; counter = "Timeout Errors"; instance = instance }
  /// Serial Overrun Errors: 
  let ``Serial Overrun Errors`` instance =
    { category = "RAS Port"; counter = "Serial Overrun Errors"; instance = instance }
  /// Alignment Errors: 
  let ``Alignment Errors`` instance =
    { category = "RAS Port"; counter = "Alignment Errors"; instance = instance }
  /// Buffer Overrun Errors: 
  let ``Buffer Overrun Errors`` instance =
    { category = "RAS Port"; counter = "Buffer Overrun Errors"; instance = instance }
  /// Total Errors: 
  let ``Total Errors`` instance =
    { category = "RAS Port"; counter = "Total Errors"; instance = instance }
  /// Bytes Transmitted/Sec: 
  let ``Bytes Transmitted/Sec`` instance =
    { category = "RAS Port"; counter = "Bytes Transmitted/Sec"; instance = instance }
  /// Bytes Received/Sec: 
  let ``Bytes Received/Sec`` instance =
    { category = "RAS Port"; counter = "Bytes Received/Sec"; instance = instance }
  /// Frames Transmitted/Sec: 
  let ``Frames Transmitted/Sec`` instance =
    { category = "RAS Port"; counter = "Frames Transmitted/Sec"; instance = instance }
  /// Frames Received/Sec: 
  let ``Frames Received/Sec`` instance =
    { category = "RAS Port"; counter = "Frames Received/Sec"; instance = instance }
  /// Total Errors/Sec: 
  let ``Total Errors/Sec`` instance =
    { category = "RAS Port"; counter = "Total Errors/Sec"; instance = instance }

  let allCounters =
    [ ``Bytes Transmitted``
      ``Bytes Received``
      ``Frames Transmitted``
      ``Frames Received``
      ``Percent Compression Out``
      ``Percent Compression In``
      ``CRC Errors``
      ``Timeout Errors``
      ``Serial Overrun Errors``
      ``Alignment Errors``
      ``Buffer Overrun Errors``
      ``Total Errors``
      ``Bytes Transmitted/Sec``
      ``Bytes Received/Sec``
      ``Frames Transmitted/Sec``
      ``Frames Received/Sec``
      ``Total Errors/Sec``
    ]

/// RAS Total: The RAS Object Type handles all combined ports of the RAS device on your system.
///
/// This performance counter does not have instance based counters
module ``RAS Total`` =

  [<Literal>]
  let Category = "RAS Total"

  let PCC = getPCC Category
  /// Bytes Transmitted: The number of bytes transmitted total for this connection.
  let ``Bytes Transmitted`` =
    { category = "RAS Total"; counter = "Bytes Transmitted"; instance = NotApplicable }
  /// Bytes Received: The number of bytes received total for this connection.
  let ``Bytes Received`` =
    { category = "RAS Total"; counter = "Bytes Received"; instance = NotApplicable }
  /// Frames Transmitted: The number of data frames transmitted total for this connection.
  let ``Frames Transmitted`` =
    { category = "RAS Total"; counter = "Frames Transmitted"; instance = NotApplicable }
  /// Frames Received: The number of data frames received total for this connection.
  let ``Frames Received`` =
    { category = "RAS Total"; counter = "Frames Received"; instance = NotApplicable }
  /// Percent Compression Out: The compression ratio for bytes being transmitted.
  let ``Percent Compression Out`` =
    { category = "RAS Total"; counter = "Percent Compression Out"; instance = NotApplicable }
  /// Percent Compression In: The compression ratio for bytes being received.
  let ``Percent Compression In`` =
    { category = "RAS Total"; counter = "Percent Compression In"; instance = NotApplicable }
  /// CRC Errors: The total number of CRC Errors for this connection.  CRC Errors occur when the frame received contains erroneous data.
  let ``CRC Errors`` =
    { category = "RAS Total"; counter = "CRC Errors"; instance = NotApplicable }
  /// Timeout Errors: The total number of Timeout Errors for this connection.  Timeout Errors occur when an expected is not received in time.
  let ``Timeout Errors`` =
    { category = "RAS Total"; counter = "Timeout Errors"; instance = NotApplicable }
  /// Serial Overrun Errors: The total number of Serial Overrun Errors for this connection.  Serial Overrun Errors occur when the hardware cannot handle the rate at which data is received.
  let ``Serial Overrun Errors`` =
    { category = "RAS Total"; counter = "Serial Overrun Errors"; instance = NotApplicable }
  /// Alignment Errors: The total number of Alignment Errors for this connection.  Alignment Errors occur when a byte received is different from the byte expected.
  let ``Alignment Errors`` =
    { category = "RAS Total"; counter = "Alignment Errors"; instance = NotApplicable }
  /// Buffer Overrun Errors: The total number of Buffer Overrun Errors for this connection.  Buffer Overrun Errors when the software cannot handle the rate at which data is received.
  let ``Buffer Overrun Errors`` =
    { category = "RAS Total"; counter = "Buffer Overrun Errors"; instance = NotApplicable }
  /// Total Errors: The total number of CRC, Timeout, Serial Overrun, Alignment, and Buffer Overrun Errors for this connection.
  let ``Total Errors`` =
    { category = "RAS Total"; counter = "Total Errors"; instance = NotApplicable }
  /// Bytes Transmitted/Sec: The number of bytes transmitted per second.
  let ``Bytes Transmitted/Sec`` =
    { category = "RAS Total"; counter = "Bytes Transmitted/Sec"; instance = NotApplicable }
  /// Bytes Received/Sec: The number of bytes received per second.
  let ``Bytes Received/Sec`` =
    { category = "RAS Total"; counter = "Bytes Received/Sec"; instance = NotApplicable }
  /// Frames Transmitted/Sec: The number of frames transmitted per second.
  let ``Frames Transmitted/Sec`` =
    { category = "RAS Total"; counter = "Frames Transmitted/Sec"; instance = NotApplicable }
  /// Frames Received/Sec: The number of frames received per second.
  let ``Frames Received/Sec`` =
    { category = "RAS Total"; counter = "Frames Received/Sec"; instance = NotApplicable }
  /// Total Errors/Sec: The total number of CRC, Timeout, Serial Overrun, Alignment, and Buffer Overrun Errors per second.
  let ``Total Errors/Sec`` =
    { category = "RAS Total"; counter = "Total Errors/Sec"; instance = NotApplicable }
  /// Total Connections: The total number of Remote Access connections.
  let ``Total Connections`` =
    { category = "RAS Total"; counter = "Total Connections"; instance = NotApplicable }

  let allCounters =
    [ ``Bytes Transmitted``
      ``Bytes Received``
      ``Frames Transmitted``
      ``Frames Received``
      ``Percent Compression Out``
      ``Percent Compression In``
      ``CRC Errors``
      ``Timeout Errors``
      ``Serial Overrun Errors``
      ``Alignment Errors``
      ``Buffer Overrun Errors``
      ``Total Errors``
      ``Bytes Transmitted/Sec``
      ``Bytes Received/Sec``
      ``Frames Transmitted/Sec``
      ``Frames Received/Sec``
      ``Total Errors/Sec``
      ``Total Connections``
    ]

/// Redirector: The Redirector performance object consists of counter that monitor network connections originating at the local computer.
///
/// This performance counter does not have instance based counters
module ``Redirector`` =

  [<Literal>]
  let Category = "Redirector"

  let PCC = getPCC Category
  /// Bytes Total/sec: Bytes Total/sec is the rate the Redirector is processing data bytes.  This includes all application and file data in addition to protocol information such as packet headers.
  let ``Bytes Total/sec`` =
    { category = "Redirector"; counter = "Bytes Total/sec"; instance = NotApplicable }
  /// File Data Operations/sec: File Data Operations/sec is the rate at which the Redirector is processing data operations. One operation should include many bytes, since each operation has overhead. The efficiency of this path can be determined by dividing the Bytes/sec by this counter to obtain the average number of bytes transferred per operation.
  let ``File Data Operations/sec`` =
    { category = "Redirector"; counter = "File Data Operations/sec"; instance = NotApplicable }
  /// Packets/sec: Packets/sec is the rate the Redirector is processing data packets.  One packet includes (hopefully) many bytes.  We say hopefully here because each packet has protocol overhead.  You can determine the efficiency of this path by dividing the Bytes/sec by this counter to determine the average number of bytes transferred/packet.  You can also divide this counter by Operations/sec to determine the average number of packets per operation, another measure of efficiency.
  let ``Packets/sec`` =
    { category = "Redirector"; counter = "Packets/sec"; instance = NotApplicable }
  /// Bytes Received/sec: Bytes Received/sec is the rate of bytes coming in to the Redirector from the network.  It includes all application data as well as network protocol information (such as packet headers).
  let ``Bytes Received/sec`` =
    { category = "Redirector"; counter = "Bytes Received/sec"; instance = NotApplicable }
  /// Packets Received/sec: Packets Received/sec is the rate at which the Redirector is receiving packets (also called SMBs or Server Message Blocks).  Network transmissions are divided into packets.  The average number of bytes received in a packet can be obtained by dividing Bytes Received/sec by this counter.  Some packets received might not contain incoming data (for example an acknowledgment to a write made by the Redirector would count as an incoming packet).
  let ``Packets Received/sec`` =
    { category = "Redirector"; counter = "Packets Received/sec"; instance = NotApplicable }
  /// Read Bytes Paging/sec: Read Bytes Paging/sec is the rate at which the Redirector is attempting to read bytes in response to page faults.  Page faults are caused by loading of modules (such as programs and libraries), by a miss in the Cache (see Read Bytes Cache/sec), or by files directly mapped into the address space of applications (a high-performance feature of Windows NT).
  let ``Read Bytes Paging/sec`` =
    { category = "Redirector"; counter = "Read Bytes Paging/sec"; instance = NotApplicable }
  /// Read Bytes Non-Paging/sec: Read Bytes Non-Paging/sec are those bytes read by the Redirector in response to normal file requests by an application when they are redirected to come from another computer.  In addition to file requests, this counter includes other methods of reading across the network such as Named Pipes and Transactions.  This counter does not count network protocol information, just application data.
  let ``Read Bytes Non-Paging/sec`` =
    { category = "Redirector"; counter = "Read Bytes Non-Paging/sec"; instance = NotApplicable }
  /// Read Bytes Cache/sec: Read Bytes Cache/sec is the rate at which applications are accessing the file system cache by using the Redirector.  Some of these data requests are satisfied by retrieving the data from the cache.  Requests that miss the Cache cause a page fault (see Read Bytes Paging/sec).
  let ``Read Bytes Cache/sec`` =
    { category = "Redirector"; counter = "Read Bytes Cache/sec"; instance = NotApplicable }
  /// Read Bytes Network/sec: Read Bytes Network/sec is the rate at which applications are reading data across the network. This occurs when data sought in the file system cache is not found there and must be retrieved from the network.  Dividing this value by Bytes Received/sec indicates the proportion of application data traveling across the network. (see Bytes Received/sec).
  let ``Read Bytes Network/sec`` =
    { category = "Redirector"; counter = "Read Bytes Network/sec"; instance = NotApplicable }
  /// Bytes Transmitted/sec: Bytes Transmitted/sec is the rate at which bytes are leaving the Redirector to the network.  It includes all application data as well as network protocol information (such as packet headers and the like).
  let ``Bytes Transmitted/sec`` =
    { category = "Redirector"; counter = "Bytes Transmitted/sec"; instance = NotApplicable }
  /// Packets Transmitted/sec: Packets Transmitted/sec is the rate at which the Redirector is sending packets (also called SMBs or Server Message Blocks).  Network transmissions are divided into packets.  The average number of bytes transmitted in a packet can be obtained by dividing Bytes Transmitted/sec by this counter.
  let ``Packets Transmitted/sec`` =
    { category = "Redirector"; counter = "Packets Transmitted/sec"; instance = NotApplicable }
  /// Write Bytes Paging/sec: Write Bytes Paging/sec is the rate at which the Redirector is attempting to write bytes changed in the pages being used by applications.  The program data changed by modules (such as programs and libraries) that were loaded over the network are 'paged out' when no longer needed.  Other output pages come from the file system cache (see Write Bytes Cache/sec).
  let ``Write Bytes Paging/sec`` =
    { category = "Redirector"; counter = "Write Bytes Paging/sec"; instance = NotApplicable }
  /// Write Bytes Non-Paging/sec: Write Bytes Non-Paging/sec is the rate at which bytes are written by the Redirector in response to normal file outputs by an application when they are redirected to another computer.  In addition to file requests, this count includes other methods of writing across the network, such as Named Pipes and Transactions.  This counter does not count network protocol information, just application data.
  let ``Write Bytes Non-Paging/sec`` =
    { category = "Redirector"; counter = "Write Bytes Non-Paging/sec"; instance = NotApplicable }
  /// Write Bytes Cache/sec: Write Bytes Cache/sec is the rate at which applications on your computer are writing to the file system cache by using the Redirector.  The data might not leave your computer immediately; it can be retained in the cache for further modification before being written to the network.  This saves network traffic.  Each write of a byte into the cache is counted here.
  let ``Write Bytes Cache/sec`` =
    { category = "Redirector"; counter = "Write Bytes Cache/sec"; instance = NotApplicable }
  /// Write Bytes Network/sec: Write Bytes Network/sec is the rate at which applications are writing data across the network. This occurs when the file system cache is bypassed, such as for Named Pipes or Transactions, or when the cache writes the bytes to disk to make room for other data.  Dividing this counter by Bytes Transmitted/sec will indicate the proportion of application data being to the network (see Transmitted Bytes/sec).
  let ``Write Bytes Network/sec`` =
    { category = "Redirector"; counter = "Write Bytes Network/sec"; instance = NotApplicable }
  /// File Read Operations/sec: File Read Operations/sec is the rate at which applications are asking the Redirector for data. Each call to a file system or similar Application Program Interface (API) call counts as one operation.
  let ``File Read Operations/sec`` =
    { category = "Redirector"; counter = "File Read Operations/sec"; instance = NotApplicable }
  /// Read Operations Random/sec: Read Operations Random/sec counts the rate at which, on a file-by-file basis, reads are made that are not sequential.  If a read is made using a particular file handle, and then is followed by another read that is not immediately the contiguous next byte, this counter is incremented by one.
  let ``Read Operations Random/sec`` =
    { category = "Redirector"; counter = "Read Operations Random/sec"; instance = NotApplicable }
  /// Read Packets/sec: Read Packets/sec is the rate at which read packets are being placed on the network.  Each time a single packet is sent with a request to read data remotely, this counter is incremented by one.
  let ``Read Packets/sec`` =
    { category = "Redirector"; counter = "Read Packets/sec"; instance = NotApplicable }
  /// Reads Large/sec: Reads Large/sec is the rate at which reads over 2 times the server's negotiated buffer size are made by applications.  Too many of these could place a strain on server resources.  This counter is incremented once for each read. It does not count packets.
  let ``Reads Large/sec`` =
    { category = "Redirector"; counter = "Reads Large/sec"; instance = NotApplicable }
  /// Read Packets Small/sec: Read Packets Small/sec is the rate at which reads less than one-fourth of the server's negotiated buffer size are made by applications.  Too many of these could indicate a waste of buffers on the server.  This counter is incremented once for each read. It does not count packets.
  let ``Read Packets Small/sec`` =
    { category = "Redirector"; counter = "Read Packets Small/sec"; instance = NotApplicable }
  /// File Write Operations/sec: File Write Operations/sec is the rate at which applications are sending data to the Redirector. Each call to a file system or similar Application Program Interface (API) call counts as one operation.
  let ``File Write Operations/sec`` =
    { category = "Redirector"; counter = "File Write Operations/sec"; instance = NotApplicable }
  /// Write Operations Random/sec: Write Operations Random/sec is the rate at which, on a file-by-file basis, writes are made that are not sequential.  If a write is made using a particular file handle, and then is followed by another write that is not immediately the next contiguous byte, this counter is incremented by one.
  let ``Write Operations Random/sec`` =
    { category = "Redirector"; counter = "Write Operations Random/sec"; instance = NotApplicable }
  /// Write Packets/sec: Write Packets/sec is the rate at which writes are being sent to the network.  Each time a single packet is sent with a request to write remote data, this counter is incremented by one.
  let ``Write Packets/sec`` =
    { category = "Redirector"; counter = "Write Packets/sec"; instance = NotApplicable }
  /// Writes Large/sec: Writes Large/sec is the rate at which writes are made by applications that are over 2 times the server's negotiated buffer size.  Too many of these could place a strain on server resources.  This counter is incremented once for each write: it counts writes, not packets.
  let ``Writes Large/sec`` =
    { category = "Redirector"; counter = "Writes Large/sec"; instance = NotApplicable }
  /// Write Packets Small/sec: Write Packets Small/sec is the rate at which writes are made by applications that are less than one-fourth of the server's negotiated buffer size.  Too many of these could indicate a waste of buffers on the server.  This counter is incremented once for each write: it counts writes, not packets.
  let ``Write Packets Small/sec`` =
    { category = "Redirector"; counter = "Write Packets Small/sec"; instance = NotApplicable }
  /// Reads Denied/sec: Reads Denied/sec is the rate at which the server is unable to accommodate requests for Raw Reads.  When a read is much larger than the server's negotiated buffer size, the Redirector requests a Raw Read which, if granted, would permit the transfer of the data without lots of protocol overhead on each packet.  To accomplish this the server must lock out other requests, so the request is denied if the server is really busy.
  let ``Reads Denied/sec`` =
    { category = "Redirector"; counter = "Reads Denied/sec"; instance = NotApplicable }
  /// Writes Denied/sec: Writes Denied/sec is the rate at which the server is unable to accommodate requests for Raw Writes.  When a write is much larger than the server's negotiated buffer size, the Redirector requests a Raw Write which, if granted, would permit the transfer of the data without lots of protocol overhead on each packet.  To accomplish this the server must lock out other requests, so the request is denied if the server is really busy.
  let ``Writes Denied/sec`` =
    { category = "Redirector"; counter = "Writes Denied/sec"; instance = NotApplicable }
  /// Network Errors/sec: Network Errors/sec is the rate at which serious unexpected errors are occurring. Such errors generally indicate that the Redirector and one or more Servers are having serious communication difficulties. For example an SMB (Server Manager Block) protocol error is a Network Error. An entry is written to the System Event Log and provide details.
  let ``Network Errors/sec`` =
    { category = "Redirector"; counter = "Network Errors/sec"; instance = NotApplicable }
  /// Server Sessions: Server Sessions counts the total number of security objects the Redirector has managed.  For example, a logon to a server followed by a network access to the same server will establish one connection, but two sessions.
  let ``Server Sessions`` =
    { category = "Redirector"; counter = "Server Sessions"; instance = NotApplicable }
  /// Server Reconnects: Server Reconnects counts the number of times your Redirector has had to reconnect to a server in order to complete a new active request.  You can be disconnected by the Server if you remain inactive for too long.  Locally even if all your remote files are closed, the Redirector will keep your connections intact for (nominally) ten minutes.  Such inactive connections are called Dormant Connections.  Reconnecting is expensive in time.
  let ``Server Reconnects`` =
    { category = "Redirector"; counter = "Server Reconnects"; instance = NotApplicable }
  /// Connects Core: Connects Core counts the number of connections you have to servers running the original MS-Net SMB protocol, including MS-Net itself and Xenix and VAX's.
  let ``Connects Core`` =
    { category = "Redirector"; counter = "Connects Core"; instance = NotApplicable }
  /// Connects Lan Manager 2.0: Connects LAN Manager 2.0 counts connections to LAN Manager 2.0 servers, including LMX servers.
  let ``Connects Lan Manager 2.0`` =
    { category = "Redirector"; counter = "Connects Lan Manager 2.0"; instance = NotApplicable }
  /// Connects Lan Manager 2.1: Connects LAN Manager 2.1 counts connections to LAN Manager 2.1 servers, including LMX servers.
  let ``Connects Lan Manager 2.1`` =
    { category = "Redirector"; counter = "Connects Lan Manager 2.1"; instance = NotApplicable }
  /// Connects Windows NT: Connects Windows NT counts the connections to Windows 2000 or earlier computers.
  let ``Connects Windows NT`` =
    { category = "Redirector"; counter = "Connects Windows NT"; instance = NotApplicable }
  /// Server Disconnects: Server Disconnects counts the number of times a Server has disconnected your Redirector.  See also Server Reconnects.
  let ``Server Disconnects`` =
    { category = "Redirector"; counter = "Server Disconnects"; instance = NotApplicable }
  /// Server Sessions Hung: Server Sessions Hung counts the number of active sessions that are timed out and unable to proceed due to a lack of response from the remote server.
  let ``Server Sessions Hung`` =
    { category = "Redirector"; counter = "Server Sessions Hung"; instance = NotApplicable }
  /// Current Commands: Current Commands counter indicates the number of pending commands from the local computer to all destination servers.  If the Current Commands counter shows a high number and the local computer is idle, this may indicate a network-related problem or a redirector bottleneck on the local computer.
  let ``Current Commands`` =
    { category = "Redirector"; counter = "Current Commands"; instance = NotApplicable }

  let allCounters =
    [ ``Bytes Total/sec``
      ``File Data Operations/sec``
      ``Packets/sec``
      ``Bytes Received/sec``
      ``Packets Received/sec``
      ``Read Bytes Paging/sec``
      ``Read Bytes Non-Paging/sec``
      ``Read Bytes Cache/sec``
      ``Read Bytes Network/sec``
      ``Bytes Transmitted/sec``
      ``Packets Transmitted/sec``
      ``Write Bytes Paging/sec``
      ``Write Bytes Non-Paging/sec``
      ``Write Bytes Cache/sec``
      ``Write Bytes Network/sec``
      ``File Read Operations/sec``
      ``Read Operations Random/sec``
      ``Read Packets/sec``
      ``Reads Large/sec``
      ``Read Packets Small/sec``
      ``File Write Operations/sec``
      ``Write Operations Random/sec``
      ``Write Packets/sec``
      ``Writes Large/sec``
      ``Write Packets Small/sec``
      ``Reads Denied/sec``
      ``Writes Denied/sec``
      ``Network Errors/sec``
      ``Server Sessions``
      ``Server Reconnects``
      ``Connects Core``
      ``Connects Lan Manager 2.0``
      ``Connects Lan Manager 2.1``
      ``Connects Windows NT``
      ``Server Disconnects``
      ``Server Sessions Hung``
      ``Current Commands``
    ]

/// RemoteFX Graphics: The RemoteFX encoding performance object consists of counters that measure the performance of RemoteFX graphics encoding
///
/// This performance counter does not have instance based counters
module ``RemoteFX Graphics`` =

  [<Literal>]
  let Category = "RemoteFX Graphics"

  let PCC = getPCC Category
  /// Input Frames/Second: 
  let ``Input Frames/Second`` instance =
    { category = "RemoteFX Graphics"; counter = "Input Frames/Second"; instance = instance }
  /// Graphics Compression ratio: 
  let ``Graphics Compression ratio`` instance =
    { category = "RemoteFX Graphics"; counter = "Graphics Compression ratio"; instance = instance }
  /// Output Frames/Second: 
  let ``Output Frames/Second`` instance =
    { category = "RemoteFX Graphics"; counter = "Output Frames/Second"; instance = instance }
  /// Frames Skipped/Second - Insufficient Client Resources: 
  let ``Frames Skipped/Second - Insufficient Client Resources`` instance =
    { category = "RemoteFX Graphics"; counter = "Frames Skipped/Second - Insufficient Client Resources"; instance = instance }
  /// Frames Skipped/Second - Insufficient Network Resources: 
  let ``Frames Skipped/Second - Insufficient Network Resources`` instance =
    { category = "RemoteFX Graphics"; counter = "Frames Skipped/Second - Insufficient Network Resources"; instance = instance }
  /// Frames Skipped/Second - Insufficient Server Resources: 
  let ``Frames Skipped/Second - Insufficient Server Resources`` instance =
    { category = "RemoteFX Graphics"; counter = "Frames Skipped/Second - Insufficient Server Resources"; instance = instance }
  /// Frame Quality: 
  let ``Frame Quality`` instance =
    { category = "RemoteFX Graphics"; counter = "Frame Quality"; instance = instance }
  /// Average Encoding Time: 
  let ``Average Encoding Time`` instance =
    { category = "RemoteFX Graphics"; counter = "Average Encoding Time"; instance = instance }
  /// Source Frames/Second: 
  let ``Source Frames/Second`` instance =
    { category = "RemoteFX Graphics"; counter = "Source Frames/Second"; instance = instance }

  let allCounters =
    [ ``Input Frames/Second``
      ``Graphics Compression ratio``
      ``Output Frames/Second``
      ``Frames Skipped/Second - Insufficient Client Resources``
      ``Frames Skipped/Second - Insufficient Network Resources``
      ``Frames Skipped/Second - Insufficient Server Resources``
      ``Frame Quality``
      ``Average Encoding Time``
      ``Source Frames/Second``
    ]

/// RemoteFX Network: This is counter set for the per session RemoteFX network counters
///
/// This performance counter does not have instance based counters
module ``RemoteFX Network`` =

  [<Literal>]
  let Category = "RemoteFX Network"

  let PCC = getPCC Category
  /// Base TCP RTT: 
  let ``Base TCP RTT`` instance =
    { category = "RemoteFX Network"; counter = "Base TCP RTT"; instance = instance }
  /// Current TCP RTT: 
  let ``Current TCP RTT`` instance =
    { category = "RemoteFX Network"; counter = "Current TCP RTT"; instance = instance }
  /// Current TCP Bandwidth: 
  let ``Current TCP Bandwidth`` instance =
    { category = "RemoteFX Network"; counter = "Current TCP Bandwidth"; instance = instance }
  /// Total Received Rate: 
  let ``Total Received Rate`` instance =
    { category = "RemoteFX Network"; counter = "Total Received Rate"; instance = instance }
  /// TCP Received Rate: 
  let ``TCP Received Rate`` instance =
    { category = "RemoteFX Network"; counter = "TCP Received Rate"; instance = instance }
  /// UDP Received Rate: 
  let ``UDP Received Rate`` instance =
    { category = "RemoteFX Network"; counter = "UDP Received Rate"; instance = instance }
  /// UDP Packets Received/sec: 
  let ``UDP Packets Received/sec`` instance =
    { category = "RemoteFX Network"; counter = "UDP Packets Received/sec"; instance = instance }
  /// Total Sent Rate: 
  let ``Total Sent Rate`` instance =
    { category = "RemoteFX Network"; counter = "Total Sent Rate"; instance = instance }
  /// TCP Sent Rate: 
  let ``TCP Sent Rate`` instance =
    { category = "RemoteFX Network"; counter = "TCP Sent Rate"; instance = instance }
  /// UDP Sent Rate: 
  let ``UDP Sent Rate`` instance =
    { category = "RemoteFX Network"; counter = "UDP Sent Rate"; instance = instance }
  /// UDP Packets Sent/sec: 
  let ``UDP Packets Sent/sec`` instance =
    { category = "RemoteFX Network"; counter = "UDP Packets Sent/sec"; instance = instance }
  /// Sent Rate P0: 
  let ``Sent Rate P0`` instance =
    { category = "RemoteFX Network"; counter = "Sent Rate P0"; instance = instance }
  /// Sent Rate P1: 
  let ``Sent Rate P1`` instance =
    { category = "RemoteFX Network"; counter = "Sent Rate P1"; instance = instance }
  /// Sent Rate P2: 
  let ``Sent Rate P2`` instance =
    { category = "RemoteFX Network"; counter = "Sent Rate P2"; instance = instance }
  /// Sent Rate P3: 
  let ``Sent Rate P3`` instance =
    { category = "RemoteFX Network"; counter = "Sent Rate P3"; instance = instance }
  /// Loss Rate: 
  let ``Loss Rate`` instance =
    { category = "RemoteFX Network"; counter = "Loss Rate"; instance = instance }
  /// Retransmission Rate: 
  let ``Retransmission Rate`` instance =
    { category = "RemoteFX Network"; counter = "Retransmission Rate"; instance = instance }
  /// FEC Rate: 
  let ``FEC Rate`` instance =
    { category = "RemoteFX Network"; counter = "FEC Rate"; instance = instance }
  /// Base UDP RTT: 
  let ``Base UDP RTT`` instance =
    { category = "RemoteFX Network"; counter = "Base UDP RTT"; instance = instance }
  /// Current UDP RTT: 
  let ``Current UDP RTT`` instance =
    { category = "RemoteFX Network"; counter = "Current UDP RTT"; instance = instance }
  /// Current UDP Bandwidth: 
  let ``Current UDP Bandwidth`` instance =
    { category = "RemoteFX Network"; counter = "Current UDP Bandwidth"; instance = instance }

  let allCounters =
    [ ``Base TCP RTT``
      ``Current TCP RTT``
      ``Current TCP Bandwidth``
      ``Total Received Rate``
      ``TCP Received Rate``
      ``UDP Received Rate``
      ``UDP Packets Received/sec``
      ``Total Sent Rate``
      ``TCP Sent Rate``
      ``UDP Sent Rate``
      ``UDP Packets Sent/sec``
      ``Sent Rate P0``
      ``Sent Rate P1``
      ``Sent Rate P2``
      ``Sent Rate P3``
      ``Loss Rate``
      ``Retransmission Rate``
      ``FEC Rate``
      ``Base UDP RTT``
      ``Current UDP RTT``
      ``Current UDP Bandwidth``
    ]

/// ReportServer:Service: Statistics related to SQL Report Server Service
///
/// This performance counter does not have instance based counters
module ``ReportServer:Service`` =

  [<Literal>]
  let Category = "ReportServer:Service"

  let PCC = getPCC Category
  /// Requests/sec: Number of requests executed per second. This represents the current throughput of the application.
  let ``Requests/sec`` =
    { category = "ReportServer:Service"; counter = "Requests/sec"; instance = NotApplicable }
  /// Requests Total: The total number of requests received by the report server service since service start up.
  let ``Requests Total`` =
    { category = "ReportServer:Service"; counter = "Requests Total"; instance = NotApplicable }
  /// Errors/sec: Number of errors that occur during the execution of HTTP requests (error codes 400s and 500s) per second.
  let ``Errors/sec`` =
    { category = "ReportServer:Service"; counter = "Errors/sec"; instance = NotApplicable }
  /// Errors Total: The total number of errors that occur during the execution of HTTP requests (error codes 400s and 500s).
  let ``Errors Total`` =
    { category = "ReportServer:Service"; counter = "Errors Total"; instance = NotApplicable }
  /// Bytes Sent/sec: Rate of bytes sent per second.
  let ``Bytes Sent/sec`` =
    { category = "ReportServer:Service"; counter = "Bytes Sent/sec"; instance = NotApplicable }
  /// Bytes Sent Total: Number of bytes sent.
  let ``Bytes Sent Total`` =
    { category = "ReportServer:Service"; counter = "Bytes Sent Total"; instance = NotApplicable }
  /// Bytes Received/sec: Rate of bytes received per second.
  let ``Bytes Received/sec`` =
    { category = "ReportServer:Service"; counter = "Bytes Received/sec"; instance = NotApplicable }
  /// Bytes Received Total: Number of bytes received.
  let ``Bytes Received Total`` =
    { category = "ReportServer:Service"; counter = "Bytes Received Total"; instance = NotApplicable }
  /// Active Connections: Number of connections active against server.
  let ``Active Connections`` =
    { category = "ReportServer:Service"; counter = "Active Connections"; instance = NotApplicable }
  /// Logon Attempts/sec: Rate of logon attempts.
  let ``Logon Attempts/sec`` =
    { category = "ReportServer:Service"; counter = "Logon Attempts/sec"; instance = NotApplicable }
  /// Logon Attempts Total: Number of logon attempts for RSWindows* authentication types. Returns 0 for Custom authentication
  let ``Logon Attempts Total`` =
    { category = "ReportServer:Service"; counter = "Logon Attempts Total"; instance = NotApplicable }
  /// Logon Successes/sec: Rate of successful logons.
  let ``Logon Successes/sec`` =
    { category = "ReportServer:Service"; counter = "Logon Successes/sec"; instance = NotApplicable }
  /// Logon Successes Total: Number of successful logons for RSWindows* authuentication types. Returns 0 for Custom authentication.
  let ``Logon Successes Total`` =
    { category = "ReportServer:Service"; counter = "Logon Successes Total"; instance = NotApplicable }
  /// Requests Not Authorized: Number of requests failing with HTTP 401 error code.
  let ``Requests Not Authorized`` =
    { category = "ReportServer:Service"; counter = "Requests Not Authorized"; instance = NotApplicable }
  /// Requests Rejected: Total number of requests not executed because of insufficient server resources. This counter represents the number of requests that return a 503 HTTP status code, indicating that the server is too busy.
  let ``Requests Rejected`` =
    { category = "ReportServer:Service"; counter = "Requests Rejected"; instance = NotApplicable }
  /// Requests Disconnected: Number of requests that have been disconnected due to a communication failure.
  let ``Requests Disconnected`` =
    { category = "ReportServer:Service"; counter = "Requests Disconnected"; instance = NotApplicable }
  /// Requests Executing: Number of requests currently executing.
  let ``Requests Executing`` =
    { category = "ReportServer:Service"; counter = "Requests Executing"; instance = NotApplicable }
  /// Memory Pressure State: A number from 1-5 indicating the current memory state of the server. 1:No pressure, 2:Low Pressure,3:Medium Pressure,4:High Pressure,5:Exceeded Pressure.
  let ``Memory Pressure State`` =
    { category = "ReportServer:Service"; counter = "Memory Pressure State"; instance = NotApplicable }
  /// Memory Shrink Notifications/sec: Number of shrink notifications the server issued in the last second. Indicates how often the server believes it is under memory pressure.
  let ``Memory Shrink Notifications/sec`` =
    { category = "ReportServer:Service"; counter = "Memory Shrink Notifications/sec"; instance = NotApplicable }
  /// Memory Shrink Amount: Number of bytes the server requested to shrink.
  let ``Memory Shrink Amount`` =
    { category = "ReportServer:Service"; counter = "Memory Shrink Amount"; instance = NotApplicable }
  /// Tasks Queued: Tasks Queued represents the number of tasks that are waiting for a thread to become available for processing. Each request made to the report server corresponds to one or more tasks. This counter represents only the number of tasks that are ready for processing; it does not include the number of tasks that are currently running.
  let ``Tasks Queued`` =
    { category = "ReportServer:Service"; counter = "Tasks Queued"; instance = NotApplicable }

  let allCounters =
    [ ``Requests/sec``
      ``Requests Total``
      ``Errors/sec``
      ``Errors Total``
      ``Bytes Sent/sec``
      ``Bytes Sent Total``
      ``Bytes Received/sec``
      ``Bytes Received Total``
      ``Active Connections``
      ``Logon Attempts/sec``
      ``Logon Attempts Total``
      ``Logon Successes/sec``
      ``Logon Successes Total``
      ``Requests Not Authorized``
      ``Requests Rejected``
      ``Requests Disconnected``
      ``Requests Executing``
      ``Memory Pressure State``
      ``Memory Shrink Notifications/sec``
      ``Memory Shrink Amount``
      ``Tasks Queued``
    ]

/// SMB Server Sessions: This counter set displays information about SMB server sessions using SMB protocol version 2 or higher
///
/// This performance counter does not have instance based counters
module ``SMB Server Sessions`` =

  [<Literal>]
  let Category = "SMB Server Sessions"

  let PCC = getPCC Category
  /// Received Bytes/sec: 
  let ``Received Bytes/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Received Bytes/sec"; instance = instance }
  /// Requests/sec: 
  let ``Requests/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Requests/sec"; instance = instance }
  /// Tree Connect Count: 
  let ``Tree Connect Count`` instance =
    { category = "SMB Server Sessions"; counter = "Tree Connect Count"; instance = instance }
  /// Current Open File Count: 
  let ``Current Open File Count`` instance =
    { category = "SMB Server Sessions"; counter = "Current Open File Count"; instance = instance }
  /// Sent Bytes/sec: 
  let ``Sent Bytes/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Sent Bytes/sec"; instance = instance }
  /// Transferred Bytes/sec: 
  let ``Transferred Bytes/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Transferred Bytes/sec"; instance = instance }
  /// Current Pending Requests: 
  let ``Current Pending Requests`` instance =
    { category = "SMB Server Sessions"; counter = "Current Pending Requests"; instance = instance }
  /// Avg. sec/Request: 
  let ``Avg. sec/Request`` instance =
    { category = "SMB Server Sessions"; counter = "Avg. sec/Request"; instance = instance }
  /// Write Requests/sec: 
  let ``Write Requests/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Write Requests/sec"; instance = instance }
  /// Avg. sec/Write: 
  let ``Avg. sec/Write`` instance =
    { category = "SMB Server Sessions"; counter = "Avg. sec/Write"; instance = instance }
  /// Write Bytes/sec: 
  let ``Write Bytes/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Write Bytes/sec"; instance = instance }
  /// Read Requests/sec: 
  let ``Read Requests/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Read Requests/sec"; instance = instance }
  /// Avg. sec/Read: 
  let ``Avg. sec/Read`` instance =
    { category = "SMB Server Sessions"; counter = "Avg. sec/Read"; instance = instance }
  /// Read Bytes/sec: 
  let ``Read Bytes/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Read Bytes/sec"; instance = instance }
  /// Total File Open Count: 
  let ``Total File Open Count`` instance =
    { category = "SMB Server Sessions"; counter = "Total File Open Count"; instance = instance }
  /// Files Opened/sec: 
  let ``Files Opened/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Files Opened/sec"; instance = instance }
  /// Current Durable Open File Count: 
  let ``Current Durable Open File Count`` instance =
    { category = "SMB Server Sessions"; counter = "Current Durable Open File Count"; instance = instance }
  /// Total Durable Handle Reopen Count: 
  let ``Total Durable Handle Reopen Count`` instance =
    { category = "SMB Server Sessions"; counter = "Total Durable Handle Reopen Count"; instance = instance }
  /// Total Failed Durable Handle Reopen Count: 
  let ``Total Failed Durable Handle Reopen Count`` instance =
    { category = "SMB Server Sessions"; counter = "Total Failed Durable Handle Reopen Count"; instance = instance }
  /// % Resilient Handles: 
  let ``% Resilient Handles`` instance =
    { category = "SMB Server Sessions"; counter = "% Resilient Handles"; instance = instance }
  /// Total Resilient Handle Reopen Count: 
  let ``Total Resilient Handle Reopen Count`` instance =
    { category = "SMB Server Sessions"; counter = "Total Resilient Handle Reopen Count"; instance = instance }
  /// Total Failed Resilient Handle Reopen Count: 
  let ``Total Failed Resilient Handle Reopen Count`` instance =
    { category = "SMB Server Sessions"; counter = "Total Failed Resilient Handle Reopen Count"; instance = instance }
  /// % Persistent Handles: 
  let ``% Persistent Handles`` instance =
    { category = "SMB Server Sessions"; counter = "% Persistent Handles"; instance = instance }
  /// Total Persistent Handle Reopen Count: 
  let ``Total Persistent Handle Reopen Count`` instance =
    { category = "SMB Server Sessions"; counter = "Total Persistent Handle Reopen Count"; instance = instance }
  /// Total Failed Persistent Handle Reopen Count: 
  let ``Total Failed Persistent Handle Reopen Count`` instance =
    { category = "SMB Server Sessions"; counter = "Total Failed Persistent Handle Reopen Count"; instance = instance }
  /// Metadata Requests/sec: 
  let ``Metadata Requests/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Metadata Requests/sec"; instance = instance }
  /// Avg. sec/Data Request: 
  let ``Avg. sec/Data Request`` instance =
    { category = "SMB Server Sessions"; counter = "Avg. sec/Data Request"; instance = instance }
  /// Avg. Data Bytes/Request: 
  let ``Avg. Data Bytes/Request`` instance =
    { category = "SMB Server Sessions"; counter = "Avg. Data Bytes/Request"; instance = instance }
  /// Avg. Bytes/Read: 
  let ``Avg. Bytes/Read`` instance =
    { category = "SMB Server Sessions"; counter = "Avg. Bytes/Read"; instance = instance }
  /// Avg. Bytes/Write: 
  let ``Avg. Bytes/Write`` instance =
    { category = "SMB Server Sessions"; counter = "Avg. Bytes/Write"; instance = instance }
  /// Avg. Read Queue Length: 
  let ``Avg. Read Queue Length`` instance =
    { category = "SMB Server Sessions"; counter = "Avg. Read Queue Length"; instance = instance }
  /// Avg. Write Queue Length: 
  let ``Avg. Write Queue Length`` instance =
    { category = "SMB Server Sessions"; counter = "Avg. Write Queue Length"; instance = instance }
  /// Avg. Data Queue Length: 
  let ``Avg. Data Queue Length`` instance =
    { category = "SMB Server Sessions"; counter = "Avg. Data Queue Length"; instance = instance }
  /// Data Bytes/sec: 
  let ``Data Bytes/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Data Bytes/sec"; instance = instance }
  /// Data Requests/sec: 
  let ``Data Requests/sec`` instance =
    { category = "SMB Server Sessions"; counter = "Data Requests/sec"; instance = instance }
  /// Current Data Queue Length: 
  let ``Current Data Queue Length`` instance =
    { category = "SMB Server Sessions"; counter = "Current Data Queue Length"; instance = instance }

  let allCounters =
    [ ``Received Bytes/sec``
      ``Requests/sec``
      ``Tree Connect Count``
      ``Current Open File Count``
      ``Sent Bytes/sec``
      ``Transferred Bytes/sec``
      ``Current Pending Requests``
      ``Avg. sec/Request``
      ``Write Requests/sec``
      ``Avg. sec/Write``
      ``Write Bytes/sec``
      ``Read Requests/sec``
      ``Avg. sec/Read``
      ``Read Bytes/sec``
      ``Total File Open Count``
      ``Files Opened/sec``
      ``Current Durable Open File Count``
      ``Total Durable Handle Reopen Count``
      ``Total Failed Durable Handle Reopen Count``
      ``% Resilient Handles``
      ``Total Resilient Handle Reopen Count``
      ``Total Failed Resilient Handle Reopen Count``
      ``% Persistent Handles``
      ``Total Persistent Handle Reopen Count``
      ``Total Failed Persistent Handle Reopen Count``
      ``Metadata Requests/sec``
      ``Avg. sec/Data Request``
      ``Avg. Data Bytes/Request``
      ``Avg. Bytes/Read``
      ``Avg. Bytes/Write``
      ``Avg. Read Queue Length``
      ``Avg. Write Queue Length``
      ``Avg. Data Queue Length``
      ``Data Bytes/sec``
      ``Data Requests/sec``
      ``Current Data Queue Length``
    ]

/// SMB Server Shares: This counter set displays information about SMB server shares that are shared using SMB protocol version 2 or higher.
///
/// This performance counter does not have non-instance based counters
module ``SMB Server Shares`` =

  [<Literal>]
  let Category = "SMB Server Shares"

  let PCC = getPCC Category
  /// Received Bytes/sec: The rate at which bytes are being received for requests related to this share. This value includes application data as well as SMB protocol data (such as packet headers).
  let ``Received Bytes/sec`` instance =
    { category = "SMB Server Shares"; counter = "Received Bytes/sec"; instance = instance }
  /// Requests/sec: The rate at which requests are being received for this share
  let ``Requests/sec`` instance =
    { category = "SMB Server Shares"; counter = "Requests/sec"; instance = instance }
  /// Tree Connect Count: The current number of tree connects to this share
  let ``Tree Connect Count`` instance =
    { category = "SMB Server Shares"; counter = "Tree Connect Count"; instance = instance }
  /// Current Open File Count: The number of file handles that are currently open in this share
  let ``Current Open File Count`` instance =
    { category = "SMB Server Shares"; counter = "Current Open File Count"; instance = instance }
  /// Sent Bytes/sec: The rate, in seconds, at which bytes are being sent from the SMB File Server related to this share to its clients. This value includes both data bytes and protocol bytes.
  let ``Sent Bytes/sec`` instance =
    { category = "SMB Server Shares"; counter = "Sent Bytes/sec"; instance = instance }
  /// Transferred Bytes/sec: The sum of Sent Bytes/sec and Received Bytes/sec for this share.
  let ``Transferred Bytes/sec`` instance =
    { category = "SMB Server Shares"; counter = "Transferred Bytes/sec"; instance = instance }
  /// Current Pending Requests: The number of requests related to this share that are waiting to be processed by the SMB File Server.
  let ``Current Pending Requests`` instance =
    { category = "SMB Server Shares"; counter = "Current Pending Requests"; instance = instance }
  /// Avg. sec/Request: The average number of seconds that elapse between the time at which the SMB File Server receives a request for this share and the time at which the SMB File Server sends the corresponding response.
  let ``Avg. sec/Request`` instance =
    { category = "SMB Server Shares"; counter = "Avg. sec/Request"; instance = instance }
  /// Write Requests/sec: Write requests processed/sec related to this share.
  let ``Write Requests/sec`` instance =
    { category = "SMB Server Shares"; counter = "Write Requests/sec"; instance = instance }
  /// Avg. sec/Write: The average number of seconds that elapse between the time at which a write request to this share is received and the time at which the SMB File Server sends the corresponding response.
  let ``Avg. sec/Write`` instance =
    { category = "SMB Server Shares"; counter = "Avg. sec/Write"; instance = instance }
  /// Write Bytes/sec: The rate, in seconds, at which data is being written to this share.
  let ``Write Bytes/sec`` instance =
    { category = "SMB Server Shares"; counter = "Write Bytes/sec"; instance = instance }
  /// Read Requests/sec: Read requests processed/sec related to this share.
  let ``Read Requests/sec`` instance =
    { category = "SMB Server Shares"; counter = "Read Requests/sec"; instance = instance }
  /// Avg. sec/Read: The average number of seconds that elapse between the time at which a read request to this share is received and the time at which the SMB File Server sends the corresponding response.
  let ``Avg. sec/Read`` instance =
    { category = "SMB Server Shares"; counter = "Avg. sec/Read"; instance = instance }
  /// Read Bytes/sec: The rate, in seconds, at which data is being read from this share.
  let ``Read Bytes/sec`` instance =
    { category = "SMB Server Shares"; counter = "Read Bytes/sec"; instance = instance }
  /// Total File Open Count: The number of files that have been opened by the SMB File Server on behalf of its clients on this share since the server started.
  let ``Total File Open Count`` instance =
    { category = "SMB Server Shares"; counter = "Total File Open Count"; instance = instance }
  /// Files Opened/sec: The rate, in seconds, at which files are being opened for the SMB File Server’s clients on this share.
  let ``Files Opened/sec`` instance =
    { category = "SMB Server Shares"; counter = "Files Opened/sec"; instance = instance }
  /// Current Durable Open File Count: The number of durable file handles that are currently open on this share
  let ``Current Durable Open File Count`` instance =
    { category = "SMB Server Shares"; counter = "Current Durable Open File Count"; instance = instance }
  /// Total Durable Handle Reopen Count: The number of durable opens on this share that have been recovered after a temporary network disconnect since the SMB File Server started.
  let ``Total Durable Handle Reopen Count`` instance =
    { category = "SMB Server Shares"; counter = "Total Durable Handle Reopen Count"; instance = instance }
  /// Total Failed Durable Handle Reopen Count: The number of durable opens on this share that could not be recovered after a temporary network disconnect since the SMB File Server Started.
  let ``Total Failed Durable Handle Reopen Count`` instance =
    { category = "SMB Server Shares"; counter = "Total Failed Durable Handle Reopen Count"; instance = instance }
  /// % Resilient Handles: The percentage of total opens for which clients requested resiliency.
  let ``% Resilient Handles`` instance =
    { category = "SMB Server Shares"; counter = "% Resilient Handles"; instance = instance }
  /// Total Resilient Handle Reopen Count: The number of resilient opens on this share that have been recovered after a temporary network disconnect since the SMB File Server started.
  let ``Total Resilient Handle Reopen Count`` instance =
    { category = "SMB Server Shares"; counter = "Total Resilient Handle Reopen Count"; instance = instance }
  /// Total Failed Resilient Handle Reopen Count: The number of resilient opens on this share that could not be recovered after a temporary network disconnect since the SMB File Server Started.
  let ``Total Failed Resilient Handle Reopen Count`` instance =
    { category = "SMB Server Shares"; counter = "Total Failed Resilient Handle Reopen Count"; instance = instance }
  /// % Persistent Handles: The percentage of total handles for which clients requested persistency.
  let ``% Persistent Handles`` instance =
    { category = "SMB Server Shares"; counter = "% Persistent Handles"; instance = instance }
  /// Total Persistent Handle Reopen Count: The number of persistent opens on this share that have been recovered after a temporary network disconnect since the SMB File Server started.
  let ``Total Persistent Handle Reopen Count`` instance =
    { category = "SMB Server Shares"; counter = "Total Persistent Handle Reopen Count"; instance = instance }
  /// Total Failed Persistent Handle Reopen Count: The number of persistent opens on this share that could not be recovered after a temporary network disconnect since the SMB File Server Started.
  let ``Total Failed Persistent Handle Reopen Count`` instance =
    { category = "SMB Server Shares"; counter = "Total Failed Persistent Handle Reopen Count"; instance = instance }
  /// Metadata Requests/sec: The rate, in seconds, at which metadata requests are being sent to this share.
  let ``Metadata Requests/sec`` instance =
    { category = "SMB Server Shares"; counter = "Metadata Requests/sec"; instance = instance }
  /// Avg. sec/Data Request: The average number of seconds that elapse between the time at which a read or write request to this share is received and the time at which the SMB File Server processes the request.
  let ``Avg. sec/Data Request`` instance =
    { category = "SMB Server Shares"; counter = "Avg. sec/Data Request"; instance = instance }
  /// Avg. Data Bytes/Request: The average number of bytes per read or write request.
  let ``Avg. Data Bytes/Request`` instance =
    { category = "SMB Server Shares"; counter = "Avg. Data Bytes/Request"; instance = instance }
  /// Avg. Bytes/Read: The average number of bytes per read request.
  let ``Avg. Bytes/Read`` instance =
    { category = "SMB Server Shares"; counter = "Avg. Bytes/Read"; instance = instance }
  /// Avg. Bytes/Write: The average number of bytes per write request.
  let ``Avg. Bytes/Write`` instance =
    { category = "SMB Server Shares"; counter = "Avg. Bytes/Write"; instance = instance }
  /// Avg. Read Queue Length: The average number of read requests that were queued for this share.
  let ``Avg. Read Queue Length`` instance =
    { category = "SMB Server Shares"; counter = "Avg. Read Queue Length"; instance = instance }
  /// Avg. Write Queue Length: The average number of write requests that were queued for this share.
  let ``Avg. Write Queue Length`` instance =
    { category = "SMB Server Shares"; counter = "Avg. Write Queue Length"; instance = instance }
  /// Avg. Data Queue Length: The average number of read and write requests that were queued for this share.
  let ``Avg. Data Queue Length`` instance =
    { category = "SMB Server Shares"; counter = "Avg. Data Queue Length"; instance = instance }
  /// Data Bytes/sec: The rate, in seconds, at which data is being written to or read from this share.
  let ``Data Bytes/sec`` instance =
    { category = "SMB Server Shares"; counter = "Data Bytes/sec"; instance = instance }
  /// Data Requests/sec: The rate, in seconds, at which read or write requests are received for this share.
  let ``Data Requests/sec`` instance =
    { category = "SMB Server Shares"; counter = "Data Requests/sec"; instance = instance }
  /// Current Data Queue Length: The current number of read or write requests outstanding on this share.
  let ``Current Data Queue Length`` instance =
    { category = "SMB Server Shares"; counter = "Current Data Queue Length"; instance = instance }

  let allCounters =
    [ ``Received Bytes/sec``
      ``Requests/sec``
      ``Tree Connect Count``
      ``Current Open File Count``
      ``Sent Bytes/sec``
      ``Transferred Bytes/sec``
      ``Current Pending Requests``
      ``Avg. sec/Request``
      ``Write Requests/sec``
      ``Avg. sec/Write``
      ``Write Bytes/sec``
      ``Read Requests/sec``
      ``Avg. sec/Read``
      ``Read Bytes/sec``
      ``Total File Open Count``
      ``Files Opened/sec``
      ``Current Durable Open File Count``
      ``Total Durable Handle Reopen Count``
      ``Total Failed Durable Handle Reopen Count``
      ``% Resilient Handles``
      ``Total Resilient Handle Reopen Count``
      ``Total Failed Resilient Handle Reopen Count``
      ``% Persistent Handles``
      ``Total Persistent Handle Reopen Count``
      ``Total Failed Persistent Handle Reopen Count``
      ``Metadata Requests/sec``
      ``Avg. sec/Data Request``
      ``Avg. Data Bytes/Request``
      ``Avg. Bytes/Read``
      ``Avg. Bytes/Write``
      ``Avg. Read Queue Length``
      ``Avg. Write Queue Length``
      ``Avg. Data Queue Length``
      ``Data Bytes/sec``
      ``Data Requests/sec``
      ``Current Data Queue Length``
    ]

/// SMSvcHost 3.0.0.0: SMSvcHost 3.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``SMSvcHost 3_0_0_0`` =

  [<Literal>]
  let Category = "SMSvcHost 3.0.0.0"

  let PCC = getPCC Category
  /// Protocol Failures over net.tcp: The total number of failures at the protocol layer of net.tcp.
  let ``Protocol Failures over net.tcp`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Protocol Failures over net.tcp"; instance = NotApplicable }
  /// Protocol Failures over net.pipe: The total number of failures at the protocol layer of net.pipe.
  let ``Protocol Failures over net.pipe`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Protocol Failures over net.pipe"; instance = NotApplicable }
  /// Dispatch Failures over net.tcp: The total number of failures dispatching messages received over net.tcp.
  let ``Dispatch Failures over net.tcp`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Dispatch Failures over net.tcp"; instance = NotApplicable }
  /// Dispatch Failures over net.pipe: The total number of failures dispatching messages received over net.pipe.
  let ``Dispatch Failures over net.pipe`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Dispatch Failures over net.pipe"; instance = NotApplicable }
  /// Connections Dispatched over net.tcp: The total number of connections dispatched over net.tcp.
  let ``Connections Dispatched over net.tcp`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Connections Dispatched over net.tcp"; instance = NotApplicable }
  /// Connections Dispatched over net.pipe: The total number of connections dispatched over net.pipe.
  let ``Connections Dispatched over net.pipe`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Connections Dispatched over net.pipe"; instance = NotApplicable }
  /// Connections Accepted over net.tcp: The total number of TCP connections accepted over net.tcp.
  let ``Connections Accepted over net.tcp`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Connections Accepted over net.tcp"; instance = NotApplicable }
  /// Connections Accepted over net.pipe: The total number of named pipe connections accepted over net.pipe.
  let ``Connections Accepted over net.pipe`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Connections Accepted over net.pipe"; instance = NotApplicable }
  /// Registrations Active for net.tcp: The number of uri registrations currently active for net.tcp.
  let ``Registrations Active for net.tcp`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Registrations Active for net.tcp"; instance = NotApplicable }
  /// Registrations Active for net.pipe: The number of uri registrations currently active for net.pipe.
  let ``Registrations Active for net.pipe`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Registrations Active for net.pipe"; instance = NotApplicable }
  /// Uris Registered for net.tcp: The total number of uris that were succesfully registered for net.tcp.
  let ``Uris Registered for net.tcp`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Uris Registered for net.tcp"; instance = NotApplicable }
  /// Uris Registered for net.pipe: The total number of uris that were succesfully registered for net.pipe.
  let ``Uris Registered for net.pipe`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Uris Registered for net.pipe"; instance = NotApplicable }
  /// Uris Unregistered for net.tcp: The total number of uris that were succesfully unregistered for net.tcp.
  let ``Uris Unregistered for net.tcp`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Uris Unregistered for net.tcp"; instance = NotApplicable }
  /// Uris Unregistered for net.pipe: The total number of uris that were succesfully unregistered for net.pipe.
  let ``Uris Unregistered for net.pipe`` =
    { category = "SMSvcHost 3.0.0.0"; counter = "Uris Unregistered for net.pipe"; instance = NotApplicable }

  let allCounters =
    [ ``Protocol Failures over net.tcp``
      ``Protocol Failures over net.pipe``
      ``Dispatch Failures over net.tcp``
      ``Dispatch Failures over net.pipe``
      ``Connections Dispatched over net.tcp``
      ``Connections Dispatched over net.pipe``
      ``Connections Accepted over net.tcp``
      ``Connections Accepted over net.pipe``
      ``Registrations Active for net.tcp``
      ``Registrations Active for net.pipe``
      ``Uris Registered for net.tcp``
      ``Uris Registered for net.pipe``
      ``Uris Unregistered for net.tcp``
      ``Uris Unregistered for net.pipe``
    ]

/// SMSvcHost 4.0.0.0: SMSvcHost 4.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``SMSvcHost 4_0_0_0`` =

  [<Literal>]
  let Category = "SMSvcHost 4.0.0.0"

  let PCC = getPCC Category
  /// Protocol Failures over net.tcp: The total number of failures at the protocol layer of net.tcp.
  let ``Protocol Failures over net.tcp`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Protocol Failures over net.tcp"; instance = NotApplicable }
  /// Protocol Failures over net.pipe: The total number of failures at the protocol layer of net.pipe.
  let ``Protocol Failures over net.pipe`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Protocol Failures over net.pipe"; instance = NotApplicable }
  /// Dispatch Failures over net.tcp: The total number of failures dispatching messages received over net.tcp.
  let ``Dispatch Failures over net.tcp`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Dispatch Failures over net.tcp"; instance = NotApplicable }
  /// Dispatch Failures over net.pipe: The total number of failures dispatching messages received over net.pipe.
  let ``Dispatch Failures over net.pipe`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Dispatch Failures over net.pipe"; instance = NotApplicable }
  /// Connections Dispatched over net.tcp: The total number of connections dispatched over net.tcp.
  let ``Connections Dispatched over net.tcp`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Connections Dispatched over net.tcp"; instance = NotApplicable }
  /// Connections Dispatched over net.pipe: The total number of connections dispatched over net.pipe.
  let ``Connections Dispatched over net.pipe`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Connections Dispatched over net.pipe"; instance = NotApplicable }
  /// Connections Accepted over net.tcp: The total number of TCP connections accepted over net.tcp.
  let ``Connections Accepted over net.tcp`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Connections Accepted over net.tcp"; instance = NotApplicable }
  /// Connections Accepted over net.pipe: The total number of named pipe connections accepted over net.pipe.
  let ``Connections Accepted over net.pipe`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Connections Accepted over net.pipe"; instance = NotApplicable }
  /// Registrations Active for net.tcp: The number of uri registrations currently active for net.tcp.
  let ``Registrations Active for net.tcp`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Registrations Active for net.tcp"; instance = NotApplicable }
  /// Registrations Active for net.pipe: The number of uri registrations currently active for net.pipe.
  let ``Registrations Active for net.pipe`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Registrations Active for net.pipe"; instance = NotApplicable }
  /// Uris Registered for net.tcp: The total number of uris that were succesfully registered for net.tcp.
  let ``Uris Registered for net.tcp`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Uris Registered for net.tcp"; instance = NotApplicable }
  /// Uris Registered for net.pipe: The total number of uris that were succesfully registered for net.pipe.
  let ``Uris Registered for net.pipe`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Uris Registered for net.pipe"; instance = NotApplicable }
  /// Uris Unregistered for net.tcp: The total number of uris that were succesfully unregistered for net.tcp.
  let ``Uris Unregistered for net.tcp`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Uris Unregistered for net.tcp"; instance = NotApplicable }
  /// Uris Unregistered for net.pipe: The total number of uris that were succesfully unregistered for net.pipe.
  let ``Uris Unregistered for net.pipe`` =
    { category = "SMSvcHost 4.0.0.0"; counter = "Uris Unregistered for net.pipe"; instance = NotApplicable }

  let allCounters =
    [ ``Protocol Failures over net.tcp``
      ``Protocol Failures over net.pipe``
      ``Dispatch Failures over net.tcp``
      ``Dispatch Failures over net.pipe``
      ``Connections Dispatched over net.tcp``
      ``Connections Dispatched over net.pipe``
      ``Connections Accepted over net.tcp``
      ``Connections Accepted over net.pipe``
      ``Registrations Active for net.tcp``
      ``Registrations Active for net.pipe``
      ``Uris Registered for net.tcp``
      ``Uris Registered for net.pipe``
      ``Uris Unregistered for net.tcp``
      ``Uris Unregistered for net.pipe``
    ]

/// SQLAgent:Alerts: SQLAgent statistics about alerts
///
/// This performance counter does not have instance based counters
module ``SQLAgent:Alerts`` =

  [<Literal>]
  let Category = "SQLAgent:Alerts"

  let PCC = getPCC Category
  /// Activated alerts: The number of Alerts that have activated since the last SQL Server restart.
  let ``Activated alerts`` =
    { category = "SQLAgent:Alerts"; counter = "Activated alerts"; instance = NotApplicable }
  /// Alerts activated/minute: The number of Alerts that have activated within the last minute.
  let ``Alerts activated/minute`` =
    { category = "SQLAgent:Alerts"; counter = "Alerts activated/minute"; instance = NotApplicable }

  let allCounters =
    [ ``Activated alerts``
      ``Alerts activated/minute``
    ]

/// SQLAgent:JobSteps: Statistics for job steps
///
/// This performance counter does not have instance based counters
module ``SQLAgent:JobSteps`` =

  [<Literal>]
  let Category = "SQLAgent:JobSteps"

  let PCC = getPCC Category
  /// Active steps: 
  let ``Active steps`` instance =
    { category = "SQLAgent:JobSteps"; counter = "Active steps"; instance = instance }
  /// Queued steps: 
  let ``Queued steps`` instance =
    { category = "SQLAgent:JobSteps"; counter = "Queued steps"; instance = instance }
  /// Total step retries: 
  let ``Total step retries`` instance =
    { category = "SQLAgent:JobSteps"; counter = "Total step retries"; instance = instance }

  let allCounters =
    [ ``Active steps``
      ``Queued steps``
      ``Total step retries``
    ]

/// SQLAgent:Jobs: SQLAgent General Statistics about jobs
///
/// This performance counter does not have instance based counters
module ``SQLAgent:Jobs`` =

  [<Literal>]
  let Category = "SQLAgent:Jobs"

  let PCC = getPCC Category
  /// Active jobs: 
  let ``Active jobs`` instance =
    { category = "SQLAgent:Jobs"; counter = "Active jobs"; instance = instance }
  /// Successful jobs: 
  let ``Successful jobs`` instance =
    { category = "SQLAgent:Jobs"; counter = "Successful jobs"; instance = instance }
  /// Failed jobs: 
  let ``Failed jobs`` instance =
    { category = "SQLAgent:Jobs"; counter = "Failed jobs"; instance = instance }
  /// Job success rate: 
  let ``Job success rate`` instance =
    { category = "SQLAgent:Jobs"; counter = "Job success rate"; instance = instance }
  /// Successful jobs base: 
  let ``Successful jobs base`` instance =
    { category = "SQLAgent:Jobs"; counter = "Successful jobs base"; instance = instance }
  /// Jobs activated/minute: 
  let ``Jobs activated/minute`` instance =
    { category = "SQLAgent:Jobs"; counter = "Jobs activated/minute"; instance = instance }
  /// Queued jobs: 
  let ``Queued jobs`` instance =
    { category = "SQLAgent:Jobs"; counter = "Queued jobs"; instance = instance }

  let allCounters =
    [ ``Active jobs``
      ``Successful jobs``
      ``Failed jobs``
      ``Job success rate``
      ``Successful jobs base``
      ``Jobs activated/minute``
      ``Queued jobs``
    ]

/// SQLAgent:Statistics: SQLAgent general statistics
///
/// This performance counter does not have instance based counters
module ``SQLAgent:Statistics`` =

  [<Literal>]
  let Category = "SQLAgent:Statistics"

  let PCC = getPCC Category
  /// SQL Server restarted: The number of times the SQL Server has been successfully restarted by SQL Server Agent, since the last SQL Server Agent restart.
  let ``SQL Server restarted`` =
    { category = "SQLAgent:Statistics"; counter = "SQL Server restarted"; instance = NotApplicable }

  let allCounters =
    [ ``SQL Server restarted``

    ]

/// SQLServer:Access Methods: Collects statistics associated with the database server access methods
///
/// This performance counter does not have instance based counters
module ``SQLServer:Access Methods`` =

  [<Literal>]
  let Category = "SQLServer:Access Methods"

  let PCC = getPCC Category
  /// Full Scans/sec: Number of unrestricted full scans. These can either be base table or full index scans.
  let ``Full Scans/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Full Scans/sec"; instance = NotApplicable }
  /// Range Scans/sec: Number of qualified range scans through indexes per second.
  let ``Range Scans/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Range Scans/sec"; instance = NotApplicable }
  /// Probe Scans/sec: Number of probe scans per second that are used to find at most one single qualified row in an index or base table directly.
  let ``Probe Scans/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Probe Scans/sec"; instance = NotApplicable }
  /// Scan Point Revalidations/sec: Number of times the scan point had to be revalidated to continue the scan.
  let ``Scan Point Revalidations/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Scan Point Revalidations/sec"; instance = NotApplicable }
  /// Workfiles Created/sec: Number of work files created per second. For example, work files could be used to store temporary results for hash joins and hash aggregates.
  let ``Workfiles Created/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Workfiles Created/sec"; instance = NotApplicable }
  /// Worktables Created/sec: Number of work tables created per second. For example, work tables could be used to store temporary results for query spool, LOB variables, XML variables, and cursors.
  let ``Worktables Created/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Worktables Created/sec"; instance = NotApplicable }
  /// Worktables From Cache Ratio: Percentage of work tables created where the initial two pages of the work table were not allocated but were immediately available from the work table cache.
  let ``Worktables From Cache Ratio`` =
    { category = "SQLServer:Access Methods"; counter = "Worktables From Cache Ratio"; instance = NotApplicable }
  /// Worktables From Cache Base: Percent of worktables from cache base.
  let ``Worktables From Cache Base`` =
    { category = "SQLServer:Access Methods"; counter = "Worktables From Cache Base"; instance = NotApplicable }
  /// Forwarded Records/sec: Number of records fetched through forwarded record pointers.
  let ``Forwarded Records/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Forwarded Records/sec"; instance = NotApplicable }
  /// Skipped Ghosted Records/sec: Number of ghosted records per second skipped during scans.
  let ``Skipped Ghosted Records/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Skipped Ghosted Records/sec"; instance = NotApplicable }
  /// Index Searches/sec: Number of index searches. Index searches are used to start range scans, single index record fetches, and to reposition within an index.
  let ``Index Searches/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Index Searches/sec"; instance = NotApplicable }
  /// FreeSpace Scans/sec: Number of scans per second that were initiated to search for free space within pages already allocated to an allocation unit to insert or modify record fragments. Each scan may find multiple pages.
  let ``FreeSpace Scans/sec`` =
    { category = "SQLServer:Access Methods"; counter = "FreeSpace Scans/sec"; instance = NotApplicable }
  /// FreeSpace Page Fetches/sec: Number of pages fetched per second by free space scans. These scans search for free space within pages already allocated to an allocation unit, to satisfy requests to insert or modify record fragments.
  let ``FreeSpace Page Fetches/sec`` =
    { category = "SQLServer:Access Methods"; counter = "FreeSpace Page Fetches/sec"; instance = NotApplicable }
  /// Pages Allocated/sec: Number of pages allocated per second in all databases in this SQL Server instance. These include pages allocations from both mixed extents and uniform extents.
  let ``Pages Allocated/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Pages Allocated/sec"; instance = NotApplicable }
  /// Extents Allocated/sec: Number of extents allocated per second in all databases in this SQL Server instance.
  let ``Extents Allocated/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Extents Allocated/sec"; instance = NotApplicable }
  /// Mixed page allocations/sec: Number of pages allocated per second from mixed extents. These could be used for storing the IAM pages and the first eight pages that are allocated to an allocation unit.
  let ``Mixed page allocations/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Mixed page allocations/sec"; instance = NotApplicable }
  /// Extent Deallocations/sec: Number of extents deallocated per second in all databases in this SQL Server instance.
  let ``Extent Deallocations/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Extent Deallocations/sec"; instance = NotApplicable }
  /// Page Deallocations/sec: Number of pages deallocated per second in all databases in this SQL Server instance. These include pages from mixed extents and uniform extents.
  let ``Page Deallocations/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Page Deallocations/sec"; instance = NotApplicable }
  /// Page Splits/sec: Number of page splits per second that occur as a result of overflowing index pages.
  let ``Page Splits/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Page Splits/sec"; instance = NotApplicable }
  /// Table Lock Escalations/sec: The number of times locks on a table were escalated.
  let ``Table Lock Escalations/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Table Lock Escalations/sec"; instance = NotApplicable }
  /// Deferred Dropped rowsets: The number of rowsets created as a result of aborted online index build operations that are waiting to be dropped by the background task that cleans up deferred dropped rowsets.
  let ``Deferred Dropped rowsets`` =
    { category = "SQLServer:Access Methods"; counter = "Deferred Dropped rowsets"; instance = NotApplicable }
  /// Dropped rowset cleanups/sec: The number of rowsets per second created as a result of aborted online index build operations that were successfully dropped by the background task that cleans up deferred dropped rowsets.
  let ``Dropped rowset cleanups/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Dropped rowset cleanups/sec"; instance = NotApplicable }
  /// Dropped rowsets skipped/sec: The number of rowsets per second created as a result of aborted online index build operations that were skipped by the background task that cleans up deferred dropped rowsets created.
  let ``Dropped rowsets skipped/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Dropped rowsets skipped/sec"; instance = NotApplicable }
  /// Deferred dropped AUs: The number of allocation units waiting to be dropped by the background task that cleans up deferred dropped allocation units.
  let ``Deferred dropped AUs`` =
    { category = "SQLServer:Access Methods"; counter = "Deferred dropped AUs"; instance = NotApplicable }
  /// AU cleanups/sec: The number of allocation units per second that were successfully dropped by the background task that cleans up deferred dropped allocation units. Each allocation unit drop requires multiple batches.
  let ``AU cleanups/sec`` =
    { category = "SQLServer:Access Methods"; counter = "AU cleanups/sec"; instance = NotApplicable }
  /// AU cleanup batches/sec: The number of batches that completed successfully per second by the background task that cleans up deferred dropped allocation units.
  let ``AU cleanup batches/sec`` =
    { category = "SQLServer:Access Methods"; counter = "AU cleanup batches/sec"; instance = NotApplicable }
  /// Failed AU cleanup batches/sec: The number of batches per second that failed and required retry, by the background task that cleans up deferred dropped allocation units. Failure could be due to lack of memory or disk space, hardware failure and other reasons.
  let ``Failed AU cleanup batches/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Failed AU cleanup batches/sec"; instance = NotApplicable }
  /// Used tree page cookie: Number of times a tree page cookie was used successfully during an index search since no change happened on the parent page of the tree page. The cookie is used to speed up index search.
  let ``Used tree page cookie`` =
    { category = "SQLServer:Access Methods"; counter = "Used tree page cookie"; instance = NotApplicable }
  /// Failed tree page cookie: The number of times that a tree page cookie could not be used during an index search since changes happened on the parent pages of those tree pages. The cookie is used to speed up index search.
  let ``Failed tree page cookie`` =
    { category = "SQLServer:Access Methods"; counter = "Failed tree page cookie"; instance = NotApplicable }
  /// Used leaf page cookie: Number of times a leaf page cookie was used successfully during an index search since no change happened on the leaf page. The cookie is used to speed up index search.
  let ``Used leaf page cookie`` =
    { category = "SQLServer:Access Methods"; counter = "Used leaf page cookie"; instance = NotApplicable }
  /// Failed leaf page cookie: The number of times that a leaf page cookie could not be used during an index search since changes happened on the leaf page. The cookie is used to speed up index search.
  let ``Failed leaf page cookie`` =
    { category = "SQLServer:Access Methods"; counter = "Failed leaf page cookie"; instance = NotApplicable }
  /// LobSS Provider Create Count: Count of LOB Storage Service Providers created. One worktable created per LOB Storage Service Provider.
  let ``LobSS Provider Create Count`` =
    { category = "SQLServer:Access Methods"; counter = "LobSS Provider Create Count"; instance = NotApplicable }
  /// LobSS Provider Destroy Count: Count of LOB Storage Service Providers destroyed.
  let ``LobSS Provider Destroy Count`` =
    { category = "SQLServer:Access Methods"; counter = "LobSS Provider Destroy Count"; instance = NotApplicable }
  /// LobSS Provider Truncation Count: Count of LOB Storage Service Providers truncated.
  let ``LobSS Provider Truncation Count`` =
    { category = "SQLServer:Access Methods"; counter = "LobSS Provider Truncation Count"; instance = NotApplicable }
  /// LobHandle Create Count: Count of temporary LOBs created.
  let ``LobHandle Create Count`` =
    { category = "SQLServer:Access Methods"; counter = "LobHandle Create Count"; instance = NotApplicable }
  /// LobHandle Destroy Count: Count of temporary LOBs destroyed.
  let ``LobHandle Destroy Count`` =
    { category = "SQLServer:Access Methods"; counter = "LobHandle Destroy Count"; instance = NotApplicable }
  /// By-reference Lob Create Count: Count of large object (LOB) values that were passed by reference. By-reference lobs are used in certain bulk operations to avoid the cost of passing them by value.
  let ``By-reference Lob Create Count`` =
    { category = "SQLServer:Access Methods"; counter = "By-reference Lob Create Count"; instance = NotApplicable }
  /// By-reference Lob Use Count: Count of by-reference lob values that were used. By-reference lobs are used in certain bulk operations to avoid the cost of passing them by value.
  let ``By-reference Lob Use Count`` =
    { category = "SQLServer:Access Methods"; counter = "By-reference Lob Use Count"; instance = NotApplicable }
  /// Count Push Off Row: Count of values that were pushed from in-row to off-row.
  let ``Count Push Off Row`` =
    { category = "SQLServer:Access Methods"; counter = "Count Push Off Row"; instance = NotApplicable }
  /// Count Pull In Row: Count of values that were pulled in-row from off-row.
  let ``Count Pull In Row`` =
    { category = "SQLServer:Access Methods"; counter = "Count Pull In Row"; instance = NotApplicable }
  /// Count Lob Readahead: Count of lob pages on which readahead was issued.
  let ``Count Lob Readahead`` =
    { category = "SQLServer:Access Methods"; counter = "Count Lob Readahead"; instance = NotApplicable }
  /// Page compression attempts/sec: Number of attempts to compress a database page per second
  let ``Page compression attempts/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Page compression attempts/sec"; instance = NotApplicable }
  /// Pages compressed/sec: Number of times a database page was compressed
  let ``Pages compressed/sec`` =
    { category = "SQLServer:Access Methods"; counter = "Pages compressed/sec"; instance = NotApplicable }
  /// InSysXact waits/sec: Number of times a reader needs to wait for a page because the InSysXact bit is set
  let ``InSysXact waits/sec`` =
    { category = "SQLServer:Access Methods"; counter = "InSysXact waits/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Full Scans/sec``
      ``Range Scans/sec``
      ``Probe Scans/sec``
      ``Scan Point Revalidations/sec``
      ``Workfiles Created/sec``
      ``Worktables Created/sec``
      ``Worktables From Cache Ratio``
      ``Worktables From Cache Base``
      ``Forwarded Records/sec``
      ``Skipped Ghosted Records/sec``
      ``Index Searches/sec``
      ``FreeSpace Scans/sec``
      ``FreeSpace Page Fetches/sec``
      ``Pages Allocated/sec``
      ``Extents Allocated/sec``
      ``Mixed page allocations/sec``
      ``Extent Deallocations/sec``
      ``Page Deallocations/sec``
      ``Page Splits/sec``
      ``Table Lock Escalations/sec``
      ``Deferred Dropped rowsets``
      ``Dropped rowset cleanups/sec``
      ``Dropped rowsets skipped/sec``
      ``Deferred dropped AUs``
      ``AU cleanups/sec``
      ``AU cleanup batches/sec``
      ``Failed AU cleanup batches/sec``
      ``Used tree page cookie``
      ``Failed tree page cookie``
      ``Used leaf page cookie``
      ``Failed leaf page cookie``
      ``LobSS Provider Create Count``
      ``LobSS Provider Destroy Count``
      ``LobSS Provider Truncation Count``
      ``LobHandle Create Count``
      ``LobHandle Destroy Count``
      ``By-reference Lob Create Count``
      ``By-reference Lob Use Count``
      ``Count Push Off Row``
      ``Count Pull In Row``
      ``Count Lob Readahead``
      ``Page compression attempts/sec``
      ``Pages compressed/sec``
      ``InSysXact waits/sec``
    ]

/// SQLServer:Availability Replica: This defines a HADR availability replica object for SQL Server
///
/// This performance counter does not have instance based counters
module ``SQLServer:Availability Replica`` =

  [<Literal>]
  let Category = "SQLServer:Availability Replica"

  let PCC = getPCC Category
  /// Bytes Sent to Replica/sec: 
  let ``Bytes Sent to Replica/sec`` instance =
    { category = "SQLServer:Availability Replica"; counter = "Bytes Sent to Replica/sec"; instance = instance }
  /// Sends to Replica/sec: 
  let ``Sends to Replica/sec`` instance =
    { category = "SQLServer:Availability Replica"; counter = "Sends to Replica/sec"; instance = instance }
  /// Bytes Sent to Transport/sec: 
  let ``Bytes Sent to Transport/sec`` instance =
    { category = "SQLServer:Availability Replica"; counter = "Bytes Sent to Transport/sec"; instance = instance }
  /// Sends to Transport/sec: 
  let ``Sends to Transport/sec`` instance =
    { category = "SQLServer:Availability Replica"; counter = "Sends to Transport/sec"; instance = instance }
  /// Bytes Received from Replica/sec: 
  let ``Bytes Received from Replica/sec`` instance =
    { category = "SQLServer:Availability Replica"; counter = "Bytes Received from Replica/sec"; instance = instance }
  /// Receives from Replica/sec: 
  let ``Receives from Replica/sec`` instance =
    { category = "SQLServer:Availability Replica"; counter = "Receives from Replica/sec"; instance = instance }
  /// Flow Control Time (ms/sec): 
  let ``Flow Control Time (ms/sec)`` instance =
    { category = "SQLServer:Availability Replica"; counter = "Flow Control Time (ms/sec)"; instance = instance }
  /// Flow Control/sec: 
  let ``Flow Control/sec`` instance =
    { category = "SQLServer:Availability Replica"; counter = "Flow Control/sec"; instance = instance }
  /// Resent Messages/sec: 
  let ``Resent Messages/sec`` instance =
    { category = "SQLServer:Availability Replica"; counter = "Resent Messages/sec"; instance = instance }

  let allCounters =
    [ ``Bytes Sent to Replica/sec``
      ``Sends to Replica/sec``
      ``Bytes Sent to Transport/sec``
      ``Sends to Transport/sec``
      ``Bytes Received from Replica/sec``
      ``Receives from Replica/sec``
      ``Flow Control Time (ms/sec)``
      ``Flow Control/sec``
      ``Resent Messages/sec``
    ]

/// SQLServer:Backup Device: This defines a backup device object for SQL Server
///
/// This performance counter does not have instance based counters
module ``SQLServer:Backup Device`` =

  [<Literal>]
  let Category = "SQLServer:Backup Device"

  let PCC = getPCC Category
  /// Device Throughput Bytes/sec: 
  let ``Device Throughput Bytes/sec`` instance =
    { category = "SQLServer:Backup Device"; counter = "Device Throughput Bytes/sec"; instance = instance }

  let allCounters =
    [ ``Device Throughput Bytes/sec``

    ]

/// SQLServer:Batch Resp Statistics: Counters to track SQL Batch Response times
///
/// This performance counter does not have instance based counters
module ``SQLServer:Batch Resp Statistics`` =

  [<Literal>]
  let Category = "SQLServer:Batch Resp Statistics"

  let PCC = getPCC Category
  /// Batches >=000000ms & <000001ms: 
  let ``Batches >=000000ms & <000001ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=000000ms & <000001ms"; instance = instance }
  /// Batches >=000001ms & <000002ms: 
  let ``Batches >=000001ms & <000002ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=000001ms & <000002ms"; instance = instance }
  /// Batches >=000002ms & <000005ms: 
  let ``Batches >=000002ms & <000005ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=000002ms & <000005ms"; instance = instance }
  /// Batches >=000005ms & <000010ms: 
  let ``Batches >=000005ms & <000010ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=000005ms & <000010ms"; instance = instance }
  /// Batches >=000010ms & <000020ms: 
  let ``Batches >=000010ms & <000020ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=000010ms & <000020ms"; instance = instance }
  /// Batches >=000020ms & <000050ms: 
  let ``Batches >=000020ms & <000050ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=000020ms & <000050ms"; instance = instance }
  /// Batches >=000050ms & <000100ms: 
  let ``Batches >=000050ms & <000100ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=000050ms & <000100ms"; instance = instance }
  /// Batches >=000100ms & <000200ms: 
  let ``Batches >=000100ms & <000200ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=000100ms & <000200ms"; instance = instance }
  /// Batches >=000200ms & <000500ms: 
  let ``Batches >=000200ms & <000500ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=000200ms & <000500ms"; instance = instance }
  /// Batches >=000500ms & <001000ms: 
  let ``Batches >=000500ms & <001000ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=000500ms & <001000ms"; instance = instance }
  /// Batches >=001000ms & <002000ms: 
  let ``Batches >=001000ms & <002000ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=001000ms & <002000ms"; instance = instance }
  /// Batches >=002000ms & <005000ms: 
  let ``Batches >=002000ms & <005000ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=002000ms & <005000ms"; instance = instance }
  /// Batches >=005000ms & <010000ms: 
  let ``Batches >=005000ms & <010000ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=005000ms & <010000ms"; instance = instance }
  /// Batches >=010000ms & <020000ms: 
  let ``Batches >=010000ms & <020000ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=010000ms & <020000ms"; instance = instance }
  /// Batches >=020000ms & <050000ms: 
  let ``Batches >=020000ms & <050000ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=020000ms & <050000ms"; instance = instance }
  /// Batches >=050000ms & <100000ms: 
  let ``Batches >=050000ms & <100000ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=050000ms & <100000ms"; instance = instance }
  /// Batches >=100000ms: 
  let ``Batches >=100000ms`` instance =
    { category = "SQLServer:Batch Resp Statistics"; counter = "Batches >=100000ms"; instance = instance }

  let allCounters =
    [ ``Batches >=000000ms & <000001ms``
      ``Batches >=000001ms & <000002ms``
      ``Batches >=000002ms & <000005ms``
      ``Batches >=000005ms & <000010ms``
      ``Batches >=000010ms & <000020ms``
      ``Batches >=000020ms & <000050ms``
      ``Batches >=000050ms & <000100ms``
      ``Batches >=000100ms & <000200ms``
      ``Batches >=000200ms & <000500ms``
      ``Batches >=000500ms & <001000ms``
      ``Batches >=001000ms & <002000ms``
      ``Batches >=002000ms & <005000ms``
      ``Batches >=005000ms & <010000ms``
      ``Batches >=010000ms & <020000ms``
      ``Batches >=020000ms & <050000ms``
      ``Batches >=050000ms & <100000ms``
      ``Batches >=100000ms``
    ]

/// SQLServer:Broker Activation: Service Broker Activation
///
/// This performance counter does not have instance based counters
module ``SQLServer:Broker Activation`` =

  [<Literal>]
  let Category = "SQLServer:Broker Activation"

  let PCC = getPCC Category
  /// Tasks Started/sec: 
  let ``Tasks Started/sec`` instance =
    { category = "SQLServer:Broker Activation"; counter = "Tasks Started/sec"; instance = instance }
  /// Tasks Running: 
  let ``Tasks Running`` instance =
    { category = "SQLServer:Broker Activation"; counter = "Tasks Running"; instance = instance }
  /// Tasks Aborted/sec: 
  let ``Tasks Aborted/sec`` instance =
    { category = "SQLServer:Broker Activation"; counter = "Tasks Aborted/sec"; instance = instance }
  /// Task Limit Reached/sec: 
  let ``Task Limit Reached/sec`` instance =
    { category = "SQLServer:Broker Activation"; counter = "Task Limit Reached/sec"; instance = instance }
  /// Task Limit Reached: 
  let ``Task Limit Reached`` instance =
    { category = "SQLServer:Broker Activation"; counter = "Task Limit Reached"; instance = instance }
  /// Stored Procedures Invoked/sec: 
  let ``Stored Procedures Invoked/sec`` instance =
    { category = "SQLServer:Broker Activation"; counter = "Stored Procedures Invoked/sec"; instance = instance }

  let allCounters =
    [ ``Tasks Started/sec``
      ``Tasks Running``
      ``Tasks Aborted/sec``
      ``Task Limit Reached/sec``
      ``Task Limit Reached``
      ``Stored Procedures Invoked/sec``
    ]

/// SQLServer:Broker Statistics: Service Broker Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Broker Statistics`` =

  [<Literal>]
  let Category = "SQLServer:Broker Statistics"

  let PCC = getPCC Category
  /// SQL SENDs/sec: The number of SQL SEND commands processed by the Broker per second.
  let ``SQL SENDs/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "SQL SENDs/sec"; instance = NotApplicable }
  /// SQL SEND Total: Total number of SQL SEND commands processed by the Broker.
  let ``SQL SEND Total`` =
    { category = "SQLServer:Broker Statistics"; counter = "SQL SEND Total"; instance = NotApplicable }
  /// SQL RECEIVEs/sec: The number of SQL RECEIVE commands processed by the Broker per second.
  let ``SQL RECEIVEs/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "SQL RECEIVEs/sec"; instance = NotApplicable }
  /// SQL RECEIVE Total: Total number of SQL RECEIVE commands processed by the Broker.
  let ``SQL RECEIVE Total`` =
    { category = "SQLServer:Broker Statistics"; counter = "SQL RECEIVE Total"; instance = NotApplicable }
  /// Broker Transaction Rollbacks: The number of Service Broker related transactions that have rolled back.
  let ``Broker Transaction Rollbacks`` =
    { category = "SQLServer:Broker Statistics"; counter = "Broker Transaction Rollbacks"; instance = NotApplicable }
  /// Dialog Timer Event Count: The number of dialog endpoint related timer events in the Broker.
  let ``Dialog Timer Event Count`` =
    { category = "SQLServer:Broker Statistics"; counter = "Dialog Timer Event Count"; instance = NotApplicable }
  /// Enqueued Messages/sec: The number of messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued Messages/sec"; instance = NotApplicable }
  /// Enqueued P1 Messages/sec: The number of priority 1 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P1 Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued P1 Messages/sec"; instance = NotApplicable }
  /// Enqueued P2 Messages/sec: The number of priority 2 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P2 Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued P2 Messages/sec"; instance = NotApplicable }
  /// Enqueued P3 Messages/sec: The number of priority 3 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P3 Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued P3 Messages/sec"; instance = NotApplicable }
  /// Enqueued P4 Messages/sec: The number of priority 4 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P4 Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued P4 Messages/sec"; instance = NotApplicable }
  /// Enqueued P5 Messages/sec: The number of priority 5 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P5 Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued P5 Messages/sec"; instance = NotApplicable }
  /// Enqueued P6 Messages/sec: The number of priority 6 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P6 Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued P6 Messages/sec"; instance = NotApplicable }
  /// Enqueued P7 Messages/sec: The number of priority 7 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P7 Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued P7 Messages/sec"; instance = NotApplicable }
  /// Enqueued P8 Messages/sec: The number of priority 8 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P8 Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued P8 Messages/sec"; instance = NotApplicable }
  /// Enqueued P9 Messages/sec: The number of priority 9 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P9 Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued P9 Messages/sec"; instance = NotApplicable }
  /// Enqueued P10 Messages/sec: The number of priority 10 messages from local endpoints and the transport that are successfully delivered into local target queues per second.
  let ``Enqueued P10 Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued P10 Messages/sec"; instance = NotApplicable }
  /// Enqueued Local Messages/sec: The number of messages from local endpoints that are successfully delivered directly into local target queues per second.
  let ``Enqueued Local Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued Local Messages/sec"; instance = NotApplicable }
  /// Enqueued Transport Msgs/sec: The number of messages from the transport that are successfully delivered into local target queues per second. This includes all messages from remote endpoints and messages from local endpoints which go through the transport.
  let ``Enqueued Transport Msgs/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued Transport Msgs/sec"; instance = NotApplicable }
  /// Enqueued Transport Msg Frags/sec: The number of message fragments from the transport that are successfully delivered into local target queues per second. Note that the message can be marked as disabled if it is incomplete and/or out of order.
  let ``Enqueued Transport Msg Frags/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued Transport Msg Frags/sec"; instance = NotApplicable }
  /// Enqueued Messages Total: Total number of messages from local endpoints and the transport that are successfully delivered into local target queues.
  let ``Enqueued Messages Total`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued Messages Total"; instance = NotApplicable }
  /// Enqueued Local Messages Total: Total number of messages from local endpoints that are successfully delivered directly into local target queues.
  let ``Enqueued Local Messages Total`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued Local Messages Total"; instance = NotApplicable }
  /// Enqueued Transport Msgs Total: Total number of messages from the transport that are successfully delivered into local target queues. This includes all messages from remote endpoints and messages from local endpoints which go through the transport.
  let ``Enqueued Transport Msgs Total`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued Transport Msgs Total"; instance = NotApplicable }
  /// Enqueued Transport Msg Frag Tot: Total number of message fragments from the transport that are successfully delivered into local target queues. Note that the message can be marked as disabled if it is incomplete and/or out of order.
  let ``Enqueued Transport Msg Frag Tot`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued Transport Msg Frag Tot"; instance = NotApplicable }
  /// Forwarded Pending Msg Count: The number of forwarded messages that have not been successfully sent yet.
  let ``Forwarded Pending Msg Count`` =
    { category = "SQLServer:Broker Statistics"; counter = "Forwarded Pending Msg Count"; instance = NotApplicable }
  /// Forwarded Pending Msg Bytes: The number of forwarded message bytes that have not been successfully sent yet.
  let ``Forwarded Pending Msg Bytes`` =
    { category = "SQLServer:Broker Statistics"; counter = "Forwarded Pending Msg Bytes"; instance = NotApplicable }
  /// Forwarded Msgs Discarded/sec: The number of forwarded messages that were discarded per second due to forwarded message memory limits, age limits, etc.
  let ``Forwarded Msgs Discarded/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Forwarded Msgs Discarded/sec"; instance = NotApplicable }
  /// Forwarded Msg Discarded Total: Total number of forwarded messages discarded due to forwarded message memory limits, age limits, etc.
  let ``Forwarded Msg Discarded Total`` =
    { category = "SQLServer:Broker Statistics"; counter = "Forwarded Msg Discarded Total"; instance = NotApplicable }
  /// Forwarded Messages/sec: The number of forwarded messages successfully sent per second.
  let ``Forwarded Messages/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Forwarded Messages/sec"; instance = NotApplicable }
  /// Forwarded Messages Total: Total number of forwarded messages successfully sent.
  let ``Forwarded Messages Total`` =
    { category = "SQLServer:Broker Statistics"; counter = "Forwarded Messages Total"; instance = NotApplicable }
  /// Forwarded Msg Bytes/sec: The number of forwarded message bytes successfully sent per second.
  let ``Forwarded Msg Bytes/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Forwarded Msg Bytes/sec"; instance = NotApplicable }
  /// Forwarded Msg Byte Total: Total number of forwarded message bytes successfully sent.
  let ``Forwarded Msg Byte Total`` =
    { category = "SQLServer:Broker Statistics"; counter = "Forwarded Msg Byte Total"; instance = NotApplicable }
  /// Enqueued TransmissionQ Msgs/sec: The number of messages that have been placed into the broker transmission queue per second.
  let ``Enqueued TransmissionQ Msgs/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Enqueued TransmissionQ Msgs/sec"; instance = NotApplicable }
  /// Dequeued TransmissionQ Msgs/sec: The number of messages that have been removed from the broker transmission queue per second.
  let ``Dequeued TransmissionQ Msgs/sec`` =
    { category = "SQLServer:Broker Statistics"; counter = "Dequeued TransmissionQ Msgs/sec"; instance = NotApplicable }
  /// Dropped Messages Total: The number of messages that were received in the instance but could not be delivered.
  let ``Dropped Messages Total`` =
    { category = "SQLServer:Broker Statistics"; counter = "Dropped Messages Total"; instance = NotApplicable }
  /// Corrupted Messages Total: The number of corrupted messages that were received in the instance.
  let ``Corrupted Messages Total`` =
    { category = "SQLServer:Broker Statistics"; counter = "Corrupted Messages Total"; instance = NotApplicable }
  /// Activation Errors Total: The number of times an activation stored procedure exited with an error.
  let ``Activation Errors Total`` =
    { category = "SQLServer:Broker Statistics"; counter = "Activation Errors Total"; instance = NotApplicable }

  let allCounters =
    [ ``SQL SENDs/sec``
      ``SQL SEND Total``
      ``SQL RECEIVEs/sec``
      ``SQL RECEIVE Total``
      ``Broker Transaction Rollbacks``
      ``Dialog Timer Event Count``
      ``Enqueued Messages/sec``
      ``Enqueued P1 Messages/sec``
      ``Enqueued P2 Messages/sec``
      ``Enqueued P3 Messages/sec``
      ``Enqueued P4 Messages/sec``
      ``Enqueued P5 Messages/sec``
      ``Enqueued P6 Messages/sec``
      ``Enqueued P7 Messages/sec``
      ``Enqueued P8 Messages/sec``
      ``Enqueued P9 Messages/sec``
      ``Enqueued P10 Messages/sec``
      ``Enqueued Local Messages/sec``
      ``Enqueued Transport Msgs/sec``
      ``Enqueued Transport Msg Frags/sec``
      ``Enqueued Messages Total``
      ``Enqueued Local Messages Total``
      ``Enqueued Transport Msgs Total``
      ``Enqueued Transport Msg Frag Tot``
      ``Forwarded Pending Msg Count``
      ``Forwarded Pending Msg Bytes``
      ``Forwarded Msgs Discarded/sec``
      ``Forwarded Msg Discarded Total``
      ``Forwarded Messages/sec``
      ``Forwarded Messages Total``
      ``Forwarded Msg Bytes/sec``
      ``Forwarded Msg Byte Total``
      ``Enqueued TransmissionQ Msgs/sec``
      ``Dequeued TransmissionQ Msgs/sec``
      ``Dropped Messages Total``
      ``Corrupted Messages Total``
      ``Activation Errors Total``
    ]

/// SQLServer:Broker TO Statistics: Service Broker Transmission Object Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Broker TO Statistics`` =

  [<Literal>]
  let Category = "SQLServer:Broker TO Statistics"

  let PCC = getPCC Category
  /// Transmission Obj Gets/Sec: The number of Transmission Objects requested per second.
  let ``Transmission Obj Gets/Sec`` =
    { category = "SQLServer:Broker TO Statistics"; counter = "Transmission Obj Gets/Sec"; instance = NotApplicable }
  /// Transmission Obj Set Dirty/Sec: The number of Transmission Objects marked dirty per second.
  let ``Transmission Obj Set Dirty/Sec`` =
    { category = "SQLServer:Broker TO Statistics"; counter = "Transmission Obj Set Dirty/Sec"; instance = NotApplicable }
  /// Transmission Obj Writes/Sec: The number of Transmission Objects saved per second.
  let ``Transmission Obj Writes/Sec`` =
    { category = "SQLServer:Broker TO Statistics"; counter = "Transmission Obj Writes/Sec"; instance = NotApplicable }
  /// Avg. Length of Batched Writes: Average Number of Transmission Objects saved in a batch.
  let ``Avg. Length of Batched Writes`` =
    { category = "SQLServer:Broker TO Statistics"; counter = "Avg. Length of Batched Writes"; instance = NotApplicable }
  /// Avg. Length of Batched Writes BS: Average Number of Transmission Objects saved in a batch.
  let ``Avg. Length of Batched Writes BS`` =
    { category = "SQLServer:Broker TO Statistics"; counter = "Avg. Length of Batched Writes BS"; instance = NotApplicable }
  /// Avg. Time to Write Batch (ms): Average time to save a Transmission Object batch.
  let ``Avg. Time to Write Batch (ms)`` =
    { category = "SQLServer:Broker TO Statistics"; counter = "Avg. Time to Write Batch (ms)"; instance = NotApplicable }
  /// Avg. Time to Write Batch Base: Average time to save a Transmission Object batch.
  let ``Avg. Time to Write Batch Base`` =
    { category = "SQLServer:Broker TO Statistics"; counter = "Avg. Time to Write Batch Base"; instance = NotApplicable }
  /// Avg. Time Between Batches (ms): Average time between Transmission Object batch flushes.
  let ``Avg. Time Between Batches (ms)`` =
    { category = "SQLServer:Broker TO Statistics"; counter = "Avg. Time Between Batches (ms)"; instance = NotApplicable }
  /// Avg. Time Between Batches Base: Average time between Transmission Object batch flushes.
  let ``Avg. Time Between Batches Base`` =
    { category = "SQLServer:Broker TO Statistics"; counter = "Avg. Time Between Batches Base"; instance = NotApplicable }

  let allCounters =
    [ ``Transmission Obj Gets/Sec``
      ``Transmission Obj Set Dirty/Sec``
      ``Transmission Obj Writes/Sec``
      ``Avg. Length of Batched Writes``
      ``Avg. Length of Batched Writes BS``
      ``Avg. Time to Write Batch (ms)``
      ``Avg. Time to Write Batch Base``
      ``Avg. Time Between Batches (ms)``
      ``Avg. Time Between Batches Base``
    ]

/// SQLServer:Broker/DBM Transport: Service Broker/Database Mirroring Transport Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Broker_DBM Transport`` =

  [<Literal>]
  let Category = "SQLServer:Broker/DBM Transport"

  let PCC = getPCC Category
  /// Open Connection Count: The total number of transport connections currently open.
  let ``Open Connection Count`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Open Connection Count"; instance = NotApplicable }
  /// Send I/Os/sec: The number of transport send I/Os per second. Note that a transport send I/O may contain more than one message fragment.
  let ``Send I/Os/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Send I/Os/sec"; instance = NotApplicable }
  /// Send I/O bytes/sec: The number of transport send I/O bytes per second.
  let ``Send I/O bytes/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Send I/O bytes/sec"; instance = NotApplicable }
  /// Send I/O Len Avg: The average byte length of transport send I/O operations.
  let ``Send I/O Len Avg`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Send I/O Len Avg"; instance = NotApplicable }
  /// Send I/O Len Avg Base: Base for the average byte length of transport send I/O operations.
  let ``Send I/O Len Avg Base`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Send I/O Len Avg Base"; instance = NotApplicable }
  /// Receive I/Os/sec: The number of transport receives I/O per second. Note that a transport receive I/O may contain more than one message fragment.
  let ``Receive I/Os/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Receive I/Os/sec"; instance = NotApplicable }
  /// Receive I/O bytes/sec: The number of transport receive I/O bytes per second.
  let ``Receive I/O bytes/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Receive I/O bytes/sec"; instance = NotApplicable }
  /// Receive I/O Len Avg: The average byte length of transport receive I/O operations.
  let ``Receive I/O Len Avg`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Receive I/O Len Avg"; instance = NotApplicable }
  /// Receive I/O Len Avg Base: Base for the average byte length of transport receive I/O operations.
  let ``Receive I/O Len Avg Base`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Receive I/O Len Avg Base"; instance = NotApplicable }
  /// Message Fragment Sends/sec: The number of message fragments sent per second in transport send I/O operations.
  let ``Message Fragment Sends/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment Sends/sec"; instance = NotApplicable }
  /// Message Fragment P1 Sends/sec: The number of priority 1 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P1 Sends/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment P1 Sends/sec"; instance = NotApplicable }
  /// Message Fragment P2 Sends/sec: The number of priority 2 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P2 Sends/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment P2 Sends/sec"; instance = NotApplicable }
  /// Message Fragment P3 Sends/sec: The number of priority 3 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P3 Sends/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment P3 Sends/sec"; instance = NotApplicable }
  /// Message Fragment P4 Sends/sec: The number of priority 4 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P4 Sends/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment P4 Sends/sec"; instance = NotApplicable }
  /// Message Fragment P5 Sends/sec: The number of priority 5 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P5 Sends/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment P5 Sends/sec"; instance = NotApplicable }
  /// Message Fragment P6 Sends/sec: The number of priority 6 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P6 Sends/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment P6 Sends/sec"; instance = NotApplicable }
  /// Message Fragment P7 Sends/sec: The number of priority 7 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P7 Sends/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment P7 Sends/sec"; instance = NotApplicable }
  /// Message Fragment P8 Sends/sec: The number of priority 8 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P8 Sends/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment P8 Sends/sec"; instance = NotApplicable }
  /// Message Fragment P9 Sends/sec: The number of priority 9 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P9 Sends/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment P9 Sends/sec"; instance = NotApplicable }
  /// Message Fragment P10 Sends/sec: The number of priority 10 message fragments sent per second in transport send I/O operations.
  let ``Message Fragment P10 Sends/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment P10 Sends/sec"; instance = NotApplicable }
  /// Msg Fragment Send Size Avg: The average byte size of message fragments sent in transport send I/O operations.
  let ``Msg Fragment Send Size Avg`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Msg Fragment Send Size Avg"; instance = NotApplicable }
  /// Msg Fragment Send Size Avg Base: Base for the average byte size of message fragments sent in transport send I/O operations.
  let ``Msg Fragment Send Size Avg Base`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Msg Fragment Send Size Avg Base"; instance = NotApplicable }
  /// Message Fragment Receives/sec: The number of message fragments received per second in transport receive I/O operations.
  let ``Message Fragment Receives/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Message Fragment Receives/sec"; instance = NotApplicable }
  /// Msg Fragment Recv Size Avg: The average byte size of message fragments received in transport receive I/O operations.
  let ``Msg Fragment Recv Size Avg`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Msg Fragment Recv Size Avg"; instance = NotApplicable }
  /// Msg Fragment Recv Size Avg Base: Base for the average byte size of message fragments received in transport receive I/O operations.
  let ``Msg Fragment Recv Size Avg Base`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Msg Fragment Recv Size Avg Base"; instance = NotApplicable }
  /// Pending Msg Frags for Send I/O: The current number of message fragments that are being marshalled, or marshalled and ready to be sent via the transport layer.
  let ``Pending Msg Frags for Send I/O`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Pending Msg Frags for Send I/O"; instance = NotApplicable }
  /// Current Msg Frags for Send I/O: The current number of message fragments associated with current transport send I/O operations that haven't completed.
  let ``Current Msg Frags for Send I/O`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Current Msg Frags for Send I/O"; instance = NotApplicable }
  /// Pending Bytes for Send I/O: The number of buffer bytes associated with message fragments being marshalled, or marshalled and ready to be sent with send I/O operations.
  let ``Pending Bytes for Send I/O`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Pending Bytes for Send I/O"; instance = NotApplicable }
  /// Current Bytes for Send I/O: The number of buffer bytes associated with current transport send I/O operations that haven't completed.
  let ``Current Bytes for Send I/O`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Current Bytes for Send I/O"; instance = NotApplicable }
  /// Pending Msg Frags for Recv I/O: The current number of message fragments received in transport receive I/O operations that have not been enqueued (or rejected) yet.
  let ``Pending Msg Frags for Recv I/O`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Pending Msg Frags for Recv I/O"; instance = NotApplicable }
  /// Current Bytes for Recv I/O: The number of bytes associated with current transport receive I/O operations that haven't completed.
  let ``Current Bytes for Recv I/O`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Current Bytes for Recv I/O"; instance = NotApplicable }
  /// Pending Bytes for Recv I/O: The number of bytes associated with in completed transport receive I/O operations whose message fragments haven't been enqueued (or rejected) yet.
  let ``Pending Bytes for Recv I/O`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Pending Bytes for Recv I/O"; instance = NotApplicable }
  /// Recv I/O Buffer Copies Count: The number of times when transport receive I/O operations had to move buffer fragments in memory.
  let ``Recv I/O Buffer Copies Count`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Recv I/O Buffer Copies Count"; instance = NotApplicable }
  /// Recv I/O Buffer Copies bytes/sec: The rate at which transport receive I/O operations had to move buffer fragments in memory.
  let ``Recv I/O Buffer Copies bytes/sec`` =
    { category = "SQLServer:Broker/DBM Transport"; counter = "Recv I/O Buffer Copies bytes/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Open Connection Count``
      ``Send I/Os/sec``
      ``Send I/O bytes/sec``
      ``Send I/O Len Avg``
      ``Send I/O Len Avg Base``
      ``Receive I/Os/sec``
      ``Receive I/O bytes/sec``
      ``Receive I/O Len Avg``
      ``Receive I/O Len Avg Base``
      ``Message Fragment Sends/sec``
      ``Message Fragment P1 Sends/sec``
      ``Message Fragment P2 Sends/sec``
      ``Message Fragment P3 Sends/sec``
      ``Message Fragment P4 Sends/sec``
      ``Message Fragment P5 Sends/sec``
      ``Message Fragment P6 Sends/sec``
      ``Message Fragment P7 Sends/sec``
      ``Message Fragment P8 Sends/sec``
      ``Message Fragment P9 Sends/sec``
      ``Message Fragment P10 Sends/sec``
      ``Msg Fragment Send Size Avg``
      ``Msg Fragment Send Size Avg Base``
      ``Message Fragment Receives/sec``
      ``Msg Fragment Recv Size Avg``
      ``Msg Fragment Recv Size Avg Base``
      ``Pending Msg Frags for Send I/O``
      ``Current Msg Frags for Send I/O``
      ``Pending Bytes for Send I/O``
      ``Current Bytes for Send I/O``
      ``Pending Msg Frags for Recv I/O``
      ``Current Bytes for Recv I/O``
      ``Pending Bytes for Recv I/O``
      ``Recv I/O Buffer Copies Count``
      ``Recv I/O Buffer Copies bytes/sec``
    ]

/// SQLServer:Buffer Manager: Statistics related to SQL Servers buffer manager
///
/// This performance counter does not have instance based counters
module ``SQLServer:Buffer Manager`` =

  [<Literal>]
  let Category = "SQLServer:Buffer Manager"

  let PCC = getPCC Category
  /// Buffer cache hit ratio: Percentage of pages that were found in the buffer pool without having to incur a read from disk.
  let ``Buffer cache hit ratio`` =
    { category = "SQLServer:Buffer Manager"; counter = "Buffer cache hit ratio"; instance = NotApplicable }
  /// Buffer cache hit ratio base: Base for prior entry
  let ``Buffer cache hit ratio base`` =
    { category = "SQLServer:Buffer Manager"; counter = "Buffer cache hit ratio base"; instance = NotApplicable }
  /// Page lookups/sec: Number of requests to find a page in the buffer pool.
  let ``Page lookups/sec`` =
    { category = "SQLServer:Buffer Manager"; counter = "Page lookups/sec"; instance = NotApplicable }
  /// Free list stalls/sec: Number of requests that had to wait for a free page.
  let ``Free list stalls/sec`` =
    { category = "SQLServer:Buffer Manager"; counter = "Free list stalls/sec"; instance = NotApplicable }
  /// Database pages: Number of pages in the buffer pool with database content.
  let ``Database pages`` =
    { category = "SQLServer:Buffer Manager"; counter = "Database pages"; instance = NotApplicable }
  /// Target pages: Ideal number of pages in the buffer pool.
  let ``Target pages`` =
    { category = "SQLServer:Buffer Manager"; counter = "Target pages"; instance = NotApplicable }
  /// Integral Controller Slope: The slope that integral controller for the buffer pool last used, times -10 billion
  let ``Integral Controller Slope`` =
    { category = "SQLServer:Buffer Manager"; counter = "Integral Controller Slope"; instance = NotApplicable }
  /// Lazy writes/sec: Number of buffers written by buffer manager's lazy writer.
  let ``Lazy writes/sec`` =
    { category = "SQLServer:Buffer Manager"; counter = "Lazy writes/sec"; instance = NotApplicable }
  /// Readahead pages/sec: Number of pages read in anticipation of use.
  let ``Readahead pages/sec`` =
    { category = "SQLServer:Buffer Manager"; counter = "Readahead pages/sec"; instance = NotApplicable }
  /// Page reads/sec: Number of physical database page reads issued.
  let ``Page reads/sec`` =
    { category = "SQLServer:Buffer Manager"; counter = "Page reads/sec"; instance = NotApplicable }
  /// Page writes/sec: Number of physical database page writes issued.
  let ``Page writes/sec`` =
    { category = "SQLServer:Buffer Manager"; counter = "Page writes/sec"; instance = NotApplicable }
  /// Checkpoint pages/sec: Number of pages flushed by checkpoint or other operations that require all dirty pages to be flushed.
  let ``Checkpoint pages/sec`` =
    { category = "SQLServer:Buffer Manager"; counter = "Checkpoint pages/sec"; instance = NotApplicable }
  /// Background writer pages/sec: Number of pages flushed to enforce the recovery interval settings.
  let ``Background writer pages/sec`` =
    { category = "SQLServer:Buffer Manager"; counter = "Background writer pages/sec"; instance = NotApplicable }
  /// Page life expectancy: Number of seconds a page will stay in the buffer pool without references.
  let ``Page life expectancy`` =
    { category = "SQLServer:Buffer Manager"; counter = "Page life expectancy"; instance = NotApplicable }

  let allCounters =
    [ ``Buffer cache hit ratio``
      ``Buffer cache hit ratio base``
      ``Page lookups/sec``
      ``Free list stalls/sec``
      ``Database pages``
      ``Target pages``
      ``Integral Controller Slope``
      ``Lazy writes/sec``
      ``Readahead pages/sec``
      ``Page reads/sec``
      ``Page writes/sec``
      ``Checkpoint pages/sec``
      ``Background writer pages/sec``
      ``Page life expectancy``
    ]

/// SQLServer:Buffer Node: Statistics related to SQL Server's buffer pool by NUMA node
///
/// This performance counter does not have instance based counters
module ``SQLServer:Buffer Node`` =

  [<Literal>]
  let Category = "SQLServer:Buffer Node"

  let PCC = getPCC Category
  /// Database pages: 
  let ``Database pages`` instance =
    { category = "SQLServer:Buffer Node"; counter = "Database pages"; instance = instance }
  /// Page life expectancy: 
  let ``Page life expectancy`` instance =
    { category = "SQLServer:Buffer Node"; counter = "Page life expectancy"; instance = instance }
  /// Local node page lookups/sec: 
  let ``Local node page lookups/sec`` instance =
    { category = "SQLServer:Buffer Node"; counter = "Local node page lookups/sec"; instance = instance }
  /// Remote node page lookups/sec: 
  let ``Remote node page lookups/sec`` instance =
    { category = "SQLServer:Buffer Node"; counter = "Remote node page lookups/sec"; instance = instance }

  let allCounters =
    [ ``Database pages``
      ``Page life expectancy``
      ``Local node page lookups/sec``
      ``Remote node page lookups/sec``
    ]

/// SQLServer:CLR: CLR Execution in SQL Server
///
/// This performance counter does not have instance based counters
module ``SQLServer:CLR`` =

  [<Literal>]
  let Category = "SQLServer:CLR"

  let PCC = getPCC Category
  /// CLR Execution: Total Execution time in CLR ( microseconds ).
  let ``CLR Execution`` =
    { category = "SQLServer:CLR"; counter = "CLR Execution"; instance = NotApplicable }

  let allCounters =
    [ ``CLR Execution``

    ]

/// SQLServer:Catalog Metadata: This defines a catalog metadata manager object for SQL Server
///
/// This performance counter does not have instance based counters
module ``SQLServer:Catalog Metadata`` =

  [<Literal>]
  let Category = "SQLServer:Catalog Metadata"

  let PCC = getPCC Category
  /// Cache Hit Ratio: 
  let ``Cache Hit Ratio`` instance =
    { category = "SQLServer:Catalog Metadata"; counter = "Cache Hit Ratio"; instance = instance }
  /// Cache Hit Ratio Base: 
  let ``Cache Hit Ratio Base`` instance =
    { category = "SQLServer:Catalog Metadata"; counter = "Cache Hit Ratio Base"; instance = instance }
  /// Cache Entries Count: 
  let ``Cache Entries Count`` instance =
    { category = "SQLServer:Catalog Metadata"; counter = "Cache Entries Count"; instance = instance }
  /// Cache Entries Pinned Count: 
  let ``Cache Entries Pinned Count`` instance =
    { category = "SQLServer:Catalog Metadata"; counter = "Cache Entries Pinned Count"; instance = instance }

  let allCounters =
    [ ``Cache Hit Ratio``
      ``Cache Hit Ratio Base``
      ``Cache Entries Count``
      ``Cache Entries Pinned Count``
    ]

/// SQLServer:Cursor Manager Total: Counters for cursor properties not grouped by type
///
/// This performance counter does not have instance based counters
module ``SQLServer:Cursor Manager Total`` =

  [<Literal>]
  let Category = "SQLServer:Cursor Manager Total"

  let PCC = getPCC Category
  /// Cursor conversion rate: Number of cursor conversions/sec.
  let ``Cursor conversion rate`` =
    { category = "SQLServer:Cursor Manager Total"; counter = "Cursor conversion rate"; instance = NotApplicable }
  /// Async population count: Number of cursors being populated asynchronously.
  let ``Async population count`` =
    { category = "SQLServer:Cursor Manager Total"; counter = "Async population count"; instance = NotApplicable }
  /// Cursor flushes: Total number of times a flush for a cursor xstmt occured.
  let ``Cursor flushes`` =
    { category = "SQLServer:Cursor Manager Total"; counter = "Cursor flushes"; instance = NotApplicable }

  let allCounters =
    [ ``Cursor conversion rate``
      ``Async population count``
      ``Cursor flushes``
    ]

/// SQLServer:Cursor Manager by Type: Counters for cursor properties grouped by type
///
/// This performance counter does not have instance based counters
module ``SQLServer:Cursor Manager by Type`` =

  [<Literal>]
  let Category = "SQLServer:Cursor Manager by Type"

  let PCC = getPCC Category
  /// Cache Hit Ratio: 
  let ``Cache Hit Ratio`` instance =
    { category = "SQLServer:Cursor Manager by Type"; counter = "Cache Hit Ratio"; instance = instance }
  /// Cache Hit Ratio Base: 
  let ``Cache Hit Ratio Base`` instance =
    { category = "SQLServer:Cursor Manager by Type"; counter = "Cache Hit Ratio Base"; instance = instance }
  /// Cached Cursor Counts: 
  let ``Cached Cursor Counts`` instance =
    { category = "SQLServer:Cursor Manager by Type"; counter = "Cached Cursor Counts"; instance = instance }
  /// Cursor Cache Use Counts/sec: 
  let ``Cursor Cache Use Counts/sec`` instance =
    { category = "SQLServer:Cursor Manager by Type"; counter = "Cursor Cache Use Counts/sec"; instance = instance }
  /// Cursor Requests/sec: 
  let ``Cursor Requests/sec`` instance =
    { category = "SQLServer:Cursor Manager by Type"; counter = "Cursor Requests/sec"; instance = instance }
  /// Active cursors: 
  let ``Active cursors`` instance =
    { category = "SQLServer:Cursor Manager by Type"; counter = "Active cursors"; instance = instance }
  /// Cursor memory usage: 
  let ``Cursor memory usage`` instance =
    { category = "SQLServer:Cursor Manager by Type"; counter = "Cursor memory usage"; instance = instance }
  /// Cursor worktable usage: 
  let ``Cursor worktable usage`` instance =
    { category = "SQLServer:Cursor Manager by Type"; counter = "Cursor worktable usage"; instance = instance }
  /// Number of active cursor plans: 
  let ``Number of active cursor plans`` instance =
    { category = "SQLServer:Cursor Manager by Type"; counter = "Number of active cursor plans"; instance = instance }

  let allCounters =
    [ ``Cache Hit Ratio``
      ``Cache Hit Ratio Base``
      ``Cached Cursor Counts``
      ``Cursor Cache Use Counts/sec``
      ``Cursor Requests/sec``
      ``Active cursors``
      ``Cursor memory usage``
      ``Cursor worktable usage``
      ``Number of active cursor plans``
    ]

/// SQLServer:Database Mirroring: This defines a Database Mirroring object for SQL Server
///
/// This performance counter does not have instance based counters
module ``SQLServer:Database Mirroring`` =

  [<Literal>]
  let Category = "SQLServer:Database Mirroring"

  let PCC = getPCC Category
  /// Bytes Sent/sec: 
  let ``Bytes Sent/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Bytes Sent/sec"; instance = instance }
  /// Pages Sent/sec: 
  let ``Pages Sent/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Pages Sent/sec"; instance = instance }
  /// Sends/sec: 
  let ``Sends/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Sends/sec"; instance = instance }
  /// Transaction Delay: 
  let ``Transaction Delay`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Transaction Delay"; instance = instance }
  /// Redo Queue KB: 
  let ``Redo Queue KB`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Redo Queue KB"; instance = instance }
  /// Redo Bytes/sec: 
  let ``Redo Bytes/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Redo Bytes/sec"; instance = instance }
  /// Log Send Queue KB: 
  let ``Log Send Queue KB`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Log Send Queue KB"; instance = instance }
  /// Bytes Received/sec: 
  let ``Bytes Received/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Bytes Received/sec"; instance = instance }
  /// Receives/sec: 
  let ``Receives/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Receives/sec"; instance = instance }
  /// Log Bytes Received/sec: 
  let ``Log Bytes Received/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Log Bytes Received/sec"; instance = instance }
  /// Log Bytes Sent/sec: 
  let ``Log Bytes Sent/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Log Bytes Sent/sec"; instance = instance }
  /// Send/Receive Ack Time: 
  let ``Send/Receive Ack Time`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Send/Receive Ack Time"; instance = instance }
  /// Log Compressed Bytes Rcvd/sec: 
  let ``Log Compressed Bytes Rcvd/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Log Compressed Bytes Rcvd/sec"; instance = instance }
  /// Log Compressed Bytes Sent/sec: 
  let ``Log Compressed Bytes Sent/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Log Compressed Bytes Sent/sec"; instance = instance }
  /// Mirrored Write Transactions/sec: 
  let ``Mirrored Write Transactions/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Mirrored Write Transactions/sec"; instance = instance }
  /// Log Scanned for Undo KB: 
  let ``Log Scanned for Undo KB`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Log Scanned for Undo KB"; instance = instance }
  /// Log Remaining for Undo KB: 
  let ``Log Remaining for Undo KB`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Log Remaining for Undo KB"; instance = instance }
  /// Log Bytes Sent from Cache/sec: 
  let ``Log Bytes Sent from Cache/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Log Bytes Sent from Cache/sec"; instance = instance }
  /// Log Bytes Redone from Cache/sec: 
  let ``Log Bytes Redone from Cache/sec`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Log Bytes Redone from Cache/sec"; instance = instance }
  /// Log Send Flow Control Time (ms): 
  let ``Log Send Flow Control Time (ms)`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Log Send Flow Control Time (ms)"; instance = instance }
  /// Log Harden Time (ms): 
  let ``Log Harden Time (ms)`` instance =
    { category = "SQLServer:Database Mirroring"; counter = "Log Harden Time (ms)"; instance = instance }

  let allCounters =
    [ ``Bytes Sent/sec``
      ``Pages Sent/sec``
      ``Sends/sec``
      ``Transaction Delay``
      ``Redo Queue KB``
      ``Redo Bytes/sec``
      ``Log Send Queue KB``
      ``Bytes Received/sec``
      ``Receives/sec``
      ``Log Bytes Received/sec``
      ``Log Bytes Sent/sec``
      ``Send/Receive Ack Time``
      ``Log Compressed Bytes Rcvd/sec``
      ``Log Compressed Bytes Sent/sec``
      ``Mirrored Write Transactions/sec``
      ``Log Scanned for Undo KB``
      ``Log Remaining for Undo KB``
      ``Log Bytes Sent from Cache/sec``
      ``Log Bytes Redone from Cache/sec``
      ``Log Send Flow Control Time (ms)``
      ``Log Harden Time (ms)``
    ]

/// SQLServer:Database Replica: This defines a HADR secondary database object for SQL Server
///
/// This performance counter does not have instance based counters
module ``SQLServer:Database Replica`` =

  [<Literal>]
  let Category = "SQLServer:Database Replica"

  let PCC = getPCC Category
  /// Recovery Queue: 
  let ``Recovery Queue`` instance =
    { category = "SQLServer:Database Replica"; counter = "Recovery Queue"; instance = instance }
  /// Redone Bytes/sec: 
  let ``Redone Bytes/sec`` instance =
    { category = "SQLServer:Database Replica"; counter = "Redone Bytes/sec"; instance = instance }
  /// Log Send Queue: 
  let ``Log Send Queue`` instance =
    { category = "SQLServer:Database Replica"; counter = "Log Send Queue"; instance = instance }
  /// Log Bytes Received/sec: 
  let ``Log Bytes Received/sec`` instance =
    { category = "SQLServer:Database Replica"; counter = "Log Bytes Received/sec"; instance = instance }
  /// File Bytes Received/sec: 
  let ``File Bytes Received/sec`` instance =
    { category = "SQLServer:Database Replica"; counter = "File Bytes Received/sec"; instance = instance }
  /// Mirrored Write Transactions/sec: 
  let ``Mirrored Write Transactions/sec`` instance =
    { category = "SQLServer:Database Replica"; counter = "Mirrored Write Transactions/sec"; instance = instance }
  /// Transaction Delay: 
  let ``Transaction Delay`` instance =
    { category = "SQLServer:Database Replica"; counter = "Transaction Delay"; instance = instance }
  /// Total Log requiring undo: 
  let ``Total Log requiring undo`` instance =
    { category = "SQLServer:Database Replica"; counter = "Total Log requiring undo"; instance = instance }
  /// Log remaining for undo: 
  let ``Log remaining for undo`` instance =
    { category = "SQLServer:Database Replica"; counter = "Log remaining for undo"; instance = instance }
  /// Redo Bytes Remaining: 
  let ``Redo Bytes Remaining`` instance =
    { category = "SQLServer:Database Replica"; counter = "Redo Bytes Remaining"; instance = instance }
  /// Redo blocked/sec: 
  let ``Redo blocked/sec`` instance =
    { category = "SQLServer:Database Replica"; counter = "Redo blocked/sec"; instance = instance }

  let allCounters =
    [ ``Recovery Queue``
      ``Redone Bytes/sec``
      ``Log Send Queue``
      ``Log Bytes Received/sec``
      ``File Bytes Received/sec``
      ``Mirrored Write Transactions/sec``
      ``Transaction Delay``
      ``Total Log requiring undo``
      ``Log remaining for undo``
      ``Redo Bytes Remaining``
      ``Redo blocked/sec``
    ]

/// SQLServer:Databases: This defines a Database manager object for SQL Server
///
/// This performance counter does not have instance based counters
module ``SQLServer:Databases`` =

  [<Literal>]
  let Category = "SQLServer:Databases"

  let PCC = getPCC Category
  /// Data File(s) Size (KB): 
  let ``Data File(s) Size (KB)`` instance =
    { category = "SQLServer:Databases"; counter = "Data File(s) Size (KB)"; instance = instance }
  /// Log File(s) Size (KB): 
  let ``Log File(s) Size (KB)`` instance =
    { category = "SQLServer:Databases"; counter = "Log File(s) Size (KB)"; instance = instance }
  /// Log File(s) Used Size (KB): 
  let ``Log File(s) Used Size (KB)`` instance =
    { category = "SQLServer:Databases"; counter = "Log File(s) Used Size (KB)"; instance = instance }
  /// Percent Log Used: 
  let ``Percent Log Used`` instance =
    { category = "SQLServer:Databases"; counter = "Percent Log Used"; instance = instance }
  /// Active Transactions: 
  let ``Active Transactions`` instance =
    { category = "SQLServer:Databases"; counter = "Active Transactions"; instance = instance }
  /// Transactions/sec: 
  let ``Transactions/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Transactions/sec"; instance = instance }
  /// Repl. Pending Xacts: 
  let ``Repl. Pending Xacts`` instance =
    { category = "SQLServer:Databases"; counter = "Repl. Pending Xacts"; instance = instance }
  /// Repl. Trans. Rate: 
  let ``Repl. Trans. Rate`` instance =
    { category = "SQLServer:Databases"; counter = "Repl. Trans. Rate"; instance = instance }
  /// Log Cache Reads/sec: 
  let ``Log Cache Reads/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Log Cache Reads/sec"; instance = instance }
  /// Log Cache Hit Ratio: 
  let ``Log Cache Hit Ratio`` instance =
    { category = "SQLServer:Databases"; counter = "Log Cache Hit Ratio"; instance = instance }
  /// Log Cache Hit Ratio Base: 
  let ``Log Cache Hit Ratio Base`` instance =
    { category = "SQLServer:Databases"; counter = "Log Cache Hit Ratio Base"; instance = instance }
  /// Log Pool Requests/sec: 
  let ``Log Pool Requests/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Log Pool Requests/sec"; instance = instance }
  /// Log Pool Cache Misses/sec: 
  let ``Log Pool Cache Misses/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Log Pool Cache Misses/sec"; instance = instance }
  /// Log Pool Disk Reads/sec: 
  let ``Log Pool Disk Reads/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Log Pool Disk Reads/sec"; instance = instance }
  /// Bulk Copy Rows/sec: 
  let ``Bulk Copy Rows/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Bulk Copy Rows/sec"; instance = instance }
  /// Bulk Copy Throughput/sec: 
  let ``Bulk Copy Throughput/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Bulk Copy Throughput/sec"; instance = instance }
  /// Backup/Restore Throughput/sec: 
  let ``Backup/Restore Throughput/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Backup/Restore Throughput/sec"; instance = instance }
  /// DBCC Logical Scan Bytes/sec: 
  let ``DBCC Logical Scan Bytes/sec`` instance =
    { category = "SQLServer:Databases"; counter = "DBCC Logical Scan Bytes/sec"; instance = instance }
  /// Shrink Data Movement Bytes/sec: 
  let ``Shrink Data Movement Bytes/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Shrink Data Movement Bytes/sec"; instance = instance }
  /// Log Flushes/sec: 
  let ``Log Flushes/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Log Flushes/sec"; instance = instance }
  /// Log Bytes Flushed/sec: 
  let ``Log Bytes Flushed/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Log Bytes Flushed/sec"; instance = instance }
  /// Log Flush Waits/sec: 
  let ``Log Flush Waits/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Log Flush Waits/sec"; instance = instance }
  /// Log Flush Wait Time: 
  let ``Log Flush Wait Time`` instance =
    { category = "SQLServer:Databases"; counter = "Log Flush Wait Time"; instance = instance }
  /// Log Flush Write Time (ms): 
  let ``Log Flush Write Time (ms)`` instance =
    { category = "SQLServer:Databases"; counter = "Log Flush Write Time (ms)"; instance = instance }
  /// Log Truncations: 
  let ``Log Truncations`` instance =
    { category = "SQLServer:Databases"; counter = "Log Truncations"; instance = instance }
  /// Log Growths: 
  let ``Log Growths`` instance =
    { category = "SQLServer:Databases"; counter = "Log Growths"; instance = instance }
  /// Log Shrinks: 
  let ``Log Shrinks`` instance =
    { category = "SQLServer:Databases"; counter = "Log Shrinks"; instance = instance }
  /// Tracked transactions/sec: 
  let ``Tracked transactions/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Tracked transactions/sec"; instance = instance }
  /// Write Transactions/sec: 
  let ``Write Transactions/sec`` instance =
    { category = "SQLServer:Databases"; counter = "Write Transactions/sec"; instance = instance }
  /// Commit table entries: 
  let ``Commit table entries`` instance =
    { category = "SQLServer:Databases"; counter = "Commit table entries"; instance = instance }

  let allCounters =
    [ ``Data File(s) Size (KB)``
      ``Log File(s) Size (KB)``
      ``Log File(s) Used Size (KB)``
      ``Percent Log Used``
      ``Active Transactions``
      ``Transactions/sec``
      ``Repl. Pending Xacts``
      ``Repl. Trans. Rate``
      ``Log Cache Reads/sec``
      ``Log Cache Hit Ratio``
      ``Log Cache Hit Ratio Base``
      ``Log Pool Requests/sec``
      ``Log Pool Cache Misses/sec``
      ``Log Pool Disk Reads/sec``
      ``Bulk Copy Rows/sec``
      ``Bulk Copy Throughput/sec``
      ``Backup/Restore Throughput/sec``
      ``DBCC Logical Scan Bytes/sec``
      ``Shrink Data Movement Bytes/sec``
      ``Log Flushes/sec``
      ``Log Bytes Flushed/sec``
      ``Log Flush Waits/sec``
      ``Log Flush Wait Time``
      ``Log Flush Write Time (ms)``
      ``Log Truncations``
      ``Log Growths``
      ``Log Shrinks``
      ``Tracked transactions/sec``
      ``Write Transactions/sec``
      ``Commit table entries``
    ]

/// SQLServer:Deprecated Features: Statistics on deprecated feature usage
///
/// This performance counter does not have instance based counters
module ``SQLServer:Deprecated Features`` =

  [<Literal>]
  let Category = "SQLServer:Deprecated Features"

  let PCC = getPCC Category
  /// Usage: 
  let ``Usage`` instance =
    { category = "SQLServer:Deprecated Features"; counter = "Usage"; instance = instance }

  let allCounters =
    [ ``Usage``

    ]

/// SQLServer:Exec Statistics: Execution statistics for external calls
///
/// This performance counter does not have instance based counters
module ``SQLServer:Exec Statistics`` =

  [<Literal>]
  let Category = "SQLServer:Exec Statistics"

  let PCC = getPCC Category
  /// Extended Procedures: 
  let ``Extended Procedures`` instance =
    { category = "SQLServer:Exec Statistics"; counter = "Extended Procedures"; instance = instance }
  /// DTC calls: 
  let ``DTC calls`` instance =
    { category = "SQLServer:Exec Statistics"; counter = "DTC calls"; instance = instance }
  /// OLEDB calls: 
  let ``OLEDB calls`` instance =
    { category = "SQLServer:Exec Statistics"; counter = "OLEDB calls"; instance = instance }
  /// Distributed Query: 
  let ``Distributed Query`` instance =
    { category = "SQLServer:Exec Statistics"; counter = "Distributed Query"; instance = instance }

  let allCounters =
    [ ``Extended Procedures``
      ``DTC calls``
      ``OLEDB calls``
      ``Distributed Query``
    ]

/// SQLServer:FileTable: Statistics associated with FileTable and non-transacted access
///
/// This performance counter does not have instance based counters
module ``SQLServer:FileTable`` =

  [<Literal>]
  let Category = "SQLServer:FileTable"

  let PCC = getPCC Category
  /// FileTable db operations/sec: Total number of database operational events processed by the FileTable store component per second.
  let ``FileTable db operations/sec`` =
    { category = "SQLServer:FileTable"; counter = "FileTable db operations/sec"; instance = NotApplicable }
  /// FileTable table operations/sec: Total number of table operational events processed by the FileTable store component per second.
  let ``FileTable table operations/sec`` =
    { category = "SQLServer:FileTable"; counter = "FileTable table operations/sec"; instance = NotApplicable }
  /// FileTable item get requests/sec: Total number of FileTable retrieve item requests per second.
  let ``FileTable item get requests/sec`` =
    { category = "SQLServer:FileTable"; counter = "FileTable item get requests/sec"; instance = NotApplicable }
  /// Avg time to get FileTable item: Average time (in milliseconds) taken to retrieve a FileTable item.
  let ``Avg time to get FileTable item`` =
    { category = "SQLServer:FileTable"; counter = "Avg time to get FileTable item"; instance = NotApplicable }
  /// Time to get FileTable item BASE: Average time (in milliseconds) taken to retrieve a FileTable item (BASE).
  let ``Time to get FileTable item BASE`` =
    { category = "SQLServer:FileTable"; counter = "Time to get FileTable item BASE"; instance = NotApplicable }
  /// FileTable item delete reqs/sec: Total number of FileTable delete item requests per second.
  let ``FileTable item delete reqs/sec`` =
    { category = "SQLServer:FileTable"; counter = "FileTable item delete reqs/sec"; instance = NotApplicable }
  /// Avg time delete FileTable item: Average time (in milliseconds) taken to delete a FileTable item.
  let ``Avg time delete FileTable item`` =
    { category = "SQLServer:FileTable"; counter = "Avg time delete FileTable item"; instance = NotApplicable }
  /// Time delete FileTable item BASE: Average time (in milliseconds) taken to delete a FileTable item (BASE).
  let ``Time delete FileTable item BASE`` =
    { category = "SQLServer:FileTable"; counter = "Time delete FileTable item BASE"; instance = NotApplicable }
  /// FileTable item update reqs/sec: Total number of FileTable update item requests per second.
  let ``FileTable item update reqs/sec`` =
    { category = "SQLServer:FileTable"; counter = "FileTable item update reqs/sec"; instance = NotApplicable }
  /// Avg time update FileTable item: Average time (in milliseconds) taken to update a FileTable item.
  let ``Avg time update FileTable item`` =
    { category = "SQLServer:FileTable"; counter = "Avg time update FileTable item"; instance = NotApplicable }
  /// Time update FileTable item BASE: Average time (in milliseconds) taken to update a FileTable item (BASE).
  let ``Time update FileTable item BASE`` =
    { category = "SQLServer:FileTable"; counter = "Time update FileTable item BASE"; instance = NotApplicable }
  /// FileTable item move reqs/sec: Total number of FileTable move item requests per second.
  let ``FileTable item move reqs/sec`` =
    { category = "SQLServer:FileTable"; counter = "FileTable item move reqs/sec"; instance = NotApplicable }
  /// Avg time move FileTable item: Average time (in milliseconds) taken to move a FileTable item.
  let ``Avg time move FileTable item`` =
    { category = "SQLServer:FileTable"; counter = "Avg time move FileTable item"; instance = NotApplicable }
  /// Time move FileTable item BASE: Average time (in milliseconds) taken to move a FileTable item (BASE).
  let ``Time move FileTable item BASE`` =
    { category = "SQLServer:FileTable"; counter = "Time move FileTable item BASE"; instance = NotApplicable }
  /// FileTable item rename reqs/sec: Total number of FileTable rename item requests per second.
  let ``FileTable item rename reqs/sec`` =
    { category = "SQLServer:FileTable"; counter = "FileTable item rename reqs/sec"; instance = NotApplicable }
  /// Avg time rename FileTable item: Average time (in milliseconds) taken to rename a FileTable item.
  let ``Avg time rename FileTable item`` =
    { category = "SQLServer:FileTable"; counter = "Avg time rename FileTable item"; instance = NotApplicable }
  /// Time rename FileTable item BASE: Average time (in milliseconds) taken to rename a FileTable item (BASE).
  let ``Time rename FileTable item BASE`` =
    { category = "SQLServer:FileTable"; counter = "Time rename FileTable item BASE"; instance = NotApplicable }
  /// FileTable enumeration reqs/sec: Total number of FileTable enumeration requests per second.
  let ``FileTable enumeration reqs/sec`` =
    { category = "SQLServer:FileTable"; counter = "FileTable enumeration reqs/sec"; instance = NotApplicable }
  /// Avg time FileTable enumeration: Average time (in milliseconds) taken for a FileTable enumeration request.
  let ``Avg time FileTable enumeration`` =
    { category = "SQLServer:FileTable"; counter = "Avg time FileTable enumeration"; instance = NotApplicable }
  /// Time FileTable enumeration BASE: Average time (in milliseconds) taken for a FileTable enumeration request (BASE).
  let ``Time FileTable enumeration BASE`` =
    { category = "SQLServer:FileTable"; counter = "Time FileTable enumeration BASE"; instance = NotApplicable }
  /// FileTable file I/O requests/sec: Total number of incoming FileTable file I/O requests per second.
  let ``FileTable file I/O requests/sec`` =
    { category = "SQLServer:FileTable"; counter = "FileTable file I/O requests/sec"; instance = NotApplicable }
  /// Avg time per file I/O request: Average time (in milliseconds) spent handling an incoming file I/O request.
  let ``Avg time per file I/O request`` =
    { category = "SQLServer:FileTable"; counter = "Avg time per file I/O request"; instance = NotApplicable }
  /// Time per file I/O request BASE: Average time (in milliseconds) spent handling an incoming file I/O request (BASE).
  let ``Time per file I/O request BASE`` =
    { category = "SQLServer:FileTable"; counter = "Time per file I/O request BASE"; instance = NotApplicable }
  /// FileTable file I/O response/sec: Total number of outgoing file I/O responses per second.
  let ``FileTable file I/O response/sec`` =
    { category = "SQLServer:FileTable"; counter = "FileTable file I/O response/sec"; instance = NotApplicable }
  /// Avg time per file I/O response: Average time (in milliseconds) spent handling an outgoing file I/O response.
  let ``Avg time per file I/O response`` =
    { category = "SQLServer:FileTable"; counter = "Avg time per file I/O response"; instance = NotApplicable }
  /// Time per file I/O response BASE: Average time (in milliseconds) spent handling an outgoing file I/O response (BASE).
  let ``Time per file I/O response BASE`` =
    { category = "SQLServer:FileTable"; counter = "Time per file I/O response BASE"; instance = NotApplicable }
  /// FileTable kill handle ops/sec: Total number of FileTable handle kill operations per second.
  let ``FileTable kill handle ops/sec`` =
    { category = "SQLServer:FileTable"; counter = "FileTable kill handle ops/sec"; instance = NotApplicable }
  /// Avg time FileTable handle kill: Average time (in milliseconds) taken to kill a FileTable handle.
  let ``Avg time FileTable handle kill`` =
    { category = "SQLServer:FileTable"; counter = "Avg time FileTable handle kill"; instance = NotApplicable }
  /// Time FileTable handle kill BASE: Average time (in milliseconds) taken to kill a FileTable handle (BASE).
  let ``Time FileTable handle kill BASE`` =
    { category = "SQLServer:FileTable"; counter = "Time FileTable handle kill BASE"; instance = NotApplicable }

  let allCounters =
    [ ``FileTable db operations/sec``
      ``FileTable table operations/sec``
      ``FileTable item get requests/sec``
      ``Avg time to get FileTable item``
      ``Time to get FileTable item BASE``
      ``FileTable item delete reqs/sec``
      ``Avg time delete FileTable item``
      ``Time delete FileTable item BASE``
      ``FileTable item update reqs/sec``
      ``Avg time update FileTable item``
      ``Time update FileTable item BASE``
      ``FileTable item move reqs/sec``
      ``Avg time move FileTable item``
      ``Time move FileTable item BASE``
      ``FileTable item rename reqs/sec``
      ``Avg time rename FileTable item``
      ``Time rename FileTable item BASE``
      ``FileTable enumeration reqs/sec``
      ``Avg time FileTable enumeration``
      ``Time FileTable enumeration BASE``
      ``FileTable file I/O requests/sec``
      ``Avg time per file I/O request``
      ``Time per file I/O request BASE``
      ``FileTable file I/O response/sec``
      ``Avg time per file I/O response``
      ``Time per file I/O response BASE``
      ``FileTable kill handle ops/sec``
      ``Avg time FileTable handle kill``
      ``Time FileTable handle kill BASE``
    ]

/// SQLServer:General Statistics: Server General Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:General Statistics`` =

  [<Literal>]
  let Category = "SQLServer:General Statistics"

  let PCC = getPCC Category
  /// Active Temp Tables: Number of temporary tables/table variables in use
  let ``Active Temp Tables`` =
    { category = "SQLServer:General Statistics"; counter = "Active Temp Tables"; instance = NotApplicable }
  /// Temp Tables Creation Rate: Number of temporary tables/table variables created/sec
  let ``Temp Tables Creation Rate`` =
    { category = "SQLServer:General Statistics"; counter = "Temp Tables Creation Rate"; instance = NotApplicable }
  /// Logins/sec: Total number of logins started per second.
  let ``Logins/sec`` =
    { category = "SQLServer:General Statistics"; counter = "Logins/sec"; instance = NotApplicable }
  /// Connection Reset/sec: Total number of connection resets per second.
  let ``Connection Reset/sec`` =
    { category = "SQLServer:General Statistics"; counter = "Connection Reset/sec"; instance = NotApplicable }
  /// Logouts/sec: Total number of logouts started per second.
  let ``Logouts/sec`` =
    { category = "SQLServer:General Statistics"; counter = "Logouts/sec"; instance = NotApplicable }
  /// User Connections: Number of users connected to the system.
  let ``User Connections`` =
    { category = "SQLServer:General Statistics"; counter = "User Connections"; instance = NotApplicable }
  /// Logical Connections: Number of logical connections to the system.
  let ``Logical Connections`` =
    { category = "SQLServer:General Statistics"; counter = "Logical Connections"; instance = NotApplicable }
  /// Transactions: Number of transaction enlistments (local, dtc, and bound).
  let ``Transactions`` =
    { category = "SQLServer:General Statistics"; counter = "Transactions"; instance = NotApplicable }
  /// Non-atomic yield rate: Number of non-atomic yields per second.
  let ``Non-atomic yield rate`` =
    { category = "SQLServer:General Statistics"; counter = "Non-atomic yield rate"; instance = NotApplicable }
  /// Mars Deadlocks: Number of Mars Deadlocks detected.
  let ``Mars Deadlocks`` =
    { category = "SQLServer:General Statistics"; counter = "Mars Deadlocks"; instance = NotApplicable }
  /// HTTP Authenticated Requests: Number of authenticated HTTP requests started per second.
  let ``HTTP Authenticated Requests`` =
    { category = "SQLServer:General Statistics"; counter = "HTTP Authenticated Requests"; instance = NotApplicable }
  /// SOAP Empty Requests: Number of empty SOAP requests started per second.
  let ``SOAP Empty Requests`` =
    { category = "SQLServer:General Statistics"; counter = "SOAP Empty Requests"; instance = NotApplicable }
  /// SOAP SQL Requests: Number of SOAP SQL requests started per second.
  let ``SOAP SQL Requests`` =
    { category = "SQLServer:General Statistics"; counter = "SOAP SQL Requests"; instance = NotApplicable }
  /// SOAP Method Invocations: Number of SOAP method invocations started per second.
  let ``SOAP Method Invocations`` =
    { category = "SQLServer:General Statistics"; counter = "SOAP Method Invocations"; instance = NotApplicable }
  /// SOAP WSDL Requests: Number of SOAP Web Service Description Language requests started per second.
  let ``SOAP WSDL Requests`` =
    { category = "SQLServer:General Statistics"; counter = "SOAP WSDL Requests"; instance = NotApplicable }
  /// SOAP Session Initiate Requests: Number of SOAP Session initiate requests started per second.
  let ``SOAP Session Initiate Requests`` =
    { category = "SQLServer:General Statistics"; counter = "SOAP Session Initiate Requests"; instance = NotApplicable }
  /// SOAP Session Terminate Requests: Number of SOAP Session terminate requests started per second.
  let ``SOAP Session Terminate Requests`` =
    { category = "SQLServer:General Statistics"; counter = "SOAP Session Terminate Requests"; instance = NotApplicable }
  /// Processes blocked: Number of currently blocked processes.
  let ``Processes blocked`` =
    { category = "SQLServer:General Statistics"; counter = "Processes blocked"; instance = NotApplicable }
  /// Temp Tables For Destruction: Number of temporary tables/table variables waiting to be destroyed by the cleanup system thread
  let ``Temp Tables For Destruction`` =
    { category = "SQLServer:General Statistics"; counter = "Temp Tables For Destruction"; instance = NotApplicable }
  /// Event Notifications Delayed Drop: Number of event notifications waiting to be dropped by a system thread
  let ``Event Notifications Delayed Drop`` =
    { category = "SQLServer:General Statistics"; counter = "Event Notifications Delayed Drop"; instance = NotApplicable }
  /// Trace Event Notification Queue: Number of trace event notification instances waiting in the internal queue to be sent thru Service Broker
  let ``Trace Event Notification Queue`` =
    { category = "SQLServer:General Statistics"; counter = "Trace Event Notification Queue"; instance = NotApplicable }
  /// SQL Trace IO Provider Lock Waits: Number of waits for the File IO Provider lock per second
  let ``SQL Trace IO Provider Lock Waits`` =
    { category = "SQLServer:General Statistics"; counter = "SQL Trace IO Provider Lock Waits"; instance = NotApplicable }
  /// Tempdb recovery unit id: Number of duplicate tempdb recovery unit id generated
  let ``Tempdb recovery unit id`` =
    { category = "SQLServer:General Statistics"; counter = "Tempdb recovery unit id"; instance = NotApplicable }
  /// Tempdb rowset id: Number of duplicate tempdb rowset id generated
  let ``Tempdb rowset id`` =
    { category = "SQLServer:General Statistics"; counter = "Tempdb rowset id"; instance = NotApplicable }

  let allCounters =
    [ ``Active Temp Tables``
      ``Temp Tables Creation Rate``
      ``Logins/sec``
      ``Connection Reset/sec``
      ``Logouts/sec``
      ``User Connections``
      ``Logical Connections``
      ``Transactions``
      ``Non-atomic yield rate``
      ``Mars Deadlocks``
      ``HTTP Authenticated Requests``
      ``SOAP Empty Requests``
      ``SOAP SQL Requests``
      ``SOAP Method Invocations``
      ``SOAP WSDL Requests``
      ``SOAP Session Initiate Requests``
      ``SOAP Session Terminate Requests``
      ``Processes blocked``
      ``Temp Tables For Destruction``
      ``Event Notifications Delayed Drop``
      ``Trace Event Notification Queue``
      ``SQL Trace IO Provider Lock Waits``
      ``Tempdb recovery unit id``
      ``Tempdb rowset id``
    ]

/// SQLServer:Latches: Collects statistics associated with internal server latches
///
/// This performance counter does not have instance based counters
module ``SQLServer:Latches`` =

  [<Literal>]
  let Category = "SQLServer:Latches"

  let PCC = getPCC Category
  /// Latch Waits/sec: Number of latch requests that could not be granted immediately and had to wait before being granted.
  let ``Latch Waits/sec`` =
    { category = "SQLServer:Latches"; counter = "Latch Waits/sec"; instance = NotApplicable }
  /// Average Latch Wait Time (ms): Average latch wait time (milliseconds) for latch requests that had to wait.
  let ``Average Latch Wait Time (ms)`` =
    { category = "SQLServer:Latches"; counter = "Average Latch Wait Time (ms)"; instance = NotApplicable }
  /// Average Latch Wait Time Base: Base for Average Latch Wait Time.
  let ``Average Latch Wait Time Base`` =
    { category = "SQLServer:Latches"; counter = "Average Latch Wait Time Base"; instance = NotApplicable }
  /// Total Latch Wait Time (ms): Total latch wait time (milliseconds) for latch requests that had to wait in the last second.
  let ``Total Latch Wait Time (ms)`` =
    { category = "SQLServer:Latches"; counter = "Total Latch Wait Time (ms)"; instance = NotApplicable }
  /// Number of SuperLatches: Number of latches that are currently SuperLatches.
  let ``Number of SuperLatches`` =
    { category = "SQLServer:Latches"; counter = "Number of SuperLatches"; instance = NotApplicable }
  /// SuperLatch Promotions/sec: Number of latches that have been promoted to SuperLatches
  let ``SuperLatch Promotions/sec`` =
    { category = "SQLServer:Latches"; counter = "SuperLatch Promotions/sec"; instance = NotApplicable }
  /// SuperLatch Demotions/sec: Number of SuperLatches that have been demoted to regular latches
  let ``SuperLatch Demotions/sec`` =
    { category = "SQLServer:Latches"; counter = "SuperLatch Demotions/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Latch Waits/sec``
      ``Average Latch Wait Time (ms)``
      ``Average Latch Wait Time Base``
      ``Total Latch Wait Time (ms)``
      ``Number of SuperLatches``
      ``SuperLatch Promotions/sec``
      ``SuperLatch Demotions/sec``
    ]

/// SQLServer:Locks: Describes statistics for individual lock server lock requests
///
/// This performance counter does not have instance based counters
module ``SQLServer:Locks`` =

  [<Literal>]
  let Category = "SQLServer:Locks"

  let PCC = getPCC Category
  /// Lock Requests/sec: 
  let ``Lock Requests/sec`` instance =
    { category = "SQLServer:Locks"; counter = "Lock Requests/sec"; instance = instance }
  /// Lock Timeouts/sec: 
  let ``Lock Timeouts/sec`` instance =
    { category = "SQLServer:Locks"; counter = "Lock Timeouts/sec"; instance = instance }
  /// Number of Deadlocks/sec: 
  let ``Number of Deadlocks/sec`` instance =
    { category = "SQLServer:Locks"; counter = "Number of Deadlocks/sec"; instance = instance }
  /// Lock Waits/sec: 
  let ``Lock Waits/sec`` instance =
    { category = "SQLServer:Locks"; counter = "Lock Waits/sec"; instance = instance }
  /// Lock Wait Time (ms): 
  let ``Lock Wait Time (ms)`` instance =
    { category = "SQLServer:Locks"; counter = "Lock Wait Time (ms)"; instance = instance }
  /// Average Wait Time (ms): 
  let ``Average Wait Time (ms)`` instance =
    { category = "SQLServer:Locks"; counter = "Average Wait Time (ms)"; instance = instance }
  /// Average Wait Time Base: 
  let ``Average Wait Time Base`` instance =
    { category = "SQLServer:Locks"; counter = "Average Wait Time Base"; instance = instance }
  /// Lock Timeouts (timeout > 0)/sec: 
  let ``Lock Timeouts (timeout > 0)/sec`` instance =
    { category = "SQLServer:Locks"; counter = "Lock Timeouts (timeout > 0)/sec"; instance = instance }

  let allCounters =
    [ ``Lock Requests/sec``
      ``Lock Timeouts/sec``
      ``Number of Deadlocks/sec``
      ``Lock Waits/sec``
      ``Lock Wait Time (ms)``
      ``Average Wait Time (ms)``
      ``Average Wait Time Base``
      ``Lock Timeouts (timeout > 0)/sec``
    ]

/// SQLServer:Memory Broker Clerks: Statistics related to memory broker clerks
///
/// This performance counter does not have instance based counters
module ``SQLServer:Memory Broker Clerks`` =

  [<Literal>]
  let Category = "SQLServer:Memory Broker Clerks"

  let PCC = getPCC Category
  /// Memory broker clerk size: 
  let ``Memory broker clerk size`` instance =
    { category = "SQLServer:Memory Broker Clerks"; counter = "Memory broker clerk size"; instance = instance }
  /// Simulation benefit: 
  let ``Simulation benefit`` instance =
    { category = "SQLServer:Memory Broker Clerks"; counter = "Simulation benefit"; instance = instance }
  /// Simulation size: 
  let ``Simulation size`` instance =
    { category = "SQLServer:Memory Broker Clerks"; counter = "Simulation size"; instance = instance }
  /// Internal benefit: 
  let ``Internal benefit`` instance =
    { category = "SQLServer:Memory Broker Clerks"; counter = "Internal benefit"; instance = instance }
  /// Periodic evictions (pages): 
  let ``Periodic evictions (pages)`` instance =
    { category = "SQLServer:Memory Broker Clerks"; counter = "Periodic evictions (pages)"; instance = instance }
  /// Pressure evictions (pages/sec): 
  let ``Pressure evictions (pages/sec)`` instance =
    { category = "SQLServer:Memory Broker Clerks"; counter = "Pressure evictions (pages/sec)"; instance = instance }

  let allCounters =
    [ ``Memory broker clerk size``
      ``Simulation benefit``
      ``Simulation size``
      ``Internal benefit``
      ``Periodic evictions (pages)``
      ``Pressure evictions (pages/sec)``
    ]

/// SQLServer:Memory Manager: This defines memory usage.
///
/// This performance counter does not have instance based counters
module ``SQLServer:Memory Manager`` =

  [<Literal>]
  let Category = "SQLServer:Memory Manager"

  let PCC = getPCC Category
  /// External benefit of memory: The external value of memory, in ms per page per ms, multiplied by 10 billion and truncated to an integer
  let ``External benefit of memory`` =
    { category = "SQLServer:Memory Manager"; counter = "External benefit of memory"; instance = NotApplicable }
  /// Connection Memory (KB): Total amount of dynamic memory the server is using for maintaining connections
  let ``Connection Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Connection Memory (KB)"; instance = NotApplicable }
  /// Database Cache Memory (KB): Amount of memory the server is currently using for the database cache.
  let ``Database Cache Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Database Cache Memory (KB)"; instance = NotApplicable }
  /// Free Memory (KB): Amount of memory the server is currently not using.
  let ``Free Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Free Memory (KB)"; instance = NotApplicable }
  /// Granted Workspace Memory (KB): Total amount of memory granted to executing processes. This memory is used for hash, sort and create index operations.
  let ``Granted Workspace Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Granted Workspace Memory (KB)"; instance = NotApplicable }
  /// Lock Memory (KB): Total amount of dynamic memory the server is using for locks
  let ``Lock Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Lock Memory (KB)"; instance = NotApplicable }
  /// Lock Blocks Allocated: The current number of allocated lock blocks.
  let ``Lock Blocks Allocated`` =
    { category = "SQLServer:Memory Manager"; counter = "Lock Blocks Allocated"; instance = NotApplicable }
  /// Lock Owner Blocks Allocated: The current number of allocated lock owner blocks.
  let ``Lock Owner Blocks Allocated`` =
    { category = "SQLServer:Memory Manager"; counter = "Lock Owner Blocks Allocated"; instance = NotApplicable }
  /// Lock Blocks: The current number of lock blocks that are in use on the server. Refreshed periodically.
  let ``Lock Blocks`` =
    { category = "SQLServer:Memory Manager"; counter = "Lock Blocks"; instance = NotApplicable }
  /// Lock Owner Blocks: The number of lock owner blocks that are currently in use on the server. Refreshed periodically.
  let ``Lock Owner Blocks`` =
    { category = "SQLServer:Memory Manager"; counter = "Lock Owner Blocks"; instance = NotApplicable }
  /// Maximum Workspace Memory (KB): Total amount of memory available for grants to executing processes. This memory is used primarily for hash, sort and create index operations.
  let ``Maximum Workspace Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Maximum Workspace Memory (KB)"; instance = NotApplicable }
  /// Memory Grants Outstanding: Current number of processes that have successfully acquired a workspace memory grant
  let ``Memory Grants Outstanding`` =
    { category = "SQLServer:Memory Manager"; counter = "Memory Grants Outstanding"; instance = NotApplicable }
  /// Memory Grants Pending: Current number of processes waiting for a workspace memory grant
  let ``Memory Grants Pending`` =
    { category = "SQLServer:Memory Manager"; counter = "Memory Grants Pending"; instance = NotApplicable }
  /// Optimizer Memory (KB): Total amount of dynamic memory the server is using for query optimization
  let ``Optimizer Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Optimizer Memory (KB)"; instance = NotApplicable }
  /// Reserved Server Memory (KB): Amount of memory the server has reserved for future usage. This counter shows current unused amount of the initial grant shown in Granted Workspace Memory (KB).
  let ``Reserved Server Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Reserved Server Memory (KB)"; instance = NotApplicable }
  /// SQL Cache Memory (KB): Total amount of dynamic memory the server is using for the dynamic SQL cache
  let ``SQL Cache Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "SQL Cache Memory (KB)"; instance = NotApplicable }
  /// Stolen Server Memory (KB): Amount of memory the server is currently using for the purposes other than the database pages.
  let ``Stolen Server Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Stolen Server Memory (KB)"; instance = NotApplicable }
  /// Log Pool Memory (KB): Total amount of dynamic memory the server is using for Log Pool
  let ``Log Pool Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Log Pool Memory (KB)"; instance = NotApplicable }
  /// Target Server Memory (KB): Ideal amount of memory the server is willing to consume
  let ``Target Server Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Target Server Memory (KB)"; instance = NotApplicable }
  /// Total Server Memory (KB): Total amount of dynamic memory the server is currently consuming
  let ``Total Server Memory (KB)`` =
    { category = "SQLServer:Memory Manager"; counter = "Total Server Memory (KB)"; instance = NotApplicable }

  let allCounters =
    [ ``External benefit of memory``
      ``Connection Memory (KB)``
      ``Database Cache Memory (KB)``
      ``Free Memory (KB)``
      ``Granted Workspace Memory (KB)``
      ``Lock Memory (KB)``
      ``Lock Blocks Allocated``
      ``Lock Owner Blocks Allocated``
      ``Lock Blocks``
      ``Lock Owner Blocks``
      ``Maximum Workspace Memory (KB)``
      ``Memory Grants Outstanding``
      ``Memory Grants Pending``
      ``Optimizer Memory (KB)``
      ``Reserved Server Memory (KB)``
      ``SQL Cache Memory (KB)``
      ``Stolen Server Memory (KB)``
      ``Log Pool Memory (KB)``
      ``Target Server Memory (KB)``
      ``Total Server Memory (KB)``
    ]

/// SQLServer:Memory Node: This defines memory usage per NUMA node.
///
/// This performance counter does not have instance based counters
module ``SQLServer:Memory Node`` =

  [<Literal>]
  let Category = "SQLServer:Memory Node"

  let PCC = getPCC Category
  /// Database Node Memory (KB): 
  let ``Database Node Memory (KB)`` instance =
    { category = "SQLServer:Memory Node"; counter = "Database Node Memory (KB)"; instance = instance }
  /// Free Node Memory (KB): 
  let ``Free Node Memory (KB)`` instance =
    { category = "SQLServer:Memory Node"; counter = "Free Node Memory (KB)"; instance = instance }
  /// Foreign Node Memory (KB): 
  let ``Foreign Node Memory (KB)`` instance =
    { category = "SQLServer:Memory Node"; counter = "Foreign Node Memory (KB)"; instance = instance }
  /// Stolen Node Memory (KB): 
  let ``Stolen Node Memory (KB)`` instance =
    { category = "SQLServer:Memory Node"; counter = "Stolen Node Memory (KB)"; instance = instance }
  /// Target Node Memory (KB): 
  let ``Target Node Memory (KB)`` instance =
    { category = "SQLServer:Memory Node"; counter = "Target Node Memory (KB)"; instance = instance }
  /// Total Node Memory (KB): 
  let ``Total Node Memory (KB)`` instance =
    { category = "SQLServer:Memory Node"; counter = "Total Node Memory (KB)"; instance = instance }

  let allCounters =
    [ ``Database Node Memory (KB)``
      ``Free Node Memory (KB)``
      ``Foreign Node Memory (KB)``
      ``Stolen Node Memory (KB)``
      ``Target Node Memory (KB)``
      ``Total Node Memory (KB)``
    ]

/// SQLServer:Plan Cache: This defines cache counters
///
/// This performance counter does not have instance based counters
module ``SQLServer:Plan Cache`` =

  [<Literal>]
  let Category = "SQLServer:Plan Cache"

  let PCC = getPCC Category
  /// Cache Hit Ratio: 
  let ``Cache Hit Ratio`` instance =
    { category = "SQLServer:Plan Cache"; counter = "Cache Hit Ratio"; instance = instance }
  /// Cache Hit Ratio Base: 
  let ``Cache Hit Ratio Base`` instance =
    { category = "SQLServer:Plan Cache"; counter = "Cache Hit Ratio Base"; instance = instance }
  /// Cache Pages: 
  let ``Cache Pages`` instance =
    { category = "SQLServer:Plan Cache"; counter = "Cache Pages"; instance = instance }
  /// Cache Object Counts: 
  let ``Cache Object Counts`` instance =
    { category = "SQLServer:Plan Cache"; counter = "Cache Object Counts"; instance = instance }
  /// Cache Objects in use: 
  let ``Cache Objects in use`` instance =
    { category = "SQLServer:Plan Cache"; counter = "Cache Objects in use"; instance = instance }

  let allCounters =
    [ ``Cache Hit Ratio``
      ``Cache Hit Ratio Base``
      ``Cache Pages``
      ``Cache Object Counts``
      ``Cache Objects in use``
    ]

/// SQLServer:Query Execution: Statistics associated with Query Execution
///
/// This performance counter does not have instance based counters
module ``SQLServer:Query Execution`` =

  [<Literal>]
  let Category = "SQLServer:Query Execution"

  let PCC = getPCC Category
  /// Remote requests/sec: Total number of remote request per second
  let ``Remote requests/sec`` =
    { category = "SQLServer:Query Execution"; counter = "Remote requests/sec"; instance = NotApplicable }
  /// Remote resend requests/sec: Total number of remote resend request per second
  let ``Remote resend requests/sec`` =
    { category = "SQLServer:Query Execution"; counter = "Remote resend requests/sec"; instance = NotApplicable }
  /// Remote activations/sec: Total number of remote activations per second
  let ``Remote activations/sec`` =
    { category = "SQLServer:Query Execution"; counter = "Remote activations/sec"; instance = NotApplicable }
  /// Local data access/sec: Total number of local data access per second
  let ``Local data access/sec`` =
    { category = "SQLServer:Query Execution"; counter = "Local data access/sec"; instance = NotApplicable }
  /// Rem Req Cache Hit Ratio: Ratio between cache hits and lookups
  let ``Rem Req Cache Hit Ratio`` =
    { category = "SQLServer:Query Execution"; counter = "Rem Req Cache Hit Ratio"; instance = NotApplicable }
  /// Rem Req Cache Hit Ratio Base: Base for prior entry
  let ``Rem Req Cache Hit Ratio Base`` =
    { category = "SQLServer:Query Execution"; counter = "Rem Req Cache Hit Ratio Base"; instance = NotApplicable }

  let allCounters =
    [ ``Remote requests/sec``
      ``Remote resend requests/sec``
      ``Remote activations/sec``
      ``Local data access/sec``
      ``Rem Req Cache Hit Ratio``
      ``Rem Req Cache Hit Ratio Base``
    ]

/// SQLServer:Replication Agents: Replication Summary
///
/// This performance counter does not have instance based counters
module ``SQLServer:Replication Agents`` =

  [<Literal>]
  let Category = "SQLServer:Replication Agents"

  let PCC = getPCC Category
  /// Running: 
  let ``Running`` instance =
    { category = "SQLServer:Replication Agents"; counter = "Running"; instance = instance }

  let allCounters =
    [ ``Running``

    ]

/// SQLServer:Replication Dist.: Replication Distribution Agent Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Replication Dist_`` =

  [<Literal>]
  let Category = "SQLServer:Replication Dist."

  let PCC = getPCC Category
  /// Dist:Delivery Latency: 
  let ``Dist:Delivery Latency`` instance =
    { category = "SQLServer:Replication Dist."; counter = "Dist:Delivery Latency"; instance = instance }
  /// Dist:Delivered Cmds/sec: 
  let ``Dist:Delivered Cmds/sec`` instance =
    { category = "SQLServer:Replication Dist."; counter = "Dist:Delivered Cmds/sec"; instance = instance }
  /// Dist:Delivered Trans/sec: 
  let ``Dist:Delivered Trans/sec`` instance =
    { category = "SQLServer:Replication Dist."; counter = "Dist:Delivered Trans/sec"; instance = instance }

  let allCounters =
    [ ``Dist:Delivery Latency``
      ``Dist:Delivered Cmds/sec``
      ``Dist:Delivered Trans/sec``
    ]

/// SQLServer:Replication Logreader: Replication Logreader Agent Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Replication Logreader`` =

  [<Literal>]
  let Category = "SQLServer:Replication Logreader"

  let PCC = getPCC Category
  /// Logreader:Delivery Latency: 
  let ``Logreader:Delivery Latency`` instance =
    { category = "SQLServer:Replication Logreader"; counter = "Logreader:Delivery Latency"; instance = instance }
  /// Logreader:Delivered Cmds/sec: 
  let ``Logreader:Delivered Cmds/sec`` instance =
    { category = "SQLServer:Replication Logreader"; counter = "Logreader:Delivered Cmds/sec"; instance = instance }
  /// Logreader:Delivered Trans/sec: 
  let ``Logreader:Delivered Trans/sec`` instance =
    { category = "SQLServer:Replication Logreader"; counter = "Logreader:Delivered Trans/sec"; instance = instance }

  let allCounters =
    [ ``Logreader:Delivery Latency``
      ``Logreader:Delivered Cmds/sec``
      ``Logreader:Delivered Trans/sec``
    ]

/// SQLServer:Replication Merge: Replication Merge Agent Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Replication Merge`` =

  [<Literal>]
  let Category = "SQLServer:Replication Merge"

  let PCC = getPCC Category
  /// Uploaded Changes/sec: 
  let ``Uploaded Changes/sec`` instance =
    { category = "SQLServer:Replication Merge"; counter = "Uploaded Changes/sec"; instance = instance }
  /// Downloaded Changes/sec: 
  let ``Downloaded Changes/sec`` instance =
    { category = "SQLServer:Replication Merge"; counter = "Downloaded Changes/sec"; instance = instance }
  /// Conflicts/sec: 
  let ``Conflicts/sec`` instance =
    { category = "SQLServer:Replication Merge"; counter = "Conflicts/sec"; instance = instance }

  let allCounters =
    [ ``Uploaded Changes/sec``
      ``Downloaded Changes/sec``
      ``Conflicts/sec``
    ]

/// SQLServer:Replication Snapshot: Replication Snapshot Agent Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Replication Snapshot`` =

  [<Literal>]
  let Category = "SQLServer:Replication Snapshot"

  let PCC = getPCC Category
  /// Snapshot:Delivered Cmds/sec: 
  let ``Snapshot:Delivered Cmds/sec`` instance =
    { category = "SQLServer:Replication Snapshot"; counter = "Snapshot:Delivered Cmds/sec"; instance = instance }
  /// Snapshot:Delivered Trans/sec: 
  let ``Snapshot:Delivered Trans/sec`` instance =
    { category = "SQLServer:Replication Snapshot"; counter = "Snapshot:Delivered Trans/sec"; instance = instance }

  let allCounters =
    [ ``Snapshot:Delivered Cmds/sec``
      ``Snapshot:Delivered Trans/sec``
    ]

/// SQLServer:Resource Pool Stats: Statistics associated with resource pools
///
/// This performance counter does not have instance based counters
module ``SQLServer:Resource Pool Stats`` =

  [<Literal>]
  let Category = "SQLServer:Resource Pool Stats"

  let PCC = getPCC Category
  /// CPU usage %: 
  let ``CPU usage %`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "CPU usage %"; instance = instance }
  /// CPU usage % base: 
  let ``CPU usage % base`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "CPU usage % base"; instance = instance }
  /// CPU usage target %: 
  let ``CPU usage target %`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "CPU usage target %"; instance = instance }
  /// CPU control effect %: 
  let ``CPU control effect %`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "CPU control effect %"; instance = instance }
  /// Compile memory target (KB): 
  let ``Compile memory target (KB)`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Compile memory target (KB)"; instance = instance }
  /// Cache memory target (KB): 
  let ``Cache memory target (KB)`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Cache memory target (KB)"; instance = instance }
  /// Query exec memory target (KB): 
  let ``Query exec memory target (KB)`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Query exec memory target (KB)"; instance = instance }
  /// Memory grants/sec: 
  let ``Memory grants/sec`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Memory grants/sec"; instance = instance }
  /// Active memory grants count: 
  let ``Active memory grants count`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Active memory grants count"; instance = instance }
  /// Memory grant timeouts/sec: 
  let ``Memory grant timeouts/sec`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Memory grant timeouts/sec"; instance = instance }
  /// Active memory grant amount (KB): 
  let ``Active memory grant amount (KB)`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Active memory grant amount (KB)"; instance = instance }
  /// Pending memory grants count: 
  let ``Pending memory grants count`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Pending memory grants count"; instance = instance }
  /// Max memory (KB): 
  let ``Max memory (KB)`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Max memory (KB)"; instance = instance }
  /// Used memory (KB): 
  let ``Used memory (KB)`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Used memory (KB)"; instance = instance }
  /// Target memory (KB): 
  let ``Target memory (KB)`` instance =
    { category = "SQLServer:Resource Pool Stats"; counter = "Target memory (KB)"; instance = instance }

  let allCounters =
    [ ``CPU usage %``
      ``CPU usage % base``
      ``CPU usage target %``
      ``CPU control effect %``
      ``Compile memory target (KB)``
      ``Cache memory target (KB)``
      ``Query exec memory target (KB)``
      ``Memory grants/sec``
      ``Active memory grants count``
      ``Memory grant timeouts/sec``
      ``Active memory grant amount (KB)``
      ``Pending memory grants count``
      ``Max memory (KB)``
      ``Used memory (KB)``
      ``Target memory (KB)``
    ]

/// SQLServer:SQL Errors: Statistics about errors in SQL Server
///
/// This performance counter does not have instance based counters
module ``SQLServer:SQL Errors`` =

  [<Literal>]
  let Category = "SQLServer:SQL Errors"

  let PCC = getPCC Category
  /// Errors/sec: 
  let ``Errors/sec`` instance =
    { category = "SQLServer:SQL Errors"; counter = "Errors/sec"; instance = instance }

  let allCounters =
    [ ``Errors/sec``

    ]

/// SQLServer:SQL Statistics: Collects statistics associated with SQL requests
///
/// This performance counter does not have instance based counters
module ``SQLServer:SQL Statistics`` =

  [<Literal>]
  let Category = "SQLServer:SQL Statistics"

  let PCC = getPCC Category
  /// Batch Requests/sec: Number of SQL batch requests received by server.
  let ``Batch Requests/sec`` =
    { category = "SQLServer:SQL Statistics"; counter = "Batch Requests/sec"; instance = NotApplicable }
  /// Forced Parameterizations/sec: Number of statements parameterized by forced parameterization per second.
  let ``Forced Parameterizations/sec`` =
    { category = "SQLServer:SQL Statistics"; counter = "Forced Parameterizations/sec"; instance = NotApplicable }
  /// Auto-Param Attempts/sec: Number of auto-parameterization attempts.
  let ``Auto-Param Attempts/sec`` =
    { category = "SQLServer:SQL Statistics"; counter = "Auto-Param Attempts/sec"; instance = NotApplicable }
  /// Failed Auto-Params/sec: Number of failed auto-parameterizations.
  let ``Failed Auto-Params/sec`` =
    { category = "SQLServer:SQL Statistics"; counter = "Failed Auto-Params/sec"; instance = NotApplicable }
  /// Safe Auto-Params/sec: Number of safe auto-parameterizations.
  let ``Safe Auto-Params/sec`` =
    { category = "SQLServer:SQL Statistics"; counter = "Safe Auto-Params/sec"; instance = NotApplicable }
  /// Unsafe Auto-Params/sec: Number of unsafe auto-parameterizations.
  let ``Unsafe Auto-Params/sec`` =
    { category = "SQLServer:SQL Statistics"; counter = "Unsafe Auto-Params/sec"; instance = NotApplicable }
  /// SQL Compilations/sec: Number of SQL compilations.
  let ``SQL Compilations/sec`` =
    { category = "SQLServer:SQL Statistics"; counter = "SQL Compilations/sec"; instance = NotApplicable }
  /// SQL Re-Compilations/sec: Number of SQL re-compiles.
  let ``SQL Re-Compilations/sec`` =
    { category = "SQLServer:SQL Statistics"; counter = "SQL Re-Compilations/sec"; instance = NotApplicable }
  /// SQL Attention rate: Number of attentions per second.
  let ``SQL Attention rate`` =
    { category = "SQLServer:SQL Statistics"; counter = "SQL Attention rate"; instance = NotApplicable }
  /// Guided plan executions/sec: Number of plan executions per second in which the query plan has been generated by using a plan guide.
  let ``Guided plan executions/sec`` =
    { category = "SQLServer:SQL Statistics"; counter = "Guided plan executions/sec"; instance = NotApplicable }
  /// Misguided plan executions/sec: Number of plan executions per second in which a plan guide could not be honored during plan generation. The plan guide was disregarded and normal compilation was used to generate the executed plan.
  let ``Misguided plan executions/sec`` =
    { category = "SQLServer:SQL Statistics"; counter = "Misguided plan executions/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Batch Requests/sec``
      ``Forced Parameterizations/sec``
      ``Auto-Param Attempts/sec``
      ``Failed Auto-Params/sec``
      ``Safe Auto-Params/sec``
      ``Unsafe Auto-Params/sec``
      ``SQL Compilations/sec``
      ``SQL Re-Compilations/sec``
      ``SQL Attention rate``
      ``Guided plan executions/sec``
      ``Misguided plan executions/sec``
    ]

/// SQLServer:Transactions: Statistics related to SQL Server transactions.
///
/// This performance counter does not have instance based counters
module ``SQLServer:Transactions`` =

  [<Literal>]
  let Category = "SQLServer:Transactions"

  let PCC = getPCC Category
  /// Transactions: The total number of active transactions.
  let ``Transactions`` =
    { category = "SQLServer:Transactions"; counter = "Transactions"; instance = NotApplicable }
  /// Snapshot Transactions: The total number of active snapshot transactions.
  let ``Snapshot Transactions`` =
    { category = "SQLServer:Transactions"; counter = "Snapshot Transactions"; instance = NotApplicable }
  /// Update Snapshot Transactions: The total number of active snapshot transactions that do updates.
  let ``Update Snapshot Transactions`` =
    { category = "SQLServer:Transactions"; counter = "Update Snapshot Transactions"; instance = NotApplicable }
  /// NonSnapshot Version Transactions: The total number of active non-snapshot transactions that generate version records.
  let ``NonSnapshot Version Transactions`` =
    { category = "SQLServer:Transactions"; counter = "NonSnapshot Version Transactions"; instance = NotApplicable }
  /// Longest Transaction Running Time: The longest running time of any transcation in seconds.
  let ``Longest Transaction Running Time`` =
    { category = "SQLServer:Transactions"; counter = "Longest Transaction Running Time"; instance = NotApplicable }
  /// Update conflict ratio: The fraction of update snapshot transactions that have update conflicts to the total number of update snapshot transactions.
  let ``Update conflict ratio`` =
    { category = "SQLServer:Transactions"; counter = "Update conflict ratio"; instance = NotApplicable }
  /// Update conflict ratio base: The total number of update snapshot transactions.
  let ``Update conflict ratio base`` =
    { category = "SQLServer:Transactions"; counter = "Update conflict ratio base"; instance = NotApplicable }
  /// Free Space in tempdb (KB): The free space in tempdb in KB.
  let ``Free Space in tempdb (KB)`` =
    { category = "SQLServer:Transactions"; counter = "Free Space in tempdb (KB)"; instance = NotApplicable }
  /// Version Generation rate (KB/s): The version generation rate in KB per seconds.
  let ``Version Generation rate (KB/s)`` =
    { category = "SQLServer:Transactions"; counter = "Version Generation rate (KB/s)"; instance = NotApplicable }
  /// Version Cleanup rate (KB/s): The version cleanup rate in KB per seconds.
  let ``Version Cleanup rate (KB/s)`` =
    { category = "SQLServer:Transactions"; counter = "Version Cleanup rate (KB/s)"; instance = NotApplicable }
  /// Version Store Size (KB): The size of the version store in KB.
  let ``Version Store Size (KB)`` =
    { category = "SQLServer:Transactions"; counter = "Version Store Size (KB)"; instance = NotApplicable }
  /// Version Store unit count: Number of unit in Version Store.
  let ``Version Store unit count`` =
    { category = "SQLServer:Transactions"; counter = "Version Store unit count"; instance = NotApplicable }
  /// Version Store unit creation: Creation of new unit in Version Store.
  let ``Version Store unit creation`` =
    { category = "SQLServer:Transactions"; counter = "Version Store unit creation"; instance = NotApplicable }
  /// Version Store unit truncation: Truncation of unit in Version Store.
  let ``Version Store unit truncation`` =
    { category = "SQLServer:Transactions"; counter = "Version Store unit truncation"; instance = NotApplicable }

  let allCounters =
    [ ``Transactions``
      ``Snapshot Transactions``
      ``Update Snapshot Transactions``
      ``NonSnapshot Version Transactions``
      ``Longest Transaction Running Time``
      ``Update conflict ratio``
      ``Update conflict ratio base``
      ``Free Space in tempdb (KB)``
      ``Version Generation rate (KB/s)``
      ``Version Cleanup rate (KB/s)``
      ``Version Store Size (KB)``
      ``Version Store unit count``
      ``Version Store unit creation``
      ``Version Store unit truncation``
    ]

/// SQLServer:User Settable: This defines user definable counters
///
/// This performance counter does not have instance based counters
module ``SQLServer:User Settable`` =

  [<Literal>]
  let Category = "SQLServer:User Settable"

  let PCC = getPCC Category
  /// Query: 
  let ``Query`` instance =
    { category = "SQLServer:User Settable"; counter = "Query"; instance = instance }

  let allCounters =
    [ ``Query``

    ]

/// SQLServer:Wait Statistics: Wait Statistics
///
/// This performance counter does not have instance based counters
module ``SQLServer:Wait Statistics`` =

  [<Literal>]
  let Category = "SQLServer:Wait Statistics"

  let PCC = getPCC Category
  /// Lock waits: 
  let ``Lock waits`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Lock waits"; instance = instance }
  /// Memory grant queue waits: 
  let ``Memory grant queue waits`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Memory grant queue waits"; instance = instance }
  /// Thread-safe memory objects waits: 
  let ``Thread-safe memory objects waits`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Thread-safe memory objects waits"; instance = instance }
  /// Log write waits: 
  let ``Log write waits`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Log write waits"; instance = instance }
  /// Log buffer waits: 
  let ``Log buffer waits`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Log buffer waits"; instance = instance }
  /// Network IO waits: 
  let ``Network IO waits`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Network IO waits"; instance = instance }
  /// Page IO latch waits: 
  let ``Page IO latch waits`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Page IO latch waits"; instance = instance }
  /// Page latch waits: 
  let ``Page latch waits`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Page latch waits"; instance = instance }
  /// Non-Page latch waits: 
  let ``Non-Page latch waits`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Non-Page latch waits"; instance = instance }
  /// Wait for the worker: 
  let ``Wait for the worker`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Wait for the worker"; instance = instance }
  /// Workspace synchronization waits: 
  let ``Workspace synchronization waits`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Workspace synchronization waits"; instance = instance }
  /// Transaction ownership waits: 
  let ``Transaction ownership waits`` instance =
    { category = "SQLServer:Wait Statistics"; counter = "Transaction ownership waits"; instance = instance }

  let allCounters =
    [ ``Lock waits``
      ``Memory grant queue waits``
      ``Thread-safe memory objects waits``
      ``Log write waits``
      ``Log buffer waits``
      ``Network IO waits``
      ``Page IO latch waits``
      ``Page latch waits``
      ``Non-Page latch waits``
      ``Wait for the worker``
      ``Workspace synchronization waits``
      ``Transaction ownership waits``
    ]

/// SQLServer:Workload Group Stats: Statistics associated with workload groups
///
/// This performance counter does not have instance based counters
module ``SQLServer:Workload Group Stats`` =

  [<Literal>]
  let Category = "SQLServer:Workload Group Stats"

  let PCC = getPCC Category
  /// CPU usage %: 
  let ``CPU usage %`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "CPU usage %"; instance = instance }
  /// CPU usage % base: 
  let ``CPU usage % base`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "CPU usage % base"; instance = instance }
  /// Queued requests: 
  let ``Queued requests`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "Queued requests"; instance = instance }
  /// Active requests: 
  let ``Active requests`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "Active requests"; instance = instance }
  /// Requests completed/sec: 
  let ``Requests completed/sec`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "Requests completed/sec"; instance = instance }
  /// Max request cpu time (ms): 
  let ``Max request cpu time (ms)`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "Max request cpu time (ms)"; instance = instance }
  /// Blocked tasks: 
  let ``Blocked tasks`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "Blocked tasks"; instance = instance }
  /// Reduced memory grants/sec: 
  let ``Reduced memory grants/sec`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "Reduced memory grants/sec"; instance = instance }
  /// Max request memory grant (KB): 
  let ``Max request memory grant (KB)`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "Max request memory grant (KB)"; instance = instance }
  /// Query optimizations/sec: 
  let ``Query optimizations/sec`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "Query optimizations/sec"; instance = instance }
  /// Suboptimal plans/sec: 
  let ``Suboptimal plans/sec`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "Suboptimal plans/sec"; instance = instance }
  /// Active parallel threads: 
  let ``Active parallel threads`` instance =
    { category = "SQLServer:Workload Group Stats"; counter = "Active parallel threads"; instance = instance }

  let allCounters =
    [ ``CPU usage %``
      ``CPU usage % base``
      ``Queued requests``
      ``Active requests``
      ``Requests completed/sec``
      ``Max request cpu time (ms)``
      ``Blocked tasks``
      ``Reduced memory grants/sec``
      ``Max request memory grant (KB)``
      ``Query optimizations/sec``
      ``Suboptimal plans/sec``
      ``Active parallel threads``
    ]

/// Search Indexer: Indexer PlugIn statistics
///
/// This performance counter does not have non-instance based counters
module ``Search Indexer`` =

  [<Literal>]
  let Category = "Search Indexer"

  let PCC = getPCC Category
  /// Master Index Level.: The level of the master index.
  let ``Master Index Level.`` instance =
    { category = "Search Indexer"; counter = "Master Index Level."; instance = instance }
  /// Master Merges to Date: Number of Master Merges to Date
  let ``Master Merges to Date`` instance =
    { category = "Search Indexer"; counter = "Master Merges to Date"; instance = instance }
  /// Master Merge Progress: Master Merge Progress
  let ``Master Merge Progress`` instance =
    { category = "Search Indexer"; counter = "Master Merge Progress"; instance = instance }
  /// Shadow Merge Levels: Shadow Merge Levels
  let ``Shadow Merge Levels`` instance =
    { category = "Search Indexer"; counter = "Shadow Merge Levels"; instance = instance }
  /// Shadow Merge Levels Threshold: Shadow Merge Levels Threshold
  let ``Shadow Merge Levels Threshold`` instance =
    { category = "Search Indexer"; counter = "Shadow Merge Levels Threshold"; instance = instance }
  /// Persistent Indexes: Number of Persistent Indexes
  let ``Persistent Indexes`` instance =
    { category = "Search Indexer"; counter = "Persistent Indexes"; instance = instance }
  /// Index Size: Size of Index
  let ``Index Size`` instance =
    { category = "Search Indexer"; counter = "Index Size"; instance = instance }
  /// Unique Keys: Number of Unique Keys
  let ``Unique Keys`` instance =
    { category = "Search Indexer"; counter = "Unique Keys"; instance = instance }
  /// Documents Filtered: Number of Documents Filtered
  let ``Documents Filtered`` instance =
    { category = "Search Indexer"; counter = "Documents Filtered"; instance = instance }
  /// Work Items Created: Number of invalidator work items that were created
  let ``Work Items Created`` instance =
    { category = "Search Indexer"; counter = "Work Items Created"; instance = instance }
  /// Work Items Deleted: Number of invalidator work items that were deleted
  let ``Work Items Deleted`` instance =
    { category = "Search Indexer"; counter = "Work Items Deleted"; instance = instance }
  /// Clean WidSets: Number of clean WidSets
  let ``Clean WidSets`` instance =
    { category = "Search Indexer"; counter = "Clean WidSets"; instance = instance }
  /// Dirty WidSets: Number of dirty WidSets
  let ``Dirty WidSets`` instance =
    { category = "Search Indexer"; counter = "Dirty WidSets"; instance = instance }
  /// Master Merges Now.: Indicator if a master merge is going on.
  let ``Master Merges Now.`` instance =
    { category = "Search Indexer"; counter = "Master Merges Now."; instance = instance }
  /// Active Connections: Active Connections
  let ``Active Connections`` instance =
    { category = "Search Indexer"; counter = "Active Connections"; instance = instance }
  /// Queries: Number of Queries
  let ``Queries`` instance =
    { category = "Search Indexer"; counter = "Queries"; instance = instance }
  /// Queries Failed: Number of Queries Failed
  let ``Queries Failed`` instance =
    { category = "Search Indexer"; counter = "Queries Failed"; instance = instance }
  /// Queries Succeeded: Number of Queries Succeeded
  let ``Queries Succeeded`` instance =
    { category = "Search Indexer"; counter = "Queries Succeeded"; instance = instance }
  /// L0 Indexes (Wordlists): The number of L0 Indexes (Wordlists)
  let ``L0 Indexes (Wordlists)`` instance =
    { category = "Search Indexer"; counter = "L0 Indexes (Wordlists)"; instance = instance }
  /// L0 Merges (flushes) Now.: The number of L0 merges (flushes) in progress at any one moment.
  let ``L0 Merges (flushes) Now.`` instance =
    { category = "Search Indexer"; counter = "L0 Merges (flushes) Now."; instance = instance }
  /// L0 Merge (Flush) Speed - Average: The average value [documents/hour] computed for the speed of L0 merges (flushes) since the catalog has been loaded
  let ``L0 Merge (Flush) Speed - Average`` instance =
    { category = "Search Indexer"; counter = "L0 Merge (Flush) Speed - Average"; instance = instance }
  /// L0 Merge (Flush) - Count: The number of L0 merges (flushes) since the catalog was loaded
  let ``L0 Merge (Flush) - Count`` instance =
    { category = "Search Indexer"; counter = "L0 Merge (Flush) - Count"; instance = instance }
  /// L0 Merge (Flush) Speed - Last: The last value [documents/hour] computed for the speed of L0 merges (flushes).
  let ``L0 Merge (Flush) Speed - Last`` instance =
    { category = "Search Indexer"; counter = "L0 Merge (Flush) Speed - Last"; instance = instance }
  /// Persistent Indexes L1: The number of L1 Indexes
  let ``Persistent Indexes L1`` instance =
    { category = "Search Indexer"; counter = "Persistent Indexes L1"; instance = instance }
  /// L1 Merges Now.: The number of L1 merges in progress at any one moment.
  let ``L1 Merges Now.`` instance =
    { category = "Search Indexer"; counter = "L1 Merges Now."; instance = instance }
  /// L1 Merge Speed - average: The average value [documents/hour] computed for the speed of L1 merges since the catalog has been loaded
  let ``L1 Merge Speed - average`` instance =
    { category = "Search Indexer"; counter = "L1 Merge Speed - average"; instance = instance }
  /// L1 Merge - Count: The number of L1 merges since the catalog was loaded
  let ``L1 Merge - Count`` instance =
    { category = "Search Indexer"; counter = "L1 Merge - Count"; instance = instance }
  /// L1 Merge Speed - last: The last value [documents/hour] computed for the speed of L1 merges.
  let ``L1 Merge Speed - last`` instance =
    { category = "Search Indexer"; counter = "L1 Merge Speed - last"; instance = instance }
  /// Persistent Indexes L2: The number of L2 Indexes
  let ``Persistent Indexes L2`` instance =
    { category = "Search Indexer"; counter = "Persistent Indexes L2"; instance = instance }
  /// L2 Merges Now.: The number of L2 merges in progress at any one moment.
  let ``L2 Merges Now.`` instance =
    { category = "Search Indexer"; counter = "L2 Merges Now."; instance = instance }
  /// L2 Merge Speed - average: The average value [documents/hour] computed for the speed of L2 merges since the catalog has been loaded
  let ``L2 Merge Speed - average`` instance =
    { category = "Search Indexer"; counter = "L2 Merge Speed - average"; instance = instance }
  /// L2 Merge - Count: The number of L2 merges since the catalog was loaded
  let ``L2 Merge - Count`` instance =
    { category = "Search Indexer"; counter = "L2 Merge - Count"; instance = instance }
  /// L2 Merge Speed - last: The last value [documents/hour] computed for the speed of L2 merges.
  let ``L2 Merge Speed - last`` instance =
    { category = "Search Indexer"; counter = "L2 Merge Speed - last"; instance = instance }
  /// Persistent Indexes L3: The number of L3 Indexes
  let ``Persistent Indexes L3`` instance =
    { category = "Search Indexer"; counter = "Persistent Indexes L3"; instance = instance }
  /// L3 Merges Now.: The number of L3 merges in progress at any one moment.
  let ``L3 Merges Now.`` instance =
    { category = "Search Indexer"; counter = "L3 Merges Now."; instance = instance }
  /// L3 Merge Speed - average: The average value [documents/hour] computed for the speed of L3 merges since the catalog has been loaded
  let ``L3 Merge Speed - average`` instance =
    { category = "Search Indexer"; counter = "L3 Merge Speed - average"; instance = instance }
  /// L3 Merge - Count: The number of L3 merges since the catalog was loaded
  let ``L3 Merge - Count`` instance =
    { category = "Search Indexer"; counter = "L3 Merge - Count"; instance = instance }
  /// L3 Merge Speed - last: The last value [documents/hour] computed for the speed of L3 merges.
  let ``L3 Merge Speed - last`` instance =
    { category = "Search Indexer"; counter = "L3 Merge Speed - last"; instance = instance }
  /// Persistent Indexes L4: The number of L4 Indexes
  let ``Persistent Indexes L4`` instance =
    { category = "Search Indexer"; counter = "Persistent Indexes L4"; instance = instance }
  /// L4 Merges Now.: The number of L4 merges in progress at any one moment.
  let ``L4 Merges Now.`` instance =
    { category = "Search Indexer"; counter = "L4 Merges Now."; instance = instance }
  /// L4 Merge Speed - average: The average value [documents/hour] computed for the speed of L4 merges since the catalog has been loaded
  let ``L4 Merge Speed - average`` instance =
    { category = "Search Indexer"; counter = "L4 Merge Speed - average"; instance = instance }
  /// L4 Merge - Count: The number of L4 merges since the catalog was loaded
  let ``L4 Merge - Count`` instance =
    { category = "Search Indexer"; counter = "L4 Merge - Count"; instance = instance }
  /// L4 Merge Speed - last: The last value [documents/hour] computed for the speed of L4 merges.
  let ``L4 Merge Speed - last`` instance =
    { category = "Search Indexer"; counter = "L4 Merge Speed - last"; instance = instance }
  /// Persistent Indexes L5: The number of L5 Indexes
  let ``Persistent Indexes L5`` instance =
    { category = "Search Indexer"; counter = "Persistent Indexes L5"; instance = instance }
  /// L5 Merges Now.: The number of L5 merges in progress at any one moment.
  let ``L5 Merges Now.`` instance =
    { category = "Search Indexer"; counter = "L5 Merges Now."; instance = instance }
  /// L5 Merge Speed - average: The average value [documents/hour] computed for the speed of L5 merges since the catalog has been loaded
  let ``L5 Merge Speed - average`` instance =
    { category = "Search Indexer"; counter = "L5 Merge Speed - average"; instance = instance }
  /// L5 Merge - Count: The number of L5 merges since the catalog was loaded
  let ``L5 Merge - Count`` instance =
    { category = "Search Indexer"; counter = "L5 Merge - Count"; instance = instance }
  /// L5 Merge Speed - last: The last value [documents/hour] computed for the speed of L5 merges.
  let ``L5 Merge Speed - last`` instance =
    { category = "Search Indexer"; counter = "L5 Merge Speed - last"; instance = instance }
  /// Persistent Indexes L6: The number of L6 Indexes
  let ``Persistent Indexes L6`` instance =
    { category = "Search Indexer"; counter = "Persistent Indexes L6"; instance = instance }
  /// L6 Merges Now.: The number of L6 merges in progress at any one moment.
  let ``L6 Merges Now.`` instance =
    { category = "Search Indexer"; counter = "L6 Merges Now."; instance = instance }
  /// L6 Merge Speed - average: The average value [documents/hour] computed for the speed of L6 merges since the catalog has been loaded
  let ``L6 Merge Speed - average`` instance =
    { category = "Search Indexer"; counter = "L6 Merge Speed - average"; instance = instance }
  /// L6 Merge - Count: The number of L6 merges since the catalog was loaded
  let ``L6 Merge - Count`` instance =
    { category = "Search Indexer"; counter = "L6 Merge - Count"; instance = instance }
  /// L6 Merge Speed - last: The last value [documents/hour] computed for the speed of L6 merges.
  let ``L6 Merge Speed - last`` instance =
    { category = "Search Indexer"; counter = "L6 Merge Speed - last"; instance = instance }
  /// Persistent Indexes L7: The number of L7 Indexes
  let ``Persistent Indexes L7`` instance =
    { category = "Search Indexer"; counter = "Persistent Indexes L7"; instance = instance }
  /// L7 Merges Now.: The number of L7 merges in progress at any one moment.
  let ``L7 Merges Now.`` instance =
    { category = "Search Indexer"; counter = "L7 Merges Now."; instance = instance }
  /// L7 Merge Speed - average: The average value [documents/hour] computed for the speed of L7 merges since the catalog has been loaded
  let ``L7 Merge Speed - average`` instance =
    { category = "Search Indexer"; counter = "L7 Merge Speed - average"; instance = instance }
  /// L7 Merge - Count: The number of L7 merges since the catalog was loaded
  let ``L7 Merge - Count`` instance =
    { category = "Search Indexer"; counter = "L7 Merge - Count"; instance = instance }
  /// L7 Merge Speed - last: The last value [documents/hour] computed for the speed of L7 merges.
  let ``L7 Merge Speed - last`` instance =
    { category = "Search Indexer"; counter = "L7 Merge Speed - last"; instance = instance }
  /// Persistent Indexes L8: The number of L8 Indexes
  let ``Persistent Indexes L8`` instance =
    { category = "Search Indexer"; counter = "Persistent Indexes L8"; instance = instance }
  /// L8 Merges Now.: The number of L8 merges in progress at any one moment.
  let ``L8 Merges Now.`` instance =
    { category = "Search Indexer"; counter = "L8 Merges Now."; instance = instance }
  /// L8 Merge Speed - average: The average value [documents/hour] computed for the speed of L8 merges since the catalog has been loaded
  let ``L8 Merge Speed - average`` instance =
    { category = "Search Indexer"; counter = "L8 Merge Speed - average"; instance = instance }
  /// L8 Merge - Count: The number of L8 merges since the catalog was loaded
  let ``L8 Merge - Count`` instance =
    { category = "Search Indexer"; counter = "L8 Merge - Count"; instance = instance }
  /// L8 Merge Speed - last: The last value [documents/hour] computed for the speed of L8 merges.
  let ``L8 Merge Speed - last`` instance =
    { category = "Search Indexer"; counter = "L8 Merge Speed - last"; instance = instance }

  let allCounters =
    [ ``Master Index Level.``
      ``Master Merges to Date``
      ``Master Merge Progress``
      ``Shadow Merge Levels``
      ``Shadow Merge Levels Threshold``
      ``Persistent Indexes``
      ``Index Size``
      ``Unique Keys``
      ``Documents Filtered``
      ``Work Items Created``
      ``Work Items Deleted``
      ``Clean WidSets``
      ``Dirty WidSets``
      ``Master Merges Now.``
      ``Active Connections``
      ``Queries``
      ``Queries Failed``
      ``Queries Succeeded``
      ``L0 Indexes (Wordlists)``
      ``L0 Merges (flushes) Now.``
      ``L0 Merge (Flush) Speed - Average``
      ``L0 Merge (Flush) - Count``
      ``L0 Merge (Flush) Speed - Last``
      ``Persistent Indexes L1``
      ``L1 Merges Now.``
      ``L1 Merge Speed - average``
      ``L1 Merge - Count``
      ``L1 Merge Speed - last``
      ``Persistent Indexes L2``
      ``L2 Merges Now.``
      ``L2 Merge Speed - average``
      ``L2 Merge - Count``
      ``L2 Merge Speed - last``
      ``Persistent Indexes L3``
      ``L3 Merges Now.``
      ``L3 Merge Speed - average``
      ``L3 Merge - Count``
      ``L3 Merge Speed - last``
      ``Persistent Indexes L4``
      ``L4 Merges Now.``
      ``L4 Merge Speed - average``
      ``L4 Merge - Count``
      ``L4 Merge Speed - last``
      ``Persistent Indexes L5``
      ``L5 Merges Now.``
      ``L5 Merge Speed - average``
      ``L5 Merge - Count``
      ``L5 Merge Speed - last``
      ``Persistent Indexes L6``
      ``L6 Merges Now.``
      ``L6 Merge Speed - average``
      ``L6 Merge - Count``
      ``L6 Merge Speed - last``
      ``Persistent Indexes L7``
      ``L7 Merges Now.``
      ``L7 Merge Speed - average``
      ``L7 Merge - Count``
      ``L7 Merge Speed - last``
      ``Persistent Indexes L8``
      ``L8 Merges Now.``
      ``L8 Merge Speed - average``
      ``L8 Merge - Count``
      ``L8 Merge Speed - last``
    ]

/// Server: The Server performance object consists of counters that measure communication between the  local computer and the network.
///
/// This performance counter does not have instance based counters
module ``Server`` =

  [<Literal>]
  let Category = "Server"

  let PCC = getPCC Category
  /// Bytes Total/sec: The number of bytes the server has sent to and received from the network.  This value provides an overall indication of how busy the server is.
  let ``Bytes Total/sec`` =
    { category = "Server"; counter = "Bytes Total/sec"; instance = NotApplicable }
  /// Bytes Received/sec: The number of bytes the server has received from the network.  Indicates how busy the server is.
  let ``Bytes Received/sec`` =
    { category = "Server"; counter = "Bytes Received/sec"; instance = NotApplicable }
  /// Bytes Transmitted/sec: The number of bytes the server has sent on the network.  Indicates how busy the server is.
  let ``Bytes Transmitted/sec`` =
    { category = "Server"; counter = "Bytes Transmitted/sec"; instance = NotApplicable }
  /// Sessions Timed Out: The number of sessions that have been closed due to their idle time exceeding the AutoDisconnect parameter for the server.  Shows whether the AutoDisconnect setting is helping to conserve resources.
  let ``Sessions Timed Out`` =
    { category = "Server"; counter = "Sessions Timed Out"; instance = NotApplicable }
  /// Sessions Errored Out: The number of sessions that have been closed due to unexpected error conditions or sessions that have reached the autodisconnect timeout and have been disconnected normally. The autodisconnect timeout value represents the number of seconds that idle connections with no session attached to have before being disconnected automatically by a server. The default value is 30 seconds. This counter increments as a result of normal server operation, not as an indication of network problems or unexpected error condition.
  let ``Sessions Errored Out`` =
    { category = "Server"; counter = "Sessions Errored Out"; instance = NotApplicable }
  /// Sessions Logged Off: The number of sessions that have terminated normally.  Useful in interpreting the Sessions Times Out and Sessions Errored Out statistics--allows percentage calculations.
  let ``Sessions Logged Off`` =
    { category = "Server"; counter = "Sessions Logged Off"; instance = NotApplicable }
  /// Sessions Forced Off: The number of sessions that have been forced to logoff.  Can indicate how many sessions were forced to logoff due to logon time constraints.
  let ``Sessions Forced Off`` =
    { category = "Server"; counter = "Sessions Forced Off"; instance = NotApplicable }
  /// Errors Logon: The number of failed logon attempts to the server.  Can indicate whether password guessing programs are being used to crack the security on the server.
  let ``Errors Logon`` =
    { category = "Server"; counter = "Errors Logon"; instance = NotApplicable }
  /// Errors Access Permissions: The number of times opens on behalf of clients have failed with STATUS_ACCESS_DENIED.  Can indicate whether somebody is randomly attempting to access files in hopes of getting at something that was not properly protected.
  let ``Errors Access Permissions`` =
    { category = "Server"; counter = "Errors Access Permissions"; instance = NotApplicable }
  /// Errors Granted Access: The number of times accesses to files opened successfully were denied.  Can indicate attempts to access files without proper access authorization.
  let ``Errors Granted Access`` =
    { category = "Server"; counter = "Errors Granted Access"; instance = NotApplicable }
  /// Errors System: The number of times an internal Server Error was detected.  Unexpected errors usually indicate a problem with the Server.
  let ``Errors System`` =
    { category = "Server"; counter = "Errors System"; instance = NotApplicable }
  /// Blocking Requests Rejected: The number of times the server has rejected blocking SMBs due to insufficient count of free work items.  Indicates whether the MaxWorkItem or MinFreeWorkItems server parameters might need to be adjusted.
  let ``Blocking Requests Rejected`` =
    { category = "Server"; counter = "Blocking Requests Rejected"; instance = NotApplicable }
  /// Work Item Shortages: The number of times STATUS_DATA_NOT_ACCEPTED was returned at receive indication time.  This occurs when no work item is available or can be allocated to service the incoming request.  Indicates whether the InitWorkItems or MaxWorkItems parameters might need to be adjusted.
  let ``Work Item Shortages`` =
    { category = "Server"; counter = "Work Item Shortages"; instance = NotApplicable }
  /// Files Opened Total: The number of successful open attempts performed by the server of behalf of clients.  Useful in determining the amount of file I/O, determining overhead for path-based operations, and for determining the effectiveness of open locks.
  let ``Files Opened Total`` =
    { category = "Server"; counter = "Files Opened Total"; instance = NotApplicable }
  /// Files Open: The number of files currently opened in the server.  Indicates current server activity.
  let ``Files Open`` =
    { category = "Server"; counter = "Files Open"; instance = NotApplicable }
  /// Server Sessions: The number of sessions currently active in the server.  Indicates current server activity.
  let ``Server Sessions`` =
    { category = "Server"; counter = "Server Sessions"; instance = NotApplicable }
  /// File Directory Searches: The number of searches for files currently active in the server.  Indicates current server activity.
  let ``File Directory Searches`` =
    { category = "Server"; counter = "File Directory Searches"; instance = NotApplicable }
  /// Pool Nonpaged Bytes: The number of bytes of non-pageable computer memory the server is using.  This value is useful for determining the values of the MaxNonpagedMemoryUsage value entry in the Windows NT Registry.
  let ``Pool Nonpaged Bytes`` =
    { category = "Server"; counter = "Pool Nonpaged Bytes"; instance = NotApplicable }
  /// Pool Nonpaged Failures: The number of times allocations from nonpaged pool have failed.  Indicates that the computer's physical memory is too small.
  let ``Pool Nonpaged Failures`` =
    { category = "Server"; counter = "Pool Nonpaged Failures"; instance = NotApplicable }
  /// Pool Nonpaged Peak: The maximum number of bytes of nonpaged pool the server has had in use at any one point.  Indicates how much physical memory the computer should have.
  let ``Pool Nonpaged Peak`` =
    { category = "Server"; counter = "Pool Nonpaged Peak"; instance = NotApplicable }
  /// Pool Paged Bytes: The number of bytes of pageable computer memory the server is currently using.  Can help in determining good values for the MaxPagedMemoryUsage parameter.
  let ``Pool Paged Bytes`` =
    { category = "Server"; counter = "Pool Paged Bytes"; instance = NotApplicable }
  /// Pool Paged Failures: The number of times allocations from paged pool have failed.  Indicates that the computer's physical memory or paging file are too small.
  let ``Pool Paged Failures`` =
    { category = "Server"; counter = "Pool Paged Failures"; instance = NotApplicable }
  /// Pool Paged Peak: The maximum number of bytes of paged pool the server has had allocated.  Indicates the proper sizes of the Page File(s) and physical memory.
  let ``Pool Paged Peak`` =
    { category = "Server"; counter = "Pool Paged Peak"; instance = NotApplicable }
  /// Context Blocks Queued/sec: Context Blocks Queued per second is the rate at which work context blocks had to be placed on the server's FSP queue to await server action.
  let ``Context Blocks Queued/sec`` =
    { category = "Server"; counter = "Context Blocks Queued/sec"; instance = NotApplicable }
  /// Logon/sec: Logon/sec is the rate of all server logons.
  let ``Logon/sec`` =
    { category = "Server"; counter = "Logon/sec"; instance = NotApplicable }
  /// Logon Total: Logon Total indicates the total session setup attempts, including all successful logon and failed logons since the server service is started.
  let ``Logon Total`` =
    { category = "Server"; counter = "Logon Total"; instance = NotApplicable }
  /// Total Durable Handles: The total number of durable handle disconnects that have occurred.
  let ``Total Durable Handles`` =
    { category = "Server"; counter = "Total Durable Handles"; instance = NotApplicable }
  /// Reconnected Durable Handles: The total number of durable handles that are successfully reconnected. The ratio of "reconnected durable handles"/"total durable handles" indicates the stability gain from reconnect durable handles.
  let ``Reconnected Durable Handles`` =
    { category = "Server"; counter = "Reconnected Durable Handles"; instance = NotApplicable }
  /// SMB BranchCache Hash Header Requests: The number of SMB BranchCache hash requests that were for the header only received by the server. This indicates how many requests are being done to validate hashes that are already cached by the client.
  let ``SMB BranchCache Hash Header Requests`` =
    { category = "Server"; counter = "SMB BranchCache Hash Header Requests"; instance = NotApplicable }
  /// SMB BranchCache Hash Generation Requests: The number of SMB BranchCache hash generation requests that were sent by SRV2 to the SMB Hash Generation service because a client requested hashes for the file and there was either no hash content for the file or the existing hashes were out of date.
  let ``SMB BranchCache Hash Generation Requests`` =
    { category = "Server"; counter = "SMB BranchCache Hash Generation Requests"; instance = NotApplicable }
  /// SMB BranchCache Hash Requests Received: The number of SMB BranchCache hash requests that were received by the server.
  let ``SMB BranchCache Hash Requests Received`` =
    { category = "Server"; counter = "SMB BranchCache Hash Requests Received"; instance = NotApplicable }
  /// SMB BranchCache Hash Responses Sent: The number of SMB BranchCache hash responses that have been sent from the server.
  let ``SMB BranchCache Hash Responses Sent`` =
    { category = "Server"; counter = "SMB BranchCache Hash Responses Sent"; instance = NotApplicable }
  /// SMB BranchCache Hash Bytes Sent: The amount of SMB BranchCache hash data sent from the server. This includes bytes transferred for both hash header requests and full hash data requests.
  let ``SMB BranchCache Hash Bytes Sent`` =
    { category = "Server"; counter = "SMB BranchCache Hash Bytes Sent"; instance = NotApplicable }
  /// Total Resilient Handles: The total number of resilient handle disconnect that have occurred.
  let ``Total Resilient Handles`` =
    { category = "Server"; counter = "Total Resilient Handles"; instance = NotApplicable }
  /// Reconnected Resilient Handles: The total number of resilient handles that are successfully reconnected. The ratio of "reconnected resilient handles"/"total resilient handles" indicates the stability gain from reconnect resilient handles.
  let ``Reconnected Resilient Handles`` =
    { category = "Server"; counter = "Reconnected Resilient Handles"; instance = NotApplicable }
  /// SMB BranchCache Hash V2 Header Requests: The number of SMB BranchCache hash V2 requests that were for the header only received by the server. This indicates how many requests are being done to validate hashes that are already cached by the client.
  let ``SMB BranchCache Hash V2 Header Requests`` =
    { category = "Server"; counter = "SMB BranchCache Hash V2 Header Requests"; instance = NotApplicable }
  /// SMB BranchCache Hash V2 Generation Requests: The number of SMB BranchCache hash V2 generation requests that were sent by SRV2 to the SMB Hash Generation service because a client requested hashes for the file and there was either no hash content for the file or the existing hashes were out of date.
  let ``SMB BranchCache Hash V2 Generation Requests`` =
    { category = "Server"; counter = "SMB BranchCache Hash V2 Generation Requests"; instance = NotApplicable }
  /// SMB BranchCache Hash V2 Requests Received: The number of SMB BranchCache hash V2 requests that were received by the server.
  let ``SMB BranchCache Hash V2 Requests Received`` =
    { category = "Server"; counter = "SMB BranchCache Hash V2 Requests Received"; instance = NotApplicable }
  /// SMB BranchCache Hash V2 Responses Sent: The number of SMB BranchCache hash V2 responses that have been sent from the server.
  let ``SMB BranchCache Hash V2 Responses Sent`` =
    { category = "Server"; counter = "SMB BranchCache Hash V2 Responses Sent"; instance = NotApplicable }
  /// SMB BranchCache Hash V2 Bytes Sent: The amount of SMB BranchCache hash V2 data sent from the server. This includes bytes transferred for both hash header requests and full hash data requests.
  let ``SMB BranchCache Hash V2 Bytes Sent`` =
    { category = "Server"; counter = "SMB BranchCache Hash V2 Bytes Sent"; instance = NotApplicable }
  /// SMB BranchCache Hash V2 Requests Served From Dedup: The amount of SMB BranchCache hash V2 requests that were served from dedup store by the server.
  let ``SMB BranchCache Hash V2 Requests Served From Dedup`` =
    { category = "Server"; counter = "SMB BranchCache Hash V2 Requests Served From Dedup"; instance = NotApplicable }

  let allCounters =
    [ ``Bytes Total/sec``
      ``Bytes Received/sec``
      ``Bytes Transmitted/sec``
      ``Sessions Timed Out``
      ``Sessions Errored Out``
      ``Sessions Logged Off``
      ``Sessions Forced Off``
      ``Errors Logon``
      ``Errors Access Permissions``
      ``Errors Granted Access``
      ``Errors System``
      ``Blocking Requests Rejected``
      ``Work Item Shortages``
      ``Files Opened Total``
      ``Files Open``
      ``Server Sessions``
      ``File Directory Searches``
      ``Pool Nonpaged Bytes``
      ``Pool Nonpaged Failures``
      ``Pool Nonpaged Peak``
      ``Pool Paged Bytes``
      ``Pool Paged Failures``
      ``Pool Paged Peak``
      ``Context Blocks Queued/sec``
      ``Logon/sec``
      ``Logon Total``
      ``Total Durable Handles``
      ``Reconnected Durable Handles``
      ``SMB BranchCache Hash Header Requests``
      ``SMB BranchCache Hash Generation Requests``
      ``SMB BranchCache Hash Requests Received``
      ``SMB BranchCache Hash Responses Sent``
      ``SMB BranchCache Hash Bytes Sent``
      ``Total Resilient Handles``
      ``Reconnected Resilient Handles``
      ``SMB BranchCache Hash V2 Header Requests``
      ``SMB BranchCache Hash V2 Generation Requests``
      ``SMB BranchCache Hash V2 Requests Received``
      ``SMB BranchCache Hash V2 Responses Sent``
      ``SMB BranchCache Hash V2 Bytes Sent``
      ``SMB BranchCache Hash V2 Requests Served From Dedup``
    ]

/// Server Work Queues: The Server Work Queues performance object consists of counters that monitor the length of the queues and objects in the queues.
///
/// This performance counter does not have non-instance based counters
module ``Server Work Queues`` =

  [<Literal>]
  let Category = "Server Work Queues"

  let PCC = getPCC Category
  /// Queue Length: Queue length is the current number of workitem in Blocking queues and Nonblocking queues, which indicates how busy the server is to process outstanding workitems for this CPU. A sustained queue length greater than four might indicate processor congestion.  This is an instantaneous count, not an average over time.
  let ``Queue Length`` instance =
    { category = "Server Work Queues"; counter = "Queue Length"; instance = instance }
  /// Active Threads: Active Threads is the number of threads currently working on a request from the server client for this CPU.  The system keeps this number as low as possible to minimize unnecessary context switching.  This is an instantaneous count for the CPU, not an average over time.
  let ``Active Threads`` instance =
    { category = "Server Work Queues"; counter = "Active Threads"; instance = instance }
  /// Available Threads: Available Threads is the number of server threads on this CPU not currently working on requests from a client.  The server dynamically adjusts the number of threads to maximize server performance.
  let ``Available Threads`` instance =
    { category = "Server Work Queues"; counter = "Available Threads"; instance = instance }
  /// Available Work Items: Every request from a client is represented in the server as a 'work item,' and the server maintains a pool of available work items per CPU to speed processing.  This is the instantaneous number of available work items for this CPU.  A sustained near-zero value indicates the need to increase the MinFreeWorkItems registry value for the Server service.  This value will always be 0 in the SMB1 Blocking Queue instance.
  let ``Available Work Items`` instance =
    { category = "Server Work Queues"; counter = "Available Work Items"; instance = instance }
  /// Borrowed Work Items: Every request from a client is represented in the server as a 'work item,' and the server maintains a pool of available work items per CPU to speed processing.  When a CPU runs out of work items, it borrows a free work item from another CPU.  An increasing value of this running counter might indicate the need to increase the 'MaxWorkItems' or 'MinFreeWorkItems' registry values for the Server service.  This value will always be 0 in the Blocking Queue and SMB2 Queue instances.
  let ``Borrowed Work Items`` instance =
    { category = "Server Work Queues"; counter = "Borrowed Work Items"; instance = instance }
  /// Work Item Shortages: Every request from a client is represented in the server as a 'work item,' and the server maintains a pool of available work items per CPU to speed processing.  A sustained value greater than zero indicates the need to increase the 'MaxWorkItems' registry value for the Server service.  This value will always be 0 in the Blocking Queue and SMB2 Queue instances.
  let ``Work Item Shortages`` instance =
    { category = "Server Work Queues"; counter = "Work Item Shortages"; instance = instance }
  /// Current Clients: Current Clients is the instantaneous count of the clients being serviced by this CPU.  The server actively balances the client load across all of the CPU's in the system.  This value will always be 0 in the Blocking Queue instance.
  let ``Current Clients`` instance =
    { category = "Server Work Queues"; counter = "Current Clients"; instance = instance }
  /// Bytes Received/sec: The rate at which the Server is receiving bytes from the network clients on this CPU.  This value is a measure of how busy the Server is.
  let ``Bytes Received/sec`` instance =
    { category = "Server Work Queues"; counter = "Bytes Received/sec"; instance = instance }
  /// Bytes Sent/sec: The rate at which the Server is sending bytes to the network clients on this CPU.  This value is a measure of how busy the Server is.
  let ``Bytes Sent/sec`` instance =
    { category = "Server Work Queues"; counter = "Bytes Sent/sec"; instance = instance }
  /// Bytes Transferred/sec: The rate at which the Server is sending and receiving bytes with the network clients on this CPU.  This value is a measure of how busy the Server is.
  let ``Bytes Transferred/sec`` instance =
    { category = "Server Work Queues"; counter = "Bytes Transferred/sec"; instance = instance }
  /// Read Operations/sec: Read Operations/sec is the rate the server is performing file read operations for the clients on this CPU.  This value is a measure of how busy the Server is.  This value will always be 0 in the Blocking Queue instance.
  let ``Read Operations/sec`` instance =
    { category = "Server Work Queues"; counter = "Read Operations/sec"; instance = instance }
  /// Read Bytes/sec: Read Bytes/sec is the rate the server is reading data from files for the clients on this CPU.  This value is a measure of how busy the Server is.
  let ``Read Bytes/sec`` instance =
    { category = "Server Work Queues"; counter = "Read Bytes/sec"; instance = instance }
  /// Write Operations/sec: Write Operations/sec is the rate the server is performing file write operations for the clients on this CPU.  This value is a measure of how busy the Server is.  This value will always be 0 in the Blocking Queue instance.
  let ``Write Operations/sec`` instance =
    { category = "Server Work Queues"; counter = "Write Operations/sec"; instance = instance }
  /// Write Bytes/sec: Write Bytes/sec is the rate the server is writing data to files for the clients on this CPU.  This value is a measure of how busy the Server is.
  let ``Write Bytes/sec`` instance =
    { category = "Server Work Queues"; counter = "Write Bytes/sec"; instance = instance }
  /// Total Bytes/sec: Total Bytes/sec is the rate the Server is reading and writing data to and from the files for the clients on this CPU.  This value is a measure of how busy the Server is.
  let ``Total Bytes/sec`` instance =
    { category = "Server Work Queues"; counter = "Total Bytes/sec"; instance = instance }
  /// Total Operations/sec: Total Operations/sec is the rate the Server is performing file read and file write operations for the clients on this CPU.  This value is a measure of how busy the Server is.  This value will always be 0 in the Blocking Queue instance.
  let ``Total Operations/sec`` instance =
    { category = "Server Work Queues"; counter = "Total Operations/sec"; instance = instance }
  /// Context Blocks Queued/sec: Context Blocks Queued per second is the rate at which work context blocks had to be placed on the server's FSP queue to await server action.
  let ``Context Blocks Queued/sec`` instance =
    { category = "Server Work Queues"; counter = "Context Blocks Queued/sec"; instance = instance }

  let allCounters =
    [ ``Queue Length``
      ``Active Threads``
      ``Available Threads``
      ``Available Work Items``
      ``Borrowed Work Items``
      ``Work Item Shortages``
      ``Current Clients``
      ``Bytes Received/sec``
      ``Bytes Sent/sec``
      ``Bytes Transferred/sec``
      ``Read Operations/sec``
      ``Read Bytes/sec``
      ``Write Operations/sec``
      ``Write Bytes/sec``
      ``Total Bytes/sec``
      ``Total Operations/sec``
      ``Context Blocks Queued/sec``
    ]

/// ServiceModelEndpoint 3.0.0.0: ServiceModelEndpoint 3.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``ServiceModelEndpoint 3_0_0_0`` =

  [<Literal>]
  let Category = "ServiceModelEndpoint 3.0.0.0"

  let PCC = getPCC Category
  /// Calls: 
  let ``Calls`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Calls"; instance = instance }
  /// Calls Per Second: 
  let ``Calls Per Second`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Calls Per Second"; instance = instance }
  /// Calls Outstanding: 
  let ``Calls Outstanding`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Calls Outstanding"; instance = instance }
  /// Calls Failed: 
  let ``Calls Failed`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Calls Failed"; instance = instance }
  /// Calls Failed Per Second: 
  let ``Calls Failed Per Second`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Calls Failed Per Second"; instance = instance }
  /// Calls Faulted: 
  let ``Calls Faulted`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Calls Faulted"; instance = instance }
  /// Calls Faulted Per Second: 
  let ``Calls Faulted Per Second`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Calls Faulted Per Second"; instance = instance }
  /// Calls Duration: 
  let ``Calls Duration`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Calls Duration"; instance = instance }
  /// Calls Duration Base: 
  let ``Calls Duration Base`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Calls Duration Base"; instance = instance }
  /// Transactions Flowed: 
  let ``Transactions Flowed`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Transactions Flowed"; instance = instance }
  /// Transactions Flowed Per Second: 
  let ``Transactions Flowed Per Second`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Transactions Flowed Per Second"; instance = instance }
  /// Security Validation and Authentication Failures: 
  let ``Security Validation and Authentication Failures`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Security Validation and Authentication Failures"; instance = instance }
  /// Security Validation and Authentication Failures Per Second: 
  let ``Security Validation and Authentication Failures Per Second`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Security Validation and Authentication Failures Per Second"; instance = instance }
  /// Security Calls Not Authorized: 
  let ``Security Calls Not Authorized`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Security Calls Not Authorized"; instance = instance }
  /// Security Calls Not Authorized Per Second: 
  let ``Security Calls Not Authorized Per Second`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Security Calls Not Authorized Per Second"; instance = instance }
  /// Reliable Messaging Sessions Faulted: 
  let ``Reliable Messaging Sessions Faulted`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Reliable Messaging Sessions Faulted"; instance = instance }
  /// Reliable Messaging Sessions Faulted Per Second: 
  let ``Reliable Messaging Sessions Faulted Per Second`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Reliable Messaging Sessions Faulted Per Second"; instance = instance }
  /// Reliable Messaging Messages Dropped: 
  let ``Reliable Messaging Messages Dropped`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Reliable Messaging Messages Dropped"; instance = instance }
  /// Reliable Messaging Messages Dropped Per Second: 
  let ``Reliable Messaging Messages Dropped Per Second`` instance =
    { category = "ServiceModelEndpoint 3.0.0.0"; counter = "Reliable Messaging Messages Dropped Per Second"; instance = instance }

  let allCounters =
    [ ``Calls``
      ``Calls Per Second``
      ``Calls Outstanding``
      ``Calls Failed``
      ``Calls Failed Per Second``
      ``Calls Faulted``
      ``Calls Faulted Per Second``
      ``Calls Duration``
      ``Calls Duration Base``
      ``Transactions Flowed``
      ``Transactions Flowed Per Second``
      ``Security Validation and Authentication Failures``
      ``Security Validation and Authentication Failures Per Second``
      ``Security Calls Not Authorized``
      ``Security Calls Not Authorized Per Second``
      ``Reliable Messaging Sessions Faulted``
      ``Reliable Messaging Sessions Faulted Per Second``
      ``Reliable Messaging Messages Dropped``
      ``Reliable Messaging Messages Dropped Per Second``
    ]

/// ServiceModelEndpoint 4.0.0.0: ServiceModel performance counters for endpoint
///
/// This performance counter does not have instance based counters
module ``ServiceModelEndpoint 4_0_0_0`` =

  [<Literal>]
  let Category = "ServiceModelEndpoint 4.0.0.0"

  let PCC = getPCC Category
  /// Calls: 
  let ``Calls`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Calls"; instance = instance }
  /// Calls Per Second: 
  let ``Calls Per Second`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Calls Per Second"; instance = instance }
  /// Calls Outstanding: 
  let ``Calls Outstanding`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Calls Outstanding"; instance = instance }
  /// Calls Failed: 
  let ``Calls Failed`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Calls Failed"; instance = instance }
  /// Calls Failed Per Second: 
  let ``Calls Failed Per Second`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Calls Failed Per Second"; instance = instance }
  /// Calls Faulted: 
  let ``Calls Faulted`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Calls Faulted"; instance = instance }
  /// Calls Faulted Per Second: 
  let ``Calls Faulted Per Second`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Calls Faulted Per Second"; instance = instance }
  /// Calls Duration: 
  let ``Calls Duration`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Calls Duration"; instance = instance }
  /// Security Validation and Authentication Failures: 
  let ``Security Validation and Authentication Failures`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Security Validation and Authentication Failures"; instance = instance }
  /// Security Validation and Authentication Failures Per Second: 
  let ``Security Validation and Authentication Failures Per Second`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Security Validation and Authentication Failures Per Second"; instance = instance }
  /// Security Calls Not Authorized: 
  let ``Security Calls Not Authorized`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Security Calls Not Authorized"; instance = instance }
  /// Security Calls Not Authorized Per Second: 
  let ``Security Calls Not Authorized Per Second`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Security Calls Not Authorized Per Second"; instance = instance }
  /// Reliable Messaging Sessions Faulted: 
  let ``Reliable Messaging Sessions Faulted`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Reliable Messaging Sessions Faulted"; instance = instance }
  /// Reliable Messaging Sessions Faulted Per Second: 
  let ``Reliable Messaging Sessions Faulted Per Second`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Reliable Messaging Sessions Faulted Per Second"; instance = instance }
  /// Reliable Messaging Messages Dropped: 
  let ``Reliable Messaging Messages Dropped`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Reliable Messaging Messages Dropped"; instance = instance }
  /// Reliable Messaging Messages Dropped Per Second: 
  let ``Reliable Messaging Messages Dropped Per Second`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Reliable Messaging Messages Dropped Per Second"; instance = instance }
  /// Transactions Flowed: 
  let ``Transactions Flowed`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Transactions Flowed"; instance = instance }
  /// Transactions Flowed Per Second: 
  let ``Transactions Flowed Per Second`` instance =
    { category = "ServiceModelEndpoint 4.0.0.0"; counter = "Transactions Flowed Per Second"; instance = instance }

  let allCounters =
    [ ``Calls``
      ``Calls Per Second``
      ``Calls Outstanding``
      ``Calls Failed``
      ``Calls Failed Per Second``
      ``Calls Faulted``
      ``Calls Faulted Per Second``
      ``Calls Duration``
      ``Security Validation and Authentication Failures``
      ``Security Validation and Authentication Failures Per Second``
      ``Security Calls Not Authorized``
      ``Security Calls Not Authorized Per Second``
      ``Reliable Messaging Sessions Faulted``
      ``Reliable Messaging Sessions Faulted Per Second``
      ``Reliable Messaging Messages Dropped``
      ``Reliable Messaging Messages Dropped Per Second``
      ``Transactions Flowed``
      ``Transactions Flowed Per Second``
    ]

/// ServiceModelOperation 3.0.0.0: ServiceModelOperation 3.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``ServiceModelOperation 3_0_0_0`` =

  [<Literal>]
  let Category = "ServiceModelOperation 3.0.0.0"

  let PCC = getPCC Category
  /// Calls: 
  let ``Calls`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Calls"; instance = instance }
  /// Calls Per Second: 
  let ``Calls Per Second`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Calls Per Second"; instance = instance }
  /// Calls Outstanding: 
  let ``Calls Outstanding`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Calls Outstanding"; instance = instance }
  /// Calls Failed: 
  let ``Calls Failed`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Calls Failed"; instance = instance }
  /// Call Failed Per Second: 
  let ``Call Failed Per Second`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Call Failed Per Second"; instance = instance }
  /// Calls Faulted: 
  let ``Calls Faulted`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Calls Faulted"; instance = instance }
  /// Calls Faulted Per Second: 
  let ``Calls Faulted Per Second`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Calls Faulted Per Second"; instance = instance }
  /// Calls Duration: 
  let ``Calls Duration`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Calls Duration"; instance = instance }
  /// Calls Duration Base: 
  let ``Calls Duration Base`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Calls Duration Base"; instance = instance }
  /// Transactions Flowed: 
  let ``Transactions Flowed`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Transactions Flowed"; instance = instance }
  /// Transactions Flowed Per Second: 
  let ``Transactions Flowed Per Second`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Transactions Flowed Per Second"; instance = instance }
  /// Security Validation and Authentication Failures: 
  let ``Security Validation and Authentication Failures`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Security Validation and Authentication Failures"; instance = instance }
  /// Security Validation and Authentication Failures Per Second: 
  let ``Security Validation and Authentication Failures Per Second`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Security Validation and Authentication Failures Per Second"; instance = instance }
  /// Security Calls Not Authorized: 
  let ``Security Calls Not Authorized`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Security Calls Not Authorized"; instance = instance }
  /// Security Calls Not Authorized Per Second: 
  let ``Security Calls Not Authorized Per Second`` instance =
    { category = "ServiceModelOperation 3.0.0.0"; counter = "Security Calls Not Authorized Per Second"; instance = instance }

  let allCounters =
    [ ``Calls``
      ``Calls Per Second``
      ``Calls Outstanding``
      ``Calls Failed``
      ``Call Failed Per Second``
      ``Calls Faulted``
      ``Calls Faulted Per Second``
      ``Calls Duration``
      ``Calls Duration Base``
      ``Transactions Flowed``
      ``Transactions Flowed Per Second``
      ``Security Validation and Authentication Failures``
      ``Security Validation and Authentication Failures Per Second``
      ``Security Calls Not Authorized``
      ``Security Calls Not Authorized Per Second``
    ]

/// ServiceModelOperation 4.0.0.0: ServiceModelOperation 4.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``ServiceModelOperation 4_0_0_0`` =

  [<Literal>]
  let Category = "ServiceModelOperation 4.0.0.0"

  let PCC = getPCC Category
  /// Calls: 
  let ``Calls`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Calls"; instance = instance }
  /// Calls Per Second: 
  let ``Calls Per Second`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Calls Per Second"; instance = instance }
  /// Calls Outstanding: 
  let ``Calls Outstanding`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Calls Outstanding"; instance = instance }
  /// Calls Failed: 
  let ``Calls Failed`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Calls Failed"; instance = instance }
  /// Call Failed Per Second: 
  let ``Call Failed Per Second`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Call Failed Per Second"; instance = instance }
  /// Calls Faulted: 
  let ``Calls Faulted`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Calls Faulted"; instance = instance }
  /// Calls Faulted Per Second: 
  let ``Calls Faulted Per Second`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Calls Faulted Per Second"; instance = instance }
  /// Calls Duration: 
  let ``Calls Duration`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Calls Duration"; instance = instance }
  /// Security Validation and Authentication Failures: 
  let ``Security Validation and Authentication Failures`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Security Validation and Authentication Failures"; instance = instance }
  /// Security Validation and Authentication Failures Per Second: 
  let ``Security Validation and Authentication Failures Per Second`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Security Validation and Authentication Failures Per Second"; instance = instance }
  /// Security Calls Not Authorized: 
  let ``Security Calls Not Authorized`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Security Calls Not Authorized"; instance = instance }
  /// Security Calls Not Authorized Per Second: 
  let ``Security Calls Not Authorized Per Second`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Security Calls Not Authorized Per Second"; instance = instance }
  /// Transactions Flowed: 
  let ``Transactions Flowed`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Transactions Flowed"; instance = instance }
  /// Transactions Flowed Per Second: 
  let ``Transactions Flowed Per Second`` instance =
    { category = "ServiceModelOperation 4.0.0.0"; counter = "Transactions Flowed Per Second"; instance = instance }

  let allCounters =
    [ ``Calls``
      ``Calls Per Second``
      ``Calls Outstanding``
      ``Calls Failed``
      ``Call Failed Per Second``
      ``Calls Faulted``
      ``Calls Faulted Per Second``
      ``Calls Duration``
      ``Security Validation and Authentication Failures``
      ``Security Validation and Authentication Failures Per Second``
      ``Security Calls Not Authorized``
      ``Security Calls Not Authorized Per Second``
      ``Transactions Flowed``
      ``Transactions Flowed Per Second``
    ]

/// ServiceModelService 3.0.0.0: ServiceModelService 3.0.0.0 performance counters
///
/// This performance counter does not have instance based counters
module ``ServiceModelService 3_0_0_0`` =

  [<Literal>]
  let Category = "ServiceModelService 3.0.0.0"

  let PCC = getPCC Category
  /// Calls: 
  let ``Calls`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Calls"; instance = instance }
  /// Calls Per Second: 
  let ``Calls Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Calls Per Second"; instance = instance }
  /// Calls Outstanding: 
  let ``Calls Outstanding`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Calls Outstanding"; instance = instance }
  /// Calls Failed: 
  let ``Calls Failed`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Calls Failed"; instance = instance }
  /// Calls Failed Per Second: 
  let ``Calls Failed Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Calls Failed Per Second"; instance = instance }
  /// Calls Faulted: 
  let ``Calls Faulted`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Calls Faulted"; instance = instance }
  /// Calls Faulted Per Second: 
  let ``Calls Faulted Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Calls Faulted Per Second"; instance = instance }
  /// Calls Duration: 
  let ``Calls Duration`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Calls Duration"; instance = instance }
  /// Calls Duration Base: 
  let ``Calls Duration Base`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Calls Duration Base"; instance = instance }
  /// Transactions Flowed: 
  let ``Transactions Flowed`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Transactions Flowed"; instance = instance }
  /// Transactions Flowed Per Second: 
  let ``Transactions Flowed Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Transactions Flowed Per Second"; instance = instance }
  /// Transacted Operations Committed: 
  let ``Transacted Operations Committed`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Transacted Operations Committed"; instance = instance }
  /// Transacted Operations Committed Per Second: 
  let ``Transacted Operations Committed Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Transacted Operations Committed Per Second"; instance = instance }
  /// Transacted Operations Aborted: 
  let ``Transacted Operations Aborted`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Transacted Operations Aborted"; instance = instance }
  /// Transacted Operations Aborted Per Second: 
  let ``Transacted Operations Aborted Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Transacted Operations Aborted Per Second"; instance = instance }
  /// Transacted Operations In Doubt: 
  let ``Transacted Operations In Doubt`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Transacted Operations In Doubt"; instance = instance }
  /// Transacted Operations In Doubt Per Second: 
  let ``Transacted Operations In Doubt Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Transacted Operations In Doubt Per Second"; instance = instance }
  /// Security Validation and Authentication Failures: 
  let ``Security Validation and Authentication Failures`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Security Validation and Authentication Failures"; instance = instance }
  /// Security Validation and Authentication Failures Per Second: 
  let ``Security Validation and Authentication Failures Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Security Validation and Authentication Failures Per Second"; instance = instance }
  /// Security Calls Not Authorized: 
  let ``Security Calls Not Authorized`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Security Calls Not Authorized"; instance = instance }
  /// Security Calls Not Authorized Per Second: 
  let ``Security Calls Not Authorized Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Security Calls Not Authorized Per Second"; instance = instance }
  /// Instances: 
  let ``Instances`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Instances"; instance = instance }
  /// Instances Created Per Second: 
  let ``Instances Created Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Instances Created Per Second"; instance = instance }
  /// Reliable Messaging Sessions Faulted: 
  let ``Reliable Messaging Sessions Faulted`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Reliable Messaging Sessions Faulted"; instance = instance }
  /// Reliable Messaging Sessions Faulted Per Second: 
  let ``Reliable Messaging Sessions Faulted Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Reliable Messaging Sessions Faulted Per Second"; instance = instance }
  /// Reliable Messaging Messages Dropped: 
  let ``Reliable Messaging Messages Dropped`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Reliable Messaging Messages Dropped"; instance = instance }
  /// Reliable Messaging Messages Dropped Per Second: 
  let ``Reliable Messaging Messages Dropped Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Reliable Messaging Messages Dropped Per Second"; instance = instance }
  /// Queued Poison Messages: 
  let ``Queued Poison Messages`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Queued Poison Messages"; instance = instance }
  /// Queued Poison Messages Per Second: 
  let ``Queued Poison Messages Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Queued Poison Messages Per Second"; instance = instance }
  /// Queued Messages Rejected: 
  let ``Queued Messages Rejected`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Queued Messages Rejected"; instance = instance }
  /// Queued Messages Rejected Per Second: 
  let ``Queued Messages Rejected Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Queued Messages Rejected Per Second"; instance = instance }
  /// Queued Messages Dropped: 
  let ``Queued Messages Dropped`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Queued Messages Dropped"; instance = instance }
  /// Queued Messages Dropped Per Second: 
  let ``Queued Messages Dropped Per Second`` instance =
    { category = "ServiceModelService 3.0.0.0"; counter = "Queued Messages Dropped Per Second"; instance = instance }

  let allCounters =
    [ ``Calls``
      ``Calls Per Second``
      ``Calls Outstanding``
      ``Calls Failed``
      ``Calls Failed Per Second``
      ``Calls Faulted``
      ``Calls Faulted Per Second``
      ``Calls Duration``
      ``Calls Duration Base``
      ``Transactions Flowed``
      ``Transactions Flowed Per Second``
      ``Transacted Operations Committed``
      ``Transacted Operations Committed Per Second``
      ``Transacted Operations Aborted``
      ``Transacted Operations Aborted Per Second``
      ``Transacted Operations In Doubt``
      ``Transacted Operations In Doubt Per Second``
      ``Security Validation and Authentication Failures``
      ``Security Validation and Authentication Failures Per Second``
      ``Security Calls Not Authorized``
      ``Security Calls Not Authorized Per Second``
      ``Instances``
      ``Instances Created Per Second``
      ``Reliable Messaging Sessions Faulted``
      ``Reliable Messaging Sessions Faulted Per Second``
      ``Reliable Messaging Messages Dropped``
      ``Reliable Messaging Messages Dropped Per Second``
      ``Queued Poison Messages``
      ``Queued Poison Messages Per Second``
      ``Queued Messages Rejected``
      ``Queued Messages Rejected Per Second``
      ``Queued Messages Dropped``
      ``Queued Messages Dropped Per Second``
    ]

/// ServiceModelService 4.0.0.0: ServiceModel performance counters for service
///
/// This performance counter does not have instance based counters
module ``ServiceModelService 4_0_0_0`` =

  [<Literal>]
  let Category = "ServiceModelService 4.0.0.0"

  let PCC = getPCC Category
  /// Calls: 
  let ``Calls`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Calls"; instance = instance }
  /// Calls Per Second: 
  let ``Calls Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Calls Per Second"; instance = instance }
  /// Calls Outstanding: 
  let ``Calls Outstanding`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Calls Outstanding"; instance = instance }
  /// Calls Failed: 
  let ``Calls Failed`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Calls Failed"; instance = instance }
  /// Calls Failed Per Second: 
  let ``Calls Failed Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Calls Failed Per Second"; instance = instance }
  /// Calls Faulted: 
  let ``Calls Faulted`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Calls Faulted"; instance = instance }
  /// Calls Faulted Per Second: 
  let ``Calls Faulted Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Calls Faulted Per Second"; instance = instance }
  /// Calls Duration: 
  let ``Calls Duration`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Calls Duration"; instance = instance }
  /// Security Validation and Authentication Failures: 
  let ``Security Validation and Authentication Failures`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Security Validation and Authentication Failures"; instance = instance }
  /// Security Validation and Authentication Failures Per Second: 
  let ``Security Validation and Authentication Failures Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Security Validation and Authentication Failures Per Second"; instance = instance }
  /// Security Calls Not Authorized: 
  let ``Security Calls Not Authorized`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Security Calls Not Authorized"; instance = instance }
  /// Security Calls Not Authorized Per Second: 
  let ``Security Calls Not Authorized Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Security Calls Not Authorized Per Second"; instance = instance }
  /// Instances: 
  let ``Instances`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Instances"; instance = instance }
  /// Instances Created Per Second: 
  let ``Instances Created Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Instances Created Per Second"; instance = instance }
  /// Reliable Messaging Sessions Faulted: 
  let ``Reliable Messaging Sessions Faulted`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Reliable Messaging Sessions Faulted"; instance = instance }
  /// Reliable Messaging Sessions Faulted Per Second: 
  let ``Reliable Messaging Sessions Faulted Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Reliable Messaging Sessions Faulted Per Second"; instance = instance }
  /// Reliable Messaging Messages Dropped: 
  let ``Reliable Messaging Messages Dropped`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Reliable Messaging Messages Dropped"; instance = instance }
  /// Reliable Messaging Messages Dropped Per Second: 
  let ``Reliable Messaging Messages Dropped Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Reliable Messaging Messages Dropped Per Second"; instance = instance }
  /// Transactions Flowed: 
  let ``Transactions Flowed`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Transactions Flowed"; instance = instance }
  /// Transactions Flowed Per Second: 
  let ``Transactions Flowed Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Transactions Flowed Per Second"; instance = instance }
  /// Transacted Operations Committed: 
  let ``Transacted Operations Committed`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Transacted Operations Committed"; instance = instance }
  /// Transacted Operations Committed Per Second: 
  let ``Transacted Operations Committed Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Transacted Operations Committed Per Second"; instance = instance }
  /// Transacted Operations Aborted: 
  let ``Transacted Operations Aborted`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Transacted Operations Aborted"; instance = instance }
  /// Transacted Operations Aborted Per Second: 
  let ``Transacted Operations Aborted Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Transacted Operations Aborted Per Second"; instance = instance }
  /// Transacted Operations In Doubt: 
  let ``Transacted Operations In Doubt`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Transacted Operations In Doubt"; instance = instance }
  /// Transacted Operations In Doubt Per Second: 
  let ``Transacted Operations In Doubt Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Transacted Operations In Doubt Per Second"; instance = instance }
  /// Queued Poison Messages: 
  let ``Queued Poison Messages`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Queued Poison Messages"; instance = instance }
  /// Queued Poison Messages Per Second: 
  let ``Queued Poison Messages Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Queued Poison Messages Per Second"; instance = instance }
  /// Queued Messages Rejected: 
  let ``Queued Messages Rejected`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Queued Messages Rejected"; instance = instance }
  /// Queued Messages Rejected Per Second: 
  let ``Queued Messages Rejected Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Queued Messages Rejected Per Second"; instance = instance }
  /// Queued Messages Dropped: 
  let ``Queued Messages Dropped`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Queued Messages Dropped"; instance = instance }
  /// Queued Messages Dropped Per Second: 
  let ``Queued Messages Dropped Per Second`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Queued Messages Dropped Per Second"; instance = instance }
  /// Percent Of Max Concurrent Calls: 
  let ``Percent Of Max Concurrent Calls`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Percent Of Max Concurrent Calls"; instance = instance }
  /// Percent Of Max Concurrent Instances: 
  let ``Percent Of Max Concurrent Instances`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Percent Of Max Concurrent Instances"; instance = instance }
  /// Percent Of Max Concurrent Sessions: 
  let ``Percent Of Max Concurrent Sessions`` instance =
    { category = "ServiceModelService 4.0.0.0"; counter = "Percent Of Max Concurrent Sessions"; instance = instance }

  let allCounters =
    [ ``Calls``
      ``Calls Per Second``
      ``Calls Outstanding``
      ``Calls Failed``
      ``Calls Failed Per Second``
      ``Calls Faulted``
      ``Calls Faulted Per Second``
      ``Calls Duration``
      ``Security Validation and Authentication Failures``
      ``Security Validation and Authentication Failures Per Second``
      ``Security Calls Not Authorized``
      ``Security Calls Not Authorized Per Second``
      ``Instances``
      ``Instances Created Per Second``
      ``Reliable Messaging Sessions Faulted``
      ``Reliable Messaging Sessions Faulted Per Second``
      ``Reliable Messaging Messages Dropped``
      ``Reliable Messaging Messages Dropped Per Second``
      ``Transactions Flowed``
      ``Transactions Flowed Per Second``
      ``Transacted Operations Committed``
      ``Transacted Operations Committed Per Second``
      ``Transacted Operations Aborted``
      ``Transacted Operations Aborted Per Second``
      ``Transacted Operations In Doubt``
      ``Transacted Operations In Doubt Per Second``
      ``Queued Poison Messages``
      ``Queued Poison Messages Per Second``
      ``Queued Messages Rejected``
      ``Queued Messages Rejected Per Second``
      ``Queued Messages Dropped``
      ``Queued Messages Dropped Per Second``
      ``Percent Of Max Concurrent Calls``
      ``Percent Of Max Concurrent Instances``
      ``Percent Of Max Concurrent Sessions``
    ]

/// Synchronization: The Synchronization performance object consists of counters for kernel synchronization. The synchronization object represents each processor as an instance of the object.
///
/// This performance counter does not have non-instance based counters
module ``Synchronization`` =

  [<Literal>]
  let Category = "Synchronization"

  let PCC = getPCC Category
  /// Spinlock Acquires/sec: Spinlock acquires/sec is the rate of spinlock acquisitions. It includes the basic spinlocks, queued spinlocks, in-stack queued spinlocks, and shared spinlocks acquisitions.
  let ``Spinlock Acquires/sec`` instance =
    { category = "Synchronization"; counter = "Spinlock Acquires/sec"; instance = instance }
  /// Spinlock Contentions/sec: Spinlock contentions/sec is the rate of spinlock contentions. It includes the basic spinlocks, queued spinlocks, in-stack queued spinlocks, and shared spinlocks contentions.
  let ``Spinlock Contentions/sec`` instance =
    { category = "Synchronization"; counter = "Spinlock Contentions/sec"; instance = instance }
  /// Spinlock Spins/sec: Spinlock spins/sec is the rate of spinlock spins. It includes the spins to acquire basic spinlocks, queued spinlocks, in-stack queued spinlocks, and shared spinlocks.
  let ``Spinlock Spins/sec`` instance =
    { category = "Synchronization"; counter = "Spinlock Spins/sec"; instance = instance }
  /// IPI Send Broadcast Requests/sec: IPI Send Broadcast Requests/sec is the rate of IPI broadcast requests. 
  let ``IPI Send Broadcast Requests/sec`` instance =
    { category = "Synchronization"; counter = "IPI Send Broadcast Requests/sec"; instance = instance }
  /// IPI Send Routine Requests/sec: IPI Send Routine Requests/sec is the rate of IPI routine requests.
  let ``IPI Send Routine Requests/sec`` instance =
    { category = "Synchronization"; counter = "IPI Send Routine Requests/sec"; instance = instance }
  /// IPI Send Software Interrupts/sec: IPI Send Software Interrrupts/sec is the rate of software interrupts.
  let ``IPI Send Software Interrupts/sec`` instance =
    { category = "Synchronization"; counter = "IPI Send Software Interrupts/sec"; instance = instance }
  /// Exec. Resource Total Initialize/sec: Frequency of initialization operations on Executive Resources.
  let ``Exec. Resource Total Initialize/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Total Initialize/sec"; instance = instance }
  /// Exec. Resource Total Re-Initialize/sec: Frequency of re-initialization operations on Executive Resources.
  let ``Exec. Resource Total Re-Initialize/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Total Re-Initialize/sec"; instance = instance }
  /// Exec. Resource Total Delete/sec: Frequency of delete operations on Executive Resources.
  let ``Exec. Resource Total Delete/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Total Delete/sec"; instance = instance }
  /// Exec. Resource Total Acquires/sec: Frequency of acquire operations on Executive Resources.
  let ``Exec. Resource Total Acquires/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Total Acquires/sec"; instance = instance }
  /// Exec. Resource Total Contentions/sec: Contention rate on Executive Resources.
  let ``Exec. Resource Total Contentions/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Total Contentions/sec"; instance = instance }
  /// Exec. Resource Total Exclusive Releases/sec: Frequency of Exclusive releases on Executive Resources.
  let ``Exec. Resource Total Exclusive Releases/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Total Exclusive Releases/sec"; instance = instance }
  /// Exec. Resource Total Shared Releases/sec: Frequency of Shared releases on Executive Resources.
  let ``Exec. Resource Total Shared Releases/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Total Shared Releases/sec"; instance = instance }
  /// Exec. Resource Total Conv. Exclusive To Shared/sec: Frequency of convert to shared operations on Executive Resources.
  let ``Exec. Resource Total Conv. Exclusive To Shared/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Total Conv. Exclusive To Shared/sec"; instance = instance }
  /// Exec. Resource Attempts AcqExclLite/sec: Frequency of acquire exclusive attempts on Executive Resources from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Attempts AcqExclLite/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Attempts AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Acquires AcqExclLite/sec: Frequency of first exclusive acquires from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Acquires AcqExclLite/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Acquires AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqExclLite/sec: Frequency of recursive exclusive acquires from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Recursive Excl. Acquires AcqExclLite/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Recursive Excl. Acquires AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Contention AcqExclLite/sec: Frequency of waits during exclusive acquire attempts from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Contention AcqExclLite/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Contention AcqExclLite/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqExclLite/sec: Frequency of no-waits during exclusive acquire attempts from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource no-Waits AcqExclLite/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource no-Waits AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Attempts AcqShrdLite/sec: Frequency of acquire shared attempts on Executive Resources from ExAcquireResourceSharedLite.
  let ``Exec. Resource Attempts AcqShrdLite/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Attempts AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec: Frequency of recursive exclusive acquires from ExAcquireResourceSharedLite.
  let ``Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Acquires AcqShrdLite/sec: Frequency of first shared acquires from ExAcquireResourceSharedLite.
  let ``Exec. Resource Acquires AcqShrdLite/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Acquires AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec: Frequency of recursive shared acquires from ExAcquireResourceSharedLite.
  let ``Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Contention AcqShrdLite/sec: Frequency of waits during acquire attempts from ExAcquireResourceSharedLite.
  let ``Exec. Resource Contention AcqShrdLite/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Contention AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqShrdLite/sec: Frequency of no-waits during acquire attempts from ExAcquireResourceSharedLite.
  let ``Exec. Resource no-Waits AcqShrdLite/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource no-Waits AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Attempts AcqShrdStarveExcl/sec: Frequency of acquire shared attempts on Executive Resources from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Attempts AcqShrdStarveExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Attempts AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec: Frequency of recursive exclusive acquires from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Acquires AcqShrdStarveExcl/sec: Frequency of first shared acquires from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Acquires AcqShrdStarveExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Acquires AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec: Frequency of recursive shared acquires from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Contention AcqShrdStarveExcl/sec: Frequency of waits during shared acquire attempts from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Contention AcqShrdStarveExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Contention AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqShrdStarveExcl/sec: Frequency of no-waits during shared acquire attempts from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource no-Waits AcqShrdStarveExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource no-Waits AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Attempts AcqShrdWaitForExcl/sec: Frequency of acquire shared attempts on Executive Resources from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Attempts AcqShrdWaitForExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Attempts AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec: Frequency of recursive exclusive acquires from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Acquires AcqShrdWaitForExcl/sec: Frequency of first shared acquires from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Acquires AcqShrdWaitForExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Acquires AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec: Frequency of recursive shared acquires from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Contention AcqShrdWaitForExcl/sec: Frequency of waits during shared acquire attempts from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Contention AcqShrdWaitForExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Contention AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqShrdWaitForExcl/sec: Frequency of no-waits during exclusive acquire attempts from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource no-Waits AcqShrdWaitForExcl/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource no-Waits AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Set Owner Pointer Exclusive/sec: Frequency of ExSetResourceOwnerPointer to an exclusive owner.
  let ``Exec. Resource Set Owner Pointer Exclusive/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Set Owner Pointer Exclusive/sec"; instance = instance }
  /// Exec. Resource Set Owner Pointer Shared (New Owner)/sec: Frequency of ExSetResourceOwnerPointer to a new shared owner.
  let ``Exec. Resource Set Owner Pointer Shared (New Owner)/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Set Owner Pointer Shared (New Owner)/sec"; instance = instance }
  /// Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec: Frequency of ExSetResourceOwnerPointer to an existing shared owner.
  let ``Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec"; instance = instance }
  /// Exec. Resource Boost Excl. Owner/sec: Frequency of boosting exclusive ownwer when waiting for this Executive Resource.
  let ``Exec. Resource Boost Excl. Owner/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Boost Excl. Owner/sec"; instance = instance }
  /// Exec. Resource Boost Shared Owners/sec: Frequency of boosting shared ownwer(s) when waiting for this Executive Resource.
  let ``Exec. Resource Boost Shared Owners/sec`` instance =
    { category = "Synchronization"; counter = "Exec. Resource Boost Shared Owners/sec"; instance = instance }

  let allCounters =
    [ ``Spinlock Acquires/sec``
      ``Spinlock Contentions/sec``
      ``Spinlock Spins/sec``
      ``IPI Send Broadcast Requests/sec``
      ``IPI Send Routine Requests/sec``
      ``IPI Send Software Interrupts/sec``
      ``Exec. Resource Total Initialize/sec``
      ``Exec. Resource Total Re-Initialize/sec``
      ``Exec. Resource Total Delete/sec``
      ``Exec. Resource Total Acquires/sec``
      ``Exec. Resource Total Contentions/sec``
      ``Exec. Resource Total Exclusive Releases/sec``
      ``Exec. Resource Total Shared Releases/sec``
      ``Exec. Resource Total Conv. Exclusive To Shared/sec``
      ``Exec. Resource Attempts AcqExclLite/sec``
      ``Exec. Resource Acquires AcqExclLite/sec``
      ``Exec. Resource Recursive Excl. Acquires AcqExclLite/sec``
      ``Exec. Resource Contention AcqExclLite/sec``
      ``Exec. Resource no-Waits AcqExclLite/sec``
      ``Exec. Resource Attempts AcqShrdLite/sec``
      ``Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec``
      ``Exec. Resource Acquires AcqShrdLite/sec``
      ``Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec``
      ``Exec. Resource Contention AcqShrdLite/sec``
      ``Exec. Resource no-Waits AcqShrdLite/sec``
      ``Exec. Resource Attempts AcqShrdStarveExcl/sec``
      ``Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec``
      ``Exec. Resource Acquires AcqShrdStarveExcl/sec``
      ``Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec``
      ``Exec. Resource Contention AcqShrdStarveExcl/sec``
      ``Exec. Resource no-Waits AcqShrdStarveExcl/sec``
      ``Exec. Resource Attempts AcqShrdWaitForExcl/sec``
      ``Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec``
      ``Exec. Resource Acquires AcqShrdWaitForExcl/sec``
      ``Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec``
      ``Exec. Resource Contention AcqShrdWaitForExcl/sec``
      ``Exec. Resource no-Waits AcqShrdWaitForExcl/sec``
      ``Exec. Resource Set Owner Pointer Exclusive/sec``
      ``Exec. Resource Set Owner Pointer Shared (New Owner)/sec``
      ``Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec``
      ``Exec. Resource Boost Excl. Owner/sec``
      ``Exec. Resource Boost Shared Owners/sec``
    ]

/// SynchronizationNuma: The Synchronization performance object consists of counters for kernel synchronization. The synchronization object represents each processor as an instance of the object. The counters are aggregated based on the system NUMA topology.
///
/// This performance counter does not have non-instance based counters
module ``SynchronizationNuma`` =

  [<Literal>]
  let Category = "SynchronizationNuma"

  let PCC = getPCC Category
  /// Spinlock Acquires/sec: Spinlock acquires/sec is the rate of spinlock acquisitions. It includes the basic spinlocks, queued spinlocks, in-stack queued spinlocks, and shared spinlocks acquisitions.
  let ``Spinlock Acquires/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Spinlock Acquires/sec"; instance = instance }
  /// Spinlock Contentions/sec: Spinlock contentions/sec is the rate of spinlock contentions. It includes the basic spinlocks, queued spinlocks, in-stack queued spinlocks, and shared spinlocks contentions.
  let ``Spinlock Contentions/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Spinlock Contentions/sec"; instance = instance }
  /// Spinlock Spins/sec: Spinlock spins/sec is the rate of spinlock spins. It includes the spins to acquire basic spinlocks, queued spinlocks, in-stack queued spinlocks, and shared spinlocks.
  let ``Spinlock Spins/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Spinlock Spins/sec"; instance = instance }
  /// IPI Send Broadcast Requests/sec: IPI Send Broadcast Requests/sec is the rate of IPI broadcast requests. 
  let ``IPI Send Broadcast Requests/sec`` instance =
    { category = "SynchronizationNuma"; counter = "IPI Send Broadcast Requests/sec"; instance = instance }
  /// IPI Send Routine Requests/sec: IPI Send Routine Requests/sec is the rate of IPI routine requests.
  let ``IPI Send Routine Requests/sec`` instance =
    { category = "SynchronizationNuma"; counter = "IPI Send Routine Requests/sec"; instance = instance }
  /// IPI Send Software Interrupts/sec: IPI Send Software Interrrupts/sec is the rate of software interrupts.
  let ``IPI Send Software Interrupts/sec`` instance =
    { category = "SynchronizationNuma"; counter = "IPI Send Software Interrupts/sec"; instance = instance }
  /// Exec. Resource Total Initialize/sec: Frequency of initialization operations on Executive Resources.
  let ``Exec. Resource Total Initialize/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Total Initialize/sec"; instance = instance }
  /// Exec. Resource Total Re-Initialize/sec: Frequency of re-initialization operations on Executive Resources.
  let ``Exec. Resource Total Re-Initialize/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Total Re-Initialize/sec"; instance = instance }
  /// Exec. Resource Total Delete/sec: Frequency of delete operations on Executive Resources.
  let ``Exec. Resource Total Delete/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Total Delete/sec"; instance = instance }
  /// Exec. Resource Total Acquires/sec: Frequency of acquire operations on Executive Resources.
  let ``Exec. Resource Total Acquires/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Total Acquires/sec"; instance = instance }
  /// Exec. Resource Total Contentions/sec: Contention rate on Executive Resources.
  let ``Exec. Resource Total Contentions/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Total Contentions/sec"; instance = instance }
  /// Exec. Resource Total Exclusive Releases/sec: Frequency of Exclusive releases on Executive Resources.
  let ``Exec. Resource Total Exclusive Releases/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Total Exclusive Releases/sec"; instance = instance }
  /// Exec. Resource Total Shared Releases/sec: Frequency of Shared releases on Executive Resources.
  let ``Exec. Resource Total Shared Releases/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Total Shared Releases/sec"; instance = instance }
  /// Exec. Resource Total Conv. Exclusive To Shared/sec: Frequency of convert to shared operations on Executive Resources.
  let ``Exec. Resource Total Conv. Exclusive To Shared/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Total Conv. Exclusive To Shared/sec"; instance = instance }
  /// Exec. Resource Attempts AcqExclLite/sec: Frequency of acquire exclusive attempts on Executive Resources from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Attempts AcqExclLite/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Attempts AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Acquires AcqExclLite/sec: Frequency of first exclusive acquires from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Acquires AcqExclLite/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Acquires AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqExclLite/sec: Frequency of recursive exclusive acquires from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Recursive Excl. Acquires AcqExclLite/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Recursive Excl. Acquires AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Contention AcqExclLite/sec: Frequency of waits during exclusive acquire attempts from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource Contention AcqExclLite/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Contention AcqExclLite/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqExclLite/sec: Frequency of no-waits during exclusive acquire attempts from ExAcquireResourceExclusiveLite.
  let ``Exec. Resource no-Waits AcqExclLite/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource no-Waits AcqExclLite/sec"; instance = instance }
  /// Exec. Resource Attempts AcqShrdLite/sec: Frequency of acquire shared attempts on Executive Resources from ExAcquireResourceSharedLite.
  let ``Exec. Resource Attempts AcqShrdLite/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Attempts AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec: Frequency of recursive exclusive acquires from ExAcquireResourceSharedLite.
  let ``Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Acquires AcqShrdLite/sec: Frequency of first shared acquires from ExAcquireResourceSharedLite.
  let ``Exec. Resource Acquires AcqShrdLite/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Acquires AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec: Frequency of recursive shared acquires from ExAcquireResourceSharedLite.
  let ``Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Contention AcqShrdLite/sec: Frequency of waits during acquire attempts from ExAcquireResourceSharedLite.
  let ``Exec. Resource Contention AcqShrdLite/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Contention AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqShrdLite/sec: Frequency of no-waits during acquire attempts from ExAcquireResourceSharedLite.
  let ``Exec. Resource no-Waits AcqShrdLite/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource no-Waits AcqShrdLite/sec"; instance = instance }
  /// Exec. Resource Attempts AcqShrdStarveExcl/sec: Frequency of acquire shared attempts on Executive Resources from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Attempts AcqShrdStarveExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Attempts AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec: Frequency of recursive exclusive acquires from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Acquires AcqShrdStarveExcl/sec: Frequency of first shared acquires from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Acquires AcqShrdStarveExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Acquires AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec: Frequency of recursive shared acquires from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Contention AcqShrdStarveExcl/sec: Frequency of waits during shared acquire attempts from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource Contention AcqShrdStarveExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Contention AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqShrdStarveExcl/sec: Frequency of no-waits during shared acquire attempts from ExAcquireSharedStarveExclusive.
  let ``Exec. Resource no-Waits AcqShrdStarveExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource no-Waits AcqShrdStarveExcl/sec"; instance = instance }
  /// Exec. Resource Attempts AcqShrdWaitForExcl/sec: Frequency of acquire shared attempts on Executive Resources from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Attempts AcqShrdWaitForExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Attempts AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec: Frequency of recursive exclusive acquires from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Acquires AcqShrdWaitForExcl/sec: Frequency of first shared acquires from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Acquires AcqShrdWaitForExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Acquires AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec: Frequency of recursive shared acquires from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Contention AcqShrdWaitForExcl/sec: Frequency of waits during shared acquire attempts from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource Contention AcqShrdWaitForExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Contention AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource no-Waits AcqShrdWaitForExcl/sec: Frequency of no-waits during exclusive acquire attempts from ExAcquireSharedWaitForExclusive.
  let ``Exec. Resource no-Waits AcqShrdWaitForExcl/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource no-Waits AcqShrdWaitForExcl/sec"; instance = instance }
  /// Exec. Resource Set Owner Pointer Exclusive/sec: Frequency of ExSetResourceOwnerPointer to an exclusive owner.
  let ``Exec. Resource Set Owner Pointer Exclusive/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Set Owner Pointer Exclusive/sec"; instance = instance }
  /// Exec. Resource Set Owner Pointer Shared (New Owner)/sec: Frequency of ExSetResourceOwnerPointer to a new shared owner.
  let ``Exec. Resource Set Owner Pointer Shared (New Owner)/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Set Owner Pointer Shared (New Owner)/sec"; instance = instance }
  /// Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec: Frequency of ExSetResourceOwnerPointer to an existing shared owner.
  let ``Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec"; instance = instance }
  /// Exec. Resource Boost Excl. Owner/sec: Frequency of boosting exclusive ownwer when waiting for this Executive Resource.
  let ``Exec. Resource Boost Excl. Owner/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Boost Excl. Owner/sec"; instance = instance }
  /// Exec. Resource Boost Shared Owners/sec: Frequency of boosting shared ownwer(s) when waiting for this Executive Resource.
  let ``Exec. Resource Boost Shared Owners/sec`` instance =
    { category = "SynchronizationNuma"; counter = "Exec. Resource Boost Shared Owners/sec"; instance = instance }

  let allCounters =
    [ ``Spinlock Acquires/sec``
      ``Spinlock Contentions/sec``
      ``Spinlock Spins/sec``
      ``IPI Send Broadcast Requests/sec``
      ``IPI Send Routine Requests/sec``
      ``IPI Send Software Interrupts/sec``
      ``Exec. Resource Total Initialize/sec``
      ``Exec. Resource Total Re-Initialize/sec``
      ``Exec. Resource Total Delete/sec``
      ``Exec. Resource Total Acquires/sec``
      ``Exec. Resource Total Contentions/sec``
      ``Exec. Resource Total Exclusive Releases/sec``
      ``Exec. Resource Total Shared Releases/sec``
      ``Exec. Resource Total Conv. Exclusive To Shared/sec``
      ``Exec. Resource Attempts AcqExclLite/sec``
      ``Exec. Resource Acquires AcqExclLite/sec``
      ``Exec. Resource Recursive Excl. Acquires AcqExclLite/sec``
      ``Exec. Resource Contention AcqExclLite/sec``
      ``Exec. Resource no-Waits AcqExclLite/sec``
      ``Exec. Resource Attempts AcqShrdLite/sec``
      ``Exec. Resource Recursive Excl. Acquires AcqShrdLite/sec``
      ``Exec. Resource Acquires AcqShrdLite/sec``
      ``Exec. Resource Recursive Sh. Acquires AcqShrdLite/sec``
      ``Exec. Resource Contention AcqShrdLite/sec``
      ``Exec. Resource no-Waits AcqShrdLite/sec``
      ``Exec. Resource Attempts AcqShrdStarveExcl/sec``
      ``Exec. Resource Recursive Excl. Acquires AcqShrdStarveExcl/sec``
      ``Exec. Resource Acquires AcqShrdStarveExcl/sec``
      ``Exec. Resource Recursive Sh. Acquires AcqShrdStarveExcl/sec``
      ``Exec. Resource Contention AcqShrdStarveExcl/sec``
      ``Exec. Resource no-Waits AcqShrdStarveExcl/sec``
      ``Exec. Resource Attempts AcqShrdWaitForExcl/sec``
      ``Exec. Resource Recursive Excl. Acquires AcqShrdWaitForExcl/sec``
      ``Exec. Resource Acquires AcqShrdWaitForExcl/sec``
      ``Exec. Resource Recursive Sh. Acquires AcqShrdWaitForExcl/sec``
      ``Exec. Resource Contention AcqShrdWaitForExcl/sec``
      ``Exec. Resource no-Waits AcqShrdWaitForExcl/sec``
      ``Exec. Resource Set Owner Pointer Exclusive/sec``
      ``Exec. Resource Set Owner Pointer Shared (New Owner)/sec``
      ``Exec. Resource Set Owner Pointer Shared (Existing Owner)/sec``
      ``Exec. Resource Boost Excl. Owner/sec``
      ``Exec. Resource Boost Shared Owners/sec``
    ]

/// System: The System performance object consists of counters that apply to more than one instance of a component processors on the computer.
///
/// This performance counter does not have instance based counters
module ``System`` =

  [<Literal>]
  let Category = "System"

  let PCC = getPCC Category
  /// File Read Operations/sec: File Read Operations/sec is the combined rate of file system read requests to all devices on the computer, including requests to read from the file system cache.  It is measured in numbers of reads.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``File Read Operations/sec`` =
    { category = "System"; counter = "File Read Operations/sec"; instance = NotApplicable }
  /// File Write Operations/sec: File Write Operations/sec is the combined rate of the file system write requests to all devices on the computer, including requests to write to data in the file system cache.  It is measured in numbers of writes. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``File Write Operations/sec`` =
    { category = "System"; counter = "File Write Operations/sec"; instance = NotApplicable }
  /// File Control Operations/sec: File Control Operations/sec is the combined rate of file system operations that are neither reads nor writes, such as file system control requests and requests for information about device characteristics or status.  This is the inverse of System: File Data Operations/sec and is measured in number of operations perf second.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``File Control Operations/sec`` =
    { category = "System"; counter = "File Control Operations/sec"; instance = NotApplicable }
  /// File Read Bytes/sec: File Read Bytes/sec is the overall rate at which bytes are read to satisfy  file system read requests to all devices on the computer, including reads from the file system cache.  It is measured in number of bytes per second.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``File Read Bytes/sec`` =
    { category = "System"; counter = "File Read Bytes/sec"; instance = NotApplicable }
  /// File Write Bytes/sec: File Write Bytes/sec is the overall rate at which bytes are written to satisfy file system write requests to all devices on the computer, including writes to the file system cache.  It is measured in number of bytes per second.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``File Write Bytes/sec`` =
    { category = "System"; counter = "File Write Bytes/sec"; instance = NotApplicable }
  /// File Control Bytes/sec: File Control Bytes/sec is the overall rate at which bytes are transferred for all file system operations that are neither reads nor writes, including file system control requests and requests for information about device characteristics or status.  It is measured in numbers of bytes.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``File Control Bytes/sec`` =
    { category = "System"; counter = "File Control Bytes/sec"; instance = NotApplicable }
  /// Context Switches/sec: Context Switches/sec is the combined rate at which all processors on the computer are switched from one thread to another.  Context switches occur when a running thread voluntarily relinquishes the processor, is preempted by a higher priority ready thread, or switches between user-mode and privileged (kernel) mode to use an Executive or subsystem service.  It is the sum of Thread\\Context Switches/sec for all threads running on all processors in the computer and is measured in numbers of switches.  There are context switch counters on the System and Thread objects. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Context Switches/sec`` =
    { category = "System"; counter = "Context Switches/sec"; instance = NotApplicable }
  /// System Calls/sec: System Calls/sec is the combined rate of calls to operating system service routines by all processes running on the computer. These routines perform all of the basic scheduling and synchronization of activities on the computer, and provide access to non-graphic devices, memory management, and name space management. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``System Calls/sec`` =
    { category = "System"; counter = "System Calls/sec"; instance = NotApplicable }
  /// File Data Operations/sec: File Data Operations/ sec is the combined rate of read and write operations on all logical disks on the computer.  This is the inverse of System: File Control Operations/sec.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``File Data Operations/sec`` =
    { category = "System"; counter = "File Data Operations/sec"; instance = NotApplicable }
  /// System Up Time: System Up Time is the elapsed time (in seconds) that the computer has been running since it was last started.  This counter displays the difference between the start time and the current time.
  let ``System Up Time`` =
    { category = "System"; counter = "System Up Time"; instance = NotApplicable }
  /// Processor Queue Length: Processor Queue Length is the number of threads in the processor queue.  Unlike the disk counters, this counter counters, this counter shows ready threads only, not threads that are running.  There is a single queue for processor time even on computers with multiple processors. Therefore, if a computer has multiple processors, you need to divide this value by the number of processors servicing the workload. A sustained processor queue of less than 10 threads per processor is normally acceptable, dependent of the workload.
  let ``Processor Queue Length`` =
    { category = "System"; counter = "Processor Queue Length"; instance = NotApplicable }
  /// Processes: Processes is the number of processes in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  Each process represents the running of a program.
  let ``Processes`` =
    { category = "System"; counter = "Processes"; instance = NotApplicable }
  /// Threads: Threads is the number of threads in the computer at the time of data collection. This is an instantaneous count, not an average over the time interval.  A thread is the basic executable entity that can execute instructions in a processor.
  let ``Threads`` =
    { category = "System"; counter = "Threads"; instance = NotApplicable }
  /// Alignment Fixups/sec: Alignment Fixups/sec is the rate, in incidents per seconds, at alignment faults were fixed by the system.
  let ``Alignment Fixups/sec`` =
    { category = "System"; counter = "Alignment Fixups/sec"; instance = NotApplicable }
  /// Exception Dispatches/sec: Exception Dispatches/sec is the rate, in incidents per second, at which exceptions were dispatched by the system.
  let ``Exception Dispatches/sec`` =
    { category = "System"; counter = "Exception Dispatches/sec"; instance = NotApplicable }
  /// Floating Emulations/sec: Floating Emulations/sec is the rate of floating emulations performed by the system.  This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.
  let ``Floating Emulations/sec`` =
    { category = "System"; counter = "Floating Emulations/sec"; instance = NotApplicable }
  /// % Registry Quota In Use: % Registry Quota In Use is the percentage of the Total Registry Quota Allowed that is currently being used by the system.  This counter displays the current percentage value only; it is not an average.
  let ``% Registry Quota In Use`` =
    { category = "System"; counter = "% Registry Quota In Use"; instance = NotApplicable }

  let allCounters =
    [ ``File Read Operations/sec``
      ``File Write Operations/sec``
      ``File Control Operations/sec``
      ``File Read Bytes/sec``
      ``File Write Bytes/sec``
      ``File Control Bytes/sec``
      ``Context Switches/sec``
      ``System Calls/sec``
      ``File Data Operations/sec``
      ``System Up Time``
      ``Processor Queue Length``
      ``Processes``
      ``Threads``
      ``Alignment Fixups/sec``
      ``Exception Dispatches/sec``
      ``Floating Emulations/sec``
      ``% Registry Quota In Use``
    ]

/// TCPv4: The TCP performance object consists of counters that measure the rates at which TCP Segments are sent and received by using the TCP protocol.  It includes counters that monitor the number of TCP connections in each TCP connection state.
///
/// This performance counter does not have instance based counters
module ``TCPv4`` =

  [<Literal>]
  let Category = "TCPv4"

  let PCC = getPCC Category
  /// Segments/sec: Segments/sec is the rate at which TCP segments are sent or received using the TCP protocol.
  let ``Segments/sec`` =
    { category = "TCPv4"; counter = "Segments/sec"; instance = NotApplicable }
  /// Connections Established: Connections Established is the number of TCP connections for which the current state is either ESTABLISHED or CLOSE-WAIT.
  let ``Connections Established`` =
    { category = "TCPv4"; counter = "Connections Established"; instance = NotApplicable }
  /// Connections Active: Connections Active is the number of times TCP connections have made a direct transition to the SYN-SENT state from the CLOSED state. In other words, it shows a number of connections which are initiated by the local computer. The value is a cumulative total.
  let ``Connections Active`` =
    { category = "TCPv4"; counter = "Connections Active"; instance = NotApplicable }
  /// Connections Passive: Connections Passive is the number of times TCP connections have made a direct transition to the SYN-RCVD state from the LISTEN state. In other words, it shows a number of connections to the local computer, which are initiated by remote computers. The value is a cumulative total.
  let ``Connections Passive`` =
    { category = "TCPv4"; counter = "Connections Passive"; instance = NotApplicable }
  /// Connection Failures: Connection Failures is the number of times TCP connections have made a direct transition to the CLOSED state from the SYN-SENT state or the SYN-RCVD state, plus the number of times TCP connections have made a direct transition to the LISTEN state from the SYN-RCVD state.
  let ``Connection Failures`` =
    { category = "TCPv4"; counter = "Connection Failures"; instance = NotApplicable }
  /// Connections Reset: Connections Reset is the number of times TCP connections have made a direct transition to the CLOSED state from either the ESTABLISHED state or the CLOSE-WAIT state.
  let ``Connections Reset`` =
    { category = "TCPv4"; counter = "Connections Reset"; instance = NotApplicable }
  /// Segments Received/sec: Segments Received/sec is the rate at which segments are received, including those received in error.  This count includes segments received on currently established connections.
  let ``Segments Received/sec`` =
    { category = "TCPv4"; counter = "Segments Received/sec"; instance = NotApplicable }
  /// Segments Sent/sec: Segments Sent/sec is the rate at which segments are sent, including those on current connections, but excluding those containing only retransmitted bytes.
  let ``Segments Sent/sec`` =
    { category = "TCPv4"; counter = "Segments Sent/sec"; instance = NotApplicable }
  /// Segments Retransmitted/sec: Segments Retransmitted/sec is the rate at which segments are retransmitted, that is, segments transmitted containing one or more previously transmitted bytes.
  let ``Segments Retransmitted/sec`` =
    { category = "TCPv4"; counter = "Segments Retransmitted/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Segments/sec``
      ``Connections Established``
      ``Connections Active``
      ``Connections Passive``
      ``Connection Failures``
      ``Connections Reset``
      ``Segments Received/sec``
      ``Segments Sent/sec``
      ``Segments Retransmitted/sec``
    ]

/// TCPv6: The TCP performance object consists of counters that measure the rates at which TCP Segments are sent and received by using the TCP protocol.  It includes counters that monitor the number of TCP connections in each TCP connection state.
///
/// This performance counter does not have instance based counters
module ``TCPv6`` =

  [<Literal>]
  let Category = "TCPv6"

  let PCC = getPCC Category
  /// Segments/sec: Segments/sec is the rate at which TCP segments are sent or received using the TCP protocol.
  let ``Segments/sec`` =
    { category = "TCPv6"; counter = "Segments/sec"; instance = NotApplicable }
  /// Connections Established: Connections Established is the number of TCP connections for which the current state is either ESTABLISHED or CLOSE-WAIT.
  let ``Connections Established`` =
    { category = "TCPv6"; counter = "Connections Established"; instance = NotApplicable }
  /// Connections Active: Connections Active is the number of times TCP connections have made a direct transition to the SYN-SENT state from the CLOSED state. In other words, it shows a number of connections which are initiated by the local computer. The value is a cumulative total.
  let ``Connections Active`` =
    { category = "TCPv6"; counter = "Connections Active"; instance = NotApplicable }
  /// Connections Passive: Connections Passive is the number of times TCP connections have made a direct transition to the SYN-RCVD state from the LISTEN state. In other words, it shows a number of connections to the local computer, which are initiated by remote computers. The value is a cumulative total.
  let ``Connections Passive`` =
    { category = "TCPv6"; counter = "Connections Passive"; instance = NotApplicable }
  /// Connection Failures: Connection Failures is the number of times TCP connections have made a direct transition to the CLOSED state from the SYN-SENT state or the SYN-RCVD state, plus the number of times TCP connections have made a direct transition to the LISTEN state from the SYN-RCVD state.
  let ``Connection Failures`` =
    { category = "TCPv6"; counter = "Connection Failures"; instance = NotApplicable }
  /// Connections Reset: Connections Reset is the number of times TCP connections have made a direct transition to the CLOSED state from either the ESTABLISHED state or the CLOSE-WAIT state.
  let ``Connections Reset`` =
    { category = "TCPv6"; counter = "Connections Reset"; instance = NotApplicable }
  /// Segments Received/sec: Segments Received/sec is the rate at which segments are received, including those received in error.  This count includes segments received on currently established connections.
  let ``Segments Received/sec`` =
    { category = "TCPv6"; counter = "Segments Received/sec"; instance = NotApplicable }
  /// Segments Sent/sec: Segments Sent/sec is the rate at which segments are sent, including those on current connections, but excluding those containing only retransmitted bytes.
  let ``Segments Sent/sec`` =
    { category = "TCPv6"; counter = "Segments Sent/sec"; instance = NotApplicable }
  /// Segments Retransmitted/sec: Segments Retransmitted/sec is the rate at which segments are retransmitted, that is, segments transmitted containing one or more previously transmitted bytes.
  let ``Segments Retransmitted/sec`` =
    { category = "TCPv6"; counter = "Segments Retransmitted/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Segments/sec``
      ``Connections Established``
      ``Connections Active``
      ``Connections Passive``
      ``Connection Failures``
      ``Connections Reset``
      ``Segments Received/sec``
      ``Segments Sent/sec``
      ``Segments Retransmitted/sec``
    ]

/// Telephony: The Telephony System
///
/// This performance counter does not have instance based counters
module ``Telephony`` =

  [<Literal>]
  let Category = "Telephony"

  let PCC = getPCC Category
  /// Lines: The number of telephone lines serviced by this computer.
  let ``Lines`` =
    { category = "Telephony"; counter = "Lines"; instance = NotApplicable }
  /// Telephone Devices: The number of telephone devices serviced by this computer.
  let ``Telephone Devices`` =
    { category = "Telephony"; counter = "Telephone Devices"; instance = NotApplicable }
  /// Active Lines: The number of telephone lines serviced by this computer that are currently active.
  let ``Active Lines`` =
    { category = "Telephony"; counter = "Active Lines"; instance = NotApplicable }
  /// Active Telephones: The number of telephone devices that are currently being monitored.
  let ``Active Telephones`` =
    { category = "Telephony"; counter = "Active Telephones"; instance = NotApplicable }
  /// Outgoing Calls/sec: The rate of outgoing calls made by this computer.
  let ``Outgoing Calls/sec`` =
    { category = "Telephony"; counter = "Outgoing Calls/sec"; instance = NotApplicable }
  /// Incoming Calls/sec: The rate of incoming calls answered by this computer.
  let ``Incoming Calls/sec`` =
    { category = "Telephony"; counter = "Incoming Calls/sec"; instance = NotApplicable }
  /// Client Apps: The number of applications that are currently using telephony services.
  let ``Client Apps`` =
    { category = "Telephony"; counter = "Client Apps"; instance = NotApplicable }
  /// Current Outgoing Calls: Current outgoing calls being serviced by this computer.
  let ``Current Outgoing Calls`` =
    { category = "Telephony"; counter = "Current Outgoing Calls"; instance = NotApplicable }
  /// Current Incoming Calls: Current incoming calls being serviced by this computer.
  let ``Current Incoming Calls`` =
    { category = "Telephony"; counter = "Current Incoming Calls"; instance = NotApplicable }

  let allCounters =
    [ ``Lines``
      ``Telephone Devices``
      ``Active Lines``
      ``Active Telephones``
      ``Outgoing Calls/sec``
      ``Incoming Calls/sec``
      ``Client Apps``
      ``Current Outgoing Calls``
      ``Current Incoming Calls``
    ]

/// Teredo Client: Statistics of Teredo client.
///
/// This performance counter does not have non-instance based counters
module ``Teredo Client`` =

  [<Literal>]
  let Category = "Teredo Client"

  let PCC = getPCC Category
  /// In - Teredo Router Advertisement: Total Router Advertisement packets received by the Teredo client.
  let ``In - Teredo Router Advertisement`` instance =
    { category = "Teredo Client"; counter = "In - Teredo Router Advertisement"; instance = instance }
  /// In - Teredo Bubble: Total bubble packets received by the Teredo client.
  let ``In - Teredo Bubble`` instance =
    { category = "Teredo Client"; counter = "In - Teredo Bubble"; instance = instance }
  /// In - Teredo Data: Total data packets received by the Teredo client.
  let ``In - Teredo Data`` instance =
    { category = "Teredo Client"; counter = "In - Teredo Data"; instance = instance }
  /// In - Teredo Invalid: Total error packets received by the Teredo client.
  let ``In - Teredo Invalid`` instance =
    { category = "Teredo Client"; counter = "In - Teredo Invalid"; instance = instance }
  /// Out - Teredo Router Solicitation: Total Router Solicitation packets sent by the Teredo client.
  let ``Out - Teredo Router Solicitation`` instance =
    { category = "Teredo Client"; counter = "Out - Teredo Router Solicitation"; instance = instance }
  /// Out - Teredo Bubble: Total bubble packets sent by the Teredo client.
  let ``Out - Teredo Bubble`` instance =
    { category = "Teredo Client"; counter = "Out - Teredo Bubble"; instance = instance }
  /// Out - Teredo Data: Total data packets sent by the Teredo client.
  let ``Out - Teredo Data`` instance =
    { category = "Teredo Client"; counter = "Out - Teredo Data"; instance = instance }
  /// In - Teredo Data User Mode: Total data packets received by the Teredo client in user mode.
  let ``In - Teredo Data User Mode`` instance =
    { category = "Teredo Client"; counter = "In - Teredo Data User Mode"; instance = instance }
  /// In - Teredo Data Kernel Mode: Total data packets received by the Teredo client in kernel mode.
  let ``In - Teredo Data Kernel Mode`` instance =
    { category = "Teredo Client"; counter = "In - Teredo Data Kernel Mode"; instance = instance }
  /// Out - Teredo Data User Mode: Total data packets sent by the Teredo client in user mode.
  let ``Out - Teredo Data User Mode`` instance =
    { category = "Teredo Client"; counter = "Out - Teredo Data User Mode"; instance = instance }
  /// Out - Teredo Data Kernel Mode: Total data packets sent by the Teredo client in kernel mode.
  let ``Out - Teredo Data Kernel Mode`` instance =
    { category = "Teredo Client"; counter = "Out - Teredo Data Kernel Mode"; instance = instance }

  let allCounters =
    [ ``In - Teredo Router Advertisement``
      ``In - Teredo Bubble``
      ``In - Teredo Data``
      ``In - Teredo Invalid``
      ``Out - Teredo Router Solicitation``
      ``Out - Teredo Bubble``
      ``Out - Teredo Data``
      ``In - Teredo Data User Mode``
      ``In - Teredo Data Kernel Mode``
      ``Out - Teredo Data User Mode``
      ``Out - Teredo Data Kernel Mode``
    ]

/// Teredo Relay: Statistics of Teredo relay hosted on this machine.
///
/// This performance counter does not have non-instance based counters
module ``Teredo Relay`` =

  [<Literal>]
  let Category = "Teredo Relay"

  let PCC = getPCC Category
  /// In - Teredo Relay Total Packets: Success + Error: Total packets received by the Teredo relay.
  let ``In - Teredo Relay Total Packets: Success + Error`` instance =
    { category = "Teredo Relay"; counter = "In - Teredo Relay Total Packets: Success + Error"; instance = instance }
  /// In - Teredo Relay Success Packets: Total: Total valid packets received by the Teredo relay.
  let ``In - Teredo Relay Success Packets: Total`` instance =
    { category = "Teredo Relay"; counter = "In - Teredo Relay Success Packets: Total"; instance = instance }
  /// In - Teredo Relay Success Packets: Bubbles: Total bubbles received by the Teredo relay.
  let ``In - Teredo Relay Success Packets: Bubbles`` instance =
    { category = "Teredo Relay"; counter = "In - Teredo Relay Success Packets: Bubbles"; instance = instance }
  /// In - Teredo Relay Success Packets: Data Packets: Total data packets received by the Teredo relay.
  let ``In - Teredo Relay Success Packets: Data Packets`` instance =
    { category = "Teredo Relay"; counter = "In - Teredo Relay Success Packets: Data Packets"; instance = instance }
  /// In - Teredo Relay Error Packets: Total: Total error packets received by the Teredo relay.
  let ``In - Teredo Relay Error Packets: Total`` instance =
    { category = "Teredo Relay"; counter = "In - Teredo Relay Error Packets: Total"; instance = instance }
  /// In - Teredo Relay Error Packets: Header Error: Total error packets( header error) received by the Teredo relay.
  let ``In - Teredo Relay Error Packets: Header Error`` instance =
    { category = "Teredo Relay"; counter = "In - Teredo Relay Error Packets: Header Error"; instance = instance }
  /// In - Teredo Relay Error Packets: Source Error: Total error packets( source error) received by the Teredo relay.
  let ``In - Teredo Relay Error Packets: Source Error`` instance =
    { category = "Teredo Relay"; counter = "In - Teredo Relay Error Packets: Source Error"; instance = instance }
  /// In - Teredo Relay Error Packets: Destination Error: Total error packets( destination error) received by the Teredo relay.
  let ``In - Teredo Relay Error Packets: Destination Error`` instance =
    { category = "Teredo Relay"; counter = "In - Teredo Relay Error Packets: Destination Error"; instance = instance }
  /// Out - Teredo Relay Total Packets: Success + Error: Total packets sent by the Teredo relay.
  let ``Out - Teredo Relay Total Packets: Success + Error`` instance =
    { category = "Teredo Relay"; counter = "Out - Teredo Relay Total Packets: Success + Error"; instance = instance }
  /// Out - Teredo Relay Success Packets: Total packets successfully sent by the Teredo relay.
  let ``Out - Teredo Relay Success Packets`` instance =
    { category = "Teredo Relay"; counter = "Out - Teredo Relay Success Packets"; instance = instance }
  /// Out - Teredo Relay Success Packets: Bubbles: Total bubbles sent by the Teredo relay.
  let ``Out - Teredo Relay Success Packets: Bubbles`` instance =
    { category = "Teredo Relay"; counter = "Out - Teredo Relay Success Packets: Bubbles"; instance = instance }
  /// Out - Teredo Relay Success Packets: Data Packets: Total data packets sent by the Teredo relay.
  let ``Out - Teredo Relay Success Packets: Data Packets`` instance =
    { category = "Teredo Relay"; counter = "Out - Teredo Relay Success Packets: Data Packets"; instance = instance }
  /// Out - Teredo Relay Error Packets: Total packets failed to be sent by the Teredo relay.
  let ``Out - Teredo Relay Error Packets`` instance =
    { category = "Teredo Relay"; counter = "Out - Teredo Relay Error Packets"; instance = instance }
  /// Out - Teredo Relay Error Packets: Header Error: Total packets failed( header error) to be sent by the Teredo relay.
  let ``Out - Teredo Relay Error Packets: Header Error`` instance =
    { category = "Teredo Relay"; counter = "Out - Teredo Relay Error Packets: Header Error"; instance = instance }
  /// Out - Teredo Relay Error Packets: Source Error: Total packets failed( source error) to be sent by the Teredo relay.
  let ``Out - Teredo Relay Error Packets: Source Error`` instance =
    { category = "Teredo Relay"; counter = "Out - Teredo Relay Error Packets: Source Error"; instance = instance }
  /// Out - Teredo Relay Error Packets: Destination Error: Total packets failed( destination error) to be sent by the Teredo relay.
  let ``Out - Teredo Relay Error Packets: Destination Error`` instance =
    { category = "Teredo Relay"; counter = "Out - Teredo Relay Error Packets: Destination Error"; instance = instance }
  /// In - Teredo Relay Total Packets: Success + Error / sec: Rate of total packets received by the Teredo relay.
  let ``In - Teredo Relay Total Packets: Success + Error / sec`` instance =
    { category = "Teredo Relay"; counter = "In - Teredo Relay Total Packets: Success + Error / sec"; instance = instance }
  /// Out - Teredo Relay Total Packets: Success + Error / sec: Rate of total packets sent by the Teredo relay.
  let ``Out - Teredo Relay Total Packets: Success + Error / sec`` instance =
    { category = "Teredo Relay"; counter = "Out - Teredo Relay Total Packets: Success + Error / sec"; instance = instance }
  /// In - Teredo Relay Success Packets: Data Packets User Mode: Total data packets received by the Teredo relay in user mode.
  let ``In - Teredo Relay Success Packets: Data Packets User Mode`` instance =
    { category = "Teredo Relay"; counter = "In - Teredo Relay Success Packets: Data Packets User Mode"; instance = instance }
  /// In - Teredo Relay Success Packets: Data Packets Kernel Mode: Total data packets received by the Teredo relay in kernel mode.
  let ``In - Teredo Relay Success Packets: Data Packets Kernel Mode`` instance =
    { category = "Teredo Relay"; counter = "In - Teredo Relay Success Packets: Data Packets Kernel Mode"; instance = instance }
  /// Out - Teredo Relay Success Packets: Data Packets User Mode: Total data packets sent by the Teredo relay in user mode.
  let ``Out - Teredo Relay Success Packets: Data Packets User Mode`` instance =
    { category = "Teredo Relay"; counter = "Out - Teredo Relay Success Packets: Data Packets User Mode"; instance = instance }
  /// Out - Teredo Relay Success Packets: Data Packets Kernel Mode: Total data packets sent by the Teredo relay in kernel mode.
  let ``Out - Teredo Relay Success Packets: Data Packets Kernel Mode`` instance =
    { category = "Teredo Relay"; counter = "Out - Teredo Relay Success Packets: Data Packets Kernel Mode"; instance = instance }

  let allCounters =
    [ ``In - Teredo Relay Total Packets: Success + Error``
      ``In - Teredo Relay Success Packets: Total``
      ``In - Teredo Relay Success Packets: Bubbles``
      ``In - Teredo Relay Success Packets: Data Packets``
      ``In - Teredo Relay Error Packets: Total``
      ``In - Teredo Relay Error Packets: Header Error``
      ``In - Teredo Relay Error Packets: Source Error``
      ``In - Teredo Relay Error Packets: Destination Error``
      ``Out - Teredo Relay Total Packets: Success + Error``
      ``Out - Teredo Relay Success Packets``
      ``Out - Teredo Relay Success Packets: Bubbles``
      ``Out - Teredo Relay Success Packets: Data Packets``
      ``Out - Teredo Relay Error Packets``
      ``Out - Teredo Relay Error Packets: Header Error``
      ``Out - Teredo Relay Error Packets: Source Error``
      ``Out - Teredo Relay Error Packets: Destination Error``
      ``In - Teredo Relay Total Packets: Success + Error / sec``
      ``Out - Teredo Relay Total Packets: Success + Error / sec``
      ``In - Teredo Relay Success Packets: Data Packets User Mode``
      ``In - Teredo Relay Success Packets: Data Packets Kernel Mode``
      ``Out - Teredo Relay Success Packets: Data Packets User Mode``
      ``Out - Teredo Relay Success Packets: Data Packets Kernel Mode``
    ]

/// Teredo Server: Statistics of Teredo server hosted on this machine.
///
/// This performance counter does not have non-instance based counters
module ``Teredo Server`` =

  [<Literal>]
  let Category = "Teredo Server"

  let PCC = getPCC Category
  /// In - Teredo Server Total Packets: Success + Error: Total packets received by the Teredo server.
  let ``In - Teredo Server Total Packets: Success + Error`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Total Packets: Success + Error"; instance = instance }
  /// In - Teredo Server Success Packets: Total: Total valid packets received by the Teredo server.
  let ``In - Teredo Server Success Packets: Total`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Success Packets: Total"; instance = instance }
  /// In - Teredo Server Success Packets: Bubbles: Total bubbles received by the Teredo server.
  let ``In - Teredo Server Success Packets: Bubbles`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Success Packets: Bubbles"; instance = instance }
  /// In - Teredo Server Success Packets: Echo: Total echo packets received by the Teredo server.
  let ``In - Teredo Server Success Packets: Echo`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Success Packets: Echo"; instance = instance }
  /// In - Teredo Server Success Packets: RS-Primary: Total Router Solicitations received by the primary server.
  let ``In - Teredo Server Success Packets: RS-Primary`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Success Packets: RS-Primary"; instance = instance }
  /// In - Teredo Server Success Packets: RS-Secondary: Total Router Solicitations received by the secondary server
  let ``In - Teredo Server Success Packets: RS-Secondary`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Success Packets: RS-Secondary"; instance = instance }
  /// In - Teredo Server Error Packets: Total: Total error packets received by the Teredo server.
  let ``In - Teredo Server Error Packets: Total`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Error Packets: Total"; instance = instance }
  /// In - Teredo Server Error Packets: Header Error: Total error packets( header error) received by the Teredo server.
  let ``In - Teredo Server Error Packets: Header Error`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Error Packets: Header Error"; instance = instance }
  /// In - Teredo Server Error Packets: Source Error: Total error packets( source error) received by the Teredo server.
  let ``In - Teredo Server Error Packets: Source Error`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Error Packets: Source Error"; instance = instance }
  /// In - Teredo Server Error Packets: Destination Error: Total error packets( destination error) received by the Teredo server.
  let ``In - Teredo Server Error Packets: Destination Error`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Error Packets: Destination Error"; instance = instance }
  /// In - Teredo Server Error Packets: Authentication Error: Total error packets( authentication error) received by the Teredo server.
  let ``In - Teredo Server Error Packets: Authentication Error`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Error Packets: Authentication Error"; instance = instance }
  /// Out - Teredo Server: RA-Primary: Total Router Advertisements sent by the primary server.
  let ``Out - Teredo Server: RA-Primary`` instance =
    { category = "Teredo Server"; counter = "Out - Teredo Server: RA-Primary"; instance = instance }
  /// Out - Teredo Server: RA-Secondary : Total Router Advertisements sent by the secondary server.
  let ``Out - Teredo Server: RA-Secondary `` instance =
    { category = "Teredo Server"; counter = "Out - Teredo Server: RA-Secondary "; instance = instance }
  /// In - Teredo Server Total Packets: Success + Error / sec: Rate of total packets received by the Teredo server.
  let ``In - Teredo Server Total Packets: Success + Error / sec`` instance =
    { category = "Teredo Server"; counter = "In - Teredo Server Total Packets: Success + Error / sec"; instance = instance }

  let allCounters =
    [ ``In - Teredo Server Total Packets: Success + Error``
      ``In - Teredo Server Success Packets: Total``
      ``In - Teredo Server Success Packets: Bubbles``
      ``In - Teredo Server Success Packets: Echo``
      ``In - Teredo Server Success Packets: RS-Primary``
      ``In - Teredo Server Success Packets: RS-Secondary``
      ``In - Teredo Server Error Packets: Total``
      ``In - Teredo Server Error Packets: Header Error``
      ``In - Teredo Server Error Packets: Source Error``
      ``In - Teredo Server Error Packets: Destination Error``
      ``In - Teredo Server Error Packets: Authentication Error``
      ``Out - Teredo Server: RA-Primary``
      ``Out - Teredo Server: RA-Secondary ``
      ``In - Teredo Server Total Packets: Success + Error / sec``
    ]

/// Terminal Services: Terminal Services Summary Information
///
/// This performance counter does not have instance based counters
module ``Terminal Services`` =

  [<Literal>]
  let Category = "Terminal Services"

  let PCC = getPCC Category
  /// Active Sessions: Number of active Terminal Services sessions
  let ``Active Sessions`` =
    { category = "Terminal Services"; counter = "Active Sessions"; instance = NotApplicable }
  /// Inactive Sessions: Number of inactive Terminal Services sessions
  let ``Inactive Sessions`` =
    { category = "Terminal Services"; counter = "Inactive Sessions"; instance = NotApplicable }
  /// Total Sessions: Total number Terminal services sessions
  let ``Total Sessions`` =
    { category = "Terminal Services"; counter = "Total Sessions"; instance = NotApplicable }

  let allCounters =
    [ ``Active Sessions``
      ``Inactive Sessions``
      ``Total Sessions``
    ]

/// Terminal Services Session: Terminal Services per-session resource monitoring.
///
/// This performance counter does not have non-instance based counters
module ``Terminal Services Session`` =

  [<Literal>]
  let Category = "Terminal Services Session"

  let PCC = getPCC Category
  /// % Processor Time: % Processor Time is the percentage of elapsed time that all of process threads used the processor to execution instructions. An instruction is the basic unit of execution in a computer, a thread is the object that executes instructions, and a process is the object created when a program is run. Code executed to handle some hardware interrupts and trap conditions are included in this count.
  let ``% Processor Time`` instance =
    { category = "Terminal Services Session"; counter = "% Processor Time"; instance = instance }
  /// % User Time: % User Time is the percentage of elapsed time that the process threads spent executing code in user mode. Applications, environment subsystems, and integral subsystems execute in user mode. Code executing in user mode cannot damage the integrity of the Windows executive, kernel, and device drivers. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.
  let ``% User Time`` instance =
    { category = "Terminal Services Session"; counter = "% User Time"; instance = instance }
  /// % Privileged Time: % Privileged Time is the percentage of elapsed time that the process threads spent executing code in privileged mode. When a Windows system service is called, the service will often run in privileged mode to gain access to system-private data. Such data is protected from access by threads executing in user mode. Calls to the system can be explicit or implicit, such as page faults or interrupts. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.
  let ``% Privileged Time`` instance =
    { category = "Terminal Services Session"; counter = "% Privileged Time"; instance = instance }
  /// Virtual Bytes Peak: Virtual Bytes Peak is the maximum size, in bytes, of virtual address space the process has used at any one time. Use of virtual address space does not necessarily imply corresponding use of either disk or main memory pages. However, virtual space is finite, and the process might limit its ability to load libraries.
  let ``Virtual Bytes Peak`` instance =
    { category = "Terminal Services Session"; counter = "Virtual Bytes Peak"; instance = instance }
  /// Virtual Bytes: Virtual Bytes is the current size, in bytes, of the virtual address space the process is using. Use of virtual address space does not necessarily imply corresponding use of either disk or main memory pages. Virtual space is finite, and the process can limit its ability to load libraries.
  let ``Virtual Bytes`` instance =
    { category = "Terminal Services Session"; counter = "Virtual Bytes"; instance = instance }
  /// Page Faults/sec: Page Faults/sec is the rate at which page faults by the threads executing in this process are occurring.  A page fault occurs when a thread refers to a virtual memory page that is not in its working set in main memory. This may not cause the page to be fetched from disk if it is on the standby list and hence already in main memory, or if it is in use by another process with whom the page is shared.
  let ``Page Faults/sec`` instance =
    { category = "Terminal Services Session"; counter = "Page Faults/sec"; instance = instance }
  /// Working Set Peak: Working Set Peak is the maximum size, in bytes, of the Working Set of this process at any point in time. The Working Set is the set of memory pages touched recently by the threads in the process. If free memory in the computer is above a threshold, pages are left in the Working Set of a process even if they are not in use. When free memory falls below a threshold, pages are trimmed from Working Sets. If they are needed they will then be soft-faulted back into the Working Set before they leave main memory.
  let ``Working Set Peak`` instance =
    { category = "Terminal Services Session"; counter = "Working Set Peak"; instance = instance }
  /// Working Set: Working Set is the current size, in bytes, of the Working Set of this process. The Working Set is the set of memory pages touched recently by the threads in the process. If free memory in the computer is above a threshold, pages are left in the Working Set of a process even if they are not in use.  When free memory falls below a threshold, pages are trimmed from Working Sets. If they are needed they will then be soft-faulted back into the Working Set before leaving main memory.
  let ``Working Set`` instance =
    { category = "Terminal Services Session"; counter = "Working Set"; instance = instance }
  /// Page File Bytes Peak: Page File Bytes Peak is the maximum amount of virtual memory, in bytes, that this process has reserved for use in the paging file(s). Paging files are used to store pages of memory used by the process that are not contained in other files.  Paging files are shared by all processes, and the lack of space in paging files can prevent other processes from allocating memory. If there is no paging file, this counter reflects the maximum amount of virtual memory that the process has reserved for use in physical memory.
  let ``Page File Bytes Peak`` instance =
    { category = "Terminal Services Session"; counter = "Page File Bytes Peak"; instance = instance }
  /// Page File Bytes: Page File Bytes is the current amount of virtual memory, in bytes, that this process has reserved for use in the paging file(s). Paging files are used to store pages of memory used by the process that are not contained in other files. Paging files are shared by all processes, and the lack of space in paging files can prevent other processes from allocating memory. If there is no paging file, this counter reflects the current amount of virtual memory that the process has reserved for use in physical memory.
  let ``Page File Bytes`` instance =
    { category = "Terminal Services Session"; counter = "Page File Bytes"; instance = instance }
  /// Private Bytes: Private Bytes is the current size, in bytes, of memory that this process has allocated that cannot be shared with other processes.
  let ``Private Bytes`` instance =
    { category = "Terminal Services Session"; counter = "Private Bytes"; instance = instance }
  /// Thread Count: The number of threads currently active in this process. An instruction is the basic unit of execution in a processor, and a thread is the object that executes instructions. Every running process has at least one thread.
  let ``Thread Count`` instance =
    { category = "Terminal Services Session"; counter = "Thread Count"; instance = instance }
  /// Pool Paged Bytes: Pool Paged Bytes is the size, in bytes, of the paged pool, an area of the system virtual memory that is used for objects that can be written to disk when they are not being used.  Memory\\Pool Paged Bytes is calculated differently than Process\\Pool Paged Bytes, so it might not equal Process(_Total)\\Pool Paged Bytes. This counter displays the last observed value only; it is not an average.
  let ``Pool Paged Bytes`` instance =
    { category = "Terminal Services Session"; counter = "Pool Paged Bytes"; instance = instance }
  /// Pool Nonpaged Bytes: Pool Nonpaged Bytes is the size, in bytes, of the nonpaged pool, an area of the system virtual memory that is used for objects that cannot be written to disk, but must remain in physical memory as long as they are allocated.  Memory\\Pool Nonpaged Bytes is calculated differently than Process\\Pool Nonpaged Bytes, so it might not equal Process(_Total)\\Pool Nonpaged Bytes.  This counter displays the last observed value only; it is not an average.
  let ``Pool Nonpaged Bytes`` instance =
    { category = "Terminal Services Session"; counter = "Pool Nonpaged Bytes"; instance = instance }
  /// Handle Count: The total number of handles currently open by this process. This number is equal to the sum of the handles currently open by each thread in this process.
  let ``Handle Count`` instance =
    { category = "Terminal Services Session"; counter = "Handle Count"; instance = instance }

  let allCounters =
    [ ``% Processor Time``
      ``% User Time``
      ``% Privileged Time``
      ``Virtual Bytes Peak``
      ``Virtual Bytes``
      ``Page Faults/sec``
      ``Working Set Peak``
      ``Working Set``
      ``Page File Bytes Peak``
      ``Page File Bytes``
      ``Private Bytes``
      ``Thread Count``
      ``Pool Paged Bytes``
      ``Pool Nonpaged Bytes``
      ``Handle Count``
    ]

/// Thread: The Thread performance object consists of counters that measure aspects of thread behavior.  A thread is the basic object that executes instructions on a processor.  All running processes have at least one thread.
///
/// This performance counter does not have non-instance based counters
module ``Thread`` =

  [<Literal>]
  let Category = "Thread"

  let PCC = getPCC Category
  /// Context Switches/sec: Context Switches/sec is the rate of switches from one thread to another.  Thread switches can occur either inside of a single process or across processes.  A thread switch can be caused either by one thread asking another for information, or by a thread being preempted by another, higher priority thread becoming ready to run.  Unlike some early operating systems, Windows NT uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes.  These subsystem processes provide additional protection.  Therefore, some work done by Windows NT on behalf of an application  appear in other subsystem processes in addition to the privileged time in the application.  Switching to the subsystem process causes one Context Switch in the application thread.  Switching back causes another Context Switch in the subsystem thread.
  let ``Context Switches/sec`` instance =
    { category = "Thread"; counter = "Context Switches/sec"; instance = instance }
  /// % Processor Time: % Processor Time is the percentage of elapsed time that all of process threads used the processor to execution instructions. An instruction is the basic unit of execution in a computer, a thread is the object that executes instructions, and a process is the object created when a program is run. Code executed to handle some hardware interrupts and trap conditions are included in this count.
  let ``% Processor Time`` instance =
    { category = "Thread"; counter = "% Processor Time"; instance = instance }
  /// % User Time: % User Time is the percentage of elapsed time that this thread has spent executing code in user mode.  Applications, environment subsystems, and integral subsystems execute in user mode.  Code executing in user mode cannot damage the integrity of the Windows NT Executive, Kernel, and device drivers.  Unlike some early operating systems, Windows NT uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes.  These subsystem processes provide additional protection.  Therefore, some work done by Windows NT on behalf of your application might appear in other subsystem processes in addition to the privileged time in your process.
  let ``% User Time`` instance =
    { category = "Thread"; counter = "% User Time"; instance = instance }
  /// % Privileged Time: % Privileged Time is the percentage of elapsed time that the process threads spent executing code in privileged mode.  When a Windows system service in called, the service will often run in privileged mode to gain access to system-private data. Such data is protected from access by threads executing in user mode. Calls to the system can be explicit or implicit, such as page faults or interrupts. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.
  let ``% Privileged Time`` instance =
    { category = "Thread"; counter = "% Privileged Time"; instance = instance }
  /// Elapsed Time: The total elapsed time (in seconds) this thread has been running.
  let ``Elapsed Time`` instance =
    { category = "Thread"; counter = "Elapsed Time"; instance = instance }
  /// Priority Current: The current dynamic priority of this thread.  The system can raise the thread's dynamic priority above the base priority if the thread is handling user input, or lower it towards the base priority if the thread becomes compute bound.
  let ``Priority Current`` instance =
    { category = "Thread"; counter = "Priority Current"; instance = instance }
  /// Priority Base: The current base priority of this thread.  The system can raise the thread's dynamic priority above the base priority if the thread is handling user input, or lower it towards the base priority if the thread becomes compute bound.
  let ``Priority Base`` instance =
    { category = "Thread"; counter = "Priority Base"; instance = instance }
  /// Start Address: Starting virtual address for this thread.
  let ``Start Address`` instance =
    { category = "Thread"; counter = "Start Address"; instance = instance }
  /// Thread State: Thread State is the current state of the thread.  It is 0 for Initialized, 1 for Ready, 2 for Running, 3 for Standby, 4 for Terminated, 5 for Wait, 6 for Transition, 7 for Unknown.  A Running thread is using a processor; a Standby thread is about to use one.  A Ready thread wants to use a processor, but is waiting for a processor because none are free.  A thread in Transition is waiting for a resource in order to execute, such as waiting for its execution stack to be paged in from disk.  A Waiting thread has no use for the processor because it is waiting for a peripheral operation to complete or a resource to become free.
  let ``Thread State`` instance =
    { category = "Thread"; counter = "Thread State"; instance = instance }
  /// Thread Wait Reason: Thread Wait Reason is only applicable when the thread is in the Wait state (see Thread State).  It is 0 or 7 when the thread is waiting for the Executive, 1 or 8 for a Free Page, 2 or 9 for a Page In, 3 or 10 for a Pool Allocation, 4 or 11 for an Execution Delay, 5 or 12 for a Suspended condition, 6 or 13 for a User Request, 14 for an Event Pair High, 15 for an Event Pair Low, 16 for an LPC Receive, 17 for an LPC Reply, 18 for Virtual Memory, 19 for a Page Out; 20 and higher are not assigned at the time of this writing.  Event Pairs are used to communicate with protected subsystems (see Context Switches).
  let ``Thread Wait Reason`` instance =
    { category = "Thread"; counter = "Thread Wait Reason"; instance = instance }
  /// ID Process: ID Process is the unique identifier of this process. ID Process numbers are reused, so they only identify a process for the lifetime of that process.
  let ``ID Process`` instance =
    { category = "Thread"; counter = "ID Process"; instance = instance }
  /// ID Thread: ID Thread is the unique identifier of this thread.  ID Thread numbers are reused, so they only identify a thread for the lifetime of that thread.
  let ``ID Thread`` instance =
    { category = "Thread"; counter = "ID Thread"; instance = instance }

  let allCounters =
    [ ``Context Switches/sec``
      ``% Processor Time``
      ``% User Time``
      ``% Privileged Time``
      ``Elapsed Time``
      ``Priority Current``
      ``Priority Base``
      ``Start Address``
      ``Thread State``
      ``Thread Wait Reason``
      ``ID Process``
      ``ID Thread``
    ]

/// UDPv4: The UDP performance object consists of counters that measure the rates at which UDP datagrams are sent and received by using the UDP protocol.  It includes counters that monitor UDP protocol errors.
///
/// This performance counter does not have instance based counters
module ``UDPv4`` =

  [<Literal>]
  let Category = "UDPv4"

  let PCC = getPCC Category
  /// Datagrams/sec: Datagrams/sec is the rate at which UDP datagrams are sent or received by the entity.
  let ``Datagrams/sec`` =
    { category = "UDPv4"; counter = "Datagrams/sec"; instance = NotApplicable }
  /// Datagrams Received/sec: Datagrams Received/sec is the rate at which UDP datagrams are delivered to UDP users.
  let ``Datagrams Received/sec`` =
    { category = "UDPv4"; counter = "Datagrams Received/sec"; instance = NotApplicable }
  /// Datagrams No Port/sec: Datagrams No Port/sec is the rate of received UDP datagrams for which there was no application at the destination port.
  let ``Datagrams No Port/sec`` =
    { category = "UDPv4"; counter = "Datagrams No Port/sec"; instance = NotApplicable }
  /// Datagrams Received Errors: Datagrams Received Errors is the number of received UDP datagrams that could not be delivered for reasons other than the lack of an application at the destination port.
  let ``Datagrams Received Errors`` =
    { category = "UDPv4"; counter = "Datagrams Received Errors"; instance = NotApplicable }
  /// Datagrams Sent/sec: Datagrams Sent/sec is the rate at which UDP datagrams are sent from the entity.
  let ``Datagrams Sent/sec`` =
    { category = "UDPv4"; counter = "Datagrams Sent/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Datagrams/sec``
      ``Datagrams Received/sec``
      ``Datagrams No Port/sec``
      ``Datagrams Received Errors``
      ``Datagrams Sent/sec``
    ]

/// UDPv6: The UDP performance object consists of counters that measure the rates at which UDP datagrams are sent and received by using the UDP protocol.  It includes counters that monitor UDP protocol errors.
///
/// This performance counter does not have instance based counters
module ``UDPv6`` =

  [<Literal>]
  let Category = "UDPv6"

  let PCC = getPCC Category
  /// Datagrams/sec: Datagrams/sec is the rate at which UDP datagrams are sent or received by the entity.
  let ``Datagrams/sec`` =
    { category = "UDPv6"; counter = "Datagrams/sec"; instance = NotApplicable }
  /// Datagrams Received/sec: Datagrams Received/sec is the rate at which UDP datagrams are delivered to UDP users.
  let ``Datagrams Received/sec`` =
    { category = "UDPv6"; counter = "Datagrams Received/sec"; instance = NotApplicable }
  /// Datagrams No Port/sec: Datagrams No Port/sec is the rate of received UDP datagrams for which there was no application at the destination port.
  let ``Datagrams No Port/sec`` =
    { category = "UDPv6"; counter = "Datagrams No Port/sec"; instance = NotApplicable }
  /// Datagrams Received Errors: Datagrams Received Errors is the number of received UDP datagrams that could not be delivered for reasons other than the lack of an application at the destination port.
  let ``Datagrams Received Errors`` =
    { category = "UDPv6"; counter = "Datagrams Received Errors"; instance = NotApplicable }
  /// Datagrams Sent/sec: Datagrams Sent/sec is the rate at which UDP datagrams are sent from the entity.
  let ``Datagrams Sent/sec`` =
    { category = "UDPv6"; counter = "Datagrams Sent/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Datagrams/sec``
      ``Datagrams Received/sec``
      ``Datagrams No Port/sec``
      ``Datagrams Received Errors``
      ``Datagrams Sent/sec``
    ]

/// USB: USB I/O Counters
///
/// This performance counter does not have non-instance based counters
module ``USB`` =

  [<Literal>]
  let Category = "USB"

  let PCC = getPCC Category
  /// Bulk Bytes/Sec: Displays the current bulk transfer rate in bytes/sec.
  let ``Bulk Bytes/Sec`` instance =
    { category = "USB"; counter = "Bulk Bytes/Sec"; instance = instance }
  /// Isochronous Bytes/Sec: Displays the current isochronous transfer rate in bytes/sec.
  let ``Isochronous Bytes/Sec`` instance =
    { category = "USB"; counter = "Isochronous Bytes/Sec"; instance = instance }
  /// Interrupt Bytes/Sec: Displays the current interrupt transfer rate in bytes/sec.
  let ``Interrupt Bytes/Sec`` instance =
    { category = "USB"; counter = "Interrupt Bytes/Sec"; instance = instance }
  /// Control Data Bytes/Sec: Displays the current control transfer rate in bytes/sec.
  let ``Control Data Bytes/Sec`` instance =
    { category = "USB"; counter = "Control Data Bytes/Sec"; instance = instance }
  /// Controller PCI Interrupts/Sec: Displays the rate of PCI interrupt generation by the USB controller. For controller instances only.
  let ``Controller PCI Interrupts/Sec`` instance =
    { category = "USB"; counter = "Controller PCI Interrupts/Sec"; instance = instance }
  /// Controller WorkSignals/Sec: Displays the current rate Work Signals generated per second by the usbport driver.  For controller instances only.
  let ``Controller WorkSignals/Sec`` instance =
    { category = "USB"; counter = "Controller WorkSignals/Sec"; instance = instance }
  /// % Total Bandwidth Used for Interrupt: Displays the percentage of BW reserved for interrupt transfers
  let ``% Total Bandwidth Used for Interrupt`` instance =
    { category = "USB"; counter = "% Total Bandwidth Used for Interrupt"; instance = instance }
  /// % Total Bandwidth Used for Iso: Displays the percentage of BW reserved for ISO transfers
  let ``% Total Bandwidth Used for Iso`` instance =
    { category = "USB"; counter = "% Total Bandwidth Used for Iso"; instance = instance }
  /// Avg. Bytes/Transfer: Displays the average size of all transfer URBs. For device instances only.
  let ``Avg. Bytes/Transfer`` instance =
    { category = "USB"; counter = "Avg. Bytes/Transfer"; instance = instance }
  /// Iso Packet Errors/Sec: Number of ISO packets that are NOT late, but complete with an error. For device instances only.
  let ``Iso Packet Errors/Sec`` instance =
    { category = "USB"; counter = "Iso Packet Errors/Sec"; instance = instance }
  /// Avg ms latency for ISO transfers: Avg number of ms between the current frame and the start frame of an ISO transfer when scheduled.  For device instances only.
  let ``Avg ms latency for ISO transfers`` instance =
    { category = "USB"; counter = "Avg ms latency for ISO transfers"; instance = instance }
  /// Transfer Errors/Sec: Number of Transfer URBs completing with an error status. For device instances only.
  let ``Transfer Errors/Sec`` instance =
    { category = "USB"; counter = "Transfer Errors/Sec"; instance = instance }
  /// Host Controller Idle: Non-zero value if the host controller is not running(idle).
  let ``Host Controller Idle`` instance =
    { category = "USB"; counter = "Host Controller Idle"; instance = instance }
  /// Host Controller Async Idle: Non-Zero value if the host controller async schedule is not running(idle).
  let ``Host Controller Async Idle`` instance =
    { category = "USB"; counter = "Host Controller Async Idle"; instance = instance }
  /// Host Controller Async Cache Flush Count: Incremented each time the controller async cache is flushed.
  let ``Host Controller Async Cache Flush Count`` instance =
    { category = "USB"; counter = "Host Controller Async Cache Flush Count"; instance = instance }
  /// Host Controller Periodic Idle: Non-Zero if the periodic schedule is not running(idle).
  let ``Host Controller Periodic Idle`` instance =
    { category = "USB"; counter = "Host Controller Periodic Idle"; instance = instance }
  /// Host Controller Periodic Cache Flush Count: Incremented each time the controller periodic cache is flushed.
  let ``Host Controller Periodic Cache Flush Count`` instance =
    { category = "USB"; counter = "Host Controller Periodic Cache Flush Count"; instance = instance }

  let allCounters =
    [ ``Bulk Bytes/Sec``
      ``Isochronous Bytes/Sec``
      ``Interrupt Bytes/Sec``
      ``Control Data Bytes/Sec``
      ``Controller PCI Interrupts/Sec``
      ``Controller WorkSignals/Sec``
      ``% Total Bandwidth Used for Interrupt``
      ``% Total Bandwidth Used for Iso``
      ``Avg. Bytes/Transfer``
      ``Iso Packet Errors/Sec``
      ``Avg ms latency for ISO transfers``
      ``Transfer Errors/Sec``
      ``Host Controller Idle``
      ``Host Controller Async Idle``
      ``Host Controller Async Cache Flush Count``
      ``Host Controller Periodic Idle``
      ``Host Controller Periodic Cache Flush Count``
    ]

/// W3SVC_W3WP: This counter set exposes HTTP request processing related counters for the worker process.
///
/// This performance counter does not have instance based counters
module ``W3SVC_W3WP`` =

  [<Literal>]
  let Category = "W3SVC_W3WP"

  let PCC = getPCC Category
  /// Total HTTP Requests Served: 
  let ``Total HTTP Requests Served`` instance =
    { category = "W3SVC_W3WP"; counter = "Total HTTP Requests Served"; instance = instance }
  /// Requests / Sec: 
  let ``Requests / Sec`` instance =
    { category = "W3SVC_W3WP"; counter = "Requests / Sec"; instance = instance }
  /// Active Requests: 
  let ``Active Requests`` instance =
    { category = "W3SVC_W3WP"; counter = "Active Requests"; instance = instance }
  /// Total Threads: 
  let ``Total Threads`` instance =
    { category = "W3SVC_W3WP"; counter = "Total Threads"; instance = instance }
  /// Active Threads Count: 
  let ``Active Threads Count`` instance =
    { category = "W3SVC_W3WP"; counter = "Active Threads Count"; instance = instance }
  /// Maximum Threads Count: 
  let ``Maximum Threads Count`` instance =
    { category = "W3SVC_W3WP"; counter = "Maximum Threads Count"; instance = instance }
  /// Current File Cache Memory Usage: 
  let ``Current File Cache Memory Usage`` instance =
    { category = "W3SVC_W3WP"; counter = "Current File Cache Memory Usage"; instance = instance }
  /// Maximum File Cache Memory Usage: 
  let ``Maximum File Cache Memory Usage`` instance =
    { category = "W3SVC_W3WP"; counter = "Maximum File Cache Memory Usage"; instance = instance }
  /// Output Cache Current Memory Usage: 
  let ``Output Cache Current Memory Usage`` instance =
    { category = "W3SVC_W3WP"; counter = "Output Cache Current Memory Usage"; instance = instance }
  /// Current Files Cached: 
  let ``Current Files Cached`` instance =
    { category = "W3SVC_W3WP"; counter = "Current Files Cached"; instance = instance }
  /// Total Files Cached: 
  let ``Total Files Cached`` instance =
    { category = "W3SVC_W3WP"; counter = "Total Files Cached"; instance = instance }
  /// File Cache Hits: 
  let ``File Cache Hits`` instance =
    { category = "W3SVC_W3WP"; counter = "File Cache Hits"; instance = instance }
  /// File Cache Misses: 
  let ``File Cache Misses`` instance =
    { category = "W3SVC_W3WP"; counter = "File Cache Misses"; instance = instance }
  /// File Cache Flushes: 
  let ``File Cache Flushes`` instance =
    { category = "W3SVC_W3WP"; counter = "File Cache Flushes"; instance = instance }
  /// Active Flushed Entries: 
  let ``Active Flushed Entries`` instance =
    { category = "W3SVC_W3WP"; counter = "Active Flushed Entries"; instance = instance }
  /// Total Flushed Files: 
  let ``Total Flushed Files`` instance =
    { category = "W3SVC_W3WP"; counter = "Total Flushed Files"; instance = instance }
  /// Current URIs Cached: 
  let ``Current URIs Cached`` instance =
    { category = "W3SVC_W3WP"; counter = "Current URIs Cached"; instance = instance }
  /// Total URIs Cached: 
  let ``Total URIs Cached`` instance =
    { category = "W3SVC_W3WP"; counter = "Total URIs Cached"; instance = instance }
  /// URI Cache Hits: 
  let ``URI Cache Hits`` instance =
    { category = "W3SVC_W3WP"; counter = "URI Cache Hits"; instance = instance }
  /// URI Cache Misses: 
  let ``URI Cache Misses`` instance =
    { category = "W3SVC_W3WP"; counter = "URI Cache Misses"; instance = instance }
  /// URI Cache Flushes: 
  let ``URI Cache Flushes`` instance =
    { category = "W3SVC_W3WP"; counter = "URI Cache Flushes"; instance = instance }
  /// Total Flushed URIs: 
  let ``Total Flushed URIs`` instance =
    { category = "W3SVC_W3WP"; counter = "Total Flushed URIs"; instance = instance }
  /// Current Metadata Cached: 
  let ``Current Metadata Cached`` instance =
    { category = "W3SVC_W3WP"; counter = "Current Metadata Cached"; instance = instance }
  /// Total Metadata Cached: 
  let ``Total Metadata Cached`` instance =
    { category = "W3SVC_W3WP"; counter = "Total Metadata Cached"; instance = instance }
  /// Metadata Cache Hits: 
  let ``Metadata Cache Hits`` instance =
    { category = "W3SVC_W3WP"; counter = "Metadata Cache Hits"; instance = instance }
  /// Metadata Cache Misses: 
  let ``Metadata Cache Misses`` instance =
    { category = "W3SVC_W3WP"; counter = "Metadata Cache Misses"; instance = instance }
  /// Metadata Cache Flushes: 
  let ``Metadata Cache Flushes`` instance =
    { category = "W3SVC_W3WP"; counter = "Metadata Cache Flushes"; instance = instance }
  /// Total Flushed Metadata: 
  let ``Total Flushed Metadata`` instance =
    { category = "W3SVC_W3WP"; counter = "Total Flushed Metadata"; instance = instance }
  /// Output Cache Current Items: 
  let ``Output Cache Current Items`` instance =
    { category = "W3SVC_W3WP"; counter = "Output Cache Current Items"; instance = instance }
  /// Output Cache Total Hits: 
  let ``Output Cache Total Hits`` instance =
    { category = "W3SVC_W3WP"; counter = "Output Cache Total Hits"; instance = instance }
  /// Output Cache Total Misses: 
  let ``Output Cache Total Misses`` instance =
    { category = "W3SVC_W3WP"; counter = "Output Cache Total Misses"; instance = instance }
  /// Output Cache Total Flushes: 
  let ``Output Cache Total Flushes`` instance =
    { category = "W3SVC_W3WP"; counter = "Output Cache Total Flushes"; instance = instance }
  /// Output Cache Current Flushed Items: 
  let ``Output Cache Current Flushed Items`` instance =
    { category = "W3SVC_W3WP"; counter = "Output Cache Current Flushed Items"; instance = instance }
  /// Output Cache Total Flushed Items: 
  let ``Output Cache Total Flushed Items`` instance =
    { category = "W3SVC_W3WP"; counter = "Output Cache Total Flushed Items"; instance = instance }
  /// File Cache Hits / sec: 
  let ``File Cache Hits / sec`` instance =
    { category = "W3SVC_W3WP"; counter = "File Cache Hits / sec"; instance = instance }
  /// Metadata Cache Hits / sec: 
  let ``Metadata Cache Hits / sec`` instance =
    { category = "W3SVC_W3WP"; counter = "Metadata Cache Hits / sec"; instance = instance }
  /// Output Cache Hits / sec: 
  let ``Output Cache Hits / sec`` instance =
    { category = "W3SVC_W3WP"; counter = "Output Cache Hits / sec"; instance = instance }
  /// Uri Cache Hits / sec: 
  let ``Uri Cache Hits / sec`` instance =
    { category = "W3SVC_W3WP"; counter = "Uri Cache Hits / sec"; instance = instance }
  /// File Cache Misses / sec: 
  let ``File Cache Misses / sec`` instance =
    { category = "W3SVC_W3WP"; counter = "File Cache Misses / sec"; instance = instance }
  /// Metadata Cache Misses / sec: 
  let ``Metadata Cache Misses / sec`` instance =
    { category = "W3SVC_W3WP"; counter = "Metadata Cache Misses / sec"; instance = instance }
  /// Output Cache Misses / sec: 
  let ``Output Cache Misses / sec`` instance =
    { category = "W3SVC_W3WP"; counter = "Output Cache Misses / sec"; instance = instance }
  /// Uri Cache Misses / sec: 
  let ``Uri Cache Misses / sec`` instance =
    { category = "W3SVC_W3WP"; counter = "Uri Cache Misses / sec"; instance = instance }
  /// % 401 HTTP Response Sent: 
  let ``% 401 HTTP Response Sent`` instance =
    { category = "W3SVC_W3WP"; counter = "% 401 HTTP Response Sent"; instance = instance }
  /// % 403 HTTP Response Sent: 
  let ``% 403 HTTP Response Sent`` instance =
    { category = "W3SVC_W3WP"; counter = "% 403 HTTP Response Sent"; instance = instance }
  /// % 404 HTTP Response Sent: 
  let ``% 404 HTTP Response Sent`` instance =
    { category = "W3SVC_W3WP"; counter = "% 404 HTTP Response Sent"; instance = instance }
  /// % 500 HTTP Response Sent: 
  let ``% 500 HTTP Response Sent`` instance =
    { category = "W3SVC_W3WP"; counter = "% 500 HTTP Response Sent"; instance = instance }
  /// WebSocket Active Requests: 
  let ``WebSocket Active Requests`` instance =
    { category = "W3SVC_W3WP"; counter = "WebSocket Active Requests"; instance = instance }
  /// WebSocket Connection Attempts / Sec: 
  let ``WebSocket Connection Attempts / Sec`` instance =
    { category = "W3SVC_W3WP"; counter = "WebSocket Connection Attempts / Sec"; instance = instance }
  /// WebSocket Connections Rejected / Sec: 
  let ``WebSocket Connections Rejected / Sec`` instance =
    { category = "W3SVC_W3WP"; counter = "WebSocket Connections Rejected / Sec"; instance = instance }
  /// WebSocket Connections Accepted / Sec: 
  let ``WebSocket Connections Accepted / Sec`` instance =
    { category = "W3SVC_W3WP"; counter = "WebSocket Connections Accepted / Sec"; instance = instance }

  let allCounters =
    [ ``Total HTTP Requests Served``
      ``Requests / Sec``
      ``Active Requests``
      ``Total Threads``
      ``Active Threads Count``
      ``Maximum Threads Count``
      ``Current File Cache Memory Usage``
      ``Maximum File Cache Memory Usage``
      ``Output Cache Current Memory Usage``
      ``Current Files Cached``
      ``Total Files Cached``
      ``File Cache Hits``
      ``File Cache Misses``
      ``File Cache Flushes``
      ``Active Flushed Entries``
      ``Total Flushed Files``
      ``Current URIs Cached``
      ``Total URIs Cached``
      ``URI Cache Hits``
      ``URI Cache Misses``
      ``URI Cache Flushes``
      ``Total Flushed URIs``
      ``Current Metadata Cached``
      ``Total Metadata Cached``
      ``Metadata Cache Hits``
      ``Metadata Cache Misses``
      ``Metadata Cache Flushes``
      ``Total Flushed Metadata``
      ``Output Cache Current Items``
      ``Output Cache Total Hits``
      ``Output Cache Total Misses``
      ``Output Cache Total Flushes``
      ``Output Cache Current Flushed Items``
      ``Output Cache Total Flushed Items``
      ``File Cache Hits / sec``
      ``Metadata Cache Hits / sec``
      ``Output Cache Hits / sec``
      ``Uri Cache Hits / sec``
      ``File Cache Misses / sec``
      ``Metadata Cache Misses / sec``
      ``Output Cache Misses / sec``
      ``Uri Cache Misses / sec``
      ``% 401 HTTP Response Sent``
      ``% 403 HTTP Response Sent``
      ``% 404 HTTP Response Sent``
      ``% 500 HTTP Response Sent``
      ``WebSocket Active Requests``
      ``WebSocket Connection Attempts / Sec``
      ``WebSocket Connections Rejected / Sec``
      ``WebSocket Connections Accepted / Sec``
    ]

/// WAS_W3WP: This counter set exposes Windows Process Activation Service (WAS) related counters for the worker process.
///
/// This performance counter does not have instance based counters
module ``WAS_W3WP`` =

  [<Literal>]
  let Category = "WAS_W3WP"

  let PCC = getPCC Category
  /// Total Requests Served: 
  let ``Total Requests Served`` instance =
    { category = "WAS_W3WP"; counter = "Total Requests Served"; instance = instance }
  /// Total Health Pings.: 
  let ``Total Health Pings.`` instance =
    { category = "WAS_W3WP"; counter = "Total Health Pings."; instance = instance }
  /// Total Runtime Status Queries: 
  let ``Total Runtime Status Queries`` instance =
    { category = "WAS_W3WP"; counter = "Total Runtime Status Queries"; instance = instance }
  /// Active Listener Channels: 
  let ``Active Listener Channels`` instance =
    { category = "WAS_W3WP"; counter = "Active Listener Channels"; instance = instance }
  /// Active Protocol Handlers: 
  let ``Active Protocol Handlers`` instance =
    { category = "WAS_W3WP"; counter = "Active Protocol Handlers"; instance = instance }
  /// Total WAS Messages Received: 
  let ``Total WAS Messages Received`` instance =
    { category = "WAS_W3WP"; counter = "Total WAS Messages Received"; instance = instance }
  /// Total Messages Sent to WAS: 
  let ``Total Messages Sent to WAS`` instance =
    { category = "WAS_W3WP"; counter = "Total Messages Sent to WAS"; instance = instance }
  /// Health Ping Reply Latency: 
  let ``Health Ping Reply Latency`` instance =
    { category = "WAS_W3WP"; counter = "Health Ping Reply Latency"; instance = instance }

  let allCounters =
    [ ``Total Requests Served``
      ``Total Health Pings.``
      ``Total Runtime Status Queries``
      ``Active Listener Channels``
      ``Active Protocol Handlers``
      ``Total WAS Messages Received``
      ``Total Messages Sent to WAS``
      ``Health Ping Reply Latency``
    ]

/// WF (System.Workflow) 4.0.0.0: Windows Workflow Foundation Performance Counters
///
/// This performance counter does not have instance based counters
module ``WF (System_Workflow) 4_0_0_0`` =

  [<Literal>]
  let Category = "WF (System.Workflow) 4.0.0.0"

  let PCC = getPCC Category
  /// Workflows Created: 
  let ``Workflows Created`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Created"; instance = instance }
  /// Workflows Created/sec: 
  let ``Workflows Created/sec`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Created/sec"; instance = instance }
  /// Workflows Unloaded: 
  let ``Workflows Unloaded`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Unloaded"; instance = instance }
  /// Workflows Unloaded/sec: 
  let ``Workflows Unloaded/sec`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Unloaded/sec"; instance = instance }
  /// Workflows Loaded: 
  let ``Workflows Loaded`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Loaded"; instance = instance }
  /// Workflows Loaded/sec: 
  let ``Workflows Loaded/sec`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Loaded/sec"; instance = instance }
  /// Workflows Completed: 
  let ``Workflows Completed`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Completed"; instance = instance }
  /// Workflows Completed/sec: 
  let ``Workflows Completed/sec`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Completed/sec"; instance = instance }
  /// Workflows Suspended: 
  let ``Workflows Suspended`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Suspended"; instance = instance }
  /// Workflows Suspended/sec: 
  let ``Workflows Suspended/sec`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Suspended/sec"; instance = instance }
  /// Workflows Terminated: 
  let ``Workflows Terminated`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Terminated"; instance = instance }
  /// Workflows Terminated/sec: 
  let ``Workflows Terminated/sec`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Terminated/sec"; instance = instance }
  /// Workflows In Memory: 
  let ``Workflows In Memory`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows In Memory"; instance = instance }
  /// Workflows Aborted: 
  let ``Workflows Aborted`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Aborted"; instance = instance }
  /// Workflows Aborted/sec: 
  let ``Workflows Aborted/sec`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Aborted/sec"; instance = instance }
  /// Workflows Persisted: 
  let ``Workflows Persisted`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Persisted"; instance = instance }
  /// Workflows Persisted/sec: 
  let ``Workflows Persisted/sec`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Persisted/sec"; instance = instance }
  /// Workflows Executing: 
  let ``Workflows Executing`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Executing"; instance = instance }
  /// Workflows Idle/sec: 
  let ``Workflows Idle/sec`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Idle/sec"; instance = instance }
  /// Workflows Runnable: 
  let ``Workflows Runnable`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Runnable"; instance = instance }
  /// Workflows Pending: 
  let ``Workflows Pending`` instance =
    { category = "WF (System.Workflow) 4.0.0.0"; counter = "Workflows Pending"; instance = instance }

  let allCounters =
    [ ``Workflows Created``
      ``Workflows Created/sec``
      ``Workflows Unloaded``
      ``Workflows Unloaded/sec``
      ``Workflows Loaded``
      ``Workflows Loaded/sec``
      ``Workflows Completed``
      ``Workflows Completed/sec``
      ``Workflows Suspended``
      ``Workflows Suspended/sec``
      ``Workflows Terminated``
      ``Workflows Terminated/sec``
      ``Workflows In Memory``
      ``Workflows Aborted``
      ``Workflows Aborted/sec``
      ``Workflows Persisted``
      ``Workflows Persisted/sec``
      ``Workflows Executing``
      ``Workflows Idle/sec``
      ``Workflows Runnable``
      ``Workflows Pending``
    ]

/// WFP: WFP is the set of Windows Filtering Platform counters that do not apply to any specific Internet Protocol version.
///
/// This performance counter does not have instance based counters
module ``WFP`` =

  [<Literal>]
  let Category = "WFP"

  let PCC = getPCC Category
  /// Provider Count: Provider Count is the number of providers registered with the Windows Filtering Platform.
  let ``Provider Count`` =
    { category = "WFP"; counter = "Provider Count"; instance = NotApplicable }

  let allCounters =
    [ ``Provider Count``

    ]

/// WFPv4: WFPv4 is the set of Windows Filtering Platform counters that apply to traffic and connections over Internet Protocol version 4.
///
/// This performance counter does not have instance based counters
module ``WFPv4`` =

  [<Literal>]
  let Category = "WFPv4"

  let PCC = getPCC Category
  /// Inbound Packets Discarded/sec: Inbound Packets Discarded per Second is the rate at which inbound packets are discarded by the Windows Filtering Platform.
  let ``Inbound Packets Discarded/sec`` =
    { category = "WFPv4"; counter = "Inbound Packets Discarded/sec"; instance = NotApplicable }
  /// Outbound Packets Discarded/sec: Outbound Packets Discarded per Second is the rate at which outbound packets are discarded by the Windows Filtering Platform.
  let ``Outbound Packets Discarded/sec`` =
    { category = "WFPv4"; counter = "Outbound Packets Discarded/sec"; instance = NotApplicable }
  /// Packets Discarded/sec: Packets Discarded per Second is the rate at which the total of inbound and outbound packets are discarded by the Windows Filtering Platform.
  let ``Packets Discarded/sec`` =
    { category = "WFPv4"; counter = "Packets Discarded/sec"; instance = NotApplicable }
  /// Blocked Binds: Blocked Binds is the number of network resource assignment requests blocked by the Windows Filtering Platform since the computer was last started.
  let ``Blocked Binds`` =
    { category = "WFPv4"; counter = "Blocked Binds"; instance = NotApplicable }
  /// Inbound Connections Blocked/sec: Inbound Connections Blocked per Second is the rate at which inbound connections are being blocked by the Windows Filtering Platform.
  let ``Inbound Connections Blocked/sec`` =
    { category = "WFPv4"; counter = "Inbound Connections Blocked/sec"; instance = NotApplicable }
  /// Outbound Connections Blocked/sec: Outbound Connections Blocked per Second is the rate at which outbound connections are being blocked by the Windows Filtering Platform.
  let ``Outbound Connections Blocked/sec`` =
    { category = "WFPv4"; counter = "Outbound Connections Blocked/sec"; instance = NotApplicable }
  /// Inbound Connections Allowed/sec: Inbound Connections Allowed per Second is the rate at which inbound connections are being allowed by the Windows Filtering Platform.
  let ``Inbound Connections Allowed/sec`` =
    { category = "WFPv4"; counter = "Inbound Connections Allowed/sec"; instance = NotApplicable }
  /// Outbound Connections Allowed/sec: Outbound Connections Allowed per Second is the rate at which outbound connections are being allowed by the Windows Filtering Platform.
  let ``Outbound Connections Allowed/sec`` =
    { category = "WFPv4"; counter = "Outbound Connections Allowed/sec"; instance = NotApplicable }
  /// Inbound Connections: Inbound Connections is the number of inbound connections allowed by the Windows Filtering Platform since the computer was last started.
  let ``Inbound Connections`` =
    { category = "WFPv4"; counter = "Inbound Connections"; instance = NotApplicable }
  /// Outbound Connections: Outbound Connections is the number of outbound connections allowed by the Windows Filtering Platform since the computer was last started.
  let ``Outbound Connections`` =
    { category = "WFPv4"; counter = "Outbound Connections"; instance = NotApplicable }
  /// Active Inbound Connections: Active Inbound Connections is the number of current inbound connections allowed by the Windows Filtering Platform.
  let ``Active Inbound Connections`` =
    { category = "WFPv4"; counter = "Active Inbound Connections"; instance = NotApplicable }
  /// Active Outbound Connections: Active Outbound Connections is the number of current outbound connections allowed by the Windows Filtering Platform.
  let ``Active Outbound Connections`` =
    { category = "WFPv4"; counter = "Active Outbound Connections"; instance = NotApplicable }
  /// Allowed Classifies/sec: Allowed Classifies per Second is the rate of Windows Filtering Platform security rule evaluations which allow network activity.
  let ``Allowed Classifies/sec`` =
    { category = "WFPv4"; counter = "Allowed Classifies/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Inbound Packets Discarded/sec``
      ``Outbound Packets Discarded/sec``
      ``Packets Discarded/sec``
      ``Blocked Binds``
      ``Inbound Connections Blocked/sec``
      ``Outbound Connections Blocked/sec``
      ``Inbound Connections Allowed/sec``
      ``Outbound Connections Allowed/sec``
      ``Inbound Connections``
      ``Outbound Connections``
      ``Active Inbound Connections``
      ``Active Outbound Connections``
      ``Allowed Classifies/sec``
    ]

/// WFPv6: WFPv6 is the set of Windows Filtering Platform counters that apply to traffic and connections over Internet Protocol version 6.
///
/// This performance counter does not have instance based counters
module ``WFPv6`` =

  [<Literal>]
  let Category = "WFPv6"

  let PCC = getPCC Category
  /// Inbound Packets Discarded/sec: Inbound Packets Discarded per Second is the rate at which inbound packets are discarded by the Windows Filtering Platform.
  let ``Inbound Packets Discarded/sec`` =
    { category = "WFPv6"; counter = "Inbound Packets Discarded/sec"; instance = NotApplicable }
  /// Outbound Packets Discarded/sec: Outbound Packets Discarded per Second is the rate at which outbound packets are discarded by the Windows Filtering Platform.
  let ``Outbound Packets Discarded/sec`` =
    { category = "WFPv6"; counter = "Outbound Packets Discarded/sec"; instance = NotApplicable }
  /// Packets Discarded/sec: Packets Discarded per Second is the rate at which the total of inbound and outbound packets are discarded by the Windows Filtering Platform.
  let ``Packets Discarded/sec`` =
    { category = "WFPv6"; counter = "Packets Discarded/sec"; instance = NotApplicable }
  /// Blocked Binds: Blocked Binds is the number of network resource assignment requests blocked by the Windows Filtering Platform since the computer was last started.
  let ``Blocked Binds`` =
    { category = "WFPv6"; counter = "Blocked Binds"; instance = NotApplicable }
  /// Inbound Connections Blocked/sec: Inbound Connections Blocked per Second is the rate at which inbound connections are being blocked by the Windows Filtering Platform.
  let ``Inbound Connections Blocked/sec`` =
    { category = "WFPv6"; counter = "Inbound Connections Blocked/sec"; instance = NotApplicable }
  /// Outbound Connections Blocked/sec: Outbound Connections Blocked per Second is the rate at which outbound connections are being blocked by the Windows Filtering Platform.
  let ``Outbound Connections Blocked/sec`` =
    { category = "WFPv6"; counter = "Outbound Connections Blocked/sec"; instance = NotApplicable }
  /// Inbound Connections Allowed/sec: Inbound Connections Allowed per Second is the rate at which inbound connections are being allowed by the Windows Filtering Platform.
  let ``Inbound Connections Allowed/sec`` =
    { category = "WFPv6"; counter = "Inbound Connections Allowed/sec"; instance = NotApplicable }
  /// Outbound Connections Allowed/sec: Outbound Connections Allowed per Second is the rate at which outbound connections are being allowed by the Windows Filtering Platform.
  let ``Outbound Connections Allowed/sec`` =
    { category = "WFPv6"; counter = "Outbound Connections Allowed/sec"; instance = NotApplicable }
  /// Inbound Connections: Inbound Connections is the number of inbound connections allowed by the Windows Filtering Platform since the computer was last started.
  let ``Inbound Connections`` =
    { category = "WFPv6"; counter = "Inbound Connections"; instance = NotApplicable }
  /// Outbound Connections: Outbound Connections is the number of outbound connections allowed by the Windows Filtering Platform since the computer was last started.
  let ``Outbound Connections`` =
    { category = "WFPv6"; counter = "Outbound Connections"; instance = NotApplicable }
  /// Active Inbound Connections: Active Inbound Connections is the number of current inbound connections allowed by the Windows Filtering Platform.
  let ``Active Inbound Connections`` =
    { category = "WFPv6"; counter = "Active Inbound Connections"; instance = NotApplicable }
  /// Active Outbound Connections: Active Outbound Connections is the number of current outbound connections allowed by the Windows Filtering Platform.
  let ``Active Outbound Connections`` =
    { category = "WFPv6"; counter = "Active Outbound Connections"; instance = NotApplicable }
  /// Allowed Classifies/sec: Allowed Classifies per Second is the rate of Windows Filtering Platform security rule evaluations which allow network activity.
  let ``Allowed Classifies/sec`` =
    { category = "WFPv6"; counter = "Allowed Classifies/sec"; instance = NotApplicable }

  let allCounters =
    [ ``Inbound Packets Discarded/sec``
      ``Outbound Packets Discarded/sec``
      ``Packets Discarded/sec``
      ``Blocked Binds``
      ``Inbound Connections Blocked/sec``
      ``Outbound Connections Blocked/sec``
      ``Inbound Connections Allowed/sec``
      ``Outbound Connections Allowed/sec``
      ``Inbound Connections``
      ``Outbound Connections``
      ``Active Inbound Connections``
      ``Active Outbound Connections``
      ``Allowed Classifies/sec``
    ]

/// WSMan Quota Statistics: Displays quota usage and violation information for WS-Management processes.
///
/// This performance counter does not have instance based counters
module ``WSMan Quota Statistics`` =

  [<Literal>]
  let Category = "WSMan Quota Statistics"

  let PCC = getPCC Category
  /// Total Requests/Second: 
  let ``Total Requests/Second`` instance =
    { category = "WSMan Quota Statistics"; counter = "Total Requests/Second"; instance = instance }
  /// User Quota Violations/Second: 
  let ``User Quota Violations/Second`` instance =
    { category = "WSMan Quota Statistics"; counter = "User Quota Violations/Second"; instance = instance }
  /// System Quota Violations/Second: 
  let ``System Quota Violations/Second`` instance =
    { category = "WSMan Quota Statistics"; counter = "System Quota Violations/Second"; instance = instance }
  /// Active Shells: 
  let ``Active Shells`` instance =
    { category = "WSMan Quota Statistics"; counter = "Active Shells"; instance = instance }
  /// Active Operations: 
  let ``Active Operations`` instance =
    { category = "WSMan Quota Statistics"; counter = "Active Operations"; instance = instance }
  /// Active Users: 
  let ``Active Users`` instance =
    { category = "WSMan Quota Statistics"; counter = "Active Users"; instance = instance }
  /// Process ID: 
  let ``Process ID`` instance =
    { category = "WSMan Quota Statistics"; counter = "Process ID"; instance = instance }

  let allCounters =
    [ ``Total Requests/Second``
      ``User Quota Violations/Second``
      ``System Quota Violations/Second``
      ``Active Shells``
      ``Active Operations``
      ``Active Users``
      ``Process ID``
    ]

/// Web Service: The Web Service object includes counters specific to the World Wide Web Publishing Service.
///
/// This performance counter does not have non-instance based counters
module ``Web Service`` =

  [<Literal>]
  let Category = "Web Service"

  let PCC = getPCC Category
  /// Total Bytes Sent: Total Bytes Sent is the number of data bytes that have been sent by the Web service (since service startup).
  let ``Total Bytes Sent`` instance =
    { category = "Web Service"; counter = "Total Bytes Sent"; instance = instance }
  /// Bytes Sent/sec: Bytes Sent/sec is the rate data bytes are being sent by the Web service.
  let ``Bytes Sent/sec`` instance =
    { category = "Web Service"; counter = "Bytes Sent/sec"; instance = instance }
  /// Total Bytes Received: Total Bytes Received is the number of data bytes that have been received by the Web service (since service startup).
  let ``Total Bytes Received`` instance =
    { category = "Web Service"; counter = "Total Bytes Received"; instance = instance }
  /// Bytes Received/sec: Bytes Received/sec is the rate that data bytes are received by the Web service.
  let ``Bytes Received/sec`` instance =
    { category = "Web Service"; counter = "Bytes Received/sec"; instance = instance }
  /// Total Bytes Transferred: Total bytes either received or sent by the Web service (since service startup).
  let ``Total Bytes Transferred`` instance =
    { category = "Web Service"; counter = "Total Bytes Transferred"; instance = instance }
  /// Bytes Total/sec: Bytes Total/sec is the sum of Bytes Sent/sec and Bytes Received/sec.  This is the total rate of bytes transferred by the Web service.
  let ``Bytes Total/sec`` instance =
    { category = "Web Service"; counter = "Bytes Total/sec"; instance = instance }
  /// Total Files Sent: Total Files Sent is the total number of files sent by the Web service (since service startup).
  let ``Total Files Sent`` instance =
    { category = "Web Service"; counter = "Total Files Sent"; instance = instance }
  /// Files Sent/sec: The rate files are sent by the Web service.
  let ``Files Sent/sec`` instance =
    { category = "Web Service"; counter = "Files Sent/sec"; instance = instance }
  /// Total Files Received: Total Files Received is the total number of files received by the Web service (since service startup).
  let ``Total Files Received`` instance =
    { category = "Web Service"; counter = "Total Files Received"; instance = instance }
  /// Files Received/sec: The rate files are received by the Web service.
  let ``Files Received/sec`` instance =
    { category = "Web Service"; counter = "Files Received/sec"; instance = instance }
  /// Total Files Transferred: Total Files Transferred is the sum of Files Sent and Files Received (since service startup).
  let ``Total Files Transferred`` instance =
    { category = "Web Service"; counter = "Total Files Transferred"; instance = instance }
  /// Files/sec: The rate files are transferred, that is, sent and received by the Web service.
  let ``Files/sec`` instance =
    { category = "Web Service"; counter = "Files/sec"; instance = instance }
  /// Current Anonymous Users: Current Anonymous Users is the number of users who currently have an anonymous connection using the Web service.
  let ``Current Anonymous Users`` instance =
    { category = "Web Service"; counter = "Current Anonymous Users"; instance = instance }
  /// Current NonAnonymous Users: Current NonAnonymous Users is the number of users who currently have a non-anonymous connection using the Web service.
  let ``Current NonAnonymous Users`` instance =
    { category = "Web Service"; counter = "Current NonAnonymous Users"; instance = instance }
  /// Total Anonymous Users: Total Anonymous Users is the total number of users who established an anonymous connection with the Web service (since service startup).
  let ``Total Anonymous Users`` instance =
    { category = "Web Service"; counter = "Total Anonymous Users"; instance = instance }
  /// Anonymous Users/sec: The rate users are making anonymous connections to the Web service.
  let ``Anonymous Users/sec`` instance =
    { category = "Web Service"; counter = "Anonymous Users/sec"; instance = instance }
  /// Total NonAnonymous Users: Total NonAnonymous Users is the total number of users who established a non-anonymous connection with the Web service (since service startup).
  let ``Total NonAnonymous Users`` instance =
    { category = "Web Service"; counter = "Total NonAnonymous Users"; instance = instance }
  /// NonAnonymous Users/sec: The rate users are making non-anonymous connections to the Web service.
  let ``NonAnonymous Users/sec`` instance =
    { category = "Web Service"; counter = "NonAnonymous Users/sec"; instance = instance }
  /// Maximum Anonymous Users: Maximum Anonymous Users is the maximum number of users who established concurrent anonymous connections using the Web service (since service startup).
  let ``Maximum Anonymous Users`` instance =
    { category = "Web Service"; counter = "Maximum Anonymous Users"; instance = instance }
  /// Maximum NonAnonymous Users: Maximum NonAnonymous Users is the maximum number of concurrent non-anonymous connections to the Web service (since service startup).
  let ``Maximum NonAnonymous Users`` instance =
    { category = "Web Service"; counter = "Maximum NonAnonymous Users"; instance = instance }
  /// Current Connections: Current Connections is the current number of connections established with the Web service.
  let ``Current Connections`` instance =
    { category = "Web Service"; counter = "Current Connections"; instance = instance }
  /// Maximum Connections: Maximum Connections is the maximum number of concurrent connections established with the Web service (since service startup).
  let ``Maximum Connections`` instance =
    { category = "Web Service"; counter = "Maximum Connections"; instance = instance }
  /// Total Connection Attempts (all instances): Total Connection Attempts is the number of connections that have been attempted using the Web service (since service startup).  This counter is for all instances listed.
  let ``Total Connection Attempts (all instances)`` instance =
    { category = "Web Service"; counter = "Total Connection Attempts (all instances)"; instance = instance }
  /// Connection Attempts/sec: The rate that connections to the Web service are being attempted.
  let ``Connection Attempts/sec`` instance =
    { category = "Web Service"; counter = "Connection Attempts/sec"; instance = instance }
  /// Total Logon Attempts: Total Logon Attempts is the number of logons attempts to the Web Service (since service startup).
  let ``Total Logon Attempts`` instance =
    { category = "Web Service"; counter = "Total Logon Attempts"; instance = instance }
  /// Logon Attempts/sec: The rate that logons to the Web service are being attempted.
  let ``Logon Attempts/sec`` instance =
    { category = "Web Service"; counter = "Logon Attempts/sec"; instance = instance }
  /// Total Options Requests: Total Options Requests is the number of HTTP requests using the OPTIONS method (since service startup).
  let ``Total Options Requests`` instance =
    { category = "Web Service"; counter = "Total Options Requests"; instance = instance }
  /// Options Requests/sec: The rate HTTP requests using the OPTIONS method are made.
  let ``Options Requests/sec`` instance =
    { category = "Web Service"; counter = "Options Requests/sec"; instance = instance }
  /// Total Get Requests: Total Get Requests is the number of HTTP requests using the GET method (since service startup).  Get requests are the most common HTTP request.
  let ``Total Get Requests`` instance =
    { category = "Web Service"; counter = "Total Get Requests"; instance = instance }
  /// Get Requests/sec: The rate HTTP requests using the GET method are made.  Get requests are the most common HTTP request.
  let ``Get Requests/sec`` instance =
    { category = "Web Service"; counter = "Get Requests/sec"; instance = instance }
  /// Total Post Requests: Total Post Requests is the number of HTTP requests using the POST method (since service startup).
  let ``Total Post Requests`` instance =
    { category = "Web Service"; counter = "Total Post Requests"; instance = instance }
  /// Post Requests/sec: The rate HTTP requests using the POST method are made.
  let ``Post Requests/sec`` instance =
    { category = "Web Service"; counter = "Post Requests/sec"; instance = instance }
  /// Total Head Requests: Total Head Requests is the number of HTTP requests using the HEAD method (since service startup).  Head requests generally indicate a client is querying the state of a document they already have to see if it needs to be refreshed.
  let ``Total Head Requests`` instance =
    { category = "Web Service"; counter = "Total Head Requests"; instance = instance }
  /// Head Requests/sec: The rate HTTP requests using the HEAD method are made.  Head requests generally indicate a client is querying the state of a document they already have to see if it needs to be refreshed.
  let ``Head Requests/sec`` instance =
    { category = "Web Service"; counter = "Head Requests/sec"; instance = instance }
  /// Total Put Requests: Total Put Requests is the number of HTTP requests using the PUT method (since service startup).
  let ``Total Put Requests`` instance =
    { category = "Web Service"; counter = "Total Put Requests"; instance = instance }
  /// Put Requests/sec: The rate HTTP requests using the PUT method are made.
  let ``Put Requests/sec`` instance =
    { category = "Web Service"; counter = "Put Requests/sec"; instance = instance }
  /// Total Delete Requests: Total Delete Requests is the number of HTTP requests using the DELETE method (since service startup).  Delete requests are generally used for file removals.
  let ``Total Delete Requests`` instance =
    { category = "Web Service"; counter = "Total Delete Requests"; instance = instance }
  /// Delete Requests/sec: The rate HTTP requests using the DELETE method are made.  Delete requests are generally used for file removals.
  let ``Delete Requests/sec`` instance =
    { category = "Web Service"; counter = "Delete Requests/sec"; instance = instance }
  /// Total Trace Requests: Total Trace Requests is the number of HTTP requests using the TRACE method (since service startup).  Trace requests allow the client to see what is being received at the end of the request chain and use the information for diagnostic purposes.
  let ``Total Trace Requests`` instance =
    { category = "Web Service"; counter = "Total Trace Requests"; instance = instance }
  /// Trace Requests/sec: The rate HTTP requests using the TRACE method are made.  Trace requests allow the client to see what is being received at the end of the request chain and use the information for diagnostic purposes.
  let ``Trace Requests/sec`` instance =
    { category = "Web Service"; counter = "Trace Requests/sec"; instance = instance }
  /// Total Move Requests: Total Move Requests is the number of HTTP requests using the MOVE method (since service startup).  Move requests are used for moving files and directories.
  let ``Total Move Requests`` instance =
    { category = "Web Service"; counter = "Total Move Requests"; instance = instance }
  /// Move Requests/sec: The rate HTTP requests using the MOVE method are made.  Move requests are used for moving files and directories.
  let ``Move Requests/sec`` instance =
    { category = "Web Service"; counter = "Move Requests/sec"; instance = instance }
  /// Total Copy Requests: Total Copy Requests is the number of HTTP requests using the COPY method (since service startup).  Copy requests are used for copying files and directories.
  let ``Total Copy Requests`` instance =
    { category = "Web Service"; counter = "Total Copy Requests"; instance = instance }
  /// Copy Requests/sec: The rate HTTP requests using the COPY method are made.  Copy requests are used for copying files and directories.
  let ``Copy Requests/sec`` instance =
    { category = "Web Service"; counter = "Copy Requests/sec"; instance = instance }
  /// Total Mkcol Requests: Total Mkcol Requests is the number of HTTP requests using the MKCOL method (since service startup).  Mkcol requests are used to create directories on the server.
  let ``Total Mkcol Requests`` instance =
    { category = "Web Service"; counter = "Total Mkcol Requests"; instance = instance }
  /// Mkcol Requests/sec: The rate HTTP requests using the MKCOL method are made.  Mkcol requests are used to create directories on the server.
  let ``Mkcol Requests/sec`` instance =
    { category = "Web Service"; counter = "Mkcol Requests/sec"; instance = instance }
  /// Total Propfind Requests: Total Propfind Requests is the number of HTTP requests using the PROPFIND method (since service startup).  Propfind requests retrieve property values on files and directories.
  let ``Total Propfind Requests`` instance =
    { category = "Web Service"; counter = "Total Propfind Requests"; instance = instance }
  /// Propfind Requests/sec: The rate HTTP requests using the PROPFIND method are made.  Propfind requests retrieve property values on files and directories.
  let ``Propfind Requests/sec`` instance =
    { category = "Web Service"; counter = "Propfind Requests/sec"; instance = instance }
  /// Total Proppatch Requests: Total Proppatch Requests is the number of HTTP requests using the PROPPATCH method (since service startup).  Proppatch requests set property values on files and directories.
  let ``Total Proppatch Requests`` instance =
    { category = "Web Service"; counter = "Total Proppatch Requests"; instance = instance }
  /// Proppatch Requests/sec: The rate HTTP requests using the PROPPATCH method are made.  Proppatch requests set property values on files and directories.
  let ``Proppatch Requests/sec`` instance =
    { category = "Web Service"; counter = "Proppatch Requests/sec"; instance = instance }
  /// Total Search Requests: Total Search Requests is the number of HTTP requests using the SEARCH method (since service startup).  Search requests are used to query the server to find resources that match a set of conditions provided by the client.
  let ``Total Search Requests`` instance =
    { category = "Web Service"; counter = "Total Search Requests"; instance = instance }
  /// Search Requests/sec: The rate HTTP requests using the SEARCH method are made.  Search requests are used to query the server to find resources that match a set of conditions provided by the client.
  let ``Search Requests/sec`` instance =
    { category = "Web Service"; counter = "Search Requests/sec"; instance = instance }
  /// Total Lock Requests: Total Lock Requests is the number of HTTP requests using the LOCK method (since service startup).  Lock requests are used to lock a file for one user so that only that user can modify the file.
  let ``Total Lock Requests`` instance =
    { category = "Web Service"; counter = "Total Lock Requests"; instance = instance }
  /// Lock Requests/sec: The rate HTTP requests using the LOCK method are made.  Lock requests are used to lock a file for one user so that only that user can modify the file.
  let ``Lock Requests/sec`` instance =
    { category = "Web Service"; counter = "Lock Requests/sec"; instance = instance }
  /// Total Unlock Requests: Total Unlock Requests is the number of HTTP requests using the UNLOCK method (since service startup).  Unlock requests are used to remove locks from files.
  let ``Total Unlock Requests`` instance =
    { category = "Web Service"; counter = "Total Unlock Requests"; instance = instance }
  /// Unlock Requests/sec: The rate HTTP requests using the UNLOCK method are made.  Unlock requests are used to remove locks from files.
  let ``Unlock Requests/sec`` instance =
    { category = "Web Service"; counter = "Unlock Requests/sec"; instance = instance }
  /// Total Other Request Methods: Total Other Request Methods is the number of HTTP requests that are not OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, MOVE, COPY, MKCOL, PROPFIND, PROPPATCH, SEARCH, LOCK or UNLOCK methods (since service startup).
  let ``Total Other Request Methods`` instance =
    { category = "Web Service"; counter = "Total Other Request Methods"; instance = instance }
  /// Other Request Methods/sec: The rate HTTP requests are made that do not use the OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, MOVE, COPY, MKCOL, PROPFIND, PROPPATCH, SEARCH, LOCK or UNLOCK methods.
  let ``Other Request Methods/sec`` instance =
    { category = "Web Service"; counter = "Other Request Methods/sec"; instance = instance }
  /// Total Method Requests: Total Method Requests is the number of all HTTP requests (since service startup).
  let ``Total Method Requests`` instance =
    { category = "Web Service"; counter = "Total Method Requests"; instance = instance }
  /// Total Method Requests/sec: The rate HTTP requests are received.
  let ``Total Method Requests/sec`` instance =
    { category = "Web Service"; counter = "Total Method Requests/sec"; instance = instance }
  /// Total CGI Requests: Total CGI requests is the total number of CGI requests (since service startup).
  let ``Total CGI Requests`` instance =
    { category = "Web Service"; counter = "Total CGI Requests"; instance = instance }
  /// CGI Requests/sec: The rate CGI requests are received by the Web service.
  let ``CGI Requests/sec`` instance =
    { category = "Web Service"; counter = "CGI Requests/sec"; instance = instance }
  /// Total ISAPI Extension Requests: Total ISAPI Extension Requests received (since service startup).
  let ``Total ISAPI Extension Requests`` instance =
    { category = "Web Service"; counter = "Total ISAPI Extension Requests"; instance = instance }
  /// ISAPI Extension Requests/sec: The rate that ISAPI Extension requests are received by the Web service.
  let ``ISAPI Extension Requests/sec`` instance =
    { category = "Web Service"; counter = "ISAPI Extension Requests/sec"; instance = instance }
  /// Total Not Found Errors: Total Not Found Errors is the number of requests that couldn't be satisfied by the server because the requested document could not be found (since service startup).  These are generally reported as an HTTP 404 error code to the client.
  let ``Total Not Found Errors`` instance =
    { category = "Web Service"; counter = "Total Not Found Errors"; instance = instance }
  /// Not Found Errors/sec: The rate of errors due to requests that couldn't be satisfied by the server because the requested document could not be found.  These are generally reported as an HTTP 404 error code to the client.
  let ``Not Found Errors/sec`` instance =
    { category = "Web Service"; counter = "Not Found Errors/sec"; instance = instance }
  /// Total Locked Errors: Total Locked Errors is the number of requests that couldn't be satisfied by the server because the requested was locked (since service startup).  These are generally reported as an HTTP 423 error code to the client.
  let ``Total Locked Errors`` instance =
    { category = "Web Service"; counter = "Total Locked Errors"; instance = instance }
  /// Locked Errors/sec: The rate of errors due to requests that couldn't be satisfied by the server because the requested document was locked.  These are generally reported as an HTTP 423 error code to the client.
  let ``Locked Errors/sec`` instance =
    { category = "Web Service"; counter = "Locked Errors/sec"; instance = instance }
  /// Current CGI Requests: Current CGI Requests is the current number of CGI requests being simultaneously processed by the Web service.
  let ``Current CGI Requests`` instance =
    { category = "Web Service"; counter = "Current CGI Requests"; instance = instance }
  /// Current ISAPI Extension Requests: Current ISAPI Extension Requests is the current number of ISAPI requests being simultaneously processed by the Web service.
  let ``Current ISAPI Extension Requests`` instance =
    { category = "Web Service"; counter = "Current ISAPI Extension Requests"; instance = instance }
  /// Maximum CGI Requests: Maximum CGI Requests is the maximum number of CGI requests simultaneously processed by the Web service (since service startup).
  let ``Maximum CGI Requests`` instance =
    { category = "Web Service"; counter = "Maximum CGI Requests"; instance = instance }
  /// Maximum ISAPI Extension Requests: Maximum ISAPI Extension Requests is the maximum number of ISAPI requests simultaneously processed by the Web service (since service startup).
  let ``Maximum ISAPI Extension Requests`` instance =
    { category = "Web Service"; counter = "Maximum ISAPI Extension Requests"; instance = instance }
  /// Current CAL count for authenticated users: This counter is no longer valid. Value will always be zero.
  let ``Current CAL count for authenticated users`` instance =
    { category = "Web Service"; counter = "Current CAL count for authenticated users"; instance = instance }
  /// Maximum CAL count for authenticated users: This counter is no longer valid. Value will always be zero.
  let ``Maximum CAL count for authenticated users`` instance =
    { category = "Web Service"; counter = "Maximum CAL count for authenticated users"; instance = instance }
  /// Total count of failed CAL requests for authenticated users: This counter is no longer valid. Value will always be zero.
  let ``Total count of failed CAL requests for authenticated users`` instance =
    { category = "Web Service"; counter = "Total count of failed CAL requests for authenticated users"; instance = instance }
  /// Current CAL count for SSL connections: This counter is no longer valid. Value will always be zero.
  let ``Current CAL count for SSL connections`` instance =
    { category = "Web Service"; counter = "Current CAL count for SSL connections"; instance = instance }
  /// Maximum CAL count for SSL connections: This counter is no longer valid. Value will always be zero.
  let ``Maximum CAL count for SSL connections`` instance =
    { category = "Web Service"; counter = "Maximum CAL count for SSL connections"; instance = instance }
  /// Total count of failed CAL requests for SSL connections: This counter is no longer valid. Value will always be zero.
  let ``Total count of failed CAL requests for SSL connections`` instance =
    { category = "Web Service"; counter = "Total count of failed CAL requests for SSL connections"; instance = instance }
  /// Total Blocked Async I/O Requests: Total requests temporarily blocked due to bandwidth throttling settings (since service startup).
  let ``Total Blocked Async I/O Requests`` instance =
    { category = "Web Service"; counter = "Total Blocked Async I/O Requests"; instance = instance }
  /// Total Allowed Async I/O Requests: Total requests allowed by bandwidth throttling settings (since service startup).
  let ``Total Allowed Async I/O Requests`` instance =
    { category = "Web Service"; counter = "Total Allowed Async I/O Requests"; instance = instance }
  /// Total Rejected Async I/O Requests: Total requests rejected due to bandwidth throttling settings (since service startup).
  let ``Total Rejected Async I/O Requests`` instance =
    { category = "Web Service"; counter = "Total Rejected Async I/O Requests"; instance = instance }
  /// Current Blocked Async I/O Requests: Current requests temporarily blocked due to bandwidth throttling settings.
  let ``Current Blocked Async I/O Requests`` instance =
    { category = "Web Service"; counter = "Current Blocked Async I/O Requests"; instance = instance }
  /// Measured Async I/O Bandwidth Usage: Measured bandwidth of asynchronous I/O averaged over a minute.
  let ``Measured Async I/O Bandwidth Usage`` instance =
    { category = "Web Service"; counter = "Measured Async I/O Bandwidth Usage"; instance = instance }
  /// Total blocked bandwidth bytes.: Total bytes blocked due to bandwidth throttling settings (since service startup).
  let ``Total blocked bandwidth bytes.`` instance =
    { category = "Web Service"; counter = "Total blocked bandwidth bytes."; instance = instance }
  /// Current blocked bandwidth bytes.: Current bytes temporarily blocked due to bandwidth throttling settings.
  let ``Current blocked bandwidth bytes.`` instance =
    { category = "Web Service"; counter = "Current blocked bandwidth bytes."; instance = instance }
  /// Service Uptime: The length of time the Web Service has been running.
  let ``Service Uptime`` instance =
    { category = "Web Service"; counter = "Service Uptime"; instance = instance }

  let allCounters =
    [ ``Total Bytes Sent``
      ``Bytes Sent/sec``
      ``Total Bytes Received``
      ``Bytes Received/sec``
      ``Total Bytes Transferred``
      ``Bytes Total/sec``
      ``Total Files Sent``
      ``Files Sent/sec``
      ``Total Files Received``
      ``Files Received/sec``
      ``Total Files Transferred``
      ``Files/sec``
      ``Current Anonymous Users``
      ``Current NonAnonymous Users``
      ``Total Anonymous Users``
      ``Anonymous Users/sec``
      ``Total NonAnonymous Users``
      ``NonAnonymous Users/sec``
      ``Maximum Anonymous Users``
      ``Maximum NonAnonymous Users``
      ``Current Connections``
      ``Maximum Connections``
      ``Total Connection Attempts (all instances)``
      ``Connection Attempts/sec``
      ``Total Logon Attempts``
      ``Logon Attempts/sec``
      ``Total Options Requests``
      ``Options Requests/sec``
      ``Total Get Requests``
      ``Get Requests/sec``
      ``Total Post Requests``
      ``Post Requests/sec``
      ``Total Head Requests``
      ``Head Requests/sec``
      ``Total Put Requests``
      ``Put Requests/sec``
      ``Total Delete Requests``
      ``Delete Requests/sec``
      ``Total Trace Requests``
      ``Trace Requests/sec``
      ``Total Move Requests``
      ``Move Requests/sec``
      ``Total Copy Requests``
      ``Copy Requests/sec``
      ``Total Mkcol Requests``
      ``Mkcol Requests/sec``
      ``Total Propfind Requests``
      ``Propfind Requests/sec``
      ``Total Proppatch Requests``
      ``Proppatch Requests/sec``
      ``Total Search Requests``
      ``Search Requests/sec``
      ``Total Lock Requests``
      ``Lock Requests/sec``
      ``Total Unlock Requests``
      ``Unlock Requests/sec``
      ``Total Other Request Methods``
      ``Other Request Methods/sec``
      ``Total Method Requests``
      ``Total Method Requests/sec``
      ``Total CGI Requests``
      ``CGI Requests/sec``
      ``Total ISAPI Extension Requests``
      ``ISAPI Extension Requests/sec``
      ``Total Not Found Errors``
      ``Not Found Errors/sec``
      ``Total Locked Errors``
      ``Locked Errors/sec``
      ``Current CGI Requests``
      ``Current ISAPI Extension Requests``
      ``Maximum CGI Requests``
      ``Maximum ISAPI Extension Requests``
      ``Current CAL count for authenticated users``
      ``Maximum CAL count for authenticated users``
      ``Total count of failed CAL requests for authenticated users``
      ``Current CAL count for SSL connections``
      ``Maximum CAL count for SSL connections``
      ``Total count of failed CAL requests for SSL connections``
      ``Total Blocked Async I/O Requests``
      ``Total Allowed Async I/O Requests``
      ``Total Rejected Async I/O Requests``
      ``Current Blocked Async I/O Requests``
      ``Measured Async I/O Bandwidth Usage``
      ``Total blocked bandwidth bytes.``
      ``Current blocked bandwidth bytes.``
      ``Service Uptime``
    ]

/// Web Service Cache: The Web Service Cache Counters object includes cache counters specific to the World Wide Web Publishing Service.
///
/// This performance counter does not have instance based counters
module ``Web Service Cache`` =

  [<Literal>]
  let Category = "Web Service Cache"

  let PCC = getPCC Category
  /// Current Files Cached: Current number of files whose content is in the user-mode cache.
  let ``Current Files Cached`` =
    { category = "Web Service Cache"; counter = "Current Files Cached"; instance = NotApplicable }
  /// Total Files Cached: Total number of files whose content was ever added to the user-mode cache (since service startup).
  let ``Total Files Cached`` =
    { category = "Web Service Cache"; counter = "Total Files Cached"; instance = NotApplicable }
  /// File Cache Hits: Total number of successful lookups in the user-mode file cache (since service startup).
  let ``File Cache Hits`` =
    { category = "Web Service Cache"; counter = "File Cache Hits"; instance = NotApplicable }
  /// File Cache Misses: Total number of unsuccessful lookups in the user-mode file cache (since service startup).
  let ``File Cache Misses`` =
    { category = "Web Service Cache"; counter = "File Cache Misses"; instance = NotApplicable }
  /// File Cache Hits %: The ratio of user-mode file cache hits to total cache requests (since service startup).
  let ``File Cache Hits %`` =
    { category = "Web Service Cache"; counter = "File Cache Hits %"; instance = NotApplicable }
  /// File Cache Flushes: The number of files removed from the user-mode cache (since service startup).
  let ``File Cache Flushes`` =
    { category = "Web Service Cache"; counter = "File Cache Flushes"; instance = NotApplicable }
  /// Current File Cache Memory Usage: Current number of bytes used for the user-mode file cache.
  let ``Current File Cache Memory Usage`` =
    { category = "Web Service Cache"; counter = "Current File Cache Memory Usage"; instance = NotApplicable }
  /// Maximum File Cache Memory Usage: Maximum number of bytes used for user-mode file cache (since service startup).
  let ``Maximum File Cache Memory Usage`` =
    { category = "Web Service Cache"; counter = "Maximum File Cache Memory Usage"; instance = NotApplicable }
  /// Active Flushed Entries: Active Flushed Entries are file handles cached in user-mode that will be closed when all current transfers complete.
  let ``Active Flushed Entries`` =
    { category = "Web Service Cache"; counter = "Active Flushed Entries"; instance = NotApplicable }
  /// Total Flushed Files: Total Flushed Files is the number of file handles that have been removed from the user-mode cache (since service startup).
  let ``Total Flushed Files`` =
    { category = "Web Service Cache"; counter = "Total Flushed Files"; instance = NotApplicable }
  /// Current URIs Cached: URI information blocks currently in the user-mode cache.
  let ``Current URIs Cached`` =
    { category = "Web Service Cache"; counter = "Current URIs Cached"; instance = NotApplicable }
  /// Total URIs Cached: Total number of URI information blocks added to the user-mode cache (since service startup).
  let ``Total URIs Cached`` =
    { category = "Web Service Cache"; counter = "Total URIs Cached"; instance = NotApplicable }
  /// URI Cache Hits: Total number of successful lookups in the user-mode URI cache (since service startup).
  let ``URI Cache Hits`` =
    { category = "Web Service Cache"; counter = "URI Cache Hits"; instance = NotApplicable }
  /// URI Cache Misses: Total number of unsuccessful lookups in the user-mode URI cache (since service startup).
  let ``URI Cache Misses`` =
    { category = "Web Service Cache"; counter = "URI Cache Misses"; instance = NotApplicable }
  /// URI Cache Hits %: The ratio of user-mode URI Cache Hits to total cache requests (since service startup).
  let ``URI Cache Hits %`` =
    { category = "Web Service Cache"; counter = "URI Cache Hits %"; instance = NotApplicable }
  /// URI Cache Flushes: User-mode URI Cache flushes (since service startup).
  let ``URI Cache Flushes`` =
    { category = "Web Service Cache"; counter = "URI Cache Flushes"; instance = NotApplicable }
  /// Total Flushed URIs: The number of URI information blocks that have been removed from the user-mode cache (since service startup).
  let ``Total Flushed URIs`` =
    { category = "Web Service Cache"; counter = "Total Flushed URIs"; instance = NotApplicable }
  /// Current Metadata Cached: Current number of metadata information blocks currently in the user-mode cache.
  let ``Current Metadata Cached`` =
    { category = "Web Service Cache"; counter = "Current Metadata Cached"; instance = NotApplicable }
  /// Total Metadata Cached: Total number of metadata information blocks added to the user-mode cache (since service startup).
  let ``Total Metadata Cached`` =
    { category = "Web Service Cache"; counter = "Total Metadata Cached"; instance = NotApplicable }
  /// Metadata Cache Hits: Total number of successful lookups in the user-mode metadata cache (since service startup).
  let ``Metadata Cache Hits`` =
    { category = "Web Service Cache"; counter = "Metadata Cache Hits"; instance = NotApplicable }
  /// Metadata Cache Misses: Total number of unsuccessful lookups in the user-mode metadata cache (since service startup).
  let ``Metadata Cache Misses`` =
    { category = "Web Service Cache"; counter = "Metadata Cache Misses"; instance = NotApplicable }
  /// Metadata Cache Hits %: The ratio of user-mode metadata cache hits to total cache requests (since service startup).
  let ``Metadata Cache Hits %`` =
    { category = "Web Service Cache"; counter = "Metadata Cache Hits %"; instance = NotApplicable }
  /// Metadata Cache Flushes: The number of user-mode metadata cache flushes (since service startup).
  let ``Metadata Cache Flushes`` =
    { category = "Web Service Cache"; counter = "Metadata Cache Flushes"; instance = NotApplicable }
  /// Total Flushed Metadata: Total Flushed Metadata is the number of Metadata information blocks that have been removed from the user-mode cache (since service startup).
  let ``Total Flushed Metadata`` =
    { category = "Web Service Cache"; counter = "Total Flushed Metadata"; instance = NotApplicable }
  /// Kernel: Current URIs Cached: URI information blocks currently cached by the kernel.
  let ``Kernel: Current URIs Cached`` =
    { category = "Web Service Cache"; counter = "Kernel: Current URIs Cached"; instance = NotApplicable }
  /// Kernel: Total URIs Cached: Total number of URI information blocks added to the kernel cache (since service startup).
  let ``Kernel: Total URIs Cached`` =
    { category = "Web Service Cache"; counter = "Kernel: Total URIs Cached"; instance = NotApplicable }
  /// Kernel: URI Cache Hits: Total number of successful lookups in the kernel URI cache (since service startup).
  let ``Kernel: URI Cache Hits`` =
    { category = "Web Service Cache"; counter = "Kernel: URI Cache Hits"; instance = NotApplicable }
  /// Kernel: Uri Cache Hits/sec: The rate of kernel URI Cache hits.
  let ``Kernel: Uri Cache Hits/sec`` =
    { category = "Web Service Cache"; counter = "Kernel: Uri Cache Hits/sec"; instance = NotApplicable }
  /// Kernel: URI Cache Misses: Total number of unsuccessful lookups in the kernel URI cache (since service startup).
  let ``Kernel: URI Cache Misses`` =
    { category = "Web Service Cache"; counter = "Kernel: URI Cache Misses"; instance = NotApplicable }
  /// Kernel: URI Cache Hits %: The ratio of kernel URI cache hits to total cache requests (since service startup).
  let ``Kernel: URI Cache Hits %`` =
    { category = "Web Service Cache"; counter = "Kernel: URI Cache Hits %"; instance = NotApplicable }
  /// Kernel: URI Cache Flushes: Kernel URI Cache Flushes (since server startup).
  let ``Kernel: URI Cache Flushes`` =
    { category = "Web Service Cache"; counter = "Kernel: URI Cache Flushes"; instance = NotApplicable }
  /// Kernel: Total Flushed URIs: The number of URI information blocks that have been removed from the kernel cache (since service startup).
  let ``Kernel: Total Flushed URIs`` =
    { category = "Web Service Cache"; counter = "Kernel: Total Flushed URIs"; instance = NotApplicable }
  /// Output Cache Current Memory Usage: Current memory usage by output cache.
  let ``Output Cache Current Memory Usage`` =
    { category = "Web Service Cache"; counter = "Output Cache Current Memory Usage"; instance = NotApplicable }
  /// Output Cache Current Items: Number of items currently in output cache.
  let ``Output Cache Current Items`` =
    { category = "Web Service Cache"; counter = "Output Cache Current Items"; instance = NotApplicable }
  /// Output Cache Total Hits: Total number of hits in output cache.
  let ``Output Cache Total Hits`` =
    { category = "Web Service Cache"; counter = "Output Cache Total Hits"; instance = NotApplicable }
  /// Output Cache Total Misses: Total number of misses in output cache.
  let ``Output Cache Total Misses`` =
    { category = "Web Service Cache"; counter = "Output Cache Total Misses"; instance = NotApplicable }
  /// Output Cache Total Flushes: Total number of flushes in output cache.
  let ``Output Cache Total Flushes`` =
    { category = "Web Service Cache"; counter = "Output Cache Total Flushes"; instance = NotApplicable }
  /// Output Cache Current Flushed Items: Number of items that have been flushed, but are still being used by outgoing responses so are still taking up memory.
  let ``Output Cache Current Flushed Items`` =
    { category = "Web Service Cache"; counter = "Output Cache Current Flushed Items"; instance = NotApplicable }
  /// Output Cache Total Flushed Items: Total number of items flushed by cache.
  let ``Output Cache Total Flushed Items`` =
    { category = "Web Service Cache"; counter = "Output Cache Total Flushed Items"; instance = NotApplicable }
  /// Output Cache Current Hits %: Output Cache current hit ratio. Calculated as (H)/(H+M) where H and M represent Hits and Misses in previous sample interval respectively.
  let ``Output Cache Current Hits %`` =
    { category = "Web Service Cache"; counter = "Output Cache Current Hits %"; instance = NotApplicable }
  /// W3SVC_W3WP: This counter set exposes HTTP request processing related counters for the worker process.
  let ``W3SVC_W3WP`` =
    { category = "Web Service Cache"; counter = "W3SVC_W3WP"; instance = NotApplicable }

  let allCounters =
    [ ``Current Files Cached``
      ``Total Files Cached``
      ``File Cache Hits``
      ``File Cache Misses``
      ``File Cache Hits %``
      ``File Cache Flushes``
      ``Current File Cache Memory Usage``
      ``Maximum File Cache Memory Usage``
      ``Active Flushed Entries``
      ``Total Flushed Files``
      ``Current URIs Cached``
      ``Total URIs Cached``
      ``URI Cache Hits``
      ``URI Cache Misses``
      ``URI Cache Hits %``
      ``URI Cache Flushes``
      ``Total Flushed URIs``
      ``Current Metadata Cached``
      ``Total Metadata Cached``
      ``Metadata Cache Hits``
      ``Metadata Cache Misses``
      ``Metadata Cache Hits %``
      ``Metadata Cache Flushes``
      ``Total Flushed Metadata``
      ``Kernel: Current URIs Cached``
      ``Kernel: Total URIs Cached``
      ``Kernel: URI Cache Hits``
      ``Kernel: Uri Cache Hits/sec``
      ``Kernel: URI Cache Misses``
      ``Kernel: URI Cache Hits %``
      ``Kernel: URI Cache Flushes``
      ``Kernel: Total Flushed URIs``
      ``Output Cache Current Memory Usage``
      ``Output Cache Current Items``
      ``Output Cache Total Hits``
      ``Output Cache Total Misses``
      ``Output Cache Total Flushes``
      ``Output Cache Current Flushed Items``
      ``Output Cache Total Flushed Items``
      ``Output Cache Current Hits %``
      ``W3SVC_W3WP``
    ]

/// Windows Media Player Metadata: Windows Media Player Metadata
///
/// This performance counter does not have instance based counters
module ``Windows Media Player Metadata`` =

  [<Literal>]
  let Category = "Windows Media Player Metadata"

  let PCC = getPCC Category
  /// Files Scanned/Minute: 
  let ``Files Scanned/Minute`` instance =
    { category = "Windows Media Player Metadata"; counter = "Files Scanned/Minute"; instance = instance }
  /// Monitored Folder Updates/Second: 
  let ``Monitored Folder Updates/Second`` instance =
    { category = "Windows Media Player Metadata"; counter = "Monitored Folder Updates/Second"; instance = instance }
  /// Groveler Service Routine Executions/Second: 
  let ``Groveler Service Routine Executions/Second`` instance =
    { category = "Windows Media Player Metadata"; counter = "Groveler Service Routine Executions/Second"; instance = instance }
  /// Library Description Updates/Second: 
  let ``Library Description Updates/Second`` instance =
    { category = "Windows Media Player Metadata"; counter = "Library Description Updates/Second"; instance = instance }
  /// Library Description Change Notifications/Second: 
  let ``Library Description Change Notifications/Second`` instance =
    { category = "Windows Media Player Metadata"; counter = "Library Description Change Notifications/Second"; instance = instance }
  /// File Scanning Thread Prioirty: 
  let ``File Scanning Thread Prioirty`` instance =
    { category = "Windows Media Player Metadata"; counter = "File Scanning Thread Prioirty"; instance = instance }
  /// Directory Change Queue Length: 
  let ``Directory Change Queue Length`` instance =
    { category = "Windows Media Player Metadata"; counter = "Directory Change Queue Length"; instance = instance }
  /// Scanning State: 
  let ``Scanning State`` instance =
    { category = "Windows Media Player Metadata"; counter = "Scanning State"; instance = instance }
  /// Dirty Directory Hit Count: 
  let ``Dirty Directory Hit Count`` instance =
    { category = "Windows Media Player Metadata"; counter = "Dirty Directory Hit Count"; instance = instance }
  /// Timestamp Directory Hit Count: 
  let ``Timestamp Directory Hit Count`` instance =
    { category = "Windows Media Player Metadata"; counter = "Timestamp Directory Hit Count"; instance = instance }
  /// AFTS Execution Time (ms): 
  let ``AFTS Execution Time (ms)`` instance =
    { category = "Windows Media Player Metadata"; counter = "AFTS Execution Time (ms)"; instance = instance }
  /// URL Classification Time (ms): 
  let ``URL Classification Time (ms)`` instance =
    { category = "Windows Media Player Metadata"; counter = "URL Classification Time (ms)"; instance = instance }
  /// Property Extraction Time (ms): 
  let ``Property Extraction Time (ms)`` instance =
    { category = "Windows Media Player Metadata"; counter = "Property Extraction Time (ms)"; instance = instance }
  /// Art Extraction Time (ms): 
  let ``Art Extraction Time (ms)`` instance =
    { category = "Windows Media Player Metadata"; counter = "Art Extraction Time (ms)"; instance = instance }
  /// Reorganize Time (ms): 
  let ``Reorganize Time (ms)`` instance =
    { category = "Windows Media Player Metadata"; counter = "Reorganize Time (ms)"; instance = instance }
  /// Commit Time (ms): 
  let ``Commit Time (ms)`` instance =
    { category = "Windows Media Player Metadata"; counter = "Commit Time (ms)"; instance = instance }
  /// Normalization Time (ms): 
  let ``Normalization Time (ms)`` instance =
    { category = "Windows Media Player Metadata"; counter = "Normalization Time (ms)"; instance = instance }

  let allCounters =
    [ ``Files Scanned/Minute``
      ``Monitored Folder Updates/Second``
      ``Groveler Service Routine Executions/Second``
      ``Library Description Updates/Second``
      ``Library Description Change Notifications/Second``
      ``File Scanning Thread Prioirty``
      ``Directory Change Queue Length``
      ``Scanning State``
      ``Dirty Directory Hit Count``
      ``Timestamp Directory Hit Count``
      ``AFTS Execution Time (ms)``
      ``URL Classification Time (ms)``
      ``Property Extraction Time (ms)``
      ``Art Extraction Time (ms)``
      ``Reorganize Time (ms)``
      ``Commit Time (ms)``
      ``Normalization Time (ms)``
    ]

/// Windows Workflow Foundation: Windows Workflow Foundation Performance Counters
///
/// This performance counter does not have instance based counters
module ``Windows Workflow Foundation`` =

  [<Literal>]
  let Category = "Windows Workflow Foundation"

  let PCC = getPCC Category
  /// Workflows Created: 
  let ``Workflows Created`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Created"; instance = instance }
  /// Workflows Created/sec: 
  let ``Workflows Created/sec`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Created/sec"; instance = instance }
  /// Workflows Unloaded: 
  let ``Workflows Unloaded`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Unloaded"; instance = instance }
  /// Workflows Unloaded/sec: 
  let ``Workflows Unloaded/sec`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Unloaded/sec"; instance = instance }
  /// Workflows Loaded: 
  let ``Workflows Loaded`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Loaded"; instance = instance }
  /// Workflows Loaded/sec: 
  let ``Workflows Loaded/sec`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Loaded/sec"; instance = instance }
  /// Workflows Completed: 
  let ``Workflows Completed`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Completed"; instance = instance }
  /// Workflows Completed/sec: 
  let ``Workflows Completed/sec`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Completed/sec"; instance = instance }
  /// Workflows Suspended: 
  let ``Workflows Suspended`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Suspended"; instance = instance }
  /// Workflows Suspended/sec: 
  let ``Workflows Suspended/sec`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Suspended/sec"; instance = instance }
  /// Workflows Terminated: 
  let ``Workflows Terminated`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Terminated"; instance = instance }
  /// Workflows Terminated/sec: 
  let ``Workflows Terminated/sec`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Terminated/sec"; instance = instance }
  /// Workflows In Memory: 
  let ``Workflows In Memory`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows In Memory"; instance = instance }
  /// Workflows Aborted: 
  let ``Workflows Aborted`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Aborted"; instance = instance }
  /// Workflows Aborted/sec: 
  let ``Workflows Aborted/sec`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Aborted/sec"; instance = instance }
  /// Workflows Persisted: 
  let ``Workflows Persisted`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Persisted"; instance = instance }
  /// Workflows Persisted/sec: 
  let ``Workflows Persisted/sec`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Persisted/sec"; instance = instance }
  /// Workflows Executing: 
  let ``Workflows Executing`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Executing"; instance = instance }
  /// Workflows Idle/sec: 
  let ``Workflows Idle/sec`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Idle/sec"; instance = instance }
  /// Workflows Runnable: 
  let ``Workflows Runnable`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Runnable"; instance = instance }
  /// Workflows Pending: 
  let ``Workflows Pending`` instance =
    { category = "Windows Workflow Foundation"; counter = "Workflows Pending"; instance = instance }

  let allCounters =
    [ ``Workflows Created``
      ``Workflows Created/sec``
      ``Workflows Unloaded``
      ``Workflows Unloaded/sec``
      ``Workflows Loaded``
      ``Workflows Loaded/sec``
      ``Workflows Completed``
      ``Workflows Completed/sec``
      ``Workflows Suspended``
      ``Workflows Suspended/sec``
      ``Workflows Terminated``
      ``Workflows Terminated/sec``
      ``Workflows In Memory``
      ``Workflows Aborted``
      ``Workflows Aborted/sec``
      ``Workflows Persisted``
      ``Workflows Persisted/sec``
      ``Workflows Executing``
      ``Workflows Idle/sec``
      ``Workflows Runnable``
      ``Workflows Pending``
    ]

/// WorkflowServiceHost 4.0.0.0: WorkflowServiceHost performance counters for workflow service
///
/// This performance counter does not have instance based counters
module ``WorkflowServiceHost 4_0_0_0`` =

  [<Literal>]
  let Category = "WorkflowServiceHost 4.0.0.0"

  let PCC = getPCC Category
  /// Workflows Created: 
  let ``Workflows Created`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Created"; instance = instance }
  /// Workflows Created Per Second: 
  let ``Workflows Created Per Second`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Created Per Second"; instance = instance }
  /// Workflows Executing: 
  let ``Workflows Executing`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Executing"; instance = instance }
  /// Workflows Completed: 
  let ``Workflows Completed`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Completed"; instance = instance }
  /// Workflows Completed Per Second: 
  let ``Workflows Completed Per Second`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Completed Per Second"; instance = instance }
  /// Workflows Aborted: 
  let ``Workflows Aborted`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Aborted"; instance = instance }
  /// Workflows Aborted Per Second: 
  let ``Workflows Aborted Per Second`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Aborted Per Second"; instance = instance }
  /// Workflows In Memory: 
  let ``Workflows In Memory`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows In Memory"; instance = instance }
  /// Workflows Persisted: 
  let ``Workflows Persisted`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Persisted"; instance = instance }
  /// Workflows Persisted Per Second: 
  let ``Workflows Persisted Per Second`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Persisted Per Second"; instance = instance }
  /// Workflows Terminated: 
  let ``Workflows Terminated`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Terminated"; instance = instance }
  /// Workflows Terminated Per Second: 
  let ``Workflows Terminated Per Second`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Terminated Per Second"; instance = instance }
  /// Workflows Loaded: 
  let ``Workflows Loaded`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Loaded"; instance = instance }
  /// Workflows Loaded Per Second: 
  let ``Workflows Loaded Per Second`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Loaded Per Second"; instance = instance }
  /// Workflows Unloaded: 
  let ``Workflows Unloaded`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Unloaded"; instance = instance }
  /// Workflows Unloaded Per Second: 
  let ``Workflows Unloaded Per Second`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Unloaded Per Second"; instance = instance }
  /// Workflows Suspended: 
  let ``Workflows Suspended`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Suspended"; instance = instance }
  /// Workflows Suspended Per Second: 
  let ``Workflows Suspended Per Second`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Suspended Per Second"; instance = instance }
  /// Workflows Idle Per Second: 
  let ``Workflows Idle Per Second`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Workflows Idle Per Second"; instance = instance }
  /// Average Workflow Load Time: 
  let ``Average Workflow Load Time`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Average Workflow Load Time"; instance = instance }
  /// Average Workflow Persist Time: 
  let ``Average Workflow Persist Time`` instance =
    { category = "WorkflowServiceHost 4.0.0.0"; counter = "Average Workflow Persist Time"; instance = instance }

  let allCounters =
    [ ``Workflows Created``
      ``Workflows Created Per Second``
      ``Workflows Executing``
      ``Workflows Completed``
      ``Workflows Completed Per Second``
      ``Workflows Aborted``
      ``Workflows Aborted Per Second``
      ``Workflows In Memory``
      ``Workflows Persisted``
      ``Workflows Persisted Per Second``
      ``Workflows Terminated``
      ``Workflows Terminated Per Second``
      ``Workflows Loaded``
      ``Workflows Loaded Per Second``
      ``Workflows Unloaded``
      ``Workflows Unloaded Per Second``
      ``Workflows Suspended``
      ``Workflows Suspended Per Second``
      ``Workflows Idle Per Second``
      ``Average Workflow Load Time``
      ``Average Workflow Persist Time``
    ]
